{
  "version": 3,
  "sources": ["node_modules/dayjs/dayjs.min.js", "node_modules/dayjs/plugin/customParseFormat.js", "node_modules/dayjs/plugin/timezone.js", "node_modules/dayjs/plugin/utc.js", "node_modules/@opentelemetry/api/src/platform/browser/globalThis.ts", "node_modules/@opentelemetry/api/src/version.ts", "node_modules/@opentelemetry/api/src/internal/semver.ts", "node_modules/@opentelemetry/api/src/internal/global-utils.ts", "node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts", "node_modules/@opentelemetry/api/src/diag/types.ts", "node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts", "node_modules/@opentelemetry/api/src/api/diag.ts", "node_modules/@opentelemetry/api/src/context/context.ts", "node_modules/@opentelemetry/api/src/context/NoopContextManager.ts", "node_modules/@opentelemetry/api/src/api/context.ts", "node_modules/@opentelemetry/api/src/trace/trace_flags.ts", "node_modules/@opentelemetry/api/src/trace/invalid-span-constants.ts", "node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts", "node_modules/@opentelemetry/api/src/trace/context-utils.ts", "node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts", "node_modules/@opentelemetry/api/src/trace/NoopTracer.ts", "node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts", "node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts", "node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts", "node_modules/@opentelemetry/api/src/trace/span_kind.ts", "node_modules/@opentelemetry/api/src/context-api.ts", "node_modules/@opentelemetry/api/src/api/trace.ts", "node_modules/@opentelemetry/api/src/trace-api.ts", "node_modules/@ax-llm/dsp/modelinfo.ts", "node_modules/@ax-llm/util/crypto.ts", "node_modules/@ax-llm/util/sse.ts", "node_modules/@ax-llm/util/stream.ts", "node_modules/@ax-llm/util/apicall.ts", "node_modules/@ax-llm/ai/base.ts", "node_modules/@ax-llm/dsp/globals.ts", "node_modules/@ax-llm/trace/trace.ts", "node_modules/@ax-llm/util/transform.ts", "node_modules/@ax-llm/util/log.ts", "node_modules/@ax-llm/dsp/loggers.ts", "node_modules/@ax-llm/ai/debug.ts", "node_modules/@ax-llm/ai/metrics.ts", "node_modules/@ax-llm/ai/anthropic/types.ts", "node_modules/@ax-llm/ai/anthropic/info.ts", "node_modules/@ax-llm/ai/anthropic/api.ts", "node_modules/@ax-llm/ai/openai/chat_types.ts", "node_modules/@ax-llm/ai/openai/responses_types.ts", "node_modules/@ax-llm/ai/openai/info.ts", "node_modules/@ax-llm/ai/openai/api.ts", "node_modules/@ax-llm/ai/azure-openai/api.ts", "node_modules/@ax-llm/ai/balance.ts", "node_modules/@ax-llm/ai/cohere/types.ts", "node_modules/@ax-llm/ai/cohere/info.ts", "node_modules/@ax-llm/ai/cohere/api.ts", "node_modules/@ax-llm/ai/deepseek/types.ts", "node_modules/@ax-llm/ai/deepseek/info.ts", "node_modules/@ax-llm/ai/deepseek/api.ts", "node_modules/@ax-llm/ai/google-gemini/types.ts", "node_modules/@ax-llm/ai/google-gemini/info.ts", "node_modules/@ax-llm/ai/google-gemini/api.ts", "node_modules/@ax-llm/util/rate-limit.ts", "node_modules/@ax-llm/ai/groq/types.ts", "node_modules/@ax-llm/ai/groq/info.ts", "node_modules/@ax-llm/ai/groq/api.ts", "node_modules/@ax-llm/ai/huggingface/info.ts", "node_modules/@ax-llm/ai/huggingface/types.ts", "node_modules/@ax-llm/ai/huggingface/api.ts", "node_modules/@ax-llm/ai/mistral/types.ts", "node_modules/@ax-llm/ai/mistral/info.ts", "node_modules/@ax-llm/ai/mistral/api.ts", "node_modules/@ax-llm/ai/mock/api.ts", "node_modules/@ax-llm/ai/multiservice.ts", "node_modules/@ax-llm/ai/ollama/api.ts", "node_modules/@ax-llm/ai/openai/responses_api.ts", "node_modules/@ax-llm/ai/openai/responses_api_base.ts", "node_modules/@ax-llm/ai/reka/types.ts", "node_modules/@ax-llm/ai/reka/info.ts", "node_modules/@ax-llm/ai/reka/api.ts", "node_modules/@ax-llm/ai/together/info.ts", "node_modules/@ax-llm/ai/together/api.ts", "node_modules/@ax-llm/ai/validate.ts", "node_modules/@ax-llm/ai/wrap.ts", "node_modules/@ax-llm/ai/x-grok/types.ts", "node_modules/@ax-llm/ai/x-grok/info.ts", "node_modules/@ax-llm/ai/x-grok/api.ts", "node_modules/@ax-llm/db/base.ts", "node_modules/@ax-llm/db/cloudflare.ts", "node_modules/@ax-llm/db/memory.ts", "node_modules/@ax-llm/db/pinecone.ts", "node_modules/@ax-llm/db/weaviate.ts", "node_modules/@ax-llm/db/wrap.ts", "node_modules/@ax-llm/docs/manager.ts", "node_modules/@ax-llm/dsp/generate.ts", "node_modules/@ax-llm/mem/memory.ts", "node_modules/@ax-llm/dsp/asserts.ts", "node_modules/@ax-llm/dsp/errors.ts", "node_modules/@ax-llm/dsp/jsonschema.ts", "node_modules/@ax-llm/dsp/functions.ts", "node_modules/@ax-llm/dsp/metrics.ts", "node_modules/@ax-llm/ai/util.ts", "node_modules/@ax-llm/dsp/datetime.ts", "node_modules/@ax-llm/dsp/util.ts", "node_modules/@ax-llm/dsp/extract.ts", "node_modules/@ax-llm/dsp/fieldProcessor.ts", "node_modules/@ax-llm/dsp/processResponse.ts", "node_modules/@ax-llm/dsp/registry.ts", "node_modules/@ax-llm/dsp/parser.ts", "node_modules/@ax-llm/dsp/sig.ts", "node_modules/@ax-llm/dsp/program.ts", "node_modules/@ax-llm/dsp/prompt.ts", "node_modules/@ax-llm/dsp/samples.ts", "node_modules/@ax-llm/dsp/validate.ts", "node_modules/@ax-llm/dsp/strutil.ts", "node_modules/@ax-llm/docs/reranker.ts", "node_modules/@ax-llm/docs/tika.ts", "node_modules/@ax-llm/dsp/classifier.ts", "node_modules/@ax-llm/dsp/stopwords.ts", "node_modules/@ax-llm/dsp/eval.ts", "node_modules/@ax-llm/dsp/evaluate.ts", "node_modules/@ax-llm/dsp/loader.ts", "node_modules/@ax-llm/dsp/optimizer.ts", "node_modules/@ax-llm/dsp/optimizers/bootstrapFewshot.ts", "node_modules/@ax-llm/dsp/optimizers/miproV2.ts", "node_modules/@ax-llm/dsp/template.ts", "node_modules/@ax-llm/flow/flow.ts", "node_modules/@ax-llm/funcs/docker.ts", "node_modules/@ax-llm/funcs/embed.ts", "node_modules/@ax-llm/mcp/client.ts", "node_modules/@ax-llm/mcp/httpTransport.ts", "node_modules/@ax-llm/prompts/agent.ts", "node_modules/@ax-llm/prompts/cot.ts", "node_modules/@ax-llm/prompts/rag.ts"],
  "sourcesContent": ["!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));", "!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_customParseFormat=t()}(this,(function(){\"use strict\";var e={LTS:\"h:mm:ss A\",LT:\"h:mm A\",L:\"MM/DD/YYYY\",LL:\"MMMM D, YYYY\",LLL:\"MMMM D, YYYY h:mm A\",LLLL:\"dddd, MMMM D, YYYY h:mm A\"},t=/(\\[[^[]*\\])|([-_:/.,()\\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\\d/,r=/\\d\\d/,i=/\\d\\d?/,o=/\\d*[^-_:/,()\\s\\d]+/,s={},a=function(e){return(e=+e)+(e>68?1900:2e3)};var f=function(e){return function(t){this[e]=+t}},h=[/[+-]\\d\\d:?(\\d\\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if(\"Z\"===e)return 0;var t=e.match(/([+-]|\\d\\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:\"+\"===t[0]?-n:n}(e)}],u=function(e){var t=s[e];return t&&(t.indexOf?t:t.s.concat(t.f))},d=function(e,t){var n,r=s.meridiem;if(r){for(var i=1;i<=24;i+=1)if(e.indexOf(r(i,0,t))>-1){n=i>12;break}}else n=e===(t?\"pm\":\"PM\");return n},c={A:[o,function(e){this.afternoon=d(e,!1)}],a:[o,function(e){this.afternoon=d(e,!0)}],Q:[n,function(e){this.month=3*(e-1)+1}],S:[n,function(e){this.milliseconds=100*+e}],SS:[r,function(e){this.milliseconds=10*+e}],SSS:[/\\d{3}/,function(e){this.milliseconds=+e}],s:[i,f(\"seconds\")],ss:[i,f(\"seconds\")],m:[i,f(\"minutes\")],mm:[i,f(\"minutes\")],H:[i,f(\"hours\")],h:[i,f(\"hours\")],HH:[i,f(\"hours\")],hh:[i,f(\"hours\")],D:[i,f(\"day\")],DD:[r,f(\"day\")],Do:[o,function(e){var t=s.ordinal,n=e.match(/\\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\\[|\\]/g,\"\")===e&&(this.day=r)}],w:[i,f(\"week\")],ww:[r,f(\"week\")],M:[i,f(\"month\")],MM:[r,f(\"month\")],MMM:[o,function(e){var t=u(\"months\"),n=(u(\"monthsShort\")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n}],MMMM:[o,function(e){var t=u(\"months\").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t}],Y:[/[+-]?\\d+/,f(\"year\")],YY:[r,function(e){this.year=a(e)}],YYYY:[/\\d{4}/,f(\"year\")],Z:h,ZZ:h};function l(n){var r,i;r=n,i=s&&s.formats;for(var o=(n=r.replace(/(\\[[^\\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var o=r&&r.toUpperCase();return n||i[r]||e[r]||i[o].replace(/(\\[[^\\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),a=o.length,f=0;f<a;f+=1){var h=o[f],u=c[h],d=u&&u[0],l=u&&u[1];o[f]=l?{regex:d,parser:l}:h.replace(/^\\[|\\]$/g,\"\")}return function(e){for(var t={},n=0,r=0;n<a;n+=1){var i=o[n];if(\"string\"==typeof i)r+=i.length;else{var s=i.regex,f=i.parser,h=e.slice(r),u=s.exec(h)[0];f.call(t,u),e=e.replace(u,\"\")}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(a=e.parseTwoDigitYear);var r=t.prototype,i=r.parse;r.parse=function(e){var t=e.date,r=e.utc,o=e.args;this.$u=r;var a=o[1];if(\"string\"==typeof a){var f=!0===o[2],h=!0===o[3],u=f||h,d=o[2];h&&(d=o[2]),s=this.$locale(),!f&&d&&(s=n.Ls[d]),this.$d=function(e,t,n,r){try{if([\"x\",\"X\"].indexOf(t)>-1)return new Date((\"X\"===t?1e3:1)*e);var i=l(t)(e),o=i.year,s=i.month,a=i.day,f=i.hours,h=i.minutes,u=i.seconds,d=i.milliseconds,c=i.zone,m=i.week,M=new Date,Y=a||(o||s?1:M.getDate()),p=o||M.getFullYear(),v=0;o&&!s||(v=s>0?s-1:M.getMonth());var D,w=f||0,g=h||0,y=u||0,L=d||0;return c?new Date(Date.UTC(p,v,Y,w,g,y,L+60*c.offset*1e3)):n?new Date(Date.UTC(p,v,Y,w,g,y,L)):(D=new Date(p,v,Y,w,g,y,L),m&&(D=r(D).week(m).toDate()),D)}catch(e){return new Date(\"\")}}(t,a,r,n),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),u&&t!=this.format(a)&&(this.$d=new Date(\"\")),s={}}else if(a instanceof Array)for(var c=a.length,m=1;m<=c;m+=1){o[1]=a[m-1];var M=n.apply(this,o);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===c&&(this.$d=new Date(\"\"))}else i.call(this,e)}}}));", "!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_timezone=e()}(this,(function(){\"use strict\";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||\"short\",o=t+\"|\"+i,r=e[o];return r||(r=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,h=r[0]+\"-\"+r[1]+\"-\"+r[2]+\" \"+l+\":\"+r[4]+\":\"+r[5]+\":000\",v=+e;return(o.utc(h).valueOf()-(v-=v%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n,i=this.utcOffset(),a=this.toDate(),u=a.toLocaleString(\"en-US\",{timeZone:t}),f=Math.round((a-new Date(u))/1e3/60),s=15*-Math.round(a.getTimezoneOffset()/15)-f;if(!Number(s))n=this.utcOffset(0,e);else if(n=o(u,{locale:this.$L}).$set(\"millisecond\",this.$ms).utcOffset(s,!0),e){var m=n.utcOffset();n=n.add(i-m,\"minute\")}return n.$x.$timezone=t,n},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return\"timezonename\"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\"),{locale:this.$L});return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if(\"string\"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));", "!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_utc=i()}(this,(function(){\"use strict\";var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return\"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Updates to this file should also be replicated to @opentelemetry/core too.\n\n/**\n * - globalThis (New standard)\n * - self (Will return the current window instance for supported browsers)\n * - window (fallback for older browser implementations)\n * - global (NodeJS implementation)\n * - <object> (When all else fails)\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef\nexport const _globalThis: typeof globalThis =\n  typeof globalThis === 'object'\n    ? globalThis\n    : typeof self === 'object'\n    ? self\n    : typeof window === 'object'\n    ? window\n    : typeof global === 'object'\n    ? global\n    : ({} as typeof globalThis);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n", "import type { AxAIInputModelList, AxModelInfo } from '../ai/types.js';\n\ninterface GetModelInfoParams<TModel = string, TEmbedModel = undefined> {\n  model: TModel;\n  modelInfo: readonly AxModelInfo[];\n  models?: AxAIInputModelList<TModel, TEmbedModel>;\n}\n\nexport function getModelInfo<TModel = string, TEmbedModel = undefined>({\n  model,\n  modelInfo,\n  models,\n}: Readonly<\n  GetModelInfoParams<TModel, TEmbedModel>\n>): Readonly<AxModelInfo> | null {\n  // First check if there's a mapping for this model\n  const modelEntry = models?.find((v) => v.key === model);\n  const mappedModel =\n    modelEntry && 'model' in modelEntry\n      ? (modelEntry.model as string)\n      : (model as string);\n\n  // Try exact match first\n  const exactMatch = modelInfo.find((v) => v.name === model);\n  if (exactMatch) return exactMatch;\n\n  // Handle normalization if no exact match\n  const normalizedName = mappedModel\n    // Remove vendor prefixes\n    .replace(/^(anthropic\\.|openai\\.)/, '')\n    // Remove various postfixes one by one, stopping after first match\n    .replace(/-latest$/, '')\n    .replace(/-\\d{8}$/, '') // YYYYMMDD\n    .replace(/-v\\d+:\\d+$/, '') // v2:0\n    .replace(/@\\d{8}$/, '') // @YYYYMMDD\n    .replace(/-\\d{2,}(-[a-zA-Z0-9-]+)?$/, '') // XX or XXXXX-something\n    .replace(/-v\\d+@\\d{8}$/, '') // vX@YYYYMMDD\n    .replace(/-v\\d+$/, ''); // Remove standalone version number\n\n  // Try to find a match with the normalized name\n  const normalizedMatch = modelInfo.find((v) => v.name === normalizedName);\n  if (normalizedMatch) return normalizedMatch;\n\n  // Return default if no match found\n  return null;\n}\n", "/**\n * Cross-platform crypto utilities that work in both Node.js and browser environments\n * using Web Crypto API standards\n */\n\n// Web Crypto API is available in both modern Node.js (16+) and browsers via globalThis.crypto\nconst webCrypto = (() => {\n  if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {\n    return globalThis.crypto;\n  }\n\n  throw new Error(\n    'Web Crypto API with randomUUID support not available. Requires Node.js 16+ or modern browser.'\n  );\n})();\n\n/**\n * Generate a random UUID using Web Crypto API\n * @returns A random UUID string\n */\nexport function randomUUID(): string {\n  return webCrypto.randomUUID();\n}\n\n/**\n * Create a SHA-256 hash of the input data\n * @param data - The data to hash (string or ArrayBuffer)\n * @returns A promise that resolves to the hex-encoded hash\n */\nexport async function sha256(data: string | ArrayBuffer): Promise<string> {\n  const encoder = new TextEncoder();\n  const inputData = typeof data === 'string' ? encoder.encode(data) : data;\n\n  const hashBuffer = await webCrypto.subtle.digest('SHA-256', inputData);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n\n  return hashHex;\n}\n\n/**\n * Create a hash instance that can be updated incrementally (similar to Node.js createHash)\n * Note: This is a synchronous wrapper around async Web Crypto API - uses simplified hash for compatibility\n */\nexport class Hash {\n  private data = '';\n\n  update(chunk: string): this {\n    this.data += chunk;\n    return this;\n  }\n\n  digest(encoding: 'hex'): string {\n    if (encoding !== 'hex') {\n      throw new Error('Only hex encoding is supported');\n    }\n\n    // For browser compatibility, we use a simple hash function\n    // This maintains API compatibility but is not cryptographically secure\n    const encoder = new TextEncoder();\n    const inputData = encoder.encode(this.data);\n\n    let hash = 0;\n    for (let i = 0; i < inputData.length; i++) {\n      const char = inputData[i]!;\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n\n    // Convert to hex string\n    return Math.abs(hash).toString(16).padStart(8, '0');\n  }\n\n  async digestAsync(): Promise<string> {\n    return sha256(this.data);\n  }\n}\n\n/**\n * Create a hash instance (compatibility function)\n * @param algorithm - The hash algorithm (only 'sha256' supported)\n * @returns A Hash instance\n */\nexport function createHash(algorithm: string): Hash {\n  if (algorithm !== 'sha256') {\n    throw new Error('Only SHA-256 algorithm is supported');\n  }\n  return new Hash();\n}\n\n/**\n * Get the crypto object for use in JavaScript interpreter contexts\n * @returns The Web Crypto API object\n */\nexport function getCrypto() {\n  return webCrypto;\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\n\ninterface CurrentEventState {\n  event?: string;\n  rawData: string;\n  id?: string;\n  retry?: number;\n}\n\ninterface SSEParserOptions<T> {\n  dataParser?: (data: string) => T;\n  onError?: (error: Error, rawData: string) => void;\n}\n\nexport class SSEParser<T = unknown> extends TransformStream<string, T> {\n  private buffer = '';\n  private currentEvent: CurrentEventState = { rawData: '' };\n  private dataParser: (data: string) => T;\n  private onError: (error: Error, rawData: string) => void;\n\n  constructor(options: SSEParserOptions<T> = {}) {\n    super({\n      transform: (chunk, controller) => this.handleChunk(chunk, controller),\n      flush: (controller) => this.handleFlush(controller),\n    });\n\n    this.dataParser = options.dataParser || JSON.parse;\n    this.onError =\n      options.onError ||\n      ((error, rawData) => {\n        console.warn('Failed to parse event data:', error);\n        console.log('Raw data that failed to parse:', rawData);\n      });\n  }\n\n  private handleChunk(\n    chunk: string,\n    controller: TransformStreamDefaultController<T>\n  ): void {\n    this.buffer += chunk;\n    this.processBuffer(controller);\n  }\n\n  private handleFlush(controller: TransformStreamDefaultController<T>): void {\n    this.processBuffer(controller);\n    if (this.currentEvent.rawData) {\n      this.processEvent(controller);\n    }\n  }\n\n  private processBuffer(controller: TransformStreamDefaultController<T>): void {\n    // Normalize newlines to \\n\n    const normalizedBuffer = this.buffer.replace(/\\r\\n|\\r/g, '\\n');\n    const lines = normalizedBuffer.split('\\n');\n    this.buffer = lines.pop() || '';\n\n    for (const line of lines) {\n      if (line === '') {\n        this.processEvent(controller);\n      } else {\n        this.parseLine(line);\n      }\n    }\n  }\n\n  private parseLine(line: string): void {\n    if (line.startsWith(':')) {\n      return; // Ignore comment lines\n    }\n\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      this.currentEvent.rawData +=\n        (this.currentEvent.rawData && !this.currentEvent.rawData.endsWith('\\n')\n          ? '\\n'\n          : '') + line.trim();\n      return;\n    }\n\n    const field = line.slice(0, colonIndex).trim();\n    const value = line.slice(colonIndex + 1).trim();\n\n    switch (field) {\n      case 'event':\n        this.currentEvent.event = value;\n        break;\n      case 'data':\n        this.currentEvent.rawData +=\n          (this.currentEvent.rawData &&\n          !this.currentEvent.rawData.endsWith('\\n')\n            ? '\\n'\n            : '') + value;\n        break;\n      case 'id':\n        this.currentEvent.id = value;\n        break;\n      case 'retry': {\n        const retryValue = Number.parseInt(value, 10);\n        if (!Number.isNaN(retryValue)) {\n          this.currentEvent.retry = retryValue;\n        }\n        break;\n      }\n    }\n  }\n\n  private processEvent(controller: TransformStreamDefaultController<T>): void {\n    if (this.currentEvent.rawData) {\n      if (!this.currentEvent.event) {\n        this.currentEvent.event = 'message';\n      }\n\n      if (this.currentEvent.rawData.trim() === '[DONE]') {\n        // maybe we want to emit [DONE] to signal the end of the stream\n        // controller.enqueue('[DONE]' as any)\n        // Reset the current event\n        this.currentEvent = { rawData: '' };\n        return;\n      }\n\n      try {\n        const parsedData: T = this.dataParser(this.currentEvent.rawData);\n        controller.enqueue(parsedData);\n      } catch (e) {\n        this.onError(e as Error, this.currentEvent.rawData);\n      }\n\n      this.currentEvent = { rawData: '' };\n    }\n  }\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\n\nexport interface TextDecoderCommon {\n  readonly encoding: string;\n  readonly fatal: boolean;\n  readonly ignoreBOM: boolean;\n}\n\nclass TextDecodeTransformer\n  implements Transformer<ArrayBuffer | Uint8Array, string>\n{\n  private decoder;\n\n  constructor() {\n    this.decoder = new TextDecoder();\n  }\n\n  transform(\n    chunk: ArrayBuffer | Uint8Array,\n    controller: TransformStreamDefaultController<string>\n  ) {\n    if (!(chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk))) {\n      throw new TypeError('Input data must be a BufferSource');\n    }\n    const text = this.decoder.decode(chunk, { stream: true });\n    if (text.length !== 0) {\n      controller.enqueue(text);\n    }\n  }\n\n  flush(controller: TransformStreamDefaultController<string>) {\n    const text = this.decoder.decode();\n    if (text.length !== 0) {\n      controller.enqueue(text);\n    }\n  }\n}\n\nexport class TextDecoderStreamPolyfill extends TransformStream<\n  ArrayBuffer | Uint8Array,\n  string\n> {\n  constructor() {\n    super(new TextDecodeTransformer());\n  }\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\nimport type { Span } from '@opentelemetry/api';\nimport { randomUUID } from './crypto.js';\n\nimport { SSEParser } from './sse.js';\nimport { TextDecoderStreamPolyfill } from './stream.js';\n\n// Configuration Types\nexport interface RetryConfig {\n  maxRetries: number;\n  initialDelayMs: number;\n  maxDelayMs: number;\n  backoffFactor: number;\n  retryableStatusCodes: number[];\n}\n\nexport interface RequestMetrics {\n  startTime: number;\n  retryCount: number;\n  lastRetryTime?: number;\n  streamChunks?: number;\n  lastChunkTime?: number;\n  streamDuration?: number;\n  errorTime?: number;\n}\n\n// Validation Interfaces\ninterface RequestValidation {\n  validateRequest?: (request: unknown) => boolean | Promise<boolean>;\n}\n\ninterface ResponseValidation {\n  validateResponse?: (response: unknown) => boolean | Promise<boolean>;\n}\n\n// API Base Types\nexport interface AxAPI {\n  name?: string;\n  headers?: Record<string, string>;\n  put?: boolean;\n}\n\n// Enhanced API Configuration\nexport interface AxAPIConfig\n  extends AxAPI,\n    RequestValidation,\n    ResponseValidation {\n  url: string | URL;\n  stream?: boolean;\n  debug?: boolean;\n  fetch?: typeof fetch;\n  span?: Span;\n  timeout?: number;\n  retry?: Partial<RetryConfig>;\n  abortSignal?: AbortSignal;\n}\n\n// Default Configurations\nexport const defaultRetryConfig: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 60000,\n  backoffFactor: 2,\n  retryableStatusCodes: [500, 408, 429, 502, 503, 504],\n};\n\nconst defaultTimeoutMs = 30000;\nconst textDecoderStream =\n  (globalThis as any).TextDecoderStream ?? TextDecoderStreamPolyfill;\n\n// Error Classes\nexport class AxAIServiceError extends Error {\n  public readonly timestamp: string;\n  public readonly errorId: string;\n  public readonly context: Record<string, unknown>;\n\n  constructor(\n    message: string,\n    public readonly url: string,\n    public readonly requestBody: unknown,\n    public readonly responseBody: unknown,\n    context: Record<string, unknown> = {}\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n    this.context = context;\n\n    this.stack = this.toString();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `URL: ${this.url}`,\n      `Request Body: ${JSON.stringify(this.requestBody, null, 2)}`,\n      `Response Body: ${JSON.stringify(this.responseBody, null, 2)}`,\n      `Context: ${JSON.stringify(this.context, null, 2)}`,\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ].join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport class AxAIServiceStatusError extends AxAIServiceError {\n  constructor(\n    public readonly status: number,\n    public readonly statusText: string,\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(`HTTP ${status} - ${statusText}`, url, requestBody, {\n      httpStatus: status,\n      httpStatusText: statusText,\n      responseBody,\n      ...context,\n    });\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceNetworkError extends AxAIServiceError {\n  constructor(\n    public readonly originalError: Error,\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Network Error: ${originalError.message}`,\n      url,\n      requestBody,\n      responseBody,\n      {\n        originalErrorName: originalError.name,\n        originalErrorStack: originalError.stack,\n        ...context,\n      }\n    );\n    this.name = this.constructor.name;\n    this.stack = originalError.stack;\n  }\n}\n\nexport class AxAIServiceResponseError extends AxAIServiceError {\n  constructor(\n    message: string,\n    url: string,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(message, url, requestBody, undefined, context);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceStreamTerminatedError extends AxAIServiceError {\n  constructor(\n    url: string,\n    requestBody?: unknown,\n    public readonly lastChunk?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      'Stream terminated unexpectedly by remote host',\n      url,\n      requestBody,\n      undefined,\n      {\n        lastChunk,\n        ...context,\n      }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceTimeoutError extends AxAIServiceError {\n  constructor(\n    url: string,\n    timeoutMs: number,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Request timed out after ${timeoutMs}ms`,\n      url,\n      requestBody,\n      undefined,\n      { timeoutMs, ...context }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceAbortedError extends AxAIServiceError {\n  constructor(\n    url: string,\n    reason?: string,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Request aborted${reason ? `: ${reason}` : ''}`,\n      url,\n      requestBody,\n      undefined,\n      { abortReason: reason, ...context }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceAuthenticationError extends AxAIServiceError {\n  constructor(\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super('Authentication failed', url, requestBody, responseBody, context);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIRefusalError extends Error {\n  public readonly timestamp: string;\n  public readonly errorId: string;\n\n  constructor(\n    public readonly refusalMessage: string,\n    public readonly model?: string,\n    public readonly requestId?: string\n  ) {\n    super(`Model refused to fulfill request: ${refusalMessage}`);\n    this.name = 'AxAIRefusalError';\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `Refusal: ${this.refusalMessage}`,\n      this.model ? `Model: ${this.model}` : '',\n      this.requestId ? `Request ID: ${this.requestId}` : '',\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ]\n      .filter(Boolean)\n      .join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n// Utility Functions\nasync function safeReadResponseBody(response: Response): Promise<unknown> {\n  try {\n    if (response.headers.get('content-type')?.includes('application/json')) {\n      return await response.json();\n    }\n\n    // Clone the response so we can read it without consuming the original\n    const clonedResponse = response.clone();\n    return await clonedResponse.text();\n  } catch (e) {\n    // If we can't read the body, return a descriptive message\n    return `[ReadableStream - read failed: ${(e as Error).message}]`;\n  }\n}\n\nfunction calculateRetryDelay(\n  attempt: number,\n  config: Readonly<RetryConfig>\n): number {\n  const delay = Math.min(\n    config.maxDelayMs,\n    config.initialDelayMs * config.backoffFactor ** attempt\n  );\n  return delay * (0.75 + Math.random() * 0.5);\n}\n\nfunction createRequestMetrics(): RequestMetrics {\n  return {\n    startTime: Date.now(),\n    retryCount: 0,\n  };\n}\n\n// eslint-disable-next-line functional/prefer-immutable-types\nfunction updateRetryMetrics(metrics: RequestMetrics): void {\n  metrics.retryCount++;\n  metrics.lastRetryTime = Date.now();\n}\n\nfunction shouldRetry(\n  error: Error,\n  status: number | undefined,\n  attempt: number,\n  config: Readonly<RetryConfig>\n): boolean {\n  if (attempt >= config.maxRetries) return false;\n  if (status && config.retryableStatusCodes.includes(status)) return true;\n\n  return (\n    error instanceof AxAIServiceNetworkError &&\n    !(error instanceof AxAIServiceAuthenticationError)\n  );\n}\n\n// Enhanced API Call Function\nexport const apiCall = async <TRequest = unknown, TResponse = unknown>(\n  api: Readonly<AxAPIConfig>,\n  json: TRequest\n): Promise<TResponse | ReadableStream<TResponse>> => {\n  const retryConfig: RetryConfig = { ...defaultRetryConfig, ...api.retry };\n  const timeoutMs = api.timeout ?? defaultTimeoutMs;\n  const metrics = createRequestMetrics();\n  let timeoutId: NodeJS.Timeout;\n\n  const baseUrl = new URL(process.env.PROXY ?? api.url);\n  const apiPath = `${[baseUrl.pathname, api.name]\n    .filter(Boolean)\n    .join('/')\n    .replace(/\\/+/g, '/')}${baseUrl.search}`;\n  const apiUrl = new URL(apiPath, baseUrl);\n\n  const requestId = randomUUID();\n\n  // Validate request if validator is provided\n  if (api.validateRequest) {\n    const isValid = await api.validateRequest(json);\n    if (!isValid) {\n      throw new AxAIServiceResponseError(\n        'Invalid request data',\n        apiUrl.href,\n        json,\n        { validation: 'request' }\n      );\n    }\n  }\n\n  // Set up telemetry\n  api.span?.setAttributes({\n    'http.request.method': api.put ? 'PUT' : 'POST',\n    'url.full': apiUrl.href,\n    'request.id': requestId,\n    'request.startTime': metrics.startTime,\n  });\n\n  let attempt = 0;\n\n  while (true) {\n    // Combine user abort signal with timeout signal\n    const combinedAbortController = new AbortController();\n\n    // Handle user abort signal\n    if (api.abortSignal) {\n      if (api.abortSignal.aborted) {\n        throw new AxAIServiceAbortedError(\n          apiUrl.href,\n          api.abortSignal.reason,\n          json,\n          { metrics }\n        );\n      }\n\n      const userAbortHandler = () => {\n        combinedAbortController.abort(\n          api.abortSignal!.reason || 'User aborted request'\n        );\n      };\n      api.abortSignal.addEventListener('abort', userAbortHandler, {\n        once: true,\n      });\n\n      // Clean up listener if we complete before abort\n      const originalAbort = combinedAbortController.abort.bind(\n        combinedAbortController\n      );\n      combinedAbortController.abort = (reason?: string) => {\n        api.abortSignal!.removeEventListener('abort', userAbortHandler);\n        originalAbort(reason);\n      };\n    }\n\n    timeoutId = setTimeout(() => {\n      combinedAbortController.abort('Request timeout');\n    }, timeoutMs);\n\n    try {\n      // Set up timeout with proper cleanup\n\n      const res = await (api.fetch ?? fetch)(apiUrl, {\n        method: api.put ? 'PUT' : 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Request-ID': requestId,\n          'X-Retry-Count': attempt.toString(),\n          ...api.headers,\n        },\n        body: JSON.stringify(json),\n        signal: combinedAbortController.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      // Handle authentication errors\n      if (res.status === 401 || res.status === 403) {\n        const responseBody = await safeReadResponseBody(res);\n        throw new AxAIServiceAuthenticationError(\n          apiUrl.href,\n          json,\n          responseBody,\n          {\n            metrics,\n          }\n        );\n      }\n\n      // Handle retryable status codes\n      if (\n        res.status >= 400 &&\n        shouldRetry(new Error(), res.status, attempt, retryConfig)\n      ) {\n        const delay = calculateRetryDelay(attempt, retryConfig);\n        attempt++;\n        updateRetryMetrics(metrics);\n\n        api.span?.addEvent('retry', {\n          attempt,\n          delay,\n          status: res.status,\n          'metrics.startTime': metrics.startTime,\n          'metrics.retryCount': metrics.retryCount,\n          'metrics.lastRetryTime': metrics.lastRetryTime,\n        });\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      if (res.status >= 400) {\n        const responseBody = await safeReadResponseBody(res);\n        throw new AxAIServiceStatusError(\n          res.status,\n          res.statusText,\n          apiUrl.href,\n          json,\n          responseBody,\n          { metrics }\n        );\n      }\n\n      // Handle non-streaming response\n      if (!api.stream) {\n        const resJson = await res.json();\n\n        // Validate response if validator is provided\n        if (api.validateResponse) {\n          const isValid = await api.validateResponse(resJson);\n          if (!isValid) {\n            throw new AxAIServiceResponseError(\n              'Invalid response data',\n              apiUrl.href,\n              json,\n              { validation: 'response' }\n            );\n          }\n        }\n\n        api.span?.setAttributes({\n          'response.time': Date.now() - metrics.startTime,\n          'response.retries': metrics.retryCount,\n        });\n\n        return resJson as TResponse;\n      }\n\n      // Handle streaming response\n      if (!res.body) {\n        throw new AxAIServiceResponseError(\n          'Response body is null',\n          apiUrl.href,\n          json,\n          { metrics }\n        );\n      }\n\n      let lastChunk: TResponse | undefined;\n      let chunkCount = 0;\n\n      // Enhanced tracking stream\n      const trackingStream = new TransformStream<TResponse, TResponse>({\n        transform(chunk, controller) {\n          lastChunk = chunk;\n          chunkCount++;\n          metrics.streamChunks = chunkCount;\n          metrics.lastChunkTime = Date.now();\n          controller.enqueue(chunk);\n\n          api.span?.addEvent('stream.chunk', {\n            'stream.chunks': chunkCount,\n            'stream.duration': Date.now() - metrics.startTime,\n            'response.retries': metrics.retryCount,\n          });\n        },\n      });\n\n      // Flag to track if the controller is closed.\n      let closed = false;\n\n      // Enhanced wrapped stream\n      return new ReadableStream<TResponse>({\n        start(controller) {\n          const reader = res\n            .body!.pipeThrough(new textDecoderStream())\n            .pipeThrough(new SSEParser<TResponse>())\n            .pipeThrough(trackingStream)\n            .getReader();\n\n          async function read() {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (!closed) {\n                    closed = true;\n                    controller.close();\n                  }\n                  break;\n                }\n\n                // Check if the controller is already closed before enqueuing.\n                if (closed) break;\n                controller.enqueue(value);\n              }\n            } catch (e) {\n              const error = e as Error;\n              const streamMetrics = {\n                ...metrics,\n                streamDuration: Date.now() - metrics.startTime,\n              };\n\n              if (\n                error.name === 'AbortError' ||\n                error.message?.includes('aborted')\n              ) {\n                controller.error(\n                  new AxAIServiceStreamTerminatedError(\n                    apiUrl.href,\n                    json,\n                    lastChunk,\n                    { streamMetrics }\n                  )\n                );\n              } else if (\n                error instanceof TypeError &&\n                error.message.includes('cancelled')\n              ) {\n                controller.error(\n                  new AxAIServiceStreamTerminatedError(\n                    apiUrl.href,\n                    json,\n                    lastChunk,\n                    {\n                      streamMetrics,\n                      cancelReason: 'Stream cancelled by client',\n                    }\n                  )\n                );\n              } else {\n                controller.error(\n                  new AxAIServiceNetworkError(\n                    error,\n                    apiUrl.href,\n                    json,\n                    '[ReadableStream - consumed during streaming]',\n                    {\n                      streamMetrics,\n                    }\n                  )\n                );\n              }\n              throw error;\n            } finally {\n              clearTimeout(timeoutId);\n              reader.releaseLock();\n            }\n          }\n\n          read();\n        },\n        // When the consumer cancels the stream, set our flag to stop processing further.\n        cancel() {\n          closed = true;\n        },\n      });\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        // Check if this was a user abort or timeout\n        if (api.abortSignal?.aborted) {\n          throw new AxAIServiceAbortedError(\n            apiUrl.href,\n            api.abortSignal.reason,\n            json,\n            { metrics }\n          );\n        }\n        throw new AxAIServiceTimeoutError(apiUrl.href, timeoutMs, json, {\n          metrics,\n        });\n      }\n\n      if (api.span?.isRecording()) {\n        api.span.recordException(error as Error);\n        api.span.setAttributes({\n          'error.time': Date.now() - metrics.startTime,\n          'error.retries': metrics.retryCount,\n        });\n      }\n\n      // Handle retryable network errors\n      if (\n        error instanceof AxAIServiceNetworkError &&\n        shouldRetry(error, undefined, attempt, retryConfig)\n      ) {\n        const delay = calculateRetryDelay(attempt, retryConfig);\n        attempt++;\n        updateRetryMetrics(metrics);\n\n        api.span?.addEvent('retry', {\n          attempt,\n          delay,\n          error: error.message,\n          'metrics.startTime': metrics.startTime,\n          'metrics.retryCount': metrics.retryCount,\n          'metrics.lastRetryTime': metrics.lastRetryTime,\n        });\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      if (error instanceof AxAIServiceError) {\n        error.context.metrics = metrics;\n      }\n\n      throw error;\n    } finally {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n};\n\nexport function createApiConfig(\n  config: Readonly<Partial<AxAPIConfig>>\n): AxAPIConfig {\n  return {\n    timeout: defaultTimeoutMs,\n    retry: defaultRetryConfig,\n    ...config,\n    url: config.url!, // URL is required\n  };\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+ via DOM types\nimport { type Span, SpanKind, context } from '@opentelemetry/api';\nimport { randomUUID } from '../util/crypto.js';\n\nimport { axGlobals } from '../dsp/globals.js';\nimport { axSpanAttributes, axSpanEvents } from '../trace/trace.js';\nimport { apiCall } from '../util/apicall.js';\nimport { RespTransformStream } from '../util/transform.js';\n\nimport { defaultLogger } from '../dsp/loggers.js';\nimport { logChatRequest, logResponse } from './debug.js';\nimport {\n  type AxAIMetricsInstruments,\n  getOrCreateAIMetricsInstruments,\n  recordAbortMetric,\n  recordContextWindowUsageMetric,\n  recordErrorMetric,\n  recordErrorRateMetric,\n  recordEstimatedCostMetric,\n  recordFunctionCallMetric,\n  recordLatencyMetric,\n  recordLatencyStatsMetrics,\n  recordModelConfigMetrics,\n  recordMultimodalRequestMetric,\n  recordPromptLengthMetric,\n  recordRequestMetric,\n  recordRequestSizeMetric,\n  recordResponseSizeMetric,\n  recordStreamingRequestMetric,\n  recordThinkingBudgetUsageMetric,\n  recordTimeoutMetric,\n  recordTokenMetric,\n} from './metrics.js';\nimport type {\n  AxAIInputModelList,\n  AxAIModelList,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceImpl,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxModelInfo,\n  AxModelUsage,\n} from './types.js';\n\nexport interface AxAIFeatures {\n  functions: boolean;\n  streaming: boolean;\n  functionCot?: boolean;\n  hasThinkingBudget?: boolean;\n  hasShowThoughts?: boolean;\n}\n\nexport interface AxBaseAIArgs<TModel, TEmbedModel> {\n  name: string;\n  apiURL: string;\n  headers: () => Promise<Record<string, string>>;\n  modelInfo: Readonly<AxModelInfo[]>;\n  defaults: Readonly<{ model: TModel; embedModel?: TEmbedModel }>;\n  options?: Readonly<AxAIServiceOptions>;\n  supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n  models?: AxAIInputModelList<TModel, TEmbedModel>;\n}\n\nexport const axBaseAIDefaultConfig = (): AxModelConfig =>\n  structuredClone({\n    temperature: 0,\n    topK: 40,\n    topP: 0.9,\n  });\n\nexport const axBaseAIDefaultCreativeConfig = (): AxModelConfig =>\n  structuredClone({\n    temperature: 0.4,\n    topP: 0.7,\n    frequencyPenalty: 0.2,\n  });\n\nexport class AxBaseAI<\n  TModel,\n  TEmbedModel,\n  TChatRequest,\n  TEmbedRequest,\n  TChatResponse,\n  TChatResponseDelta,\n  TEmbedResponse,\n> implements AxAIService<TModel, TEmbedModel>\n{\n  private debug = false;\n\n  private rt?: AxAIServiceOptions['rateLimiter'];\n  private fetch?: AxAIServiceOptions['fetch'];\n  private tracer?: AxAIServiceOptions['tracer'];\n  private meter?: AxAIServiceOptions['meter'];\n  private timeout?: AxAIServiceOptions['timeout'];\n  private excludeContentFromTrace?: boolean;\n  private models?: AxAIInputModelList<TModel, TEmbedModel>;\n  private abortSignal?: AbortSignal;\n  private logger: AxLoggerFunction = defaultLogger;\n\n  private modelInfo: readonly AxModelInfo[];\n  private modelUsage?: AxModelUsage;\n  private embedModelUsage?: AxModelUsage;\n  private defaults: AxBaseAIArgs<TModel, TEmbedModel>['defaults'];\n  private lastUsedModelConfig?: AxModelConfig;\n  private lastUsedChatModel?: TModel;\n  private lastUsedEmbedModel?: TEmbedModel;\n\n  protected apiURL: string;\n  protected name: string;\n  protected id: string;\n  protected headers: () => Promise<Record<string, string>>;\n  protected supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n\n  // Add private metrics tracking properties\n  private metrics: AxAIServiceMetrics = {\n    latency: {\n      chat: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n      embed: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n    },\n    errors: {\n      chat: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n      embed: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n    },\n  };\n\n  constructor(\n    private readonly aiImpl: Readonly<\n      AxAIServiceImpl<\n        TModel,\n        TEmbedModel,\n        TChatRequest,\n        TEmbedRequest,\n        TChatResponse,\n        TChatResponseDelta,\n        TEmbedResponse\n      >\n    >,\n    {\n      name,\n      apiURL,\n      headers,\n      modelInfo,\n      defaults,\n      options = {},\n      supportFor,\n      models,\n    }: Readonly<AxBaseAIArgs<TModel, TEmbedModel>>\n  ) {\n    this.name = name;\n    this.apiURL = apiURL;\n    this.headers = headers;\n    this.supportFor = supportFor;\n    this.tracer = options.tracer ?? axGlobals.tracer;\n    this.meter = options.meter ?? axGlobals.meter;\n    this.modelInfo = modelInfo;\n    this.models = models;\n    this.id = randomUUID();\n\n    const model = this.getModel(defaults.model) ?? defaults.model;\n    const embedModel =\n      this.getEmbedModel(defaults.embedModel) ?? defaults.embedModel;\n\n    this.defaults = { model, embedModel };\n\n    if (\n      !defaults.model ||\n      typeof defaults.model !== 'string' ||\n      defaults.model === ''\n    ) {\n      throw new Error('No model defined');\n    }\n\n    this.setOptions(options);\n\n    if (models) {\n      validateModels(models);\n    }\n  }\n\n  private getMetricsInstruments(): AxAIMetricsInstruments | undefined {\n    return getOrCreateAIMetricsInstruments(this.meter);\n  }\n\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  public getId(): string {\n    return this.id;\n  }\n\n  public setAPIURL(apiURL: string): void {\n    this.apiURL = apiURL;\n  }\n\n  public setHeaders(headers: () => Promise<Record<string, string>>): void {\n    this.headers = headers;\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.debug = options.debug ?? false;\n    this.rt = options.rateLimiter;\n    this.fetch = options.fetch;\n    this.timeout = options.timeout;\n    this.tracer = options.tracer ?? axGlobals.tracer;\n    this.meter = options.meter ?? axGlobals.meter;\n    this.excludeContentFromTrace = options.excludeContentFromTrace;\n    this.abortSignal = options.abortSignal;\n    this.logger = options.logger ?? defaultLogger;\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return {\n      debug: this.debug,\n      rateLimiter: this.rt,\n      fetch: this.fetch,\n      tracer: this.tracer,\n      meter: this.meter,\n      timeout: this.timeout,\n      excludeContentFromTrace: this.excludeContentFromTrace,\n      abortSignal: this.abortSignal,\n      logger: this.logger,\n    };\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.logger;\n  }\n\n  getModelList(): AxAIModelList | undefined {\n    const models: AxAIModelList = [];\n    for (const model of this.models ?? []) {\n      if (model.isInternal) {\n        continue;\n      }\n\n      if ('model' in model && model.model) {\n        models.push({\n          key: model.key,\n          description: model.description,\n          model: model.model as string,\n        });\n      }\n\n      if ('embedModel' in model && model.embedModel) {\n        models.push({\n          key: model.key,\n          description: model.description,\n          embedModel: model.embedModel as string,\n        });\n      }\n    }\n\n    return models;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getFeatures(model?: TModel): AxAIFeatures {\n    return typeof this.supportFor === 'function'\n      ? this.supportFor(model ?? this.defaults.model)\n      : this.supportFor;\n  }\n\n  getLastUsedChatModel(): TModel | undefined {\n    return this.lastUsedChatModel;\n  }\n\n  getLastUsedEmbedModel(): TEmbedModel | undefined {\n    return this.lastUsedEmbedModel;\n  }\n\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.lastUsedModelConfig;\n  }\n\n  // Method to calculate percentiles\n  private calculatePercentile(\n    samples: readonly number[],\n    percentile: number\n  ): number {\n    if (samples.length === 0) return 0;\n    const sorted = [...samples].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[index] ?? 0;\n  }\n\n  // Method to update latency metrics\n  private updateLatencyMetrics(type: 'chat' | 'embed', duration: number): void {\n    const metrics = this.metrics.latency[type];\n    metrics.samples.push(duration);\n\n    // Keep only last 1000 samples to prevent memory issues\n    if (metrics.samples.length > 1000) {\n      metrics.samples.shift();\n    }\n\n    // Update statistics\n    metrics.mean =\n      metrics.samples.reduce((a, b) => a + b, 0) / metrics.samples.length;\n    metrics.p95 = this.calculatePercentile(metrics.samples, 95);\n    metrics.p99 = this.calculatePercentile(metrics.samples, 99);\n\n    // Export to OpenTelemetry metrics\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n\n      // Record individual latency measurement\n      recordLatencyMetric(metricsInstruments, type, duration, this.name, model);\n\n      // Record latency statistics as gauges\n      recordLatencyStatsMetrics(\n        metricsInstruments,\n        type,\n        metrics.mean,\n        metrics.p95,\n        metrics.p99,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Method to update error metrics\n  private updateErrorMetrics(type: 'chat' | 'embed', isError: boolean): void {\n    const metrics = this.metrics.errors[type];\n    metrics.total++;\n    if (isError) {\n      metrics.count++;\n    }\n    metrics.rate = metrics.count / metrics.total;\n\n    // Export to OpenTelemetry metrics\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n\n      // Always record request count\n      recordRequestMetric(metricsInstruments, type, this.name, model);\n\n      // Record error count if there was an error\n      if (isError) {\n        recordErrorMetric(metricsInstruments, type, this.name, model);\n      }\n\n      // Record current error rate as a gauge\n      recordErrorRateMetric(\n        metricsInstruments,\n        type,\n        metrics.rate,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Method to record token usage metrics\n  private recordTokenUsage(modelUsage?: AxModelUsage): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments && modelUsage?.tokens) {\n      const { promptTokens, completionTokens, totalTokens, thoughtsTokens } =\n        modelUsage.tokens;\n\n      if (promptTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'input',\n          promptTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (completionTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'output',\n          completionTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (totalTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'total',\n          totalTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (thoughtsTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'thoughts',\n          thoughtsTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n    }\n  }\n\n  // Helper method to calculate request size in bytes\n  private calculateRequestSize(req: unknown): number {\n    try {\n      return new TextEncoder().encode(JSON.stringify(req)).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Helper method to calculate response size in bytes\n  private calculateResponseSize(response: unknown): number {\n    try {\n      return new TextEncoder().encode(JSON.stringify(response)).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Helper method to detect multimodal content\n  private detectMultimodalContent(req: Readonly<AxChatRequest<TModel>>): {\n    hasImages: boolean;\n    hasAudio: boolean;\n  } {\n    let hasImages = false;\n    let hasAudio = false;\n\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      for (const message of req.chatPrompt) {\n        if (message.role === 'user' && Array.isArray(message.content)) {\n          for (const part of message.content) {\n            if (part.type === 'image') {\n              hasImages = true;\n            } else if (part.type === 'audio') {\n              hasAudio = true;\n            }\n          }\n        }\n      }\n    }\n\n    return { hasImages, hasAudio };\n  }\n\n  // Helper method to calculate prompt length\n  private calculatePromptLength(req: Readonly<AxChatRequest<TModel>>): number {\n    let totalLength = 0;\n\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      for (const message of req.chatPrompt) {\n        if (message.role === 'system' || message.role === 'assistant') {\n          if (message.content) {\n            totalLength += message.content.length;\n          }\n        } else if (message.role === 'user') {\n          if (typeof message.content === 'string') {\n            totalLength += message.content.length;\n          } else if (Array.isArray(message.content)) {\n            for (const part of message.content) {\n              if (part.type === 'text') {\n                totalLength += part.text.length;\n              }\n            }\n          }\n        } else if (message.role === 'function') {\n          if (message.result) {\n            totalLength += message.result.length;\n          }\n        }\n      }\n    }\n\n    return totalLength;\n  }\n\n  // Helper method to calculate context window usage\n  private calculateContextWindowUsage(\n    model: TModel,\n    modelUsage?: AxModelUsage\n  ): number {\n    if (!modelUsage?.tokens?.promptTokens) return 0;\n\n    // Get model info to find context window size\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (!modelInfo?.contextWindow) return 0;\n\n    return modelUsage.tokens.promptTokens / modelInfo.contextWindow;\n  }\n\n  // Helper method to estimate cost\n  private estimateCost(model: TModel, modelUsage?: AxModelUsage): number {\n    if (!modelUsage?.tokens) return 0;\n\n    // Get model info to find pricing\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (\n      !modelInfo ||\n      (!modelInfo.promptTokenCostPer1M && !modelInfo.completionTokenCostPer1M)\n    )\n      return 0;\n\n    const { promptTokens = 0, completionTokens = 0 } = modelUsage.tokens;\n    const promptCostPer1M = modelInfo.promptTokenCostPer1M || 0;\n    const completionCostPer1M = modelInfo.completionTokenCostPer1M || 0;\n\n    return (\n      (promptTokens * promptCostPer1M) / 1000000 +\n      (completionTokens * completionCostPer1M) / 1000000\n    );\n  }\n\n  // Helper method to estimate cost by model name\n  private estimateCostByName(\n    modelName: string,\n    modelUsage?: AxModelUsage\n  ): number {\n    if (!modelUsage?.tokens) return 0;\n\n    // Get model info to find pricing\n    const modelInfo = this.modelInfo.find((info) => info.name === modelName);\n    if (\n      !modelInfo ||\n      (!modelInfo.promptTokenCostPer1M && !modelInfo.completionTokenCostPer1M)\n    )\n      return 0;\n\n    const { promptTokens = 0, completionTokens = 0 } = modelUsage.tokens;\n    const promptCostPer1M = modelInfo.promptTokenCostPer1M || 0;\n    const completionCostPer1M = modelInfo.completionTokenCostPer1M || 0;\n\n    return (\n      (promptTokens * promptCostPer1M) / 1000000 +\n      (completionTokens * completionCostPer1M) / 1000000\n    );\n  }\n\n  // Helper method to record function call metrics\n  private recordFunctionCallMetrics(\n    functionCalls?: readonly unknown[],\n    model?: TModel\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments || !functionCalls) return;\n\n    for (const call of functionCalls) {\n      if (\n        call &&\n        typeof call === 'object' &&\n        'function' in call &&\n        call.function &&\n        typeof call.function === 'object' &&\n        'name' in call.function\n      ) {\n        recordFunctionCallMetric(\n          metricsInstruments,\n          (call.function as { name: string }).name,\n          undefined, // latency would need to be tracked separately\n          this.name,\n          model as string\n        );\n      }\n    }\n  }\n\n  // Helper method to record timeout metrics\n  private recordTimeoutMetric(type: 'chat' | 'embed'): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n      recordTimeoutMetric(metricsInstruments, type, this.name, model);\n    }\n  }\n\n  // Helper method to record abort metrics\n  private recordAbortMetric(type: 'chat' | 'embed'): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n      recordAbortMetric(metricsInstruments, type, this.name, model);\n    }\n  }\n\n  // Comprehensive method to record all chat-related metrics\n  private recordChatMetrics(\n    req: Readonly<AxChatRequest<TModel>>,\n    options?: Readonly<\n      AxAIPromptConfig & AxAIServiceActionOptions<TModel, TEmbedModel>\n    >,\n    result?: AxChatResponse | ReadableStream<AxChatResponse>\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments) return;\n\n    const model = this.lastUsedChatModel as string;\n    const modelConfig = this.lastUsedModelConfig;\n\n    // Record streaming request metric\n    const isStreaming = modelConfig?.stream ?? false;\n    recordStreamingRequestMetric(\n      metricsInstruments,\n      'chat',\n      isStreaming,\n      this.name,\n      model\n    );\n\n    // Record multimodal request metric\n    const { hasImages, hasAudio } = this.detectMultimodalContent(req);\n    recordMultimodalRequestMetric(\n      metricsInstruments,\n      hasImages,\n      hasAudio,\n      this.name,\n      model\n    );\n\n    // Record prompt length metric\n    const promptLength = this.calculatePromptLength(req);\n    recordPromptLengthMetric(\n      metricsInstruments,\n      promptLength,\n      this.name,\n      model\n    );\n\n    // Record model configuration metrics\n    recordModelConfigMetrics(\n      metricsInstruments,\n      modelConfig?.temperature,\n      modelConfig?.maxTokens,\n      this.name,\n      model\n    );\n\n    // Record thinking budget usage if applicable\n    if (\n      options?.thinkingTokenBudget &&\n      this.modelUsage?.tokens?.thoughtsTokens\n    ) {\n      recordThinkingBudgetUsageMetric(\n        metricsInstruments,\n        this.modelUsage.tokens.thoughtsTokens,\n        this.name,\n        model\n      );\n    }\n\n    // Record request size\n    const requestSize = this.calculateRequestSize(req);\n    recordRequestSizeMetric(\n      metricsInstruments,\n      'chat',\n      requestSize,\n      this.name,\n      model\n    );\n\n    // Record response size and function calls for non-streaming responses\n    if (result && !isStreaming) {\n      const chatResponse = result as AxChatResponse;\n      const responseSize = this.calculateResponseSize(chatResponse);\n      recordResponseSizeMetric(\n        metricsInstruments,\n        'chat',\n        responseSize,\n        this.name,\n        model\n      );\n\n      // Record function call metrics\n      if (chatResponse.results) {\n        for (const chatResult of chatResponse.results) {\n          if (chatResult.functionCalls) {\n            this.recordFunctionCallMetrics(\n              chatResult.functionCalls,\n              this.lastUsedChatModel\n            );\n          }\n        }\n      }\n\n      // Record context window usage\n      const contextUsage = this.calculateContextWindowUsage(\n        this.lastUsedChatModel!,\n        chatResponse.modelUsage\n      );\n      if (contextUsage > 0) {\n        recordContextWindowUsageMetric(\n          metricsInstruments,\n          contextUsage,\n          this.name,\n          model\n        );\n      }\n\n      // Record estimated cost\n      const estimatedCost = this.estimateCost(\n        this.lastUsedChatModel!,\n        chatResponse.modelUsage\n      );\n      if (estimatedCost > 0) {\n        recordEstimatedCostMetric(\n          metricsInstruments,\n          'chat',\n          estimatedCost,\n          this.name,\n          model\n        );\n      }\n    }\n  }\n\n  // Comprehensive method to record all embed-related metrics\n  private recordEmbedMetrics(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    result: Readonly<AxEmbedResponse>\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments) return;\n\n    const model = this.lastUsedEmbedModel as string;\n\n    // Record request size\n    const requestSize = this.calculateRequestSize(req);\n    recordRequestSizeMetric(\n      metricsInstruments,\n      'embed',\n      requestSize,\n      this.name,\n      model\n    );\n\n    // Record response size\n    const responseSize = this.calculateResponseSize(result);\n    recordResponseSizeMetric(\n      metricsInstruments,\n      'embed',\n      responseSize,\n      this.name,\n      model\n    );\n\n    // Record estimated cost\n    const estimatedCost = this.estimateCostByName(model, result.modelUsage);\n    if (estimatedCost > 0) {\n      recordEstimatedCostMetric(\n        metricsInstruments,\n        'embed',\n        estimatedCost,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Public method to get metrics\n  public getMetrics(): AxAIServiceMetrics {\n    return structuredClone(this.metrics);\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<TModel>>,\n    options?: Readonly<\n      AxAIPromptConfig & AxAIServiceActionOptions<TModel, TEmbedModel>\n    >\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const startTime = performance.now();\n    let isError = false;\n    let result: AxChatResponse | ReadableStream<AxChatResponse>;\n\n    try {\n      result = await this._chat1(req, options);\n      return result;\n    } catch (error) {\n      isError = true;\n      // Check for specific error types\n      if (error instanceof Error) {\n        if (\n          error.message.includes('timeout') ||\n          error.name === 'TimeoutError'\n        ) {\n          this.recordTimeoutMetric('chat');\n        } else if (\n          error.message.includes('abort') ||\n          error.name === 'AbortError'\n        ) {\n          this.recordAbortMetric('chat');\n        }\n      }\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.updateLatencyMetrics('chat', duration);\n      this.updateErrorMetrics('chat', isError);\n\n      // Record additional metrics if successful\n      if (!isError) {\n        this.recordChatMetrics(req, options, result!);\n      }\n    }\n  }\n\n  private async _chat1(\n    req: Readonly<AxChatRequest<TModel>>,\n    options?: Readonly<\n      AxAIPromptConfig & AxAIServiceActionOptions<TModel, TEmbedModel>\n    >\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const model = this.getModel(req.model) ?? req.model ?? this.defaults.model;\n\n    // Validate chat prompt messages for empty content\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      validateAxMessageArray(req.chatPrompt);\n    }\n\n    const modelConfig = {\n      ...this.aiImpl.getModelConfig(),\n      ...req.modelConfig,\n    };\n\n    // Check for thinkingTokenBudget support\n    if (\n      options?.thinkingTokenBudget &&\n      !this.getFeatures(model).hasThinkingBudget\n    ) {\n      throw new Error(\n        `Model ${model as string} does not support thinkingTokenBudget.`\n      );\n    }\n\n    // Check for showThoughts support\n    if (options?.showThoughts && !this.getFeatures(model).hasShowThoughts) {\n      throw new Error(\n        `Model ${model as string} does not support showThoughts.`\n      );\n    }\n\n    // Check for expensive model usage\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (modelInfo?.isExpensive && options?.useExpensiveModel !== 'yes') {\n      throw new Error(\n        `Model ${model as string} is marked as expensive and requires explicit confirmation. Set useExpensiveModel: \"yes\" to proceed.`\n      );\n    }\n\n    // stream is true by default unless explicitly set to false\n    modelConfig.stream =\n      (options?.stream !== undefined ? options.stream : modelConfig.stream) ??\n      true;\n\n    const canStream = this.getFeatures(model).streaming;\n    if (!canStream) {\n      modelConfig.stream = false;\n    }\n\n    if (this.tracer) {\n      return await this.tracer.startActiveSpan(\n        'AI Chat Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_OPERATION_NAME]: 'chat',\n            [axSpanAttributes.LLM_REQUEST_MODEL]: model as string,\n            [axSpanAttributes.LLM_REQUEST_MAX_TOKENS]:\n              modelConfig.maxTokens ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_TEMPERATURE]: modelConfig.temperature,\n            [axSpanAttributes.LLM_REQUEST_TOP_P]: modelConfig.topP ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_TOP_K]: modelConfig.topK ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_FREQUENCY_PENALTY]:\n              modelConfig.frequencyPenalty ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_PRESENCE_PENALTY]:\n              modelConfig.presencePenalty ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_STOP_SEQUENCES]:\n              modelConfig.stopSequences?.join(', ') ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_LLM_IS_STREAMING]:\n              modelConfig.stream ?? 'Not set',\n          },\n        },\n        options?.traceContext ?? context.active(),\n        async (span) => {\n          return await this._chat2(model, modelConfig, req, options, span);\n        }\n      );\n    }\n    return await this._chat2(model, modelConfig, req, options);\n  }\n\n  private cleanupFunctionSchema(\n    fn: Readonly<NonNullable<AxChatRequest['functions']>[number]>\n  ): NonNullable<AxChatRequest['functions']>[number] {\n    const cleanFn = { ...fn };\n    if (cleanFn.parameters) {\n      const cleanParams = { ...cleanFn.parameters };\n\n      // Remove empty required array\n      if (\n        Array.isArray(cleanParams.required) &&\n        cleanParams.required.length === 0\n      ) {\n        delete cleanParams.required;\n      }\n\n      // Remove empty properties object\n      if (\n        cleanParams.properties &&\n        Object.keys(cleanParams.properties).length === 0\n      ) {\n        delete cleanParams.properties;\n      }\n\n      // After cleaning, remove the entire parameters object if it's effectively empty\n      // i.e., either no keys left or just { type: 'object' } remaining.\n      if (\n        Object.keys(cleanParams).length === 0 ||\n        (Object.keys(cleanParams).length === 1 && cleanParams.type === 'object')\n      ) {\n        delete cleanFn.parameters;\n      } else {\n        cleanFn.parameters = cleanParams;\n      }\n    }\n    return cleanFn;\n  }\n\n  private async _chat2(\n    model: TModel,\n    modelConfig: Readonly<AxModelConfig>,\n    chatReq: Readonly<Omit<AxChatRequest<TModel>, 'modelConfig'>>,\n    options?: Readonly<AxAIServiceActionOptions<TModel, TEmbedModel>>,\n    span?: Span\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    if (!this.aiImpl.createChatReq) {\n      throw new Error('generateChatReq not implemented');\n    }\n\n    const debug = options?.debug ?? this.debug;\n\n    let functions: NonNullable<AxChatRequest['functions']> | undefined;\n\n    if (chatReq.functions && chatReq.functions.length > 0) {\n      functions = chatReq.functions.map((fn) => this.cleanupFunctionSchema(fn));\n    }\n\n    const req = {\n      ...chatReq,\n      model,\n      functions,\n      modelConfig,\n    };\n\n    // Store the last used model and config\n    this.lastUsedChatModel = model;\n    this.lastUsedModelConfig = modelConfig;\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = await this.aiImpl.createChatReq(\n        req,\n        options as AxAIPromptConfig\n      );\n\n      if (span?.isRecording()) {\n        setChatRequestEvents(chatReq, span, this.excludeContentFromTrace);\n      }\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          headers: await this.buildHeaders(apiConfig.headers),\n          stream: modelConfig.stream,\n          timeout: this.timeout,\n          debug,\n          fetch: this.fetch,\n          span,\n          abortSignal: options?.abortSignal ?? this.abortSignal,\n        },\n        reqValue\n      );\n      return res;\n    };\n\n    if (debug) {\n      logChatRequest(\n        req.chatPrompt,\n        options?.debugHideSystemPrompt,\n        options?.logger ?? this.logger\n      );\n    }\n\n    const rt = options?.rateLimiter ?? this.rt;\n    const rv = rt ? await rt(fn, { modelUsage: this.modelUsage }) : await fn();\n\n    if (modelConfig.stream) {\n      if (!this.aiImpl.createChatStreamResp) {\n        throw new Error('generateChatResp not implemented');\n      }\n\n      const respFn = this.aiImpl.createChatStreamResp.bind(this);\n      const wrappedRespFn =\n        (state: object) => (resp: Readonly<TChatResponseDelta>) => {\n          const res = respFn(resp, state);\n          res.sessionId = options?.sessionId;\n\n          // Only call getTokenUsage if modelUsage is not already provided by the service\n          if (!res.modelUsage) {\n            const tokenUsage = this.aiImpl.getTokenUsage();\n            if (tokenUsage) {\n              res.modelUsage = {\n                ai: this.name,\n                model: model as string,\n                tokens: tokenUsage,\n              };\n            }\n          }\n          this.modelUsage = res.modelUsage;\n          this.recordTokenUsage(res.modelUsage);\n\n          if (span?.isRecording()) {\n            setChatResponseEvents(res, span, this.excludeContentFromTrace);\n          }\n\n          if (debug) {\n            logResponse(res, options?.logger ?? this.logger);\n          }\n          return res;\n        };\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const doneCb = async (_values: readonly AxChatResponse[]) => {\n        if (span?.isRecording()) {\n          span.end();\n        }\n      };\n\n      const st = (rv as ReadableStream<TChatResponseDelta>).pipeThrough(\n        new RespTransformStream<TChatResponseDelta, AxChatResponse>(\n          wrappedRespFn({}),\n          doneCb\n        )\n      );\n      return st;\n    }\n\n    if (!this.aiImpl.createChatResp) {\n      throw new Error('generateChatResp not implemented');\n    }\n\n    const res = this.aiImpl.createChatResp(rv as TChatResponse);\n    res.sessionId = options?.sessionId;\n\n    // Only call getTokenUsage if modelUsage is not already provided by the service\n    if (!res.modelUsage) {\n      const tokenUsage = this.aiImpl.getTokenUsage();\n      if (tokenUsage) {\n        res.modelUsage = {\n          ai: this.name,\n          model: model as string,\n          tokens: tokenUsage,\n        };\n      }\n    }\n\n    if (res.modelUsage) {\n      this.modelUsage = res.modelUsage;\n      this.recordTokenUsage(res.modelUsage);\n    }\n\n    if (span?.isRecording()) {\n      setChatResponseEvents(res, span, this.excludeContentFromTrace);\n      span.end();\n    }\n\n    if (debug) {\n      logResponse(res, options?.logger ?? this.logger);\n    }\n\n    return res;\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceActionOptions<TModel, TEmbedModel>>\n  ): Promise<AxEmbedResponse> {\n    const startTime = performance.now();\n    let isError = false;\n    let result: AxEmbedResponse;\n\n    try {\n      result = await this._embed1(req, options);\n      return result;\n    } catch (error) {\n      isError = true;\n      // Check for specific error types\n      if (error instanceof Error) {\n        if (\n          error.message.includes('timeout') ||\n          error.name === 'TimeoutError'\n        ) {\n          this.recordTimeoutMetric('embed');\n        } else if (\n          error.message.includes('abort') ||\n          error.name === 'AbortError'\n        ) {\n          this.recordAbortMetric('embed');\n        }\n      }\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.updateLatencyMetrics('embed', duration);\n      this.updateErrorMetrics('embed', isError);\n\n      // Record additional metrics if successful\n      if (!isError) {\n        this.recordEmbedMetrics(req, result!);\n      }\n    }\n  }\n\n  private async _embed1(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceActionOptions<TModel, TEmbedModel>>\n  ): Promise<AxEmbedResponse> {\n    const embedModel =\n      this.getEmbedModel(req.embedModel) ??\n      req.embedModel ??\n      this.defaults.embedModel;\n\n    if (!embedModel) {\n      throw new Error('No embed model defined');\n    }\n\n    if (this.tracer) {\n      await this.tracer?.startActiveSpan(\n        'AI Embed Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_OPERATION_NAME]: 'embeddings',\n            [axSpanAttributes.LLM_REQUEST_MODEL]: embedModel as string,\n          },\n        },\n        options?.traceContext ?? context.active(),\n        async (span) => {\n          try {\n            return await this._embed2(embedModel, req, options, span);\n          } finally {\n            span.end();\n          }\n        }\n      );\n    }\n    return this._embed2(embedModel, req, options);\n  }\n\n  private async _embed2(\n    embedModel: TEmbedModel,\n    embedReq: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceActionOptions<TModel, TEmbedModel>>,\n    span?: Span\n  ): Promise<AxEmbedResponse> {\n    if (!this.aiImpl.createEmbedReq) {\n      throw new Error('generateEmbedReq not implemented');\n    }\n    if (!this.aiImpl.createEmbedResp) {\n      throw new Error('generateEmbedResp not implemented');\n    }\n\n    const debug = options?.debug ?? this.debug;\n\n    const req = {\n      ...embedReq,\n      embedModel,\n    };\n\n    // Store the last used embed model\n    this.lastUsedEmbedModel = embedModel;\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = await this.aiImpl.createEmbedReq!(req);\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          headers: await this.buildHeaders(apiConfig.headers),\n          debug,\n          fetch: this.fetch,\n          timeout: this.timeout,\n          span,\n          abortSignal: options?.abortSignal ?? this.abortSignal,\n        },\n        reqValue\n      );\n      return res;\n    };\n\n    const resValue = this.rt\n      ? await this.rt(fn, { modelUsage: this.embedModelUsage })\n      : await fn();\n    const res = this.aiImpl.createEmbedResp!(resValue as TEmbedResponse);\n\n    res.sessionId = options?.sessionId;\n\n    // Only call getTokenUsage if modelUsage is not already provided by the service\n    if (!res.modelUsage) {\n      const tokenUsage = this.aiImpl.getTokenUsage();\n      if (tokenUsage) {\n        res.modelUsage = {\n          ai: this.name,\n          model: embedModel as string,\n          tokens: tokenUsage,\n        };\n      }\n    }\n    this.embedModelUsage = res.modelUsage;\n    this.recordTokenUsage(res.modelUsage);\n\n    if (span?.isRecording() && res.modelUsage?.tokens) {\n      span.addEvent(axSpanEvents.GEN_AI_USAGE, {\n        [axSpanAttributes.LLM_USAGE_INPUT_TOKENS]:\n          res.modelUsage.tokens.promptTokens,\n        [axSpanAttributes.LLM_USAGE_OUTPUT_TOKENS]:\n          res.modelUsage.tokens.completionTokens ?? 0,\n        [axSpanAttributes.LLM_USAGE_TOTAL_TOKENS]:\n          res.modelUsage.tokens.totalTokens,\n      });\n    }\n\n    span?.end();\n    return res;\n  }\n\n  private async buildHeaders(\n    headers: Record<string, string> = {}\n  ): Promise<Record<string, string>> {\n    return { ...headers, ...(await this.headers()) };\n  }\n\n  private getModelByKey(\n    modelName?: TModel | TEmbedModel\n  ): AxAIInputModelList<TModel, TEmbedModel>[number] | undefined {\n    if (!modelName) {\n      return undefined;\n    }\n    const item = this.models?.find((v) => v.key === modelName);\n    return item;\n  }\n\n  private getModel(modelName?: TModel): TModel | undefined {\n    const item = this.getModelByKey(modelName);\n    return item && 'model' in item ? item.model : undefined;\n  }\n\n  private getEmbedModel(modelName?: TEmbedModel): TEmbedModel | undefined {\n    const item = this.getModelByKey(modelName);\n    return item && 'embedModel' in item ? item.embedModel : undefined;\n  }\n}\n\nexport function setChatRequestEvents(\n  req: Readonly<AxChatRequest<unknown>>,\n  span: Span,\n  excludeContentFromTrace?: boolean\n): void {\n  const userMessages: string[] = [];\n\n  if (\n    req.chatPrompt &&\n    Array.isArray(req.chatPrompt) &&\n    req.chatPrompt.length > 0\n  ) {\n    for (const prompt of req.chatPrompt) {\n      switch (prompt.role) {\n        case 'system':\n          if (prompt.content) {\n            const eventData: { content?: string } = {};\n            if (!excludeContentFromTrace) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_SYSTEM_MESSAGE, eventData);\n          }\n          break;\n        case 'user':\n          if (typeof prompt.content === 'string') {\n            userMessages.push(prompt.content);\n          } else if (Array.isArray(prompt.content)) {\n            for (const part of prompt.content) {\n              if (part.type === 'text') {\n                userMessages.push(part.text);\n              }\n            }\n          }\n          break;\n        case 'assistant': {\n          const functionCalls = prompt.functionCalls?.map((call) => {\n            return {\n              id: call.id,\n              type: call.type,\n              function: call.function.name,\n              arguments: call.function.params,\n            };\n          });\n\n          if (functionCalls && functionCalls.length > 0) {\n            const eventData: { content?: string; function_calls: string } = {\n              function_calls: JSON.stringify(functionCalls, null, 2),\n            };\n            if (!excludeContentFromTrace && prompt.content) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_ASSISTANT_MESSAGE, eventData);\n          } else if (prompt.content) {\n            const eventData: { content?: string } = {};\n            if (!excludeContentFromTrace) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_ASSISTANT_MESSAGE, eventData);\n          }\n          break;\n        }\n\n        case 'function': {\n          const eventData: { content?: string; id: string } = {\n            id: prompt.functionId,\n          };\n          if (!excludeContentFromTrace) {\n            eventData.content = prompt.result;\n          }\n          span.addEvent(axSpanEvents.GEN_AI_TOOL_MESSAGE, eventData);\n          break;\n        }\n      }\n    }\n  }\n\n  // Always add user message event, even if empty\n  const userEventData: { content?: string } = {};\n  if (!excludeContentFromTrace) {\n    userEventData.content = userMessages.join('\\n');\n  }\n  span.addEvent(axSpanEvents.GEN_AI_USER_MESSAGE, userEventData);\n}\n\nexport function setChatResponseEvents(\n  res: Readonly<AxChatResponse>,\n  span: Span,\n  excludeContentFromTrace?: boolean\n) {\n  if (res.modelUsage?.tokens) {\n    const thoughTokens = res.modelUsage.tokens.thoughtsTokens\n      ? {\n          [axSpanAttributes.LLM_USAGE_THOUGHTS_TOKENS]:\n            res.modelUsage.tokens.thoughtsTokens,\n        }\n      : {};\n    span.addEvent(axSpanEvents.GEN_AI_USAGE, {\n      [axSpanAttributes.LLM_USAGE_INPUT_TOKENS]:\n        res.modelUsage.tokens.promptTokens,\n      [axSpanAttributes.LLM_USAGE_OUTPUT_TOKENS]:\n        res.modelUsage.tokens.completionTokens ?? 0,\n      [axSpanAttributes.LLM_USAGE_TOTAL_TOKENS]:\n        res.modelUsage.tokens.totalTokens,\n      ...thoughTokens,\n    });\n  }\n\n  if (!res.results) {\n    return;\n  }\n\n  for (let index = 0; index < res.results.length; index++) {\n    const result = res.results[index];\n    if (!result) {\n      continue;\n    }\n\n    // Skip empty results that have no meaningful content to avoid empty GEN_AI_CHOICE events\n    if (\n      !result.content &&\n      !result.thought &&\n      !result.functionCalls?.length &&\n      !result.finishReason\n    ) {\n      continue;\n    }\n\n    const toolCalls = result.functionCalls?.map((call) => {\n      return {\n        id: call.id,\n        type: call.type,\n        function: call.function.name,\n        arguments: call.function.params,\n      };\n    });\n\n    const message: { content?: string; tool_calls?: unknown[] } = {};\n\n    if (toolCalls && toolCalls.length > 0) {\n      if (!excludeContentFromTrace) {\n        message.content = result.content;\n      }\n      message.tool_calls = toolCalls;\n    } else {\n      if (!excludeContentFromTrace) {\n        message.content = result.content ?? '';\n      }\n    }\n\n    span.addEvent(axSpanEvents.GEN_AI_CHOICE, {\n      finish_reason: result.finishReason,\n      index,\n      message: JSON.stringify(message, null, 2),\n    });\n  }\n}\n\nexport function validateAxMessageArray<T>(values: T[]): void {\n  // Validate AxMessage array items\n  for (let i = 0; i < values.length; i++) {\n    const message = values[i];\n    if (!message || typeof message !== 'object') {\n      throw new Error(\n        `AxMessage array validation failed: Item at index ${i} is not a valid message object`\n      );\n    }\n    if (\n      'content' in message &&\n      typeof message.content === 'string' &&\n      message.content.trim() === ''\n    ) {\n      throw new Error(\n        `AxMessage array validation failed: Item at index ${i} has empty content`\n      );\n    }\n  }\n}\n\nfunction validateModels<TModel, TEmbedModel>(\n  models: Readonly<AxAIInputModelList<TModel, TEmbedModel>>\n): void {\n  // Validate duplicate keys in models.\n  const keys = new Set<string>();\n  for (const model of models) {\n    if (keys.has(model.key)) {\n      throw new Error(\n        `Duplicate model key detected: \"${model.key}\". Each model key must be unique.`\n      );\n    }\n    keys.add(model.key);\n  }\n}\n", "import type { Meter, Tracer } from '@opentelemetry/api';\n\nexport type AxFunctionResultFormatter = (result: unknown) => string;\n\nexport const axGlobals = {\n  signatureStrict: true, // Controls reservedNames enforcement in signature parsing/validation\n  tracer: undefined as Tracer | undefined, // Global OpenTelemetry tracer for all AI operations\n  meter: undefined as Meter | undefined, // Global OpenTelemetry meter for metrics collection\n  functionResultFormatter: ((result: unknown) => {\n    return typeof result === 'string'\n      ? result\n      : result === undefined || result === null\n        ? ''\n        : JSON.stringify(result, null, 2);\n  }) as AxFunctionResultFormatter, // Global function result formatter\n};\n", "export const axSpanAttributes = {\n  // LLM\n  LLM_SYSTEM: 'gen_ai.system',\n  LLM_OPERATION_NAME: 'gen_ai.operation.name',\n  LLM_REQUEST_MODEL: 'gen_ai.request.model',\n  LLM_REQUEST_MAX_TOKENS: 'gen_ai.request.max_tokens',\n  LLM_REQUEST_TEMPERATURE: 'gen_ai.request.temperature',\n  LLM_REQUEST_TOP_K: 'gen_ai.request.top_k',\n  LLM_REQUEST_FREQUENCY_PENALTY: 'gen_ai.request.frequency_penalty',\n  LLM_REQUEST_PRESENCE_PENALTY: 'gen_ai.request.presence_penalty',\n  LLM_REQUEST_STOP_SEQUENCES: 'gen_ai.request.stop_sequences',\n  LLM_REQUEST_LLM_IS_STREAMING: 'gen_ai.request.llm_is_streaming',\n  LLM_REQUEST_TOP_P: 'gen_ai.request.top_p',\n\n  LLM_USAGE_INPUT_TOKENS: 'gen_ai.usage.input_tokens',\n  LLM_USAGE_OUTPUT_TOKENS: 'gen_ai.usage.output_tokens',\n  LLM_USAGE_TOTAL_TOKENS: 'gen_ai.usage.total_tokens',\n  LLM_USAGE_THOUGHTS_TOKENS: 'gen_ai.usage.thoughts_tokens',\n\n  // Vector DB\n  DB_SYSTEM: 'db.system',\n  DB_TABLE: 'db.table',\n  DB_NAMESPACE: 'db.namespace',\n  DB_ID: 'db.id',\n  DB_QUERY_TEXT: 'db.query.text',\n  DB_VECTOR: 'db.vector',\n  DB_OPERATION_NAME: 'db.operation.name',\n  DB_VECTOR_QUERY_TOP_K: 'db.vector.query.top_k',\n\n  DB_QUERY_EMBEDDINGS: 'db.query.embeddings',\n  DB_QUERY_RESULT: 'db.query.result',\n\n  // Query Embeddings\n  DB_QUERY_EMBEDDINGS_VECTOR: 'db.query.embeddings.vector',\n\n  // Query Result (canonical format)\n  DB_QUERY_RESULT_ID: 'db.query.result.id',\n  DB_QUERY_RESULT_SCORE: 'db.query.result.score',\n  DB_QUERY_RESULT_DISTANCE: 'db.query.result.distance',\n  DB_QUERY_RESULT_METADATA: 'db.query.result.metadata',\n  DB_QUERY_RESULT_VECTOR: 'db.query.result.vector',\n  DB_QUERY_RESULT_DOCUMENT: 'db.query.result.document',\n};\n\nexport const axSpanEvents = {\n  GEN_AI_USER_MESSAGE: 'gen_ai.user.message',\n  GEN_AI_SYSTEM_MESSAGE: 'gen_ai.system.message',\n  GEN_AI_ASSISTANT_MESSAGE: 'gen_ai.assistant.message',\n  GEN_AI_TOOL_MESSAGE: 'gen_ai.tool.message', // For tool messages in request & response tool calls\n  GEN_AI_CHOICE: 'gen_ai.choice',\n  GEN_AI_USAGE: 'gen_ai.usage',\n};\n\nexport enum AxLLMRequestTypeValues {\n  COMPLETION = 'completion',\n  CHAT = 'chat',\n  RERANK = 'rerank',\n  UNKNOWN = 'unknown',\n}\n\nexport enum AxSpanKindValues {\n  WORKFLOW = 'workflow',\n  TASK = 'task',\n  AGENT = 'agent',\n  TOOL = 'tool',\n  UNKNOWN = 'unknown',\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\n\nclass TypeTransformer<I, O> implements Transformer<I, O> {\n  private buffer?: O[];\n  private doneCallback?: (args0: readonly O[]) => Promise<void>;\n  private transformFn: (arg0: I) => O;\n\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    this.transformFn = transformFn;\n    this.doneCallback = doneCallback;\n    this.buffer = doneCallback ? [] : undefined;\n  }\n\n  async transform(obj: I, controller: TransformStreamDefaultController<O>) {\n    const val = this.transformFn(obj);\n    if (val) {\n      controller.enqueue(val);\n      this.buffer?.push(val);\n    }\n  }\n\n  async flush(controller: TransformStreamDefaultController<O>) {\n    await this.doneCallback?.(this.buffer ?? []);\n    controller.terminate();\n  }\n}\n\nexport class RespTransformStream<I, O> extends TransformStream<I, O> {\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    super(new TypeTransformer<I, O>(transformFn, doneCallback));\n  }\n}\n", "export class ColorLog {\n  // ANSI escape codes for different colors\n  private readonly ANSI_WHITE_BRIGHT = '\\x1b[97m';\n  private readonly ANSI_GREEN_BRIGHT = '\\x1b[92m';\n  private readonly ANSI_BLUE_BRIGHT = '\\x1b[94m';\n  private readonly ANSI_RED_BRIGHT = '\\x1b[91m';\n\n  private readonly ANSI_YELLOW = '\\x1b[93m';\n  private readonly ANSI_RED = '\\x1b[91m';\n  private readonly ANSI_RESET = '\\x1b[0m';\n  private readonly ANSI_ORANGE = '\\x1b[38;5;208m';\n  private readonly ANSI_WHITE = '\\x1b[37m';\n\n  // Method to wrap text with the specified ANSI color code\n  private colorize(text: string, colorCode: string): string {\n    return `${colorCode}${text}${this.ANSI_RESET}`;\n  }\n\n  // Public methods to colorize text in various colors\n  public whiteBright(text: string): string {\n    return this.colorize(text, this.ANSI_WHITE_BRIGHT);\n  }\n\n  public greenBright(text: string): string {\n    return this.colorize(text, this.ANSI_GREEN_BRIGHT);\n  }\n\n  public blueBright(text: string): string {\n    return this.colorize(text, this.ANSI_BLUE_BRIGHT);\n  }\n\n  public redBright(text: string): string {\n    return this.colorize(text, this.ANSI_RED_BRIGHT);\n  }\n\n  public white(text: string): string {\n    return this.colorize(text, this.ANSI_WHITE);\n  }\n\n  public yellow(text: string): string {\n    return this.colorize(text, this.ANSI_YELLOW);\n  }\n\n  public red(text: string): string {\n    return this.colorize(text, this.ANSI_RED);\n  }\n\n  public orange(text: string): string {\n    return this.colorize(text, this.ANSI_ORANGE);\n  }\n}\n", "import type { AxLoggerFunction, AxLoggerTag } from '../ai/types.js';\nimport { ColorLog } from '../util/log.js';\n\nconst colorLog = new ColorLog();\n\n// Default output function that writes to stdout\nconst defaultOutput = (message: string): void => {\n  process.stdout.write(message);\n};\n\n// Factory function to create a default logger with customizable output\nexport const axCreateDefaultColorLogger = (\n  output: (message: string) => void = defaultOutput\n): AxLoggerFunction => {\n  return (message: string, options?: { tags?: AxLoggerTag[] }) => {\n    const tags = options?.tags ?? [];\n    let formattedMessage = message;\n\n    // Step 1: Pick color function based on semantic tags\n    let colorFunction: (text: string) => string = (text) => text; // default no color\n\n    if (tags.includes('systemContent')) {\n      colorFunction = (text) => colorLog.white(text);\n    } else if (tags.includes('userContent')) {\n      colorFunction = (text) => colorLog.white(text);\n    } else if (tags.includes('functionName')) {\n      colorFunction = (text) => colorLog.greenBright(text);\n    } else if (tags.includes('functionArg')) {\n      colorFunction = (text) => colorLog.greenBright(text);\n    } else if (tags.includes('assistantContent')) {\n      colorFunction = (text) => colorLog.white(text);\n    } else if (tags.includes('responseContent')) {\n      colorFunction = (text) => colorLog.greenBright(text);\n    } else if (tags.includes('functionResult')) {\n      colorFunction = (text) => colorLog.blueBright(text);\n    }\n\n    if (tags.includes('error')) {\n      colorFunction = (text) => colorLog.redBright(text);\n    } else if (tags.includes('warning')) {\n      colorFunction = (text) => colorLog.red(text);\n    }\n\n    // Step 2: Add prefix based on tag type\n    if (\n      tags.includes('systemContent') ||\n      tags.includes('userContent') ||\n      tags.includes('functionName') ||\n      tags.includes('functionArg') ||\n      tags.includes('functionResult') ||\n      tags.includes('assistantStart') ||\n      tags.includes('start') ||\n      tags.includes('end')\n    ) {\n      formattedMessage = `\\n${formattedMessage}`;\n    }\n\n    if (tags.includes('responseEnd')) {\n      formattedMessage = `${formattedMessage}\\n\\n`;\n    }\n    // Step 4: Apply color function and output\n    output(colorFunction(formattedMessage));\n  };\n};\n\nexport const defaultLogger: AxLoggerFunction = axCreateDefaultColorLogger();\n\n// Factory function to create a text-only logger (no colors) with customizable output\nexport const axCreateDefaultTextLogger = (\n  output: (message: string) => void = defaultOutput\n): AxLoggerFunction => {\n  return (message: string, options?: { tags?: AxLoggerTag[] }) => {\n    const tags = options?.tags ?? [];\n    let formattedMessage = message;\n\n    // Step 1: No color function needed for text logger\n\n    // Step 2: Add prefix based on tag type\n    if (\n      tags.includes('systemContent') ||\n      tags.includes('userContent') ||\n      tags.includes('functionName') ||\n      tags.includes('functionArg') ||\n      tags.includes('functionResult') ||\n      tags.includes('assistantStart') ||\n      tags.includes('start') ||\n      tags.includes('end')\n    ) {\n      formattedMessage = `\\n${formattedMessage}`;\n    }\n\n    if (tags.includes('responseEnd')) {\n      formattedMessage = `${formattedMessage}\\n`;\n    }\n\n    // Step 4: Output without color\n    output(formattedMessage);\n  };\n};\n\n/**\n * Factory function to create an enhanced optimizer logger with clean visual formatting\n * that works for all optimizer types using semantic tags for proper categorization\n */\nexport const axCreateOptimizerLogger = (\n  output: (message: string) => void = (msg) => process.stdout.write(msg)\n): AxLoggerFunction => {\n  const baseLogger = axCreateDefaultColorLogger(output);\n\n  // Track state for better visual flow\n  let isFirstPhase = true;\n\n  return (message: string, options) => {\n    const tags = options?.tags ?? [];\n    let formattedMessage = message;\n\n    // Use tags for semantic formatting instead of string pattern matching\n    if (tags.includes('optimizer')) {\n      if (tags.includes('start')) {\n        const trialsMatch =\n          message.match(/with (\\d+) trials?/) || message.match(/(\\d+) trials?/);\n        const optimizerMatch = message.match(\n          /(MIPROv2|BootstrapFewshot|[A-Z][a-zA-Z]+)/\n        );\n        const optimizerName = optimizerMatch ? optimizerMatch[1] : 'Optimizer';\n\n        if (trialsMatch?.[1]) {\n          formattedMessage = `\\n ${optimizerName} optimization (${trialsMatch[1]} trials)\\n`;\n        } else {\n          formattedMessage = `\\n ${optimizerName} optimization\\n`;\n        }\n        isFirstPhase = true;\n      } else if (tags.includes('config')) {\n        if (message.includes('examples') && message.includes('training')) {\n          const match =\n            message.match(\n              /(\\d+) examples for training and (\\d+) for validation/\n            ) || message.match(/(\\d+) training.*?(\\d+) validation/);\n          if (match?.[1] && match[2]) {\n            formattedMessage = `  Dataset: ${match[1]} training, ${match[2]} validation\\n`;\n          } else {\n            const simpleMatch = message.match(/(\\d+) examples/);\n            if (simpleMatch?.[1]) {\n              formattedMessage = `  Dataset: ${simpleMatch[1]} examples\\n`;\n            }\n          }\n        } else if (message.includes('teacher')) {\n          formattedMessage = '  Using teacher model\\n';\n        } else {\n          formattedMessage = `  ${message}\\n`;\n        }\n      } else if (tags.includes('phase')) {\n        if (isFirstPhase) {\n          formattedMessage = ` ${message}\\n`;\n          isFirstPhase = false;\n        } else {\n          formattedMessage = ` ${message}\\n`;\n        }\n      } else if (tags.includes('result')) {\n        if (message.includes('Generated') || message.includes('Selected')) {\n          const match = message.match(/(\\d+)/);\n          if (match?.[1]) {\n            formattedMessage = `   ${message}\\n`;\n          } else {\n            formattedMessage = `   ${message}\\n`;\n          }\n        } else if (message.includes('configuration')) {\n          formattedMessage = '  Applied best configuration\\n';\n        } else {\n          formattedMessage = `  ${message}\\n`;\n        }\n      } else if (tags.includes('progress')) {\n        formattedMessage = `  ${message}\\n`;\n      } else if (tags.includes('complete')) {\n        const scoreMatch = message.match(/(score|performance):\\s*([\\d.]+)/);\n        if (scoreMatch?.[2]) {\n          const score = Number.parseFloat(scoreMatch[2]);\n          const percentage =\n            score <= 1 ? `${(score * 100).toFixed(1)}%` : score.toFixed(3);\n          formattedMessage = ` Complete! Best: ${percentage}\\n`;\n        } else if (message.includes('Bootstrap')) {\n          formattedMessage = ` ${message}\\n`;\n        } else {\n          formattedMessage = ' Optimization complete\\n';\n        }\n      } else if (tags.includes('checkpoint')) {\n        if (message.includes('Resuming')) {\n          formattedMessage = `  ${message}\\n`;\n        } else {\n          const match =\n            message.match(/checkpoint:\\s*(.+)/) ||\n            message.match(/Saved\\s+(.+)/);\n          if (match?.[1]) {\n            formattedMessage = ` Saved: ${match[1]}\\n`;\n          } else {\n            formattedMessage = ' Checkpoint saved\\n';\n          }\n        }\n      }\n    }\n\n    // Handle non-optimizer messages with basic formatting\n    else if (tags.includes('discovery')) {\n      if (message.includes('Found') && message.includes('examples')) {\n        const match = message.match(/Found (\\d+)/);\n        if (match?.[1]) {\n          formattedMessage = `  Found ${match[1]} examples\\n`;\n        }\n      }\n    }\n\n    // Handle errors and warnings\n    if (tags.includes('error')) {\n      formattedMessage = `\\n ${message}\\n`;\n    } else if (tags.includes('warning')) {\n      formattedMessage = `\\n ${message}\\n`;\n    }\n\n    // Use the base logger for color formatting and output\n    baseLogger(formattedMessage, options);\n  };\n};\n\n/**\n * Default optimizer logger instance\n */\nexport const axDefaultOptimizerLogger = axCreateOptimizerLogger();\n", "import { defaultLogger } from '../dsp/loggers.js';\nimport type {\n  AxChatRequest,\n  AxChatResponse,\n  AxLoggerFunction,\n  AxLoggerTag,\n} from './types.js';\n\nconst formatChatMessage = (\n  msg: AxChatRequest['chatPrompt'][number],\n  hideContent?: boolean,\n  hideSystemPrompt?: boolean\n) => {\n  switch (msg.role) {\n    case 'system':\n      if (hideSystemPrompt) {\n        return '';\n      }\n      return ` System: \\n${msg.content}`;\n    case 'function':\n      return ` Function Result: \\n${msg.result}`;\n    case 'user': {\n      if (typeof msg.content === 'string') {\n        return ` User: \\n${msg.content}`;\n      }\n      const items = msg.content.map((v) => {\n        switch (v.type) {\n          case 'text':\n            return v.text;\n          case 'image':\n            return `(Image, ${v.mimeType}) ${v.image.substring(0, 10)}`;\n          default:\n            throw new Error('Invalid content type');\n        }\n      });\n      return ` User: \\n${items.join('\\n')}`;\n    }\n    case 'assistant': {\n      if (msg.functionCalls) {\n        const fns = msg.functionCalls?.map(({ function: fn }) => {\n          const args =\n            typeof fn.params !== 'string'\n              ? JSON.stringify(fn.params, null, 2)\n              : fn.params;\n          return `${fn.name}(${args})`;\n        });\n        return ` Functions: \\n${fns.join('\\n')}`;\n      }\n      return ` Assistant: \\n${hideContent ? '' : (msg.content ?? '<empty>')}`;\n    }\n    default:\n      throw new Error('Invalid role');\n  }\n};\n\nexport const logChatRequestMessage = (\n  msg: AxChatRequest['chatPrompt'][number],\n  hideSystemPrompt?: boolean,\n  logger: AxLoggerFunction = defaultLogger\n) => {\n  logChatRequest([msg], hideSystemPrompt, logger);\n};\n\nexport const logChatRequest = (\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>,\n  hideSystemPrompt?: boolean,\n  logger: AxLoggerFunction = defaultLogger\n) => {\n  for (const msg of chatPrompt ?? []) {\n    const formattedMessage = formatChatMessage(msg, false, hideSystemPrompt);\n    if (formattedMessage) {\n      const tags: AxLoggerTag[] = [];\n\n      switch (msg.role) {\n        case 'system':\n          tags.push('systemContent');\n          break;\n        case 'function':\n          tags.push('functionName');\n          break;\n        case 'user':\n          tags.push('userContent');\n          break;\n      }\n\n      logger(formattedMessage, { tags });\n    }\n  }\n\n  logger(' Assistant: ', { tags: ['assistantStart'] });\n};\n\nexport const logResponseResult = (\n  r: Readonly<AxChatResponse['results'][number] & { index: number }>,\n  logger: AxLoggerFunction = defaultLogger\n) => {\n  if (r.content) {\n    logger(r.content, { tags: ['responseContent'] });\n  }\n\n  const loggedFunctionCalls = new Set<string>();\n\n  if (r.functionCalls && r.functionCalls.length > 0) {\n    for (const [i, f] of r.functionCalls.entries()) {\n      if (f.id) {\n        if (loggedFunctionCalls.has(f.id)) {\n          continue;\n        }\n        loggedFunctionCalls.add(f.id);\n\n        const tags: AxLoggerTag[] = ['functionName'];\n        if (i === 0) {\n          tags.push('firstFunction');\n        }\n        if (r.functionCalls.length > 1) {\n          tags.push('multipleFunctions');\n        }\n        logger(`[${i + 1}] ${f.function.name} [${f.id}]`, { tags });\n      }\n\n      if (f.function.params) {\n        const params =\n          typeof f.function.params === 'string'\n            ? f.function.params\n            : JSON.stringify(f.function.params, null, 2);\n        logger(params, { tags: ['functionArg'] });\n      }\n    }\n  }\n};\n\nexport const logResponse = (\n  resp: Readonly<AxChatResponse>,\n  logger: AxLoggerFunction = defaultLogger\n) => {\n  if (!resp.results) {\n    return;\n  }\n  for (const r of resp.results) {\n    logResponseResult(r, logger);\n  }\n};\n\nexport const logResponseDelta = (\n  delta: string,\n  logger: AxLoggerFunction = defaultLogger\n) => {\n  logger(delta, { tags: ['responseContent', 'responseDelta'] });\n};\n\nexport const logFunctionResults = (\n  results: Readonly<\n    { result: string; functionId: string; isError?: boolean; index: number }[]\n  >,\n  logger: AxLoggerFunction = defaultLogger\n) => {\n  for (const result of results) {\n    logger(`Function Result [${result.functionId}]:`, {\n      tags: ['functionResult'],\n    });\n\n    if (result.isError) {\n      logger(result.result, { tags: ['functionResult', 'error'] });\n    } else {\n      logger(result.result, { tags: ['functionResult'] });\n    }\n  }\n};\n", "import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\n// Utility function to sanitize metric labels\nconst sanitizeLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length to prevent excessive memory usage\n      sanitized[key] =\n        stringValue.length > 100 ? stringValue.substring(0, 100) : stringValue;\n    }\n  }\n  return sanitized;\n};\n\nexport interface AxAIMetricsInstruments {\n  latencyHistogram?: Histogram;\n  errorCounter?: Counter;\n  requestCounter?: Counter;\n  tokenCounter?: Counter;\n  inputTokenCounter?: Counter;\n  outputTokenCounter?: Counter;\n  errorRateGauge?: Gauge;\n  meanLatencyGauge?: Gauge;\n  p95LatencyGauge?: Gauge;\n  p99LatencyGauge?: Gauge;\n\n  streamingRequestsCounter?: Counter;\n\n  functionCallsCounter?: Counter;\n  functionCallLatencyHistogram?: Histogram;\n\n  requestSizeHistogram?: Histogram;\n  responseSizeHistogram?: Histogram;\n\n  temperatureGauge?: Gauge;\n  maxTokensGauge?: Gauge;\n\n  estimatedCostCounter?: Counter;\n\n  promptLengthHistogram?: Histogram;\n  contextWindowUsageGauge?: Gauge;\n\n  timeoutsCounter?: Counter;\n  abortsCounter?: Counter;\n\n  thinkingBudgetUsageCounter?: Counter;\n  multimodalRequestsCounter?: Counter;\n}\n\n// Singleton instance for AI metrics instruments\nlet globalAIMetricsInstruments: AxAIMetricsInstruments | undefined;\n\n// Function to get or create AI metrics instruments (singleton pattern)\nexport const getOrCreateAIMetricsInstruments = (\n  meter?: Meter\n): AxAIMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalAIMetricsInstruments) {\n    return globalAIMetricsInstruments;\n  }\n\n  if (meter) {\n    globalAIMetricsInstruments = createMetricsInstruments(meter);\n    return globalAIMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the AI metrics singleton (useful for testing)\nexport const resetAIMetricsInstruments = (): void => {\n  globalAIMetricsInstruments = undefined;\n};\n\nexport const createMetricsInstruments = (\n  meter: Meter\n): AxAIMetricsInstruments => {\n  return {\n    latencyHistogram: meter.createHistogram('ax_llm_request_duration_ms', {\n      description: 'Duration of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    errorCounter: meter.createCounter('ax_llm_errors_total', {\n      description: 'Total number of LLM request errors',\n    }),\n\n    requestCounter: meter.createCounter('ax_llm_requests_total', {\n      description: 'Total number of LLM requests',\n    }),\n\n    tokenCounter: meter.createCounter('ax_llm_tokens_total', {\n      description: 'Total number of LLM tokens consumed',\n    }),\n\n    inputTokenCounter: meter.createCounter('ax_llm_input_tokens_total', {\n      description: 'Total number of input/prompt tokens consumed',\n    }),\n\n    outputTokenCounter: meter.createCounter('ax_llm_output_tokens_total', {\n      description: 'Total number of output/completion tokens generated',\n    }),\n\n    errorRateGauge: meter.createGauge('ax_llm_error_rate', {\n      description: 'Current error rate as a percentage (0-100)',\n    }),\n\n    meanLatencyGauge: meter.createGauge('ax_llm_mean_latency_ms', {\n      description: 'Mean latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    p95LatencyGauge: meter.createGauge('ax_llm_p95_latency_ms', {\n      description: '95th percentile latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    p99LatencyGauge: meter.createGauge('ax_llm_p99_latency_ms', {\n      description: '99th percentile latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    streamingRequestsCounter: meter.createCounter(\n      'ax_llm_streaming_requests_total',\n      {\n        description: 'Total number of streaming LLM requests',\n      }\n    ),\n\n    functionCallsCounter: meter.createCounter('ax_llm_function_calls_total', {\n      description: 'Total number of function/tool calls made',\n    }),\n\n    functionCallLatencyHistogram: meter.createHistogram(\n      'ax_llm_function_call_latency_ms',\n      {\n        description: 'Latency of function calls in milliseconds',\n        unit: 'ms',\n      }\n    ),\n\n    requestSizeHistogram: meter.createHistogram('ax_llm_request_size_bytes', {\n      description: 'Size of LLM request payloads in bytes',\n      unit: 'By',\n    }),\n\n    responseSizeHistogram: meter.createHistogram('ax_llm_response_size_bytes', {\n      description: 'Size of LLM response payloads in bytes',\n      unit: 'By',\n    }),\n\n    temperatureGauge: meter.createGauge('ax_llm_temperature_gauge', {\n      description: 'Temperature setting used for LLM requests',\n    }),\n\n    maxTokensGauge: meter.createGauge('ax_llm_max_tokens_gauge', {\n      description: 'Maximum tokens setting used for LLM requests',\n    }),\n\n    estimatedCostCounter: meter.createCounter('ax_llm_estimated_cost_total', {\n      description: 'Estimated cost of LLM requests in USD',\n      unit: '$',\n    }),\n\n    promptLengthHistogram: meter.createHistogram('ax_llm_prompt_length_chars', {\n      description: 'Length of prompts in characters',\n    }),\n\n    contextWindowUsageGauge: meter.createGauge(\n      'ax_llm_context_window_usage_ratio',\n      {\n        description: 'Context window utilization ratio (0-1)',\n      }\n    ),\n\n    timeoutsCounter: meter.createCounter('ax_llm_timeouts_total', {\n      description: 'Total number of timed out LLM requests',\n    }),\n\n    abortsCounter: meter.createCounter('ax_llm_aborts_total', {\n      description: 'Total number of aborted LLM requests',\n    }),\n\n    thinkingBudgetUsageCounter: meter.createCounter(\n      'ax_llm_thinking_budget_usage_total',\n      {\n        description: 'Total thinking budget tokens used',\n      }\n    ),\n\n    multimodalRequestsCounter: meter.createCounter(\n      'ax_llm_multimodal_requests_total',\n      {\n        description: 'Total number of multimodal requests (with images/audio)',\n      }\n    ),\n  };\n};\n\nexport const recordLatencyMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  duration: number,\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    if (instruments.latencyHistogram) {\n      const labels = sanitizeLabels({\n        operation: type,\n        ai_service: aiService,\n        ...(model ? { model } : {}),\n      });\n      instruments.latencyHistogram.record(duration, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record latency metric:', error);\n  }\n};\n\nexport const recordLatencyStatsMetrics = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  meanLatency: number,\n  p95Latency: number,\n  p99Latency: number,\n  aiService: string,\n  model?: string\n): void => {\n  const labels = {\n    operation: type,\n    ai_service: aiService,\n    ...(model ? { model } : {}),\n  };\n\n  if (instruments.meanLatencyGauge) {\n    instruments.meanLatencyGauge.record(meanLatency, labels);\n  }\n\n  if (instruments.p95LatencyGauge) {\n    instruments.p95LatencyGauge.record(p95Latency, labels);\n  }\n\n  if (instruments.p99LatencyGauge) {\n    instruments.p99LatencyGauge.record(p99Latency, labels);\n  }\n};\n\nexport const recordErrorMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    if (instruments.errorCounter) {\n      const labels = sanitizeLabels({\n        operation: type,\n        ai_service: aiService,\n        ...(model ? { model } : {}),\n      });\n      instruments.errorCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record error metric:', error);\n  }\n};\n\nexport const recordErrorRateMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  errorRate: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.errorRateGauge) {\n    instruments.errorRateGauge.record(errorRate * 100, {\n      // Convert to percentage\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.requestCounter) {\n    instruments.requestCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordTokenMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'input' | 'output' | 'total' | 'thoughts',\n  tokens: number,\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n\n    // Record in the general token counter with type label\n    if (instruments.tokenCounter) {\n      instruments.tokenCounter.add(tokens, {\n        token_type: type,\n        ...labels,\n      });\n    }\n\n    // Also record in specific counters for input/output\n    if (type === 'input' && instruments.inputTokenCounter) {\n      instruments.inputTokenCounter.add(tokens, labels);\n    }\n\n    if (type === 'output' && instruments.outputTokenCounter) {\n      instruments.outputTokenCounter.add(tokens, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record token metric:', error);\n  }\n};\n\nexport const recordStreamingRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  isStreaming: boolean,\n  aiService: string,\n  model?: string\n): void => {\n  if (isStreaming && instruments.streamingRequestsCounter) {\n    instruments.streamingRequestsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordFunctionCallMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  functionName: string,\n  latency?: number,\n  aiService?: string,\n  model?: string\n): void => {\n  const labels = {\n    function_name: functionName,\n    ...(aiService ? { ai_service: aiService } : {}),\n    ...(model ? { model } : {}),\n  };\n\n  if (instruments.functionCallsCounter) {\n    instruments.functionCallsCounter.add(1, labels);\n  }\n\n  if (latency && instruments.functionCallLatencyHistogram) {\n    instruments.functionCallLatencyHistogram.record(latency, labels);\n  }\n};\n\nexport const recordRequestSizeMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  sizeBytes: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.requestSizeHistogram) {\n    instruments.requestSizeHistogram.record(sizeBytes, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordResponseSizeMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  sizeBytes: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.responseSizeHistogram) {\n    instruments.responseSizeHistogram.record(sizeBytes, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordModelConfigMetrics = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  temperature?: number,\n  maxTokens?: number,\n  aiService?: string,\n  model?: string\n): void => {\n  const labels = {\n    ...(aiService ? { ai_service: aiService } : {}),\n    ...(model ? { model } : {}),\n  };\n\n  if (temperature !== undefined && instruments.temperatureGauge) {\n    instruments.temperatureGauge.record(temperature, labels);\n  }\n\n  if (maxTokens !== undefined && instruments.maxTokensGauge) {\n    instruments.maxTokensGauge.record(maxTokens, labels);\n  }\n};\n\nexport const recordEstimatedCostMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  costUSD: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.estimatedCostCounter) {\n    instruments.estimatedCostCounter.add(costUSD, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordPromptLengthMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  lengthChars: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.promptLengthHistogram) {\n    instruments.promptLengthHistogram.record(lengthChars, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordContextWindowUsageMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  usageRatio: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.contextWindowUsageGauge) {\n    instruments.contextWindowUsageGauge.record(usageRatio, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordTimeoutMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.timeoutsCounter) {\n    instruments.timeoutsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordAbortMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.abortsCounter) {\n    instruments.abortsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordThinkingBudgetUsageMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  tokensUsed: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.thinkingBudgetUsageCounter) {\n    instruments.thinkingBudgetUsageCounter.add(tokensUsed, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordMultimodalRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  hasImages: boolean,\n  hasAudio: boolean,\n  aiService: string,\n  model?: string\n): void => {\n  if ((hasImages || hasAudio) && instruments.multimodalRequestsCounter) {\n    instruments.multimodalRequestsCounter.add(1, {\n      ai_service: aiService,\n      has_images: hasImages.toString(),\n      has_audio: hasAudio.toString(),\n      ...(model ? { model } : {}),\n    });\n  }\n};\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIAnthropicModel {\n  Claude4Opus = 'claude-opus-4-20250514',\n  Claude4Sonnet = 'claude-sonnet-4-20250514',\n  Claude37Sonnet = 'claude-3-7-sonnet-latest',\n\n  Claude35Sonnet = 'claude-3-5-sonnet-latest',\n  Claude35Haiku = 'claude-3-5-haiku-latest',\n\n  Claude3Opus = 'claude-3-opus-latest',\n  Claude3Sonnet = 'claude-3-sonnet-20240229',\n  Claude3Haiku = 'claude-3-haiku-20240307',\n\n  Claude21 = 'claude-2.1',\n  ClaudeInstant12 = 'claude-instant-1.2',\n}\n\nexport enum AxAIAnthropicVertexModel {\n  Claude37Sonnet = 'claude-3-7-sonnet',\n  Claude35Haiku = 'claude-3-5-haiku',\n  Claude35Sonnet = 'claude-3-5-sonnet',\n  Claude35SonnetV2 = 'claude-3-5-sonnet-v2',\n  Claude3Haiku = 'claude-3-haiku',\n  Claude3Opus = 'claude-3-opus',\n}\n\nexport type AxAIAnthropicThinkingConfig = {\n  type: 'enabled';\n  budget_tokens: number;\n};\n\nexport type AxAIAnthropicThinkingTokenBudgetLevels = {\n  minimal?: number;\n  low?: number;\n  medium?: number;\n  high?: number;\n  highest?: number;\n};\n\nexport type AxAIAnthropicConfig = AxModelConfig & {\n  model: AxAIAnthropicModel | AxAIAnthropicVertexModel;\n  thinking?: AxAIAnthropicThinkingConfig;\n  thinkingTokenBudgetLevels?: AxAIAnthropicThinkingTokenBudgetLevels;\n};\n\nexport type AxAIAnthropicChatRequestCacheParam = {\n  cache_control?: { type: 'ephemeral' };\n};\n\n// Type for the request to create a message using Anthropic's Messages API\nexport type AxAIAnthropicChatRequest = {\n  model?: string;\n  anthropic_version?: string;\n  messages: (\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | ({\n                  type: 'text';\n                  text: string;\n                } & AxAIAnthropicChatRequestCacheParam)\n              | ({\n                  type: 'image';\n                  source: { type: 'base64'; media_type: string; data: string };\n                } & AxAIAnthropicChatRequestCacheParam)\n              | {\n                  type: 'tool_result';\n                  is_error?: boolean;\n                  tool_use_id: string;\n                  content:\n                    | string\n                    | (\n                        | ({\n                            type: 'text';\n                            text: string;\n                          } & AxAIAnthropicChatRequestCacheParam)\n                        | ({\n                            type: 'image';\n                            source: {\n                              type: 'base64';\n                              media_type: string;\n                              data: string;\n                            };\n                          } & AxAIAnthropicChatRequestCacheParam)\n                      )[];\n                }\n            )[];\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | (\n              | { type: 'text'; text: string }\n              | { type: 'tool_use'; id: string; name: string; input: object }\n              | { type: 'thinking'; thinking: string; signature?: string }\n              | {\n                  type: 'redacted_thinking';\n                  thinking: string;\n                  signature?: string;\n                }\n            )[];\n      }\n  )[];\n  tools?: ({\n    name: string;\n    description: string;\n    input_schema?: object;\n  } & AxAIAnthropicChatRequestCacheParam)[];\n  tool_choice?: { type: 'auto' | 'any' } | { type: 'tool'; name?: string };\n  max_tokens?: number; // Maximum number of tokens to generate\n  // Optional metadata about the request\n  stop_sequences?: string[]; // Custom sequences that trigger the end of generation\n  stream?: boolean; // Whether to stream the response incrementally\n  system?:\n    | string\n    | ({\n        type: 'text';\n        text: string;\n      } & AxAIAnthropicChatRequestCacheParam)[]; // system prompt\n  temperature?: number; // Randomness of the response\n  top_p?: number; // Nucleus sampling probability\n  top_k?: number; // Sample from the top K options\n  thinking?: AxAIAnthropicThinkingConfig; // Extended thinking configuration\n  metadata?: {\n    user_id: string;\n  };\n};\n\nexport type AxAIAnthropicChatResponse = {\n  id: string; // Unique identifier for the response\n  type: 'message'; // Object type, always 'message' for this API\n  role: 'assistant'; // Conversational role of the generated message, always 'assistant'\n  content: (\n    | {\n        type: 'text';\n        text: string;\n      }\n    | {\n        id: string;\n        name: string;\n        type: 'tool_use';\n        input?: string;\n      }\n    | {\n        type: 'thinking';\n        thinking: string;\n        signature?: string;\n      }\n    | {\n        type: 'redacted_thinking';\n        thinking: string;\n        signature?: string;\n      }\n  )[];\n  model: string;\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use';\n  stop_sequence?: string;\n  usage: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n};\n\nexport type AxAIAnthropicChatError = {\n  type: 'error';\n  error: {\n    type: 'authentication_error';\n    message: string;\n  };\n};\n\n// Represents the start of a message with an empty content array\nexport interface AxAIAnthropicMessageStartEvent {\n  type: 'message_start';\n  message: {\n    id: string;\n    type: 'message';\n    role: 'assistant';\n    content: [];\n    model: string;\n    stop_reason: null | string;\n    stop_sequence: null | string;\n    usage: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n}\n\n// Indicates the start of a content block within a message\nexport interface AxAIAnthropicContentBlockStartEvent {\n  index: number;\n  type: 'content_block_start';\n  content_block:\n    | {\n        type: 'text';\n        text: string;\n      }\n    | {\n        type: 'tool_use';\n        id: string;\n        name: string;\n        input: object;\n      }\n    | {\n        type: 'thinking';\n        thinking: string;\n      };\n}\n\n// Represents incremental updates to a content block\nexport interface AxAIAnthropicContentBlockDeltaEvent {\n  index: number;\n  type: 'content_block_delta';\n  delta:\n    | {\n        type: 'text_delta';\n        text: string;\n      }\n    | {\n        type: 'input_json_delta';\n        partial_json: string;\n      }\n    | {\n        type: 'thinking_delta';\n        thinking: string;\n      }\n    | {\n        type: 'signature_delta';\n        signature: string;\n      };\n}\n\n// Marks the end of a content block within a message\nexport interface AxAIAnthropicContentBlockStopEvent {\n  type: 'content_block_stop';\n  index: number;\n}\n\n// Indicates top-level changes to the final message object\nexport interface AxAIAnthropicMessageDeltaEvent {\n  type: 'message_delta';\n  delta: {\n    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | null;\n    stop_sequence: string | null;\n  };\n  usage: {\n    output_tokens: number;\n  };\n}\n\n// Marks the end of a message\nexport interface AxAIAnthropicMessageStopEvent {\n  type: 'message_stop';\n}\n\n// Represents a ping event, which can occur any number of times\nexport interface AxAIAnthropicPingEvent {\n  type: 'ping';\n}\n\n// Represents an error event\nexport interface AxAIAnthropicErrorEvent {\n  type: 'error';\n  error: {\n    type: 'overloaded_error';\n    message: string;\n  };\n}\n\n// Union type for all possible event types in the stream\nexport type AxAIAnthropicChatResponseDelta =\n  | AxAIAnthropicMessageStartEvent\n  | AxAIAnthropicContentBlockStartEvent\n  | AxAIAnthropicContentBlockDeltaEvent\n  | AxAIAnthropicContentBlockStopEvent\n  | AxAIAnthropicMessageDeltaEvent\n  | AxAIAnthropicMessageStopEvent\n  | AxAIAnthropicPingEvent\n  | AxAIAnthropicErrorEvent;\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIAnthropicModel } from './types.js';\n\nexport const axModelInfoAnthropic: AxModelInfo[] = [\n  // 4\n  {\n    name: AxAIAnthropicModel.Claude4Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n    maxTokens: 32000,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIAnthropicModel.Claude4Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 64000,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  // 3.7\n  {\n    name: AxAIAnthropicModel.Claude37Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 64000,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  // 3.5\n  {\n    name: AxAIAnthropicModel.Claude35Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 8192,\n  },\n  {\n    name: AxAIAnthropicModel.Claude35Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 4.0,\n    maxTokens: 8192,\n  },\n  // 3\n  {\n    name: AxAIAnthropicModel.Claude3Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 1.25,\n    maxTokens: 4096,\n  },\n  // 2.1\n  {\n    name: AxAIAnthropicModel.Claude21,\n    currency: 'usd',\n    promptTokenCostPer1M: 8.0,\n    completionTokenCostPer1M: 25,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.ClaudeInstant12,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2.24,\n    maxTokens: 4096,\n  },\n];\n", "import { getModelInfo } from '@ax-llm/ax/dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport { AxBaseAI, axBaseAIDefaultConfig } from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\nimport { axModelInfoAnthropic } from './info.js';\nimport {\n  type AxAIAnthropicChatError,\n  type AxAIAnthropicChatRequest,\n  type AxAIAnthropicChatResponse,\n  type AxAIAnthropicChatResponseDelta,\n  type AxAIAnthropicConfig,\n  type AxAIAnthropicContentBlockDeltaEvent,\n  type AxAIAnthropicContentBlockStartEvent,\n  type AxAIAnthropicErrorEvent,\n  type AxAIAnthropicMessageDeltaEvent,\n  type AxAIAnthropicMessageStartEvent,\n  AxAIAnthropicModel,\n  type AxAIAnthropicThinkingConfig,\n  AxAIAnthropicVertexModel,\n} from './types.js';\n\nexport const axAIAnthropicDefaultConfig = (): AxAIAnthropicConfig =>\n  structuredClone({\n    model: AxAIAnthropicModel.Claude37Sonnet,\n    maxTokens: 40000, // Ensure maxTokens is higher than highest thinking budget\n    thinkingTokenBudgetLevels: {\n      minimal: 1024,\n      low: 5000,\n      medium: 10000,\n      high: 20000,\n      highest: 32000,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIAnthropicVertexDefaultConfig = (): AxAIAnthropicConfig =>\n  structuredClone({\n    model: AxAIAnthropicVertexModel.Claude37Sonnet,\n    maxTokens: 40000, // Ensure maxTokens is higher than highest thinking budget\n    thinkingTokenBudgetLevels: {\n      minimal: 1024,\n      low: 5000,\n      medium: 10000,\n      high: 20000,\n      highest: 32000,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport interface AxAIAnthropicArgs {\n  name: 'anthropic';\n  apiKey?: string | (() => Promise<string>);\n  projectId?: string;\n  region?: string;\n  config?: Readonly<Partial<AxAIAnthropicConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<\n    AxAIAnthropicModel | AxAIAnthropicVertexModel,\n    undefined\n  >;\n}\n\nclass AxAIAnthropicImpl\n  implements\n    AxAIServiceImpl<\n      AxAIAnthropicModel | AxAIAnthropicVertexModel,\n      unknown,\n      AxAIAnthropicChatRequest,\n      unknown,\n      AxAIAnthropicChatResponse,\n      AxAIAnthropicChatResponseDelta,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n  private currentPromptConfig?: AxAIPromptConfig;\n\n  constructor(\n    private config: AxAIAnthropicConfig,\n    private isVertex: boolean\n  ) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens ?? 4096,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      stream: config.stream,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq = async (\n    req: Readonly<\n      AxInternalChatRequest<AxAIAnthropicModel | AxAIAnthropicVertexModel>\n    >,\n    config: Readonly<AxAIPromptConfig>\n  ): Promise<[AxAPI, AxAIAnthropicChatRequest]> => {\n    // Store config for use in response methods\n    this.currentPromptConfig = config;\n\n    const model = req.model;\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    let apiConfig: AxAPI;\n    if (this.isVertex) {\n      apiConfig = {\n        name: stream\n          ? `/models/${model}:streamRawPredict?alt=sse`\n          : `/models/${model}:rawPredict`,\n      };\n    } else {\n      apiConfig = {\n        name: '/messages',\n      };\n    }\n\n    let toolsChoice:\n      | { tool_choice: { type: 'auto' | 'any' | 'tool'; name?: string } }\n      | undefined;\n\n    if (req.functionCall && req.functions && req.functions.length > 0) {\n      if (typeof req.functionCall === 'string') {\n        switch (req.functionCall) {\n          case 'auto':\n            toolsChoice = { tool_choice: { type: 'auto' as const } };\n            break;\n          case 'required':\n            toolsChoice = { tool_choice: { type: 'any' as const } };\n            break;\n          case 'none':\n            throw new Error('functionCall none not supported');\n        }\n      } else if ('function' in req.functionCall) {\n        toolsChoice = {\n          tool_choice: {\n            type: 'tool' as const,\n            name: req.functionCall.function.name,\n          },\n        };\n      } else {\n        throw new Error('Invalid function call type, must be string or object');\n      }\n    }\n\n    const system = req.chatPrompt\n      .filter((msg) => msg.role === 'system')\n      .map((msg) => ({\n        type: 'text' as const,\n        text: msg.content,\n        ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n      }));\n\n    const otherMessages = req.chatPrompt.filter((msg) => msg.role !== 'system');\n\n    const messages = createMessages(otherMessages);\n\n    const tools: AxAIAnthropicChatRequest['tools'] = req.functions?.map(\n      (v) => ({\n        name: v.name,\n        description: v.description,\n        input_schema: v.parameters,\n      })\n    );\n\n    const maxTokens = req.modelConfig?.maxTokens ?? this.config.maxTokens;\n    const stopSequences =\n      req.modelConfig?.stopSequences ?? this.config.stopSequences;\n    const temperature = req.modelConfig?.temperature ?? this.config.temperature;\n    const topP = req.modelConfig?.topP ?? this.config.topP;\n    const topK = req.modelConfig?.topK ?? this.config.topK;\n    const n = req.modelConfig?.n ?? this.config.n;\n\n    if (n && n > 1) {\n      throw new Error('Anthropic does not support sampling (n > 1)');\n    }\n\n    // Handle thinking configuration\n    let thinkingConfig: AxAIAnthropicThinkingConfig | undefined;\n\n    if (this.config.thinking?.budget_tokens) {\n      thinkingConfig = this.config.thinking;\n    }\n\n    // Override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      const levels = this.config.thinkingTokenBudgetLevels;\n\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          // When thinkingTokenBudget is 'none', disable thinking entirely\n          thinkingConfig = undefined;\n          break;\n        case 'minimal':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.minimal ?? 1024,\n          };\n          break;\n        case 'low':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.low ?? 5000,\n          };\n          break;\n        case 'medium':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.medium ?? 10000,\n          };\n          break;\n        case 'high':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.high ?? 20000,\n          };\n          break;\n        case 'highest':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.highest ?? 32000,\n          };\n          break;\n      }\n    }\n\n    const reqValue: AxAIAnthropicChatRequest = {\n      ...(this.isVertex\n        ? { anthropic_version: 'vertex-2023-10-16' }\n        : { model }),\n      ...(maxTokens ? { max_tokens: maxTokens } : {}),\n      ...(stopSequences && stopSequences.length > 0\n        ? { stop_sequences: stopSequences }\n        : {}),\n      // Only include temperature when thinking is not enabled\n      ...(temperature && !thinkingConfig ? { temperature } : {}),\n      // Only include top_p when thinking is not enabled, or when it's >= 0.95\n      ...(topP && (!thinkingConfig || topP >= 0.95) ? { top_p: topP } : {}),\n      // Only include top_k when thinking is not enabled\n      ...(topK && !thinkingConfig ? { top_k: topK } : {}),\n      ...toolsChoice,\n      ...(tools && tools.length > 0 ? { tools } : {}),\n      ...(stream ? { stream: true } : {}),\n      ...(system ? { system } : {}),\n      ...(thinkingConfig ? { thinking: thinkingConfig } : {}),\n      messages,\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIAnthropicChatResponse | AxAIAnthropicChatError>\n  ): AxChatResponse => {\n    if (resp.type === 'error') {\n      // Use AxAIRefusalError for authentication and API errors that could be refusal-related\n      throw new AxAIRefusalError(\n        resp.error.message,\n        undefined, // model not specified in error response\n        undefined // requestId not specified in error response\n      );\n    }\n\n    const finishReason = mapFinishReason(resp.stop_reason);\n\n    // Determine if thoughts should be shown\n    const showThoughts =\n      this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n      this.currentPromptConfig?.showThoughts !== false;\n\n    const results = resp.content\n      .map((msg, index): AxChatResponseResult => {\n        if (msg.type === 'tool_use') {\n          return {\n            index,\n            id: msg.id,\n            functionCalls: [\n              {\n                id: msg.id,\n                type: 'function' as const,\n                function: {\n                  name: msg.name,\n                  params: msg.input,\n                },\n              },\n            ],\n            finishReason,\n          };\n        }\n        if (\n          (msg.type === 'thinking' || msg.type === 'redacted_thinking') &&\n          showThoughts\n        ) {\n          return {\n            index,\n            thought: msg.thinking,\n            id: resp.id,\n            finishReason,\n          };\n        }\n        return {\n          index,\n          content: msg.type === 'text' ? msg.text : '',\n          id: resp.id,\n          finishReason,\n        };\n      })\n      .filter(\n        (result) =>\n          result.content !== '' ||\n          result.thought !== undefined ||\n          result.functionCalls !== undefined\n      );\n\n    this.tokensUsed = {\n      promptTokens: resp.usage.input_tokens,\n      completionTokens: resp.usage.output_tokens,\n      totalTokens: resp.usage.input_tokens + resp.usage.output_tokens,\n    };\n\n    return { results, remoteId: resp.id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIAnthropicChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    if (!('type' in resp)) {\n      throw new Error('Invalid Anthropic streaming event');\n    }\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>;\n    };\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {};\n    }\n\n    if (resp.type === 'error') {\n      const { error } = resp as unknown as AxAIAnthropicErrorEvent;\n      throw new AxAIRefusalError(\n        error.message,\n        undefined, // model not specified in error event\n        undefined // requestId not specified in error event\n      );\n    }\n\n    const index = 0;\n\n    if (resp.type === 'message_start') {\n      const { message } = resp as unknown as AxAIAnthropicMessageStartEvent;\n      const results = [{ index, content: '', id: message.id }];\n\n      this.tokensUsed = {\n        promptTokens: message.usage?.input_tokens ?? 0,\n        completionTokens: message.usage?.output_tokens ?? 0,\n        totalTokens:\n          (message.usage?.input_tokens ?? 0) +\n          (message.usage?.output_tokens ?? 0),\n      };\n      return { results };\n    }\n\n    if (resp.type === 'content_block_start') {\n      const { content_block: contentBlock } =\n        resp as unknown as AxAIAnthropicContentBlockStartEvent;\n\n      if (contentBlock.type === 'text') {\n        return {\n          results: [{ index, content: contentBlock.text }],\n        };\n      }\n      if (contentBlock.type === 'thinking') {\n        // Determine if thoughts should be shown\n        const showThoughts =\n          this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n          this.currentPromptConfig?.showThoughts !== false;\n        if (showThoughts) {\n          return {\n            results: [{ index, thought: contentBlock.thinking }],\n          };\n        }\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (contentBlock.type === 'tool_use') {\n        if (\n          typeof contentBlock.id === 'string' &&\n          typeof resp.index === 'number' &&\n          !sstate.indexIdMap[resp.index]\n        ) {\n          sstate.indexIdMap[resp.index] = contentBlock.id;\n          const functionCalls = [\n            {\n              id: contentBlock.id,\n              type: 'function' as const,\n              function: {\n                name: contentBlock.name,\n                params: '',\n              },\n            },\n          ];\n          return {\n            results: [{ index, functionCalls }],\n          };\n        }\n      }\n    }\n\n    if (resp.type === 'content_block_delta') {\n      const { delta } = resp as unknown as AxAIAnthropicContentBlockDeltaEvent;\n      if (delta.type === 'text_delta') {\n        return {\n          results: [{ index, content: delta.text }],\n        };\n      }\n      if (delta.type === 'thinking_delta') {\n        // Determine if thoughts should be shown\n        const showThoughts =\n          this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n          this.currentPromptConfig?.showThoughts !== false;\n        if (showThoughts) {\n          return {\n            results: [{ index, thought: delta.thinking }],\n          };\n        }\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (delta.type === 'signature_delta') {\n        // Signature deltas are handled internally by Anthropic,\n        // we don't need to expose them in the response\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (delta.type === 'input_json_delta') {\n        const id = sstate.indexIdMap[resp.index];\n        if (!id) {\n          throw new Error(`invalid streaming index no id found: ${resp.index}`);\n        }\n        const functionCalls = [\n          {\n            id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: delta.partial_json,\n            },\n          },\n        ];\n        return {\n          results: [{ index, functionCalls }],\n        };\n      }\n    }\n\n    if (resp.type === 'message_delta') {\n      const { delta, usage } =\n        resp as unknown as AxAIAnthropicMessageDeltaEvent;\n\n      this.tokensUsed = {\n        promptTokens: 0,\n        completionTokens: usage.output_tokens,\n        totalTokens: usage.output_tokens,\n      };\n\n      const results = [\n        {\n          index,\n          content: '',\n          finishReason: mapFinishReason(delta.stop_reason),\n        },\n      ];\n      return { results };\n    }\n\n    return {\n      results: [{ index, content: '' }],\n    };\n  };\n}\n\nexport class AxAIAnthropic extends AxBaseAI<\n  AxAIAnthropicModel | AxAIAnthropicVertexModel,\n  unknown,\n  AxAIAnthropicChatRequest,\n  unknown,\n  AxAIAnthropicChatResponse,\n  AxAIAnthropicChatResponseDelta,\n  unknown\n> {\n  constructor({\n    apiKey,\n    projectId,\n    region,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIAnthropicArgs, 'name'>>) {\n    const isVertex = projectId !== undefined && region !== undefined;\n\n    let apiURL: string;\n    let headers: () => Promise<Record<string, string>>;\n\n    if (isVertex) {\n      if (!apiKey) {\n        throw new Error('Anthropic Vertex API key not set');\n      }\n      apiURL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/anthropic/`;\n      headers = async () => ({\n        Authorization: `Bearer ${typeof apiKey === 'function' ? await apiKey() : apiKey}`,\n      });\n    } else {\n      if (!apiKey) {\n        throw new Error('Anthropic API key not set');\n      }\n      apiURL = 'https://api.anthropic.com/v1';\n      headers = async () => ({\n        'anthropic-version': '2023-06-01',\n        'anthropic-beta': 'prompt-caching-2024-07-31',\n        'x-api-key': typeof apiKey === 'function' ? await apiKey() : apiKey,\n      });\n    }\n\n    const Config = {\n      ...axAIAnthropicDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIAnthropicImpl(Config, isVertex);\n\n    const supportFor = (\n      model: AxAIAnthropicModel | AxAIAnthropicVertexModel\n    ) => {\n      const mi = getModelInfo<\n        AxAIAnthropicModel | AxAIAnthropicVertexModel,\n        undefined\n      >({\n        model,\n        modelInfo: axModelInfoAnthropic,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        functionCot: true,\n      };\n    };\n\n    super(aiImpl, {\n      name: 'Anthropic',\n      apiURL,\n      headers,\n      modelInfo: axModelInfoAnthropic,\n      defaults: { model: Config.model },\n      options,\n      supportFor,\n      models,\n    });\n  }\n}\n\ntype AnthropicMsg = AxAIAnthropicChatRequest['messages'][0];\ntype AnthropicMsgRoleUser = Extract<AnthropicMsg, { role: 'user' }>;\ntype AnthropicMsgRoleUserToolResult = Extract<\n  AnthropicMsgRoleUser['content'][0],\n  { type: 'tool_result' }\n>;\n\nfunction createMessages(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>\n): AxAIAnthropicChatRequest['messages'] {\n  const items: AxAIAnthropicChatRequest['messages'] = chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'function': {\n        const content: AnthropicMsgRoleUserToolResult[] = [\n          {\n            type: 'tool_result' as const,\n            content: msg.result,\n            tool_use_id: msg.functionId,\n            ...(msg.isError ? { is_error: true } : {}),\n            ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n          },\n        ];\n\n        return {\n          role: 'user' as const,\n          content,\n        };\n      }\n      case 'user': {\n        if (typeof msg.content === 'string') {\n          return {\n            role: 'user' as const,\n            content: msg.content,\n          };\n        }\n        const content = msg.content.map((v) => {\n          switch (v.type) {\n            case 'text':\n              return {\n                type: 'text' as const,\n                text: v.text,\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              };\n            case 'image':\n              return {\n                type: 'image' as const,\n                source: {\n                  type: 'base64' as const,\n                  media_type: v.mimeType,\n                  data: v.image,\n                },\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              };\n            default:\n              throw new Error('Invalid content type');\n          }\n        });\n        return {\n          role: 'user' as const,\n          content,\n        };\n      }\n      case 'assistant': {\n        let content: Extract<\n          AxAIAnthropicChatRequest['messages'][0],\n          { role: 'assistant' }\n        >['content'] = '';\n\n        if (typeof msg.content === 'string') {\n          content = msg.content;\n        }\n        if (typeof msg.functionCalls !== 'undefined') {\n          content = msg.functionCalls.map((v) => {\n            let input: object = {};\n            if (typeof v.function.params === 'string') {\n              input = JSON.parse(v.function.params);\n            } else if (typeof v.function.params === 'object') {\n              input = v.function.params as object;\n            }\n            return {\n              type: 'tool_use' as const,\n              id: v.id,\n              name: v.function.name,\n              input,\n              ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n            };\n          });\n        }\n        return {\n          role: 'assistant' as const,\n          content,\n        };\n      }\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n\n  return mergeAssistantMessages(items);\n}\n\n// Anthropic and some others need this in non-streaming mode\nfunction mergeAssistantMessages(\n  messages: Readonly<AxAIAnthropicChatRequest['messages']>\n): AxAIAnthropicChatRequest['messages'] {\n  const mergedMessages: AxAIAnthropicChatRequest['messages'] = [];\n\n  for (const [i, cur] of messages.entries()) {\n    // Continue if not an assistant message or first message\n    if (cur.role !== 'assistant') {\n      mergedMessages.push(cur);\n      continue;\n    }\n\n    // Merge current message with the previous one if both are from the assistant\n    if (i > 0 && messages.at(i - 1)?.role === 'assistant') {\n      const lastMessage = mergedMessages.pop();\n\n      mergedMessages.push({\n        ...(lastMessage ? lastMessage : {}),\n        ...cur,\n      });\n    } else {\n      mergedMessages.push(cur);\n    }\n  }\n\n  return mergedMessages;\n}\n\nfunction mapFinishReason(\n  stopReason?: AxAIAnthropicChatResponse['stop_reason'] | null\n): AxChatResponse['results'][0]['finishReason'] | undefined {\n  if (!stopReason) {\n    return undefined;\n  }\n  switch (stopReason) {\n    case 'stop_sequence':\n      return 'stop';\n    case 'max_tokens':\n      return 'length';\n    case 'tool_use':\n      return 'function_call';\n    case 'end_turn':\n      return 'stop';\n    default:\n      return 'stop';\n  }\n}\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIOpenAIModel {\n  // Non-reasoning models\n  GPT4 = 'gpt-4',\n  GPT41 = 'gpt-4.1',\n  GPT41Mini = 'gpt-4.1-mini',\n  GPT4O = 'gpt-4o',\n  GPT4OMini = 'gpt-4o-mini',\n  GPT4ChatGPT4O = 'chatgpt-4o-latest',\n  GPT4Turbo = 'gpt-4-turbo',\n  GPT35Turbo = 'gpt-3.5-turbo',\n  GPT35TurboInstruct = 'gpt-3.5-turbo-instruct',\n  GPT35TextDavinci002 = 'text-davinci-002',\n  GPT3TextBabbage002 = 'text-babbage-002',\n  GPT3TextAda001 = 'text-ada-001',\n  // Reasoning models\n  O1 = 'o1',\n  O1Mini = 'o1-mini',\n  O3 = 'o3',\n  O3Mini = 'o3-mini',\n  O4Mini = 'o4-mini',\n}\n\nexport enum AxAIOpenAIEmbedModel {\n  TextEmbeddingAda002 = 'text-embedding-ada-002',\n  TextEmbedding3Small = 'text-embedding-3-small',\n  TextEmbedding3Large = 'text-embedding-3-large',\n}\n\n// Web search annotation types\nexport type AxAIOpenAIUrlCitation = {\n  url: string;\n  title?: string;\n  description?: string;\n};\n\nexport type AxAIOpenAIAnnotation = {\n  type: 'url_citation';\n  url_citation: AxAIOpenAIUrlCitation;\n};\n\nexport type AxAIOpenAIConfig<TModel, TEmbedModel> = Omit<\n  AxModelConfig,\n  'topK'\n> & {\n  model: TModel;\n  embedModel?: TEmbedModel;\n  user?: string;\n  responseFormat?: 'json_object';\n  bestOf?: number;\n  logitBias?: Map<string, number>;\n  suffix?: string | null;\n  stop?: string[];\n  logprobs?: number;\n  echo?: boolean;\n  dimensions?: number;\n  reasoningEffort?: 'low' | 'medium' | 'high';\n  store?: boolean;\n  serviceTier?: 'auto' | 'default' | 'flex';\n  webSearchOptions?: {\n    searchContextSize?: 'low' | 'medium' | 'high';\n    userLocation?: {\n      approximate: {\n        type: 'approximate';\n        city?: string;\n        country?: string;\n        region?: string;\n        timezone?: string;\n      };\n    } | null;\n  };\n};\n\nexport type AxAIOpenAILogprob = {\n  tokens: string[];\n  token_logprobs: number[];\n  top_logprobs: Map<string, number>;\n  text_offset: number[];\n};\n\nexport type AxAIOpenAIUsage = {\n  prompt_tokens: number;\n  completion_tokens: number;\n  total_tokens: number;\n};\n\nexport interface AxAIOpenAIResponseDelta<T> {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    delta: T;\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }[];\n  usage?: AxAIOpenAIUsage;\n  system_fingerprint: string;\n}\n\nexport type AxAIOpenAIChatRequest<TModel> = {\n  model: TModel;\n  reasoning_effort?: 'low' | 'medium' | 'high';\n  store?: boolean;\n  messages: (\n    | { role: 'system'; content: string }\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | {\n                  type: string;\n                  text: string;\n                }\n              | {\n                  type: 'image_url';\n                  image_url: { url: string; details?: 'high' | 'low' | 'auto' };\n                }\n              | {\n                  type: 'input_audio';\n                  input_audio: { data: string; format?: 'wav' };\n                }\n              | {\n                  type: 'file';\n                  file: {\n                    file_data: string;\n                    filename: string;\n                  };\n                }\n            )[];\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | {\n              type: string;\n              text: string;\n            };\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content?:\n          | string\n          | {\n              type: string;\n              text: string;\n            };\n        name?: string;\n        tool_calls: {\n          type: 'function';\n          function: {\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments?: string;\n          };\n        }[];\n      }\n    | { role: 'tool'; content: string; tool_call_id: string }\n  )[];\n  tools?: {\n    type: 'function';\n    function: {\n      name: string;\n      description: string;\n      parameters?: object;\n    };\n  }[];\n  tool_choice?:\n    | 'none'\n    | 'auto'\n    | 'required'\n    | { type: 'function'; function: { name: string } };\n  response_format?: { type: string };\n  max_completion_tokens?: number;\n  temperature?: number;\n  top_p?: number;\n  n?: number;\n  stream?: boolean;\n  stop?: readonly string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  logit_bias?: Map<string, number>;\n  user?: string;\n  organization?: string;\n  web_search_options?: {\n    search_context_size?: 'low' | 'medium' | 'high';\n    user_location?: {\n      approximate: {\n        type: 'approximate';\n        city?: string;\n        country?: string;\n        region?: string;\n        timezone?: string;\n      };\n    } | null;\n  };\n};\n\nexport type AxAIOpenAIChatResponse = {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    message: {\n      role: string;\n      content: string | null;\n      refusal: string | null;\n      reasoning_content?: string;\n      annotations?: AxAIOpenAIAnnotation[];\n      tool_calls?: {\n        id: string;\n        type: 'function';\n        // eslint-disable-next-line functional/functional-parameters\n        function: { name: string; arguments: string };\n      }[];\n    };\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }[];\n  usage?: AxAIOpenAIUsage;\n  error?: {\n    message: string;\n    type: string;\n    param: string;\n    code: number;\n  };\n  system_fingerprint: string;\n};\n\nexport type AxAIOpenAIChatResponseDelta = AxAIOpenAIResponseDelta<{\n  content: string | null;\n  refusal?: string | null;\n  reasoning_content?: string;\n  role?: string;\n  annotations?: AxAIOpenAIAnnotation[];\n  tool_calls?: (NonNullable<\n    AxAIOpenAIChatResponse['choices'][0]['message']['tool_calls']\n  >[0] & {\n    index: number;\n  })[];\n}>;\n\nexport type AxAIOpenAIEmbedRequest<TEmbedModel> = {\n  input: readonly string[];\n  model: TEmbedModel;\n  dimensions?: number;\n  user?: string;\n};\n\nexport type AxAIOpenAIEmbedResponse = {\n  model: string;\n  data: {\n    embedding: readonly number[];\n    index: number;\n  }[];\n  usage: AxAIOpenAIUsage;\n};\n", "import type {\n  AxChatRequest,\n  AxChatResponseResult,\n  AxModelConfig,\n} from '../types.js';\n\n// Extended model enum for the responses API that includes models only available on responses API\nexport enum AxAIOpenAIResponsesModel {\n  // Non-reasoning models\n  GPT4 = 'gpt-4',\n  GPT41 = 'gpt-4.1',\n  GPT41Mini = 'gpt-4.1-mini',\n  GPT4O = 'gpt-4o',\n  GPT4OMini = 'gpt-4o-mini',\n  GPT4ChatGPT4O = 'chatgpt-4o-latest',\n  GPT4Turbo = 'gpt-4-turbo',\n  GPT35Turbo = 'gpt-3.5-turbo',\n  GPT35TurboInstruct = 'gpt-3.5-turbo-instruct',\n  GPT35TextDavinci002 = 'text-davinci-002',\n  GPT3TextBabbage002 = 'text-babbage-002',\n  GPT3TextAda001 = 'text-ada-001',\n  // Reasoning models\n  O1Pro = 'o1-pro',\n  O1 = 'o1',\n  O1Mini = 'o1-mini',\n  O3Pro = 'o3-pro',\n  O3 = 'o3',\n  O3Mini = 'o3-mini',\n  O4Mini = 'o4-mini',\n}\n\n// Define content part types directly based on AxChatRequest structure\nexport interface TextContentPart {\n  type: 'text';\n  text: string;\n  cache?: boolean;\n}\n\nexport interface ImageContentPart {\n  type: 'image';\n  mimeType: string;\n  image: string;\n  details?: 'high' | 'low' | 'auto';\n  cache?: boolean;\n}\n\nexport interface AudioContentPart {\n  type: 'audio';\n  data: string;\n  format?: 'wav';\n  cache?: boolean;\n}\n\n// Union of all content part types\nexport type UserMessageContentItem =\n  | TextContentPart\n  | ImageContentPart\n  | AudioContentPart;\n\n// export type  for function calls as defined in AxChatResponseResult\nexport type FunctionCallType = NonNullable<\n  AxChatResponseResult['functionCalls']\n>[number];\n\n// export type  for the items in req.functions\nexport type RequestFunctionDefinition = NonNullable<\n  AxChatRequest['functions']\n>[number];\n\n// --- AxAIOpenAI /v1/responses Specific Request Types ---\n\n// Content parts for input messages\nexport interface AxAIOpenAIResponsesInputTextContentPart {\n  readonly type: 'text';\n  text: string; // Made mutable for stream aggregation\n}\n\nexport interface AxAIOpenAIResponsesInputImageUrlContentPart {\n  readonly type: 'image_url';\n  readonly image_url: {\n    readonly url: string;\n    readonly details?: 'low' | 'high' | 'auto';\n  };\n}\n\nexport interface AxAIOpenAIResponsesInputAudioContentPart {\n  readonly type: 'input_audio'; // This is an assumption based on compatibility needs\n  readonly input_audio: {\n    readonly data: string; // base64 encoded audio\n    readonly format?: string; // e.g., 'wav', 'mp3'\n  };\n}\n\nexport type AxAIOpenAIResponsesInputContentPart =\n  | AxAIOpenAIResponsesInputTextContentPart\n  | AxAIOpenAIResponsesInputImageUrlContentPart\n  | AxAIOpenAIResponsesInputAudioContentPart;\n\n// Input Item: Message\nexport interface AxAIOpenAIResponsesInputMessageItem {\n  readonly type: 'message';\n  readonly role: 'system' | 'user' | 'assistant' | 'developer';\n  readonly content: string | ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n  readonly name?: string; // Optional name for user/assistant messages\n  // status?: 'in_progress' | 'completed' | 'incomplete' // Typically for response items\n}\n\n// Input Item: Function Call (representing a past call by the model)\nexport interface AxAIOpenAIResponsesInputFunctionCallItem {\n  readonly type: 'function_call';\n  readonly id?: string; // Optional unique ID of this item in the context\n  readonly call_id: string; // The ID that links this call to its output\n  readonly name: string;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: string; // JSON string of arguments\n  // status?: string // Typically for response items\n}\n\n// Input Item: Function Call Output (representing the result of a past call)\nexport interface AxAIOpenAIResponsesInputFunctionCallOutputItem {\n  readonly type: 'function_call_output';\n  readonly id?: string; // Optional unique ID of this item in the context\n  readonly call_id: string;\n  readonly output: string; // JSON string of the output\n  // status?: string // Typically for response items\n}\n\n// Union of all possible input items\n// Add other item types here as needed (e.g., FileSearch, WebSearch, Reasoning items)\nexport type AxAIOpenAIResponsesInputItem =\n  | string // Simple text input\n  | AxAIOpenAIResponsesInputMessageItem\n  | AxAIOpenAIResponsesInputFunctionCallItem\n  | AxAIOpenAIResponsesInputFunctionCallOutputItem;\n\n// Tool Definitions\nexport interface AxAIOpenAIResponsesDefineFunctionTool {\n  readonly type: 'function';\n  readonly name: string;\n  readonly description?: string;\n  readonly parameters: object; // JSON schema\n  readonly strict?: boolean; // Default true\n}\n\n// Add other tool definitions (FileSearch, WebSearch, etc.)\n// export interface AxAIOpenAIResponsesDefineFileSearchTool { type: 'file_search'; vector_store_ids: string[]; ... }\n// export interface AxAIOpenAIResponsesDefineWebSearchTool { type: 'web_search_preview'; ... }\n\nexport type AxAIOpenAIResponsesToolDefinition =\n  AxAIOpenAIResponsesDefineFunctionTool; // | AxAIOpenAIResponsesDefineFileSearchTool | ...\n\n// Tool Choice\nexport type AxAIOpenAIResponsesToolChoice =\n  | 'none'\n  | 'auto'\n  | 'required'\n  | { readonly type: 'function'; readonly name: string }\n  | { readonly type: 'file_search' }; // And other hosted tools\n// | { type: 'web_search_preview' }\n// | { type: 'code_interpreter' }\n\n// Main Request for /v1/responses\nexport interface AxAIOpenAIResponsesRequest<TModel = AxAIOpenAIResponsesModel> {\n  readonly input: string | ReadonlyArray<AxAIOpenAIResponsesInputItem>;\n  readonly model: TModel;\n  readonly background?: boolean | null;\n  readonly include?: ReadonlyArray<\n    | 'file_search_call.results'\n    | 'message.input_image.image_url'\n    | 'computer_call_output.output.image_url'\n    | 'reasoning.encrypted_content'\n    | 'code_interpreter_call.outputs'\n  > | null;\n  readonly instructions?: string | null; // Maps to system prompt\n  readonly max_output_tokens?: number | null;\n  readonly metadata?: Readonly<Record<string, string>> | null;\n  readonly parallel_tool_calls?: boolean | null;\n  readonly previous_response_id?: string | null;\n  readonly reasoning?: {\n    readonly effort?: 'low' | 'medium' | 'high' | null;\n    readonly summary?: 'auto' | 'concise' | 'detailed' | null; // 'generate_summary' is deprecated\n  } | null;\n  readonly service_tier?: 'auto' | 'default' | 'flex' | null;\n  readonly store?: boolean | null; // Whether to store for later retrieval\n  readonly stream?: boolean | null;\n  readonly temperature?: number | null;\n  readonly text?: {\n    readonly format?:\n      | { readonly type: 'text' }\n      | { readonly type: 'json_object' } // Older JSON mode\n      | { readonly type: 'json_schema'; readonly json_schema?: object } // Structured Outputs\n      | null;\n  } | null;\n  readonly tool_choice?: AxAIOpenAIResponsesToolChoice | null;\n  readonly tools?: ReadonlyArray<AxAIOpenAIResponsesToolDefinition> | null;\n  readonly top_p?: number | null;\n  readonly truncation?: 'auto' | 'disabled' | null; // How to handle context window overflow\n  readonly user?: string | null; // User identifier for tracking/moderation\n  readonly seed?: number | null; // Added seed from later in the code\n}\n\n// --- AxAIOpenAI /v1/responses Specific Response Types ---\n\n// Output Item: Message (from assistant)\nexport interface AxAIOpenAIResponsesOutputMessageItem {\n  type: 'message'; // Mutable during construction\n  id: string; // Mutable during construction\n  role: 'assistant'; // Mutable during construction\n  content: ReadonlyArray<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n  status: 'in_progress' | 'completed' | 'incomplete'; // Mutable during construction\n}\n\n// Output Item: Function Call (emitted by the model)\nexport interface AxAIOpenAIResponsesFunctionCallItem {\n  type: 'function_call'; // Mutable during construction\n  id: string; // Mutable during construction\n  call_id: string; // Mutable during construction\n  name: string; // Mutable during construction\n  // eslint-disable-next-line functional/functional-parameters\n  arguments: string; // Mutable during construction (appendable)\n  status?: 'in_progress' | 'completed' | 'incomplete' | 'searching' | 'failed'; // Mutable\n}\n\n// Output Item: Reasoning (if requested and supported)\nexport interface AxAIOpenAIResponsesReasoningItem {\n  readonly type: 'reasoning'; // Typically not built incrementally in the same way by client\n  readonly id: string;\n  readonly summary: ReadonlyArray<{\n    type: 'summary_text';\n    text: string;\n  }>;\n  readonly encrypted_content?: string | null;\n  readonly status?: 'in_progress' | 'completed' | 'incomplete';\n}\n\n// Add this new export interface for output_text parts\nexport interface AxAIOpenAIResponsesOutputTextContentPart {\n  readonly type: 'output_text';\n  readonly text: string;\n  readonly annotations?: ReadonlyArray<unknown>;\n}\n\nexport interface AxAIOpenAIResponsesOutputRefusalContentPart {\n  readonly type: 'refusal';\n  readonly refusal: string;\n}\n\n// Add export interface for reasoning summary parts\nexport interface AxAIOpenAIResponsesReasoningSummaryPart {\n  readonly type: 'summary_text';\n  readonly text: string;\n}\n\n// Update the union of all possible output items\nexport type AxAIOpenAIResponsesOutputItem =\n  | AxAIOpenAIResponsesOutputMessageItem\n  | AxAIOpenAIResponsesFunctionCallItem\n  | AxAIOpenAIResponsesReasoningItem\n  | AxAIOpenAIResponsesFileSearchToolCall\n  | AxAIOpenAIResponsesWebSearchToolCall\n  | AxAIOpenAIResponsesComputerToolCall\n  | AxAIOpenAIResponsesCodeInterpreterToolCall\n  | AxAIOpenAIResponsesImageGenerationToolCall\n  | AxAIOpenAIResponsesLocalShellToolCall\n  | AxAIOpenAIResponsesMCPToolCall;\n\n// Main Response from /v1/responses (non-streaming)\nexport interface AxAIOpenAIResponsesResponse {\n  readonly id: string; // Response ID\n  readonly object: string; // e.g., \"response\"\n  readonly created: number; // Timestamp\n  readonly model: string; // Model ID used\n  readonly output: ReadonlyArray<AxAIOpenAIResponsesOutputItem>;\n  readonly usage?: {\n    readonly prompt_tokens: number;\n    readonly completion_tokens: number; // Or output_tokens / generated_tokens\n    readonly total_tokens: number;\n    // reasoning_tokens?: number // if applicable and included\n  } | null;\n}\n\n// --- Streaming Event Types for /v1/responses ---\n\n// Base streaming event interface\nexport interface AxAIOpenAIResponsesStreamEventBase {\n  readonly type: string;\n  readonly sequence_number: number;\n}\n\n// Response lifecycle events\nexport interface AxAIOpenAIResponsesResponseCreatedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.created';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.in_progress';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.completed';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.failed';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseIncompleteEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.incomplete';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseQueuedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.queued';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\n// Output item events\nexport interface AxAIOpenAIResponsesOutputItemAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_item.added';\n  readonly output_index: number;\n  readonly item: Readonly<AxAIOpenAIResponsesOutputItem>;\n}\n\nexport interface AxAIOpenAIResponsesOutputItemDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_item.done';\n  readonly output_index: number;\n  readonly item: Readonly<AxAIOpenAIResponsesOutputItem>;\n}\n\n// Content part events\nexport interface AxAIOpenAIResponsesContentPartAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.content_part.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly part: Readonly<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n}\n\nexport interface AxAIOpenAIResponsesContentPartDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.content_part.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly part: Readonly<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n}\n\n// Text delta events\nexport interface AxAIOpenAIResponsesOutputTextDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesOutputTextDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly text: string;\n}\n\n// Refusal events\nexport interface AxAIOpenAIResponsesRefusalDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.refusal.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesRefusalDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.refusal.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly refusal: string;\n}\n\n// Function call events\nexport interface AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.function_call_arguments.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.function_call_arguments.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: string;\n}\n\n// File search events\nexport interface AxAIOpenAIResponsesFileSearchCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchCallSearchingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.searching';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\n// Web search events\nexport interface AxAIOpenAIResponsesWebSearchCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesWebSearchCallSearchingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.searching';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesWebSearchCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\n// Reasoning events\nexport interface AxAIOpenAIResponsesReasoningDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesReasoningDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly text: string;\n}\n\n// Reasoning summary events\nexport interface AxAIOpenAIResponsesReasoningSummaryPartAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_part.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly part: Readonly<AxAIOpenAIResponsesReasoningSummaryPart>;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryPartDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_part.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly part: Readonly<AxAIOpenAIResponsesReasoningSummaryPart>;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_text.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryTextDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_text.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly text: string;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly text: string;\n}\n\n// Image generation events\nexport interface AxAIOpenAIResponsesImageGenerationCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallGeneratingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.generating';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallPartialImageEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.partial_image';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly partial_image_index: number;\n  readonly partial_image_b64: string;\n}\n\n// MCP events\nexport interface AxAIOpenAIResponsesMCPCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.arguments.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallArgumentsDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.arguments.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.completed';\n}\n\nexport interface AxAIOpenAIResponsesMCPCallFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.failed';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.in_progress';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.completed';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.failed';\n}\n\n// Annotation events\nexport interface AxAIOpenAIResponsesOutputTextAnnotationAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text_annotation.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly annotation_index: number;\n  readonly annotation: object;\n}\n\n// Error event\nexport interface AxAIOpenAIResponsesErrorEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'error';\n  readonly code: string | null;\n  readonly message: string;\n  readonly param: string | null;\n}\n\n// Union of all streaming events\nexport type AxAIOpenAIResponsesStreamEvent =\n  | AxAIOpenAIResponsesResponseCreatedEvent\n  | AxAIOpenAIResponsesResponseInProgressEvent\n  | AxAIOpenAIResponsesResponseCompletedEvent\n  | AxAIOpenAIResponsesResponseFailedEvent\n  | AxAIOpenAIResponsesResponseIncompleteEvent\n  | AxAIOpenAIResponsesResponseQueuedEvent\n  | AxAIOpenAIResponsesOutputItemAddedEvent\n  | AxAIOpenAIResponsesOutputItemDoneEvent\n  | AxAIOpenAIResponsesContentPartAddedEvent\n  | AxAIOpenAIResponsesContentPartDoneEvent\n  | AxAIOpenAIResponsesOutputTextDeltaEvent\n  | AxAIOpenAIResponsesOutputTextDoneEvent\n  | AxAIOpenAIResponsesRefusalDeltaEvent\n  | AxAIOpenAIResponsesRefusalDoneEvent\n  | AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent\n  | AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent\n  | AxAIOpenAIResponsesFileSearchCallInProgressEvent\n  | AxAIOpenAIResponsesFileSearchCallSearchingEvent\n  | AxAIOpenAIResponsesFileSearchCallCompletedEvent\n  | AxAIOpenAIResponsesWebSearchCallInProgressEvent\n  | AxAIOpenAIResponsesWebSearchCallSearchingEvent\n  | AxAIOpenAIResponsesWebSearchCallCompletedEvent\n  | AxAIOpenAIResponsesReasoningDeltaEvent\n  | AxAIOpenAIResponsesReasoningDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryPartAddedEvent\n  | AxAIOpenAIResponsesReasoningSummaryPartDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent\n  | AxAIOpenAIResponsesReasoningSummaryTextDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryDeltaEvent\n  | AxAIOpenAIResponsesReasoningSummaryDoneEvent\n  | AxAIOpenAIResponsesImageGenerationCallInProgressEvent\n  | AxAIOpenAIResponsesImageGenerationCallGeneratingEvent\n  | AxAIOpenAIResponsesImageGenerationCallCompletedEvent\n  | AxAIOpenAIResponsesImageGenerationCallPartialImageEvent\n  | AxAIOpenAIResponsesMCPCallInProgressEvent\n  | AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent\n  | AxAIOpenAIResponsesMCPCallArgumentsDoneEvent\n  | AxAIOpenAIResponsesMCPCallCompletedEvent\n  | AxAIOpenAIResponsesMCPCallFailedEvent\n  | AxAIOpenAIResponsesMCPListToolsInProgressEvent\n  | AxAIOpenAIResponsesMCPListToolsCompletedEvent\n  | AxAIOpenAIResponsesMCPListToolsFailedEvent\n  | AxAIOpenAIResponsesOutputTextAnnotationAddedEvent\n  | AxAIOpenAIResponsesErrorEvent;\n\n// Legacy delta export interface for backward compatibility - now maps to the new streaming events\nexport interface AxAIOpenAIResponsesResponseDelta {\n  readonly id?: string; // Overall response ID, appears in first event usually\n  readonly model?: string; // Model ID, might appear in first event\n  readonly event?: string; // e.g., 'response.delta', 'response.item_delta', 'response.done'\n\n  // If event is 'response.delta' or 'response.item_delta'\n  readonly delta?: {\n    // For message content delta\n    readonly content?: string; // If item is a message part\n    // For tool call argument delta\n    // eslint-disable-next-line functional/functional-parameters\n    readonly arguments?: string; // If item is a function_call part\n    // Other potential delta fields based on item type\n  };\n\n  // If event is 'response.item_created', 'response.item_delta', 'response.item_completed'\n  readonly item_index?: number; // Index of the item in the `items` array\n  readonly item?: Partial<Readonly<AxAIOpenAIResponsesOutputItem>>; // The item being streamed or its delta\n\n  // If event is 'response.done'\n  readonly response?: Readonly<AxAIOpenAIResponsesResponse>; // The final full response object (often without items if streamed separately)\n  readonly usage?: {\n    readonly prompt_tokens: number;\n    readonly completion_tokens: number;\n    readonly total_tokens: number;\n    // reasoning_tokens?: number\n  } | null; // Usage often comes in the 'response.done' event or with stream_options\n}\n\n// export type  for the function that updates the request before sending\nexport type ResponsesReqUpdater<\n  TModel,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> = (req: Readonly<TResponsesReq>) => Readonly<TResponsesReq>;\n\n// Utility export type  to make properties of T mutable\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nexport type AxAIOpenAIResponsesConfig<TModel, TEmbedModel> = Omit<\n  AxModelConfig,\n  'topK'\n> & {\n  model: TModel;\n  embedModel?: TEmbedModel;\n  user?: string;\n  bestOf?: number;\n  logitBias?: Map<string, number>;\n  suffix?: string | null;\n  stop?: string[];\n  logprobs?: number;\n  echo?: boolean;\n  dimensions?: number;\n  reasoningEffort?: 'low' | 'medium' | 'high';\n  reasoningSummary?: 'auto' | 'concise' | 'detailed';\n  store?: boolean;\n  systemPrompt?: string;\n  parallelToolCalls?: boolean;\n  seed?: number;\n  responseFormat?: 'text' | 'json_object' | 'json_schema';\n  serviceTier?: 'auto' | 'default' | 'flex';\n};\n\n// ToolCall response types\nexport interface AxAIOpenAIResponsesToolCallBase {\n  id: string;\n  type: string;\n  status?: string;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'file_search_call';\n  queries: string[];\n  results?: {\n    file_id: string;\n    filename: string;\n    score: number;\n    text: string;\n    attributes?: Record<string, string | boolean | number>;\n  }[];\n}\n\nexport interface AxAIOpenAIResponsesWebSearchToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'web_search_call';\n  queries: string[];\n}\n\nexport interface AxAIOpenAIResponsesComputerToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'computer_call';\n  action: object;\n}\n\nexport interface AxAIOpenAIResponsesCodeInterpreterToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'code_interpreter_call';\n  code: string;\n  results?: unknown[];\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'image_generation_call';\n  result?: string;\n}\n\nexport interface AxAIOpenAIResponsesLocalShellToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'local_shell_call';\n  action: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'mcp_call';\n  name: string;\n  args: string;\n  server_label: string;\n  output?: string;\n  error?: string;\n}\n\nexport type AxAIOpenAIResponsesToolCall =\n  | AxAIOpenAIResponsesFunctionCallItem\n  | AxAIOpenAIResponsesFileSearchToolCall\n  | AxAIOpenAIResponsesWebSearchToolCall\n  | AxAIOpenAIResponsesComputerToolCall\n  | AxAIOpenAIResponsesCodeInterpreterToolCall\n  | AxAIOpenAIResponsesImageGenerationToolCall\n  | AxAIOpenAIResponsesLocalShellToolCall\n  | AxAIOpenAIResponsesMCPToolCall;\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIOpenAIEmbedModel, AxAIOpenAIModel } from './chat_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoOpenAI: AxModelInfo[] = [\n  // Not Reasoning models\n  {\n    name: AxAIOpenAIModel.GPT4,\n    currency: 'usd',\n    promptTokenCostPer1M: 30,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.GPT41,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 8,\n  },\n  {\n    name: AxAIOpenAIModel.GPT41Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1.6,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4OMini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4ChatGPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n  },\n  {\n    name: AxAIOpenAIModel.GPT35Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  // Reasoning models\n  {\n    name: AxAIOpenAIModel.O1,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.O1Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 14.4,\n  },\n  {\n    name: AxAIOpenAIModel.O3,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.O3Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n  },\n  {\n    name: AxAIOpenAIModel.O4Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n  },\n  // Embedding models\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbeddingAda002,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.02,\n    completionTokenCostPer1M: 0.02,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Large,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.13,\n    completionTokenCostPer1M: 0.13,\n  },\n];\n\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoOpenAIResponses: AxModelInfo[] = [\n  // Not Reasoning models\n  {\n    name: AxAIOpenAIResponsesModel.GPT4,\n    currency: 'usd',\n    promptTokenCostPer1M: 30,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT41,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 8,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT41Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1.6,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4OMini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4ChatGPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT35Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  // Reasoning models\n  {\n    name: AxAIOpenAIResponsesModel.O1Pro,\n    currency: 'usd',\n    promptTokenCostPer1M: 150,\n    completionTokenCostPer1M: 600,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n    isExpensive: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O1,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O3Pro,\n    currency: 'usd',\n    promptTokenCostPer1M: 20,\n    completionTokenCostPer1M: 80,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n    isExpensive: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O3,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIOpenAIModel.O3Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O4Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n];\n", "import { getModelInfo } from '@ax-llm/ax/dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport {\n  type AxAIFeatures,\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\nimport {\n  type AxAIOpenAIChatRequest,\n  type AxAIOpenAIChatResponse,\n  type AxAIOpenAIChatResponseDelta,\n  type AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  type AxAIOpenAIEmbedRequest,\n  type AxAIOpenAIEmbedResponse,\n  AxAIOpenAIModel,\n} from './chat_types.js';\nimport { axModelInfoOpenAI } from './info.js';\n\n/**\n * Checks if the given OpenAI model is a thinking/reasoning model.\n * Thinking models (o1, o3, o4 series) have different parameter restrictions.\n */\nexport const isOpenAIThinkingModel = (model: string): boolean => {\n  const thinkingModels = [\n    AxAIOpenAIModel.O1,\n    AxAIOpenAIModel.O1Mini,\n    AxAIOpenAIModel.O3,\n    AxAIOpenAIModel.O3Mini,\n    AxAIOpenAIModel.O4Mini,\n    // Pro models (string values since they're not in the regular chat enum)\n    'o1-pro',\n    'o3-pro',\n  ];\n  return (\n    thinkingModels.includes(model as AxAIOpenAIModel) ||\n    thinkingModels.includes(model)\n  );\n};\n\nexport const axAIOpenAIDefaultConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT41,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIOpenAIBestConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    ...axAIOpenAIDefaultConfig(),\n    model: AxAIOpenAIModel.GPT41,\n  });\n\nexport const axAIOpenAICreativeConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT41,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport const axAIOpenAIFastConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIDefaultConfig(),\n  model: AxAIOpenAIModel.GPT41Mini,\n});\n\nexport interface AxAIOpenAIArgs<\n  TName = 'openai',\n  TModel = AxAIOpenAIModel,\n  TEmbedModel = AxAIOpenAIEmbedModel,\n  TChatReq extends\n    AxAIOpenAIChatRequest<TModel> = AxAIOpenAIChatRequest<TModel>,\n> extends Omit<\n    AxAIOpenAIBaseArgs<TModel, TEmbedModel, TChatReq>,\n    'config' | 'supportFor' | 'modelInfo'\n  > {\n  name: TName;\n  modelInfo?: AxModelInfo[];\n  config?: Partial<AxAIOpenAIBaseArgs<TModel, TEmbedModel, TChatReq>['config']>;\n}\n\ntype ChatReqUpdater<TModel, TChatReq extends AxAIOpenAIChatRequest<TModel>> = (\n  req: Readonly<TChatReq>\n) => TChatReq;\n\nexport interface AxAIOpenAIBaseArgs<\n  TModel,\n  TEmbedModel,\n  TChatReq extends AxAIOpenAIChatRequest<TModel>,\n> {\n  apiKey: string;\n  apiURL?: string;\n  config: Readonly<AxAIOpenAIConfig<TModel, TEmbedModel>>;\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>;\n  modelInfo: Readonly<AxModelInfo[]>;\n  models?: AxAIInputModelList<TModel, TEmbedModel>;\n  chatReqUpdater?: ChatReqUpdater<TModel, TChatReq>;\n  supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n}\n\nclass AxAIOpenAIImpl<\n  TModel,\n  TEmbedModel,\n  TChatReq extends AxAIOpenAIChatRequest<TModel>,\n> implements\n    AxAIServiceImpl<\n      TModel,\n      TEmbedModel,\n      AxAIOpenAIChatRequest<TModel>,\n      AxAIOpenAIEmbedRequest<TEmbedModel>,\n      AxAIOpenAIChatResponse,\n      AxAIOpenAIChatResponseDelta,\n      AxAIOpenAIEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private readonly config: Readonly<AxAIOpenAIConfig<TModel, TEmbedModel>>,\n    private streamingUsage: boolean,\n    private readonly chatReqUpdater?: ChatReqUpdater<TModel, TChatReq>\n  ) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    };\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<TModel>>,\n\n    config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAIOpenAIChatRequest<TModel>] {\n    const model = req.model;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    };\n\n    const tools = req.functions?.map((v) => ({\n      type: 'function' as const,\n      function: {\n        name: v.name,\n        description: v.description,\n        parameters: v.parameters,\n      },\n    }));\n\n    const toolsChoice =\n      !req.functionCall && req.functions && req.functions.length > 0\n        ? 'auto'\n        : req.functionCall;\n\n    const messages = createMessages(req);\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;\n\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    const store = this.config.store;\n\n    const isThinkingModel = isOpenAIThinkingModel(model as string);\n\n    let reqValue: AxAIOpenAIChatRequest<TModel> = {\n      model,\n      messages,\n      response_format: this.config?.responseFormat\n        ? { type: this.config.responseFormat }\n        : undefined,\n      tools,\n      tool_choice: toolsChoice,\n      // For thinking models, don't set these parameters as they're not supported\n      ...(isThinkingModel\n        ? {}\n        : {\n            max_completion_tokens:\n              req.modelConfig?.maxTokens ?? this.config.maxTokens,\n            temperature:\n              req.modelConfig?.temperature ?? this.config.temperature,\n            top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,\n            n: req.modelConfig?.n ?? this.config.n,\n            presence_penalty:\n              req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n            ...(frequencyPenalty\n              ? { frequency_penalty: frequencyPenalty }\n              : {}),\n          }),\n      stop: req.modelConfig?.stopSequences ?? this.config.stop,\n      logit_bias: this.config.logitBias,\n      ...(stream && this.streamingUsage\n        ? { stream: true, stream_options: { include_usage: true } }\n        : {}),\n      ...(store ? { store: store } : {}),\n      ...(this.config.serviceTier\n        ? { service_tier: this.config.serviceTier }\n        : {}),\n      ...(this.config.user ? { user: this.config.user } : {}),\n    };\n\n    if (this.config.reasoningEffort) {\n      reqValue.reasoning_effort = this.config.reasoningEffort;\n    }\n\n    if (this.config.webSearchOptions) {\n      reqValue.web_search_options = {\n        ...(this.config.webSearchOptions.searchContextSize && {\n          search_context_size: this.config.webSearchOptions.searchContextSize,\n        }),\n        ...(this.config.webSearchOptions.userLocation && {\n          user_location: {\n            approximate: {\n              type: 'approximate',\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .city && {\n                city: this.config.webSearchOptions.userLocation.approximate\n                  .city,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .country && {\n                country:\n                  this.config.webSearchOptions.userLocation.approximate.country,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .region && {\n                region:\n                  this.config.webSearchOptions.userLocation.approximate.region,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .timezone && {\n                timezone:\n                  this.config.webSearchOptions.userLocation.approximate\n                    .timezone,\n              }),\n            },\n          },\n        }),\n      };\n    }\n\n    // Then, override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          reqValue.reasoning_effort = undefined; // Explicitly set to undefined\n          break;\n        case 'minimal':\n          reqValue.reasoning_effort = 'low';\n          break;\n        case 'low':\n          reqValue.reasoning_effort = 'medium';\n          break;\n        case 'medium':\n          reqValue.reasoning_effort = 'high';\n          break;\n        case 'high':\n          reqValue.reasoning_effort = 'high';\n          break;\n        case 'highest':\n          reqValue.reasoning_effort = 'high';\n          break;\n      }\n    }\n\n    if (this.chatReqUpdater) {\n      reqValue = this.chatReqUpdater(reqValue as TChatReq);\n    }\n\n    return [apiConfig, reqValue];\n  }\n\n  createEmbedReq(\n    req: Readonly<AxInternalEmbedRequest<TEmbedModel>>\n  ): [AxAPI, AxAIOpenAIEmbedRequest<TEmbedModel>] {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embeddings',\n    };\n\n    const reqValue = {\n      model: model,\n      input: req.texts,\n      dimensions: this.config.dimensions,\n    };\n\n    return [apiConfig, reqValue];\n  }\n\n  createChatResp(resp: Readonly<AxAIOpenAIChatResponse>): AxChatResponse {\n    const { id, usage, choices, error } = resp;\n\n    if (error) {\n      throw error;\n    }\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    const results = choices.map((choice) => {\n      // Check for refusal and throw exception if present\n      if (choice.message.refusal) {\n        throw new AxAIRefusalError(choice.message.refusal, resp.model, resp.id);\n      }\n\n      const finishReason = mapFinishReason(choice.finish_reason);\n\n      const functionCalls = choice.message.tool_calls?.map(\n        ({ id, function: { arguments: params, name } }) => ({\n          id: id,\n          type: 'function' as const,\n          function: { name, params },\n        })\n      );\n\n      return {\n        index: choice.index,\n        id: `${choice.index}`,\n        content: choice.message.content ?? undefined,\n        thought: choice.message.reasoning_content,\n        annotations: choice.message.annotations,\n        functionCalls,\n        finishReason,\n      };\n    });\n\n    return {\n      results,\n      remoteId: id,\n    };\n  }\n\n  createChatStreamResp(\n    resp: Readonly<AxAIOpenAIChatResponseDelta>,\n    state: object\n  ): AxChatResponse {\n    const { id, usage, choices } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>;\n    };\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {};\n    }\n\n    const results = choices.map(\n      ({\n        index,\n        delta: {\n          content,\n          role,\n          refusal,\n          tool_calls: toolCalls,\n          reasoning_content: thought,\n          annotations,\n        },\n        finish_reason: oaiFinishReason,\n      }) => {\n        // Check for refusal and throw exception if present\n        if (refusal) {\n          throw new AxAIRefusalError(refusal, undefined, id);\n        }\n\n        const finishReason = mapFinishReason(oaiFinishReason);\n\n        const functionCalls = toolCalls\n          ?.map(({ id: Id, index, function: { name, arguments: params } }) => {\n            if (\n              typeof Id === 'string' &&\n              typeof index === 'number' &&\n              !sstate.indexIdMap[index]\n            ) {\n              sstate.indexIdMap[index] = Id;\n            }\n\n            const id = sstate.indexIdMap[index];\n            if (!id) {\n              return null;\n            }\n\n            return {\n              id,\n              type: 'function' as const,\n              function: { name, params },\n            };\n          })\n          .filter((v) => v !== null);\n\n        return {\n          index,\n          content: content ?? undefined,\n          role,\n          thought,\n          annotations,\n          functionCalls,\n          finishReason,\n          id,\n        };\n      }\n    );\n\n    return { results };\n  }\n\n  createEmbedResp(resp: Readonly<AxAIOpenAIEmbedResponse>): AxEmbedResponse {\n    const { data, usage } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    return { embeddings: data.map((v) => v.embedding) };\n  }\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIOpenAIChatResponse['choices'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const;\n    case 'length':\n      return 'length' as const;\n    case 'content_filter':\n      return 'error' as const;\n    case 'tool_calls':\n      return 'function_call' as const;\n  }\n};\n\nfunction createMessages<TModel>(\n  req: Readonly<AxInternalChatRequest<TModel>>\n): AxAIOpenAIChatRequest<TModel>['messages'] {\n  type UserContent = Extract<\n    AxAIOpenAIChatRequest<TModel>['messages'][number],\n    { role: 'user' }\n  >['content'];\n\n  const openaiReq = req.chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return { role: 'system' as const, content: msg.content };\n\n      case 'user': {\n        const content: UserContent = Array.isArray(msg.content)\n          ? msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  const url = `data:${c.mimeType};base64,${c.image}`;\n                  return {\n                    type: 'image_url' as const,\n                    image_url: { url, details: c.details ?? 'auto' },\n                  };\n                }\n                case 'audio': {\n                  const data = c.data;\n                  return {\n                    type: 'input_audio' as const,\n                    input_audio: { data, format: c.format ?? 'wav' },\n                  };\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            })\n          : msg.content;\n        return {\n          role: 'user' as const,\n          ...(msg.name ? { name: msg.name } : {}),\n          content,\n        };\n      }\n\n      case 'assistant': {\n        const toolCalls = msg.functionCalls?.map((v) => ({\n          id: v.id,\n          type: 'function' as const,\n          function: {\n            name: v.function.name,\n            arguments:\n              typeof v.function.params === 'object'\n                ? JSON.stringify(v.function.params)\n                : v.function.params,\n          },\n        }));\n\n        if (toolCalls && toolCalls.length > 0) {\n          return {\n            role: 'assistant' as const,\n            ...(msg.content ? { content: msg.content } : {}),\n            name: msg.name,\n            tool_calls: toolCalls,\n          };\n        }\n\n        if (msg.content === undefined) {\n          throw new Error(\n            'Assistant content is required when no tool calls are provided'\n          );\n        }\n\n        return {\n          role: 'assistant' as const,\n          content: msg.content,\n          ...(msg.name ? { name: msg.name } : {}),\n        };\n      }\n\n      case 'function':\n        return {\n          role: 'tool' as const,\n          content: msg.result,\n          tool_call_id: msg.functionId,\n        };\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n  return openaiReq;\n}\n\nexport class AxAIOpenAIBase<\n  TModel,\n  TEmbedModel,\n  TChatReq extends\n    AxAIOpenAIChatRequest<TModel> = AxAIOpenAIChatRequest<TModel>,\n> extends AxBaseAI<\n  TModel,\n  TEmbedModel,\n  AxAIOpenAIChatRequest<TModel>,\n  AxAIOpenAIEmbedRequest<TEmbedModel>,\n  AxAIOpenAIChatResponse,\n  AxAIOpenAIChatResponseDelta,\n  AxAIOpenAIEmbedResponse\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo,\n    models,\n    chatReqUpdater,\n    supportFor,\n  }: Readonly<\n    Omit<AxAIOpenAIBaseArgs<TModel, TEmbedModel, TChatReq>, 'name'>\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    const aiImpl = new AxAIOpenAIImpl<TModel, TEmbedModel, TChatReq>(\n      config,\n      options?.streamingUsage ?? true,\n      chatReqUpdater\n    );\n\n    super(aiImpl, {\n      name: 'OpenAI',\n      apiURL: apiURL ? apiURL : 'https://api.openai.com/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo,\n      defaults: {\n        model: config.model,\n        embedModel: config.embedModel,\n      },\n      options,\n      supportFor,\n      models,\n    });\n  }\n}\n\nexport class AxAIOpenAI extends AxAIOpenAIBase<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIOpenAIArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    modelInfo = [...axModelInfoOpenAI, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIModel) => {\n      const mi = getModelInfo<AxAIOpenAIModel, AxAIOpenAIEmbedModel>({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n      };\n    };\n\n    super({\n      apiKey,\n      config: {\n        ...axAIOpenAIDefaultConfig(),\n        ...config,\n      },\n      options,\n      modelInfo,\n      models,\n      supportFor,\n    });\n\n    super.setName('OpenAI');\n  }\n}\n", "import { getModelInfo } from '@ax-llm/ax/dsp/modelinfo.js';\nimport {\n  type AxAIOpenAIArgs,\n  AxAIOpenAIBase,\n  axAIOpenAIBestConfig,\n  axAIOpenAICreativeConfig,\n  axAIOpenAIDefaultConfig,\n  axAIOpenAIFastConfig,\n} from '../openai/api.js';\nimport type {\n  AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIModel,\n} from '../openai/chat_types.js';\nimport { axModelInfoOpenAI } from '../openai/info.js';\n\nexport const axAIAzureOpenAIDefaultConfig = axAIOpenAIDefaultConfig;\n\nexport const axAIAzureOpenAICreativeConfig = axAIOpenAICreativeConfig;\n\nexport const axAIAzureOpenAIFastConfig = axAIOpenAIFastConfig;\n\nexport const axAIAzureOpenAIBestConfig = axAIOpenAIBestConfig;\n\nexport type AxAIAzureOpenAIConfig = AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n>;\nexport type AxAIAzureOpenAIArgs = AxAIOpenAIArgs<\n  'azure-openai',\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> & {\n  resourceName: string;\n  deploymentName: string;\n  version?: string;\n};\n\nexport class AxAIAzureOpenAI extends AxAIOpenAIBase<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> {\n  constructor({\n    apiKey,\n    resourceName,\n    deploymentName,\n    version = 'api-version=2024-02-15-preview',\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIAzureOpenAIArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Azure OpenAPI API key not set');\n    }\n    if (!resourceName || resourceName === '') {\n      throw new Error('Azure OpenAPI resource name not set');\n    }\n    if (!deploymentName || deploymentName === '') {\n      throw new Error('Azure OpenAPI deployment id not set');\n    }\n\n    const Config = {\n      ...axAIAzureOpenAIDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoOpenAI, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIModel) => {\n      const mi = getModelInfo<AxAIOpenAIModel, AxAIOpenAIEmbedModel>({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n      };\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      models,\n      modelInfo,\n      supportFor,\n    });\n\n    const host = resourceName.includes('://')\n      ? resourceName\n      : `https://${resourceName}.openai.azure.com/`;\n\n    super.setName('Azure OpenAI');\n\n    super.setAPIURL(\n      new URL(\n        `/openai/deployments/${deploymentName}?api-version=${version}`,\n        host\n      ).href\n    );\n\n    super.setHeaders(async () => ({ 'api-key': apiKey }));\n  }\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport {\n  AxAIServiceAuthenticationError,\n  AxAIServiceError,\n  AxAIServiceNetworkError,\n  AxAIServiceResponseError,\n  AxAIServiceStatusError,\n  AxAIServiceStreamTerminatedError,\n  AxAIServiceTimeoutError,\n} from '../util/apicall.js';\n\nimport type {\n  AxAIModelList,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n} from './types.js';\n\n/**\n * Options for the balancer.\n */\nexport type AxBalancerOptions = {\n  comparator?: (a: AxAIService, b: AxAIService) => number;\n  debug?: boolean;\n  initialBackoffMs?: number;\n  maxBackoffMs?: number;\n  maxRetries?: number;\n};\n\n/**\n * Balancer that rotates through services.\n */\nexport class AxBalancer implements AxAIService<unknown, unknown> {\n  private services: AxAIService[];\n  private currentServiceIndex = 0;\n  private currentService: AxAIService;\n  private debug: boolean;\n  private initialBackoffMs: number;\n  private maxBackoffMs: number;\n  private maxRetries: number;\n  private serviceFailures: Map<\n    string,\n    { retries: number; lastFailureTime: number }\n  > = new Map();\n\n  constructor(services: readonly AxAIService[], options?: AxBalancerOptions) {\n    if (services.length === 0) {\n      throw new Error('No AI services provided.');\n    }\n\n    validateModels(services);\n\n    this.services = [...services].sort(\n      options?.comparator ?? AxBalancer.metricComparator\n    );\n\n    const cs = this.services[this.currentServiceIndex];\n    if (cs === undefined) {\n      throw new Error('Error initializing the AI services.'); // More specific error message\n    }\n    this.currentService = cs;\n    this.debug = options?.debug ?? true;\n    this.initialBackoffMs = options?.initialBackoffMs ?? 1000;\n    this.maxBackoffMs = options?.maxBackoffMs ?? 32000;\n    this.maxRetries = options?.maxRetries ?? 3;\n  }\n  getLastUsedChatModel(): unknown {\n    return this.currentService.getLastUsedChatModel();\n  }\n  getLastUsedEmbedModel(): unknown {\n    return this.currentService.getLastUsedEmbedModel();\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.currentService.getLastUsedModelConfig();\n  }\n\n  /**\n   * Service comparator that respects the input order of services.\n   */\n  public static inputOrderComparator = () => 0;\n\n  /**\n   * Service comparator that sorts services by cost.\n   */\n\n  // Requires a rethink\n  /*\n    public static costComparator = (a: AxAIService, b: AxAIService) => {\n      const aInfo = a.getModelInfo()\n      const bInfo = b.getModelInfo()\n      const aTotalCost =\n        (aInfo.promptTokenCostPer1M || Infinity) +\n        (aInfo.completionTokenCostPer1M || Infinity)\n      const bTotalCost =\n        (bInfo.promptTokenCostPer1M || Infinity) +\n        (bInfo.completionTokenCostPer1M || Infinity)\n      return aTotalCost - bTotalCost\n    }\n    */\n\n  public static metricComparator = (a: AxAIService, b: AxAIService) => {\n    const aMetrics = a.getMetrics();\n    const bMetrics = b.getMetrics();\n    // Compare mean chat latency between services\n    return aMetrics.latency.chat.mean - bMetrics.latency.chat.mean;\n  };\n\n  getModelList(): AxAIModelList | undefined {\n    return this.currentService.getModelList();\n  }\n\n  private getNextService(): boolean {\n    const cs = this.services[++this.currentServiceIndex];\n    if (cs === undefined) {\n      return false;\n    }\n    this.currentService = cs;\n    return true;\n  }\n\n  private reset(): void {\n    this.currentServiceIndex = 0;\n    const cs = this.services[this.currentServiceIndex];\n    if (cs === undefined) {\n      throw new Error('No AI services provided.');\n    }\n    this.currentService = cs;\n  }\n\n  getName(): string {\n    return this.currentService.getName();\n  }\n\n  getId(): string {\n    return this.currentService.getId();\n  }\n\n  getFeatures(model?: string) {\n    return this.currentService.getFeatures(model);\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.currentService.getMetrics();\n  }\n\n  private canRetryService(): boolean {\n    const failure = this.serviceFailures.get(this.currentService.getId());\n    if (!failure) return true;\n\n    const { retries, lastFailureTime } = failure;\n    const timeSinceLastFailure = Date.now() - lastFailureTime;\n\n    const backoffMs = Math.min(\n      this.initialBackoffMs * 2 ** retries,\n      this.maxBackoffMs\n    );\n    return timeSinceLastFailure >= backoffMs;\n  }\n\n  private handleFailure(): boolean {\n    const failure = this.serviceFailures.get(this.currentService.getId());\n    const retries = (failure?.retries ?? 0) + 1;\n\n    this.serviceFailures.set(this.currentService.getId(), {\n      retries,\n      lastFailureTime: Date.now(),\n    });\n\n    if (this.debug) {\n      console.warn(\n        `AxBalancer: Service ${this.currentService.getName()} failed (retry ${retries}/${this.maxRetries})`\n      );\n    }\n\n    if (retries >= this.maxRetries) {\n      const gotNextService = this.getNextService();\n      if (this.debug) {\n        console.warn(\n          `AxBalancer: Switching to service ${this.currentService.getName()}`\n        );\n      }\n      return gotNextService;\n    }\n\n    return true;\n  }\n\n  private handleSuccess(): void {\n    this.serviceFailures.delete(this.currentService.getId());\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest>,\n    options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions> | undefined\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    this.reset();\n\n    while (true) {\n      if (!this.canRetryService()) {\n        if (!this.getNextService()) {\n          throw new Error('All services exhausted');\n        }\n        continue;\n      }\n\n      try {\n        const response = await this.currentService.chat(req, options);\n        this.handleSuccess();\n        return response;\n      } catch (e) {\n        if (!(e instanceof AxAIServiceError)) {\n          throw e;\n        }\n\n        switch (e.constructor) {\n          case AxAIServiceAuthenticationError:\n            // Handle authentication failure, e.g., refresh token, prompt user to re-login\n            throw e;\n\n          case AxAIServiceStatusError:\n            // Handle specific HTTP error codes, e.g., display a user-friendly message for a 404 Not Found\n            break;\n\n          case AxAIServiceNetworkError:\n            // Handle network issues, e.g., display a message about checking network connectivity\n            break;\n\n          case AxAIServiceResponseError:\n            // Handle errors related to processing the response, e.g., log the error and retry the request\n            break;\n\n          case AxAIServiceStreamTerminatedError:\n            // Handle unexpected stream termination, e.g., retry the request or display an error message\n            break;\n\n          case AxAIServiceTimeoutError:\n            // Handle request timeouts, e.g., increase timeout, retry, or display an error message\n            break;\n\n          default:\n            throw e;\n          // Handle unexpected AxAIServiceErrors\n        }\n\n        if (!this.handleFailure()) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    options?: Readonly<AxAIServiceActionOptions> | undefined\n  ): Promise<AxEmbedResponse> {\n    this.reset();\n\n    while (true) {\n      if (!this.canRetryService()) {\n        if (!this.getNextService()) {\n          throw new Error('All services exhausted');\n        }\n        continue;\n      }\n\n      try {\n        const response = await this.currentService.embed(req, options);\n        this.handleSuccess();\n        return response;\n      } catch (e) {\n        if (!this.handleFailure()) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.currentService.setOptions(options);\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.currentService.getOptions();\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.currentService.getLogger();\n  }\n}\n\nfunction validateModels(services: readonly AxAIService[]) {\n  // Check if any service has a model list.\n  const serviceWithModel = services.find(\n    (service) => service.getModelList() !== undefined\n  );\n  if (!serviceWithModel) {\n    // No service provides a model list; no validation needed.\n    return;\n  }\n\n  // Use the first service with a model list as the reference.\n  const referenceModelList = serviceWithModel.getModelList();\n  if (!referenceModelList) {\n    throw new Error('No model list found in any service.');\n  }\n  const referenceKeys = new Set(referenceModelList.map((model) => model.key));\n\n  // Validate that all services provide a model list with the same keys.\n  for (let i = 0; i < services.length; i++) {\n    const service = services[i];\n    if (!service) {\n      throw new Error(`Service at index ${i} is undefined`);\n    }\n    const modelList = service.getModelList();\n    if (!modelList) {\n      throw new Error(\n        `Service at index ${i} (${service.getName()}) has no model list while another service does.`\n      );\n    }\n\n    const serviceKeys = new Set(modelList.map((model) => model.key));\n\n    // Check for missing keys compared to the reference\n    for (const key of referenceKeys) {\n      if (!serviceKeys.has(key)) {\n        throw new Error(\n          `Service at index ${i} (${service.getName()}) is missing model \"${key}\"`\n        );\n      }\n    }\n    // Check for extra keys not in the reference\n    for (const key of serviceKeys) {\n      if (!referenceKeys.has(key)) {\n        throw new Error(\n          `Service at index ${i} (${service.getName()}) has extra model \"${key}\"`\n        );\n      }\n    }\n  }\n}\n", "import type { AxModelConfig } from '../types.js';\n\n/**\n * Cohere: Models for text generation\n */\nexport enum AxAICohereModel {\n  CommandRPlus = 'command-r-plus',\n  CommandR = 'command-r',\n  Command = 'command',\n  CommandLight = 'command-light',\n}\n\n/**\n * Cohere: Models for use in embeddings\n */\nexport enum AxAICohereEmbedModel {\n  EmbedEnglishV30 = 'embed-english-v3.0',\n  EmbedEnglishLightV30 = 'embed-english-light-v3.0',\n  EmbedMultiLingualV30 = 'embed-multilingual-v3.0',\n  EmbedMultiLingualLightV30 = 'embed-multilingual-light-v3.0',\n}\n\n/**\n * Cohere: Model options for text generation\n */\nexport type AxAICohereConfig = AxModelConfig & {\n  model: AxAICohereModel;\n  embedModel?: AxAICohereEmbedModel;\n};\n\nexport type AxAICohereChatResponseToolCalls = {\n  name: string;\n  parameters?: object;\n}[];\n\nexport type AxAICohereChatRequestToolResults = {\n  call: AxAICohereChatResponseToolCalls[0];\n  outputs: object[];\n}[];\n\nexport type AxAICohereChatRequest = {\n  message?: string;\n  preamble?: string;\n  chat_history: (\n    | {\n        role: 'CHATBOT';\n        message: string;\n        tool_calls?: AxAICohereChatResponseToolCalls;\n      }\n    | {\n        role: 'SYSTEM';\n        message: string;\n      }\n    | {\n        role: 'USER';\n        message: string;\n      }\n    | {\n        role: 'TOOL';\n        message?: string;\n        tool_results: AxAICohereChatRequestToolResults;\n      }\n  )[];\n\n  model: AxAICohereModel;\n  max_tokens?: number;\n  temperature?: number;\n  k?: number;\n  p?: number;\n  frequency_penalty?: number;\n  presence_penalty?: number;\n  end_sequences?: readonly string[];\n  stop_sequences?: string[];\n  tools?: {\n    name: string;\n    description: string;\n    parameter_definitions: Record<\n      string,\n      {\n        description: string;\n        type: string;\n        required: boolean;\n      }\n    >;\n  }[];\n  tool_results?: AxAICohereChatRequestToolResults;\n};\n\nexport type AxAICohereChatResponse = {\n  response_id: string;\n  meta: {\n    billed_units: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n  generation_id: string;\n  text: string;\n  finish_reason:\n    | 'COMPLETE'\n    | 'ERROR'\n    | 'ERROR_TOXIC'\n    | 'ERROR_LIMIT'\n    | 'USER_CANCEL'\n    | 'MAX_TOKENS';\n  tool_calls: AxAICohereChatResponseToolCalls;\n};\n\nexport type AxAICohereChatResponseDelta = AxAICohereChatResponse & {\n  event_type:\n    | 'stream-start'\n    | 'text-generation'\n    | 'tool-calls-generation'\n    | 'stream-end';\n};\n\nexport type AxAICohereEmbedRequest = {\n  texts: readonly string[];\n  model: AxAICohereEmbedModel;\n  truncate: string;\n};\n\nexport type AxAICohereEmbedResponse = {\n  id: string;\n  texts: string[];\n  model: AxAICohereEmbedModel;\n  embeddings: number[][];\n};\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAICohereEmbedModel, AxAICohereModel } from './types.js';\n\nexport const axModelInfoCohere: AxModelInfo[] = [\n  {\n    name: AxAICohereModel.CommandRPlus,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAICohereModel.CommandR,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.Command,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.CommandLight,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n];\n", "import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoCohere } from './info.js';\nimport {\n  type AxAICohereChatRequest,\n  type AxAICohereChatResponse,\n  type AxAICohereChatResponseDelta,\n  type AxAICohereConfig,\n  AxAICohereEmbedModel,\n  type AxAICohereEmbedRequest,\n  type AxAICohereEmbedResponse,\n  AxAICohereModel,\n} from './types.js';\n\nexport const axAICohereDefaultConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandRPlus,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAICohereCreativeConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandR,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport interface AxAICohereArgs {\n  name: 'cohere';\n  apiKey: string;\n  config?: Readonly<Partial<AxAICohereConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAICohereModel, AxAICohereEmbedModel>;\n}\n\nclass AxAICohereImpl\n  implements\n    AxAIServiceImpl<\n      AxAICohereModel,\n      AxAICohereEmbedModel,\n      AxAICohereChatRequest,\n      AxAICohereEmbedRequest,\n      AxAICohereChatResponse,\n      AxAICohereChatResponseDelta,\n      AxAICohereEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAICohereConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      frequencyPenalty: config.frequencyPenalty,\n      presencePenalty: config.presencePenalty,\n      endSequences: config.endSequences,\n      stopSequences: config.stopSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<AxAICohereModel>>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAICohereChatRequest] {\n    const model = req.model;\n\n    const lastChatMsg = req.chatPrompt.at(-1);\n    const restOfChat = req.chatPrompt.slice(0, -1);\n\n    let message: AxAICohereChatRequest['message'] | undefined;\n\n    if (\n      lastChatMsg &&\n      lastChatMsg.role === 'user' &&\n      typeof lastChatMsg.content === 'string'\n    ) {\n      message = lastChatMsg?.content;\n    }\n\n    const chatHistory = createHistory(restOfChat);\n\n    type PropValue = NonNullable<\n      AxAICohereChatRequest['tools']\n    >[0]['parameter_definitions'][0];\n\n    const tools: AxAICohereChatRequest['tools'] = req.functions?.map((v) => {\n      const props: Record<string, PropValue> = {};\n      if (v.parameters?.properties) {\n        for (const [key, value] of Object.entries(v.parameters.properties)) {\n          props[key] = {\n            description: value.description,\n            type: value.type,\n            required: v.parameters.required?.includes(key) ?? false,\n          };\n        }\n      }\n\n      return {\n        name: v.name,\n        description: v.description,\n        parameter_definitions: props,\n      };\n    });\n\n    type FnType = Extract<AxChatRequest['chatPrompt'][0], { role: 'function' }>;\n\n    const toolResults: AxAICohereChatRequest['tool_results'] = (\n      req.chatPrompt as FnType[]\n    )\n      .filter((chat) => chat.role === 'function')\n      .map((chat) => {\n        const fn = tools?.find((t) => t.name === chat.functionId);\n        if (!fn) {\n          throw new Error('Function not found');\n        }\n        return {\n          call: { name: fn.name, parameters: fn.parameter_definitions },\n          outputs: [{ result: chat.result ?? '' }],\n        };\n      });\n\n    const apiConfig = {\n      name: '/chat',\n    };\n\n    const reqValue: AxAICohereChatRequest = {\n      message,\n      model,\n      tools,\n      ...(toolResults && !message ? { tool_results: toolResults } : {}),\n      chat_history: chatHistory,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      k: req.modelConfig?.topK ?? this.config.topK,\n      p: req.modelConfig?.topP ?? this.config.topP,\n      frequency_penalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      end_sequences: this.config.endSequences,\n      stop_sequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n    };\n\n    return [apiConfig, reqValue];\n  }\n\n  createEmbedReq = (\n    req: Readonly<AxInternalEmbedRequest<AxAICohereEmbedModel>>\n  ): [AxAPI, AxAICohereEmbedRequest] => {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embed',\n    };\n\n    const reqValue = {\n      model,\n      texts: req.texts ?? [],\n      input_type: 'classification',\n      truncate: '',\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (resp: Readonly<AxAICohereChatResponse>): AxChatResponse => {\n    this.tokensUsed = resp.meta.billed_units\n      ? {\n          promptTokens: resp.meta.billed_units.input_tokens,\n          completionTokens: resp.meta.billed_units.output_tokens,\n          totalTokens:\n            resp.meta.billed_units.input_tokens +\n            resp.meta.billed_units.output_tokens,\n        }\n      : undefined;\n\n    let finishReason: AxChatResponse['results'][0]['finishReason'];\n    if ('finish_reason' in resp) {\n      switch (resp.finish_reason) {\n        case 'COMPLETE':\n          finishReason = 'stop';\n          break;\n        case 'MAX_TOKENS':\n          finishReason = 'length';\n          break;\n        case 'ERROR':\n          throw new Error('Finish reason: ERROR');\n        case 'ERROR_TOXIC':\n          throw new Error('Finish reason: CONTENT_FILTER');\n        default:\n          finishReason = 'stop';\n          break;\n      }\n    }\n\n    let functionCalls: AxChatResponse['results'][0]['functionCalls'];\n\n    if ('tool_calls' in resp) {\n      functionCalls = resp.tool_calls?.map(\n        (v): NonNullable<AxChatResponse['results'][0]['functionCalls']>[0] => {\n          return {\n            id: v.name,\n            type: 'function' as const,\n            function: { name: v.name, params: v.parameters },\n          };\n        }\n      );\n    }\n\n    const results: AxChatResponse['results'] = [\n      {\n        index: 0,\n        id: resp.generation_id,\n        content: resp.text,\n        functionCalls,\n        finishReason,\n      },\n    ];\n\n    return { results, remoteId: resp.response_id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAICohereChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    const ss = state as {\n      generation_id?: string;\n    };\n\n    if (resp.event_type === 'stream-start') {\n      ss.generation_id = resp.generation_id;\n    }\n\n    this.tokensUsed = {\n      promptTokens: 0,\n      completionTokens: resp.meta.billed_units?.output_tokens ?? 0,\n      totalTokens: resp.meta.billed_units?.output_tokens ?? 0,\n    };\n\n    const { results } = this.createChatResp(resp);\n    const result = results[0];\n    if (!result) {\n      throw new Error('No result');\n    }\n\n    result.id = ss.generation_id ?? '';\n    return { results };\n  };\n\n  createEmbedResp(resp: Readonly<AxAICohereEmbedResponse>): AxEmbedResponse {\n    return {\n      remoteId: resp.id,\n      embeddings: resp.embeddings,\n    };\n  }\n}\n\nexport class AxAICohere extends AxBaseAI<\n  AxAICohereModel,\n  AxAICohereEmbedModel,\n  AxAICohereChatRequest,\n  AxAICohereEmbedRequest,\n  AxAICohereChatResponse,\n  AxAICohereChatResponseDelta,\n  AxAICohereEmbedResponse\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAICohereArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Cohere API key not set');\n    }\n    const Config = {\n      ...axAICohereDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAICohereImpl(Config);\n\n    super(aiImpl, {\n      name: 'Cohere',\n      apiURL: 'https://api.cohere.ai/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo: axModelInfoCohere,\n      defaults: { model: Config.model },\n      supportFor: { functions: true, streaming: true },\n      options,\n      models,\n    });\n  }\n}\nfunction createHistory(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>\n): AxAICohereChatRequest['chat_history'] {\n  return chatPrompt.map((chat) => {\n    let message = '';\n\n    if (\n      chat.role === 'system' ||\n      chat.role === 'assistant' ||\n      chat.role === 'user'\n    ) {\n      if (typeof chat.content === 'string') {\n        message = chat.content;\n      } else {\n        throw new Error('Multi-modal content not supported');\n      }\n    }\n\n    switch (chat.role) {\n      case 'user':\n        return { role: 'USER' as const, message };\n      case 'system':\n        return { role: 'SYSTEM' as const, message };\n      case 'assistant': {\n        const toolCalls = createToolCall(chat.functionCalls);\n        return {\n          role: 'CHATBOT' as const,\n          message,\n          tool_calls: toolCalls,\n        };\n      }\n      case 'function': {\n        const functionCalls = chatPrompt\n          .map((v) => {\n            if (v.role === 'assistant') {\n              return v.functionCalls?.find((f) => f.id === chat.functionId);\n            }\n            return undefined;\n          })\n          .filter((v) => v !== undefined);\n\n        const call = createToolCall(functionCalls)?.at(0);\n\n        if (!call) {\n          throw new Error('Function call not found');\n        }\n\n        const outputs = [{ result: chat.result }];\n        return {\n          role: 'TOOL' as const,\n          tool_results: [\n            {\n              call,\n              outputs,\n            },\n          ],\n        };\n      }\n      default:\n        throw new Error('Unknown role');\n    }\n  });\n}\nfunction createToolCall(\n  functionCalls: Readonly<\n    Extract<\n      AxChatRequest['chatPrompt'][0],\n      { role: 'assistant' }\n    >['functionCalls']\n  >\n) {\n  return functionCalls?.map((v) => {\n    const parameters =\n      typeof v.function.params === 'string'\n        ? JSON.parse(v.function.params)\n        : v.function.params;\n    return { name: v.function.name, parameters };\n  });\n}\n", "/**\n * DeepSeek: Models for text generation\n */\nexport enum AxAIDeepSeekModel {\n  DeepSeekChat = 'deepseek-chat',\n  DeepSeekCoder = 'deepseek-coder',\n  DeepSeekReasoner = 'deepseek-reasoner',\n}\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIDeepSeekModel } from './types.js';\n\nexport const axModelInfoDeepSeek: AxModelInfo[] = [\n  {\n    name: AxAIDeepSeekModel.DeepSeekChat,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.27,\n    completionTokenCostPer1M: 1.1,\n  },\n  {\n    name: AxAIDeepSeekModel.DeepSeekReasoner,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.55,\n    completionTokenCostPer1M: 2.19,\n  },\n];\n", "import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nimport { axModelInfoDeepSeek } from './info.js';\nimport { AxAIDeepSeekModel } from './types.js';\n\ntype DeepSeekConfig = AxAIOpenAIConfig<AxAIDeepSeekModel, undefined>;\n\nexport const axAIDeepSeekDefaultConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekChat,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIDeepSeekCodeConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekCoder,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport type AxAIDeepSeekArgs = AxAIOpenAIArgs<\n  'deepseek',\n  AxAIDeepSeekModel,\n  undefined\n>;\n\nexport class AxAIDeepSeek extends AxAIOpenAIBase<AxAIDeepSeekModel, undefined> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIDeepSeekArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('DeepSeek API key not set');\n    }\n    const Config = {\n      ...axAIDeepSeekDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoDeepSeek, ...(modelInfo ?? [])];\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.deepseek.com',\n      modelInfo,\n      supportFor: {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: false,\n        hasShowThoughts: false,\n      },\n      models,\n    });\n\n    super.setName('DeepSeek');\n  }\n}\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIGoogleGeminiModel {\n  Gemini25Pro = 'gemini-2.5-pro',\n  Gemini25Flash = 'gemini-2.5-flash',\n  Gemini25FlashLite = 'gemini-2.5-flash-lite-preview-06-17',\n  Gemini20Flash = 'gemini-2.0-flash',\n  Gemini20FlashLite = 'gemini-2.0-flash-lite-preview-02-05',\n  Gemini1Pro = 'gemini-1.0-pro',\n  Gemini15Flash = 'gemini-1.5-flash',\n  Gemini15Flash002 = 'gemini-1.5-flash-002',\n  Gemini15Flash8B = 'gemini-1.5-flash-8b',\n  Gemini15Pro = 'gemini-1.5-pro',\n}\n\nexport enum AxAIGoogleGeminiEmbedModel {\n  GeminiEmbedding = 'gemini-embedding-exp',\n  TextEmbeddingLarge = 'text-embedding-large-exp-03-07',\n  TextEmbedding004 = 'text-embedding-004',\n  TextEmbedding005 = 'text-embedding-005',\n}\n\nexport enum AxAIGoogleGeminiSafetyCategory {\n  HarmCategoryHarassment = 'HARM_CATEGORY_HARASSMENT',\n  HarmCategoryHateSpeech = 'HARM_CATEGORY_HATE_SPEECH',\n  HarmCategorySexuallyExplicit = 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n  HarmCategoryDangerousContent = 'HARM_CATEGORY_DANGEROUS_CONTENT',\n}\n\nexport enum AxAIGoogleGeminiSafetyThreshold {\n  BlockNone = 'BLOCK_NONE',\n  BlockOnlyHigh = 'BLOCK_ONLY_HIGH',\n  BlockMediumAndAbove = 'BLOCK_MEDIUM_AND_ABOVE',\n  BlockLowAndAbove = 'BLOCK_LOW_AND_ABOVE',\n  BlockDefault = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED',\n}\n\nexport enum AxAIGoogleGeminiEmbedTypes {\n  SemanticSimilarity = 'SEMANTIC_SIMILARITY',\n  Classification = 'CLASSIFICATION',\n  Clustering = 'CLUSTERING',\n  RetrievalDocument = 'RETRIEVAL_DOCUMENT',\n  RetrievalQuery = 'RETRIEVAL_QUERY',\n  QuestionAnswering = 'QUESTION_ANSWERING',\n  FactVerification = 'FACT_VERIFICATION',\n  CodeRetrievalQuery = 'CODE_RETRIEVAL_QUERY',\n}\n\nexport type AxAIGoogleGeminiContent = {\n  role: 'user' | 'model';\n  parts: AxAIGoogleGeminiContentPart[];\n};\n\n// Part type with common fields intersected with a union of data fields\nexport type AxAIGoogleGeminiContentPart = {\n  thought?: boolean;\n  metadata?: { videoMetadata: object };\n} & (\n  | { text: string }\n  | {\n      inlineData: {\n        mimeType: string;\n        data: string;\n      };\n    }\n  | {\n      functionCall: {\n        name: string;\n        args: object;\n      };\n    }\n  | {\n      functionResponse: {\n        name: string;\n        response: object;\n      };\n    }\n  | {\n      fileData: {\n        mimeType: string;\n        fileUri: string;\n      };\n    }\n  | { executableCode: object }\n  | { codeExecutionResult: object }\n);\n\nexport type AxAIGoogleGeminiToolFunctionDeclaration = {\n  name: string;\n  description?: string;\n  parameters?: object;\n};\n\nexport type AxAIGoogleGeminiToolGoogleSearchRetrieval = {\n  dynamic_retrieval_config: {\n    mode?: 'MODE_DYNAMIC';\n    dynamic_threshold?: number;\n  };\n};\n\nexport type AxAIGoogleGeminiTool = {\n  function_declarations?: AxAIGoogleGeminiToolFunctionDeclaration[];\n  code_execution?: object;\n  google_search_retrieval?: AxAIGoogleGeminiToolGoogleSearchRetrieval;\n  google_search?: object;\n  url_context?: object;\n};\n\nexport type AxAIGoogleGeminiToolConfig = {\n  function_calling_config: {\n    mode: 'ANY' | 'NONE' | 'AUTO';\n    allowed_function_names?: string[];\n  };\n};\n\nexport type AxAIGoogleGeminiGenerationConfig = {\n  temperature?: number;\n  topP?: number;\n  topK?: number;\n  frequencyPenalty?: number;\n  candidateCount?: number;\n  maxOutputTokens?: number;\n  stopSequences?: readonly string[];\n  responseMimeType?: string;\n  thinkingConfig?: {\n    thinkingBudget?: number;\n    includeThoughts?: boolean;\n  };\n};\n\nexport type AxAIGoogleGeminiSafetySettings = {\n  category: AxAIGoogleGeminiSafetyCategory;\n  threshold: AxAIGoogleGeminiSafetyThreshold;\n}[];\n\nexport type AxAIGoogleGeminiChatRequest = {\n  contents: AxAIGoogleGeminiContent[];\n  tools?: AxAIGoogleGeminiTool[];\n  toolConfig?: AxAIGoogleGeminiToolConfig;\n  systemInstruction?: AxAIGoogleGeminiContent;\n  generationConfig: AxAIGoogleGeminiGenerationConfig;\n  safetySettings?: AxAIGoogleGeminiSafetySettings;\n};\n\nexport type AxAIGoogleGeminiChatResponse = {\n  candidates: {\n    content: AxAIGoogleGeminiContent;\n\n    finishReason:\n      | 'STOP'\n      | 'MAX_TOKENS'\n      | 'SAFETY'\n      | 'RECITATION'\n      | 'OTHER'\n      | 'BLOCKLIST'\n      | 'PROHIBITED_CONTENT'\n      | 'SPII'\n      | 'MALFORMED_FUNCTION_CALL'\n      | 'UNEXPECTED_TOOL_CALL'\n      | 'FINISH_REASON_UNSPECIFIED';\n    citationMetadata: {\n      citations: {\n        startIndex: number;\n        endIndex: number;\n        uri: string;\n        title: string;\n        license: string;\n        publicationDate: {\n          year: number;\n          month: number;\n          day: number;\n        };\n      }[];\n    };\n  }[];\n  usageMetadata: {\n    promptTokenCount: number;\n    candidatesTokenCount: number;\n    totalTokenCount: number;\n    thoughtsTokenCount: number;\n  };\n};\n\nexport type AxAIGoogleGeminiChatResponseDelta = AxAIGoogleGeminiChatResponse;\n\nexport type AxAIGoogleGeminiThinkingConfig = {\n  thinkingTokenBudget?: number;\n  includeThoughts?: boolean;\n};\n\nexport type AxAIGoogleGeminiThinkingTokenBudgetLevels = {\n  minimal?: number;\n  low?: number;\n  medium?: number;\n  high?: number;\n  highest?: number;\n};\n\n/**\n * AxAIGoogleGeminiConfig: Configuration options for Google Gemini API\n */\nexport type AxAIGoogleGeminiConfig = AxModelConfig & {\n  model: AxAIGoogleGeminiModel;\n  embedModel?: AxAIGoogleGeminiEmbedModel;\n  safetySettings?: AxAIGoogleGeminiSafetySettings;\n  embedType?: AxAIGoogleGeminiEmbedTypes;\n  dimensions?: number;\n  autoTruncate?: boolean;\n  thinking?: AxAIGoogleGeminiThinkingConfig;\n  thinkingTokenBudgetLevels?: AxAIGoogleGeminiThinkingTokenBudgetLevels;\n  urlContext?: string;\n};\n\n/**\n * AxAIGoogleGeminiEmbedRequest: Structure for making an embedding request to the Google Gemini API.\n */\nexport type AxAIGoogleGeminiBatchEmbedRequest = {\n  requests: {\n    model: string;\n    content: {\n      parts: { text: string }[];\n    };\n  }[];\n};\n\n/**\n * AxAIGoogleGeminiEmbedResponse: Structure for handling responses from the Google Gemini API embedding requests.\n */\nexport type AxAIGoogleGeminiBatchEmbedResponse = {\n  embeddings: {\n    values: number[];\n  }[];\n};\n\n/**\n * AxAIGoogleVertexBatchEmbedRequest: Structure for making an embedding request to the Google Vertex API.\n */\nexport type AxAIGoogleVertexBatchEmbedRequest = {\n  instances: {\n    content: string;\n    task_type?: AxAIGoogleGeminiEmbedTypes;\n  }[];\n  parameters: {\n    autoTruncate?: boolean;\n    outputDimensionality?: number;\n  };\n};\n\n/**\n * AxAIGoogleVertexBatchEmbedResponse: Structure for handling responses from the Google Vertex API embedding requests.\n */\nexport type AxAIGoogleVertexBatchEmbedResponse = {\n  predictions: {\n    embeddings: {\n      values: number[];\n    };\n  }[];\n};\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIGoogleGeminiModel } from './types.js';\n\n/**\n * AxAIGoogleGemini: Model information\n */\nexport const axModelInfoGoogleGemini: AxModelInfo[] = [\n  {\n    name: AxAIGoogleGeminiModel.Gemini25Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 2.5,\n    completionTokenCostPer1M: 15.0,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini25Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 3.5,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini25FlashLite,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.4,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini20Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.01,\n    completionTokenCostPer1M: 0.4,\n  },\n\n  {\n    name: AxAIGoogleGeminiModel.Gemini20FlashLite,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.0,\n    completionTokenCostPer1M: 0.0,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.075,\n    completionTokenCostPer1M: 0.3,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash8B,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.0375,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 1.25,\n    completionTokenCostPer1M: 5.0,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini1Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n];\n", "import { getModelInfo } from '@ax-llm/ax/dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport { randomUUID } from '../../util/crypto.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\nimport { axModelInfoGoogleGemini } from './info.js';\nimport {\n  type AxAIGoogleGeminiBatchEmbedRequest,\n  type AxAIGoogleGeminiBatchEmbedResponse,\n  type AxAIGoogleGeminiChatRequest,\n  type AxAIGoogleGeminiChatResponse,\n  type AxAIGoogleGeminiChatResponseDelta,\n  type AxAIGoogleGeminiConfig,\n  type AxAIGoogleGeminiContent,\n  type AxAIGoogleGeminiContentPart,\n  AxAIGoogleGeminiEmbedModel,\n  type AxAIGoogleGeminiGenerationConfig,\n  AxAIGoogleGeminiModel,\n  AxAIGoogleGeminiSafetyCategory,\n  type AxAIGoogleGeminiSafetySettings,\n  AxAIGoogleGeminiSafetyThreshold,\n  type AxAIGoogleVertexBatchEmbedRequest,\n  type AxAIGoogleVertexBatchEmbedResponse,\n} from './types.js';\n\nconst safetySettings: AxAIGoogleGeminiSafetySettings = [\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHarassment,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHateSpeech,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategorySexuallyExplicit,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryDangerousContent,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n];\n\n/**\n * AxAIGoogleGemini: Default Model options for text generation\n */\nexport const axAIGoogleGeminiDefaultConfig = (): AxAIGoogleGeminiConfig =>\n  structuredClone<AxAIGoogleGeminiConfig>({\n    model: AxAIGoogleGeminiModel.Gemini25Flash,\n    embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding005,\n    safetySettings,\n    thinkingTokenBudgetLevels: {\n      minimal: 200,\n      low: 800,\n      medium: 5000,\n      high: 10000,\n      highest: 24500,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIGoogleGeminiDefaultCreativeConfig =\n  (): AxAIGoogleGeminiConfig =>\n    structuredClone<AxAIGoogleGeminiConfig>({\n      model: AxAIGoogleGeminiModel.Gemini20Flash,\n      embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding005,\n      safetySettings,\n      thinkingTokenBudgetLevels: {\n        minimal: 200,\n        low: 800,\n        medium: 5000,\n        high: 10000,\n        highest: 24500,\n      },\n      ...axBaseAIDefaultCreativeConfig(),\n    });\n\nexport interface AxAIGoogleGeminiOptionsTools {\n  codeExecution?: boolean;\n  googleSearchRetrieval?: {\n    mode?: 'MODE_DYNAMIC';\n    dynamicThreshold?: number;\n  };\n  googleSearch?: boolean;\n  urlContext?: boolean;\n}\n\nexport interface AxAIGoogleGeminiArgs {\n  name: 'google-gemini';\n  apiKey?: string | (() => Promise<string>);\n  projectId?: string;\n  region?: string;\n  endpointId?: string;\n  config?: Readonly<Partial<AxAIGoogleGeminiConfig>>;\n  options?: Readonly<AxAIServiceOptions & AxAIGoogleGeminiOptionsTools>;\n  models?: AxAIInputModelList<\n    AxAIGoogleGeminiModel,\n    AxAIGoogleGeminiEmbedModel\n  >;\n  modelInfo?: AxModelInfo[];\n}\n\nclass AxAIGoogleGeminiImpl\n  implements\n    AxAIServiceImpl<\n      AxAIGoogleGeminiModel,\n      AxAIGoogleGeminiEmbedModel,\n      AxAIGoogleGeminiChatRequest,\n      AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n      AxAIGoogleGeminiChatResponse,\n      AxAIGoogleGeminiChatResponseDelta,\n      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private config: AxAIGoogleGeminiConfig,\n    private isVertex: boolean,\n    private endpointId?: string,\n    private apiKey?: string | (() => Promise<string>),\n    private options?: AxAIGoogleGeminiArgs['options']\n  ) {\n    if (!this.isVertex && this.config.autoTruncate) {\n      throw new Error('Auto truncate is not supported for GoogleGemini');\n    }\n  }\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq = async (\n    req: Readonly<AxInternalChatRequest<AxAIGoogleGeminiModel>>,\n    config: Readonly<AxAIPromptConfig>\n  ): Promise<[AxAPI, AxAIGoogleGeminiChatRequest]> => {\n    const model = req.model;\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    let apiConfig: AxAPI;\n    if (this.endpointId) {\n      apiConfig = {\n        name: stream\n          ? `/${this.endpointId}:streamGenerateContent?alt=sse`\n          : `/${this.endpointId}:generateContent`,\n      };\n    } else {\n      apiConfig = {\n        name: stream\n          ? `/models/${model}:streamGenerateContent?alt=sse`\n          : `/models/${model}:generateContent`,\n      };\n    }\n\n    if (!this.isVertex) {\n      const pf = stream ? '&' : '?';\n      const keyValue =\n        typeof this.apiKey === 'function' ? await this.apiKey() : this.apiKey;\n      apiConfig.name += `${pf}key=${keyValue}`;\n    }\n\n    const systemPrompts = req.chatPrompt\n      .filter((p) => p.role === 'system')\n      .map((p) => p.content);\n\n    const systemInstruction =\n      systemPrompts.length > 0\n        ? {\n            role: 'user' as const,\n            parts: [{ text: systemPrompts.join(' ') }],\n          }\n        : undefined;\n\n    const contents: AxAIGoogleGeminiContent[] = req.chatPrompt\n      .filter((p) => p.role !== 'system')\n      .map((msg, i) => {\n        switch (msg.role) {\n          case 'user': {\n            const parts: AxAIGoogleGeminiContentPart[] = Array.isArray(\n              msg.content\n            )\n              ? msg.content.map((c, i) => {\n                  switch (c.type) {\n                    case 'text':\n                      return { text: c.text };\n                    case 'image':\n                      return {\n                        inlineData: { mimeType: c.mimeType, data: c.image },\n                      };\n                    default:\n                      throw new Error(\n                        `Chat prompt content type not supported (index: ${i})`\n                      );\n                  }\n                })\n              : [{ text: msg.content }];\n            return {\n              role: 'user' as const,\n              parts,\n            };\n          }\n\n          case 'assistant': {\n            let parts: AxAIGoogleGeminiContentPart[] = [];\n\n            if (msg.functionCalls) {\n              parts = msg.functionCalls.map((f) => {\n                const args =\n                  typeof f.function.params === 'string'\n                    ? JSON.parse(f.function.params)\n                    : f.function.params;\n                return {\n                  functionCall: {\n                    name: f.function.name,\n                    args: args,\n                  },\n                };\n              });\n\n              if (!parts) {\n                throw new Error('Function call is empty');\n              }\n\n              return {\n                role: 'model' as const,\n                parts,\n              };\n            }\n\n            if (!msg.content) {\n              throw new Error('Assistant content is empty');\n            }\n\n            parts = [{ text: msg.content }];\n            return {\n              role: 'model' as const,\n              parts,\n            };\n          }\n\n          case 'function': {\n            if (!('functionId' in msg)) {\n              throw new Error(`Chat prompt functionId is empty (index: ${i})`);\n            }\n            const parts: AxAIGoogleGeminiContentPart[] = [\n              {\n                functionResponse: {\n                  name: msg.functionId,\n                  response: { result: msg.result },\n                },\n              },\n            ];\n\n            return {\n              role: 'user' as const,\n              parts,\n            };\n          }\n\n          default:\n            throw new Error(\n              `Invalid role: ${JSON.stringify(msg)} (index: ${i})`\n            );\n        }\n      });\n\n    let tools: AxAIGoogleGeminiChatRequest['tools'] | undefined = [];\n\n    if (req.functions && req.functions.length > 0) {\n      tools.push({ function_declarations: req.functions });\n    }\n\n    if (this.options?.codeExecution) {\n      tools.push({ code_execution: {} });\n    }\n\n    if (this.options?.googleSearchRetrieval) {\n      tools.push({\n        google_search_retrieval: {\n          dynamic_retrieval_config: this.options.googleSearchRetrieval,\n        },\n      });\n    }\n\n    if (this.options?.googleSearch) {\n      tools.push({ google_search: {} });\n    }\n\n    if (this.options?.urlContext) {\n      tools.push({ url_context: {} });\n    }\n\n    if (tools.length === 0) {\n      tools = undefined;\n    }\n\n    let toolConfig:\n      | {\n          function_calling_config: {\n            mode: 'NONE' | 'AUTO' | 'ANY';\n            allowedFunctionNames?: string[];\n          };\n        }\n      | undefined;\n\n    if (req.functionCall) {\n      if (req.functionCall === 'none') {\n        toolConfig = { function_calling_config: { mode: 'NONE' as const } };\n      } else if (req.functionCall === 'auto') {\n        toolConfig = { function_calling_config: { mode: 'AUTO' as const } };\n      } else if (req.functionCall === 'required') {\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n        };\n      } else {\n        const allowedFunctionNames = req.functionCall.function?.name\n          ? {\n              allowedFunctionNames: [req.functionCall.function.name],\n            }\n          : {};\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n          ...allowedFunctionNames,\n        };\n      }\n    } else if (tools && tools.length > 0) {\n      toolConfig = { function_calling_config: { mode: 'AUTO' as const } };\n    }\n\n    const thinkingConfig: AxAIGoogleGeminiGenerationConfig['thinkingConfig'] =\n      {};\n\n    if (this.config.thinking?.includeThoughts) {\n      thinkingConfig.includeThoughts = true;\n    }\n\n    if (this.config.thinking?.thinkingTokenBudget) {\n      thinkingConfig.thinkingBudget = this.config.thinking.thinkingTokenBudget;\n    }\n\n    // Then, override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      //The thinkingBudget must be an integer in the range 0 to 24576\n      const levels = this.config.thinkingTokenBudgetLevels;\n\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          thinkingConfig.thinkingBudget = 0; // Explicitly set to 0\n          thinkingConfig.includeThoughts = false; // When thinkingTokenBudget is 'none', disable showThoughts\n          break;\n        case 'minimal':\n          thinkingConfig.thinkingBudget = levels?.minimal ?? 200;\n          break;\n        case 'low':\n          thinkingConfig.thinkingBudget = levels?.low ?? 800;\n          break;\n        case 'medium':\n          thinkingConfig.thinkingBudget = levels?.medium ?? 5000;\n          break;\n        case 'high':\n          thinkingConfig.thinkingBudget = levels?.high ?? 10000;\n          break;\n        case 'highest':\n          thinkingConfig.thinkingBudget = levels?.highest ?? 24500;\n          break;\n      }\n    }\n\n    if (config?.showThoughts !== undefined) {\n      // Only override includeThoughts if thinkingTokenBudget is not 'none'\n      if (config?.thinkingTokenBudget !== 'none') {\n        thinkingConfig.includeThoughts = config.showThoughts;\n      }\n    }\n\n    const generationConfig: AxAIGoogleGeminiGenerationConfig = {\n      maxOutputTokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      topP: req.modelConfig?.topP ?? this.config.topP,\n      topK: req.modelConfig?.topK ?? this.config.topK,\n      frequencyPenalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      candidateCount: 1,\n      stopSequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n      responseMimeType: 'text/plain',\n\n      ...(Object.keys(thinkingConfig).length > 0 ? { thinkingConfig } : {}),\n    };\n\n    const safetySettings = this.config.safetySettings;\n\n    const reqValue: AxAIGoogleGeminiChatRequest = {\n      contents,\n      tools,\n      toolConfig,\n      systemInstruction,\n      generationConfig,\n      safetySettings,\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createEmbedReq = async (\n    req: Readonly<AxInternalEmbedRequest<AxAIGoogleGeminiEmbedModel>>\n  ): Promise<\n    [\n      AxAPI,\n      AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n    ]\n  > => {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    let apiConfig: AxAPI;\n    let reqValue:\n      | AxAIGoogleGeminiBatchEmbedRequest\n      | AxAIGoogleVertexBatchEmbedRequest;\n\n    if (this.isVertex) {\n      if (this.endpointId) {\n        apiConfig = {\n          name: `/${this.endpointId}:predict`,\n        };\n      } else {\n        apiConfig = {\n          name: `/models/${model}:predict`,\n        };\n      }\n\n      reqValue = {\n        instances: req.texts.map((text) => ({\n          content: text,\n          ...(this.config.embedType && { taskType: this.config.embedType }),\n        })),\n        parameters: {\n          autoTruncate: this.config.autoTruncate,\n          outputDimensionality: this.config.dimensions,\n        },\n      };\n    } else {\n      const keyValue =\n        typeof this.apiKey === 'function' ? this.apiKey() : this.apiKey;\n      apiConfig = {\n        name: `/models/${model}:batchEmbedContents?key=${keyValue}`,\n      };\n\n      reqValue = {\n        requests: req.texts.map((text) => ({\n          model: `models/${model}`,\n          content: { parts: [{ text }] },\n          outputDimensionality: this.config.dimensions,\n          ...(this.config.embedType && { taskType: this.config.embedType }),\n        })),\n      };\n    }\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponse>\n  ): AxChatResponse => {\n    const results: AxChatResponseResult[] = resp.candidates?.map(\n      (candidate) => {\n        const result: AxChatResponseResult = { index: 0 };\n\n        switch (candidate.finishReason) {\n          case 'MAX_TOKENS':\n            result.finishReason = 'length';\n            break;\n          case 'STOP':\n            result.finishReason = 'stop';\n            break;\n          case 'SAFETY':\n            throw new AxAIRefusalError(\n              'Content was blocked due to safety settings',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'RECITATION':\n            throw new AxAIRefusalError(\n              'Content was blocked due to recitation policy',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'MALFORMED_FUNCTION_CALL':\n            throw new AxAIRefusalError(\n              'Function call was malformed and blocked',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'UNEXPECTED_TOOL_CALL':\n            throw new AxAIRefusalError(\n              'Unexpected tool call',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'FINISH_REASON_UNSPECIFIED':\n            throw new AxAIRefusalError(\n              'Finish reason unspecified',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'BLOCKLIST':\n            throw new AxAIRefusalError(\n              'Content was blocked due to blocklist',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'PROHIBITED_CONTENT':\n            throw new AxAIRefusalError(\n              'Content was blocked due to prohibited content',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'SPII':\n            throw new AxAIRefusalError(\n              'Content was blocked due to SPII',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'OTHER':\n            throw new AxAIRefusalError(\n              'Other finish reason',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n        }\n\n        if (!candidate.content || !candidate.content.parts) {\n          return result;\n        }\n\n        for (const part of candidate.content.parts) {\n          if ('text' in part) {\n            if ('thought' in part && part.thought) {\n              result.thought = part.text;\n            } else {\n              result.content = part.text;\n            }\n            continue;\n          }\n\n          if ('functionCall' in part) {\n            result.functionCalls = [\n              {\n                id: randomUUID(),\n                type: 'function',\n                function: {\n                  name: part.functionCall.name,\n                  params: part.functionCall.args,\n                },\n              },\n            ];\n          }\n        }\n        return result;\n      }\n    );\n\n    if (resp.usageMetadata) {\n      this.tokensUsed = {\n        totalTokens: resp.usageMetadata.totalTokenCount,\n        promptTokens: resp.usageMetadata.promptTokenCount,\n        completionTokens: resp.usageMetadata.candidatesTokenCount,\n        thoughtsTokens: resp.usageMetadata.thoughtsTokenCount,\n      };\n    }\n    return { results };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponseDelta>\n  ): AxChatResponse => {\n    return this.createChatResp(resp);\n  };\n\n  createEmbedResp = (\n    resp: Readonly<\n      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse\n    >\n  ): AxEmbedResponse => {\n    let embeddings: number[][];\n    if (this.isVertex) {\n      embeddings = (resp as AxAIGoogleVertexBatchEmbedResponse).predictions.map(\n        (prediction) => prediction.embeddings.values\n      );\n    } else {\n      embeddings = (resp as AxAIGoogleGeminiBatchEmbedResponse).embeddings.map(\n        (embedding) => embedding.values\n      );\n    }\n\n    return {\n      embeddings,\n    };\n  };\n}\n\n/**\n * AxAIGoogleGemini: AI Service\n */\nexport class AxAIGoogleGemini extends AxBaseAI<\n  AxAIGoogleGeminiModel,\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiChatRequest,\n  AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n  AxAIGoogleGeminiChatResponse,\n  AxAIGoogleGeminiChatResponseDelta,\n  AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse\n> {\n  constructor({\n    apiKey,\n    projectId,\n    region,\n    endpointId,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGoogleGeminiArgs, 'name'>>) {\n    const isVertex = projectId !== undefined && region !== undefined;\n\n    let apiURL: string;\n    let headers: () => Promise<Record<string, string>>;\n\n    if (isVertex) {\n      if (!apiKey) {\n        throw new Error('GoogleGemini Vertex API key not set');\n      }\n\n      let path: string;\n      if (endpointId) {\n        path = 'endpoints';\n      } else {\n        path = 'publishers/google';\n      }\n\n      const tld = region === 'global' ? 'aiplatform' : `${region}-aiplatform`;\n      apiURL = `https://${tld}.googleapis.com/v1/projects/${projectId}/locations/${region}/${path}`;\n      headers = async () => ({\n        Authorization: `Bearer ${typeof apiKey === 'function' ? await apiKey() : apiKey}`,\n      });\n    } else {\n      if (!apiKey) {\n        throw new Error('GoogleGemini AI API key not set');\n      }\n      apiURL = 'https://generativelanguage.googleapis.com/v1beta';\n      headers = async () => ({});\n    }\n\n    const Config = {\n      ...axAIGoogleGeminiDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIGoogleGeminiImpl(\n      Config,\n      isVertex,\n      endpointId,\n      apiKey,\n      options\n    );\n\n    modelInfo = [...axModelInfoGoogleGemini, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIGoogleGeminiModel) => {\n      const mi = getModelInfo<\n        AxAIGoogleGeminiModel,\n        AxAIGoogleGeminiEmbedModel\n      >({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        functionCot: false,\n      };\n    };\n\n    super(aiImpl, {\n      name: 'GoogleGeminiAI',\n      apiURL,\n      headers,\n      modelInfo,\n      defaults: {\n        model: Config.model as AxAIGoogleGeminiModel,\n        embedModel: Config.embedModel as AxAIGoogleGeminiEmbedModel,\n      },\n      options,\n      supportFor,\n      models,\n    });\n  }\n}\n", "import { ColorLog } from './log.js';\n\nconst colorLog = new ColorLog();\n\nexport interface AxRateLimiterTokenUsageOptions {\n  debug?: boolean;\n}\n\nexport class AxRateLimiterTokenUsage {\n  private options?: Readonly<AxRateLimiterTokenUsageOptions>;\n  private maxTokens: number;\n  private refillRate: number;\n  private currentTokens: number;\n  private lastRefillTime: number;\n\n  constructor(\n    maxTokens: number,\n    refillRate: number,\n    options?: Readonly<AxRateLimiterTokenUsageOptions>\n  ) {\n    this.maxTokens = maxTokens;\n    this.refillRate = refillRate;\n    this.currentTokens = maxTokens;\n    this.lastRefillTime = Date.now();\n    this.options = options;\n  }\n\n  private refillTokens() {\n    const now = Date.now();\n    const timeElapsed = (now - this.lastRefillTime) / 1000; // Convert ms to seconds\n    const tokensToAdd = timeElapsed * this.refillRate;\n    this.currentTokens = Math.min(\n      this.maxTokens,\n      this.currentTokens + tokensToAdd\n    );\n    this.lastRefillTime = now;\n  }\n\n  private async waitUntilTokensAvailable(tokens: number): Promise<void> {\n    this.refillTokens();\n    if (this.currentTokens >= tokens) {\n      this.currentTokens -= tokens;\n      return;\n    }\n    if (this.options?.debug) {\n      console.log(\n        colorLog.red(\n          `Rate limiter: Waiting for ${tokens - this.currentTokens} tokens`\n        )\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 100)); // Wait for 100ms before checking again\n    return this.waitUntilTokensAvailable(tokens); // Recursive call\n  }\n\n  public async acquire(tokens: number): Promise<void> {\n    await this.waitUntilTokensAvailable(tokens);\n  }\n}\n\n/**\n * Example usage of the rate limiter. Limits to 5800 tokens per minute.\nconst rateLimiter = new AxRateLimiterTokenUsage(5800, 5800 / 60);\n\nconst axRateLimiterFunction = async (func, info) => {\n  const totalTokens = info.modelUsage?.totalTokens || 0;\n  await rateLimiter.acquire(totalTokens);\n  return func();\n};\n**/\n", "export enum AxAIGroqModel {\n  Llama3_8B = 'llama3-8b-8192',\n  Llama33_70B = 'llama-3.3-70b-versatile',\n  Mixtral_8x7B = 'mixtral-8x7b-32768',\n  Gemma2_9B = 'gemma2-9b-it',\n}\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIGroqModel } from './types.js';\n\n/**\n * AxAIGroq: Model information\n */\nexport const axModelInfoGroq: AxModelInfo[] = [\n  {\n    name: AxAIGroqModel.Gemma2_9B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.2,\n  },\n  {\n    name: AxAIGroqModel.Llama33_70B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.59,\n    completionTokenCostPer1M: 0.79,\n  },\n  {\n    name: AxAIGroqModel.Llama3_8B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.05,\n    completionTokenCostPer1M: 0.08,\n  },\n  {\n    name: AxAIGroqModel.Mixtral_8x7B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.24,\n    completionTokenCostPer1M: 0.24,\n  },\n];\n", "import { AxRateLimiterTokenUsage } from '../../util/rate-limit.js';\nimport { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\nimport type {\n  AxAIServiceOptions,\n  AxModelInfo,\n  AxRateLimiterFunction,\n} from '../types.js';\n\nimport { axModelInfoGroq } from './info.js';\nimport { AxAIGroqModel } from './types.js';\n\ntype AxAIGroqAIConfig = AxAIOpenAIConfig<AxAIGroqModel, undefined>;\n\nconst axAIGroqDefaultConfig = (): AxAIGroqAIConfig =>\n  structuredClone({\n    model: AxAIGroqModel.Llama33_70B,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport type AxAIGroqArgs = AxAIOpenAIArgs<'groq', AxAIGroqModel, undefined> & {\n  options?: Readonly<AxAIServiceOptions> & { tokensPerMinute?: number };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIGroq extends AxAIOpenAIBase<AxAIGroqModel, undefined> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGroqArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Groq API key not set');\n    }\n    const Config = {\n      ...axAIGroqDefaultConfig(),\n      ...config,\n    };\n\n    const Options = {\n      ...options,\n      streamingUsage: false,\n    };\n\n    modelInfo = [...axModelInfoGroq, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options: Options,\n      modelInfo,\n      apiURL: 'https://api.groq.com/openai/v1',\n      models,\n      supportFor,\n    });\n\n    super.setName('Groq');\n    this.setOptions(Options);\n  }\n\n  override setOptions = (options: Readonly<AxAIServiceOptions>) => {\n    const rateLimiter = this.newRateLimiter(options);\n    super.setOptions({ ...options, rateLimiter });\n  };\n\n  private newRateLimiter = (options: Readonly<AxAIGroqArgs['options']>) => {\n    if (options?.rateLimiter) {\n      return options.rateLimiter;\n    }\n\n    const tokensPerMin = options?.tokensPerMinute ?? 4800;\n    const rt = new AxRateLimiterTokenUsage(tokensPerMin, tokensPerMin / 60, {\n      debug: options?.debug,\n    });\n\n    const rtFunc: AxRateLimiterFunction = async (func, info) => {\n      const totalTokens = info.modelUsage?.tokens?.totalTokens || 0;\n      await rt.acquire(totalTokens);\n      return await func();\n    };\n\n    return rtFunc;\n  };\n}\n", "import type { AxModelInfo } from '../types.js';\n\n/**\n * HuggingFace: Model information\n */\nexport const axModelInfoHuggingFace: AxModelInfo[] = [];\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIHuggingFaceModel {\n  MetaLlama270BChatHF = 'meta-llama/Llama-2-70b-chat-hf',\n}\n\nexport type AxAIHuggingFaceConfig = AxModelConfig & {\n  model: AxAIHuggingFaceModel;\n  returnFullText?: boolean;\n  doSample?: boolean;\n  maxTime?: number;\n  useCache?: boolean;\n  waitForModel?: boolean;\n};\n\nexport type AxAIHuggingFaceRequest = {\n  model: AxAIHuggingFaceModel;\n  inputs: string;\n  parameters: {\n    max_new_tokens?: number;\n    repetition_penalty?: number;\n    temperature?: number;\n    top_p?: number;\n    top_k?: number;\n    return_full_text?: boolean;\n    num_return_sequences?: number;\n    do_sample?: boolean;\n    max_time?: number;\n  };\n  options?: {\n    use_cache?: boolean;\n    wait_for_model?: boolean;\n  };\n};\n\nexport type AxAIHuggingFaceResponse = {\n  generated_text: string;\n};\n", "import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoHuggingFace } from './info.js';\nimport {\n  type AxAIHuggingFaceConfig,\n  AxAIHuggingFaceModel,\n  type AxAIHuggingFaceRequest,\n  type AxAIHuggingFaceResponse,\n} from './types.js';\n\nexport const axAIHuggingFaceDefaultConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIHuggingFaceCreativeConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport interface AxAIHuggingFaceArgs {\n  name: 'huggingface';\n  apiKey: string;\n  config?: Readonly<Partial<AxAIHuggingFaceConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAIHuggingFaceModel, undefined>;\n}\n\nclass AxAIHuggingFaceImpl\n  implements\n    AxAIServiceImpl<\n      AxAIHuggingFaceModel,\n      unknown,\n      AxAIHuggingFaceRequest,\n      unknown,\n      AxAIHuggingFaceResponse,\n      unknown,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAIHuggingFaceConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      n: config.n,\n      presencePenalty: config.presencePenalty,\n    } as AxModelConfig;\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest<AxAIHuggingFaceModel>>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAIHuggingFaceRequest] => {\n    const model = req.model;\n\n    const functionsList = req.functions\n      ? `Functions:\\n${JSON.stringify(req.functions, null, 2)}\\n`\n      : '';\n\n    const prompt = req.chatPrompt\n      ?.map((msg) => {\n        switch (msg.role) {\n          case 'user':\n            return `User: ${msg.content}`;\n          case 'system':\n            return `System: ${msg.content}`;\n          case 'function':\n            return `Function Result: ${msg.result}`;\n          case 'assistant': {\n            const fc = msg.functionCalls\n              ?.map((fc) => {\n                const args =\n                  typeof fc.function.params === 'string'\n                    ? fc.function.params\n                    : JSON.stringify(fc.function.params);\n\n                return `${fc.function.name}(${args})`;\n              })\n              .join('\\n');\n            if (fc) {\n              return `Assistant: ${msg.content}\\n Functions:\\n${fc}`;\n            }\n            return `Assistant: ${msg.content}`;\n          }\n          default:\n            throw new Error('Unknown role');\n        }\n\n        //return `${msg.role}: ${msg.content}`;\n      })\n      .join('\\n');\n\n    const inputs = `${functionsList} ${prompt}`.trim();\n\n    const apiConfig = {\n      name: '/models',\n    };\n\n    const reqValue: AxAIHuggingFaceRequest = {\n      model,\n      inputs,\n      parameters: {\n        max_new_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n        repetition_penalty:\n          req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n        temperature: req.modelConfig?.temperature ?? this.config.temperature,\n        top_p: req.modelConfig?.topP ?? this.config.topP,\n        top_k: req.modelConfig?.topK ?? this.config.topK,\n        return_full_text: this.config.returnFullText,\n        num_return_sequences: this.config.n,\n        do_sample: this.config.doSample,\n        max_time: this.config.maxTime,\n      },\n      options: {\n        use_cache: this.config.useCache,\n        wait_for_model: this.config.waitForModel,\n      },\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIHuggingFaceResponse>\n  ): AxChatResponse => {\n    return {\n      results: [\n        {\n          index: 0,\n          content: resp.generated_text,\n        },\n      ],\n    };\n  };\n}\n\nexport class AxAIHuggingFace extends AxBaseAI<\n  AxAIHuggingFaceModel,\n  unknown,\n  AxAIHuggingFaceRequest,\n  unknown,\n  AxAIHuggingFaceResponse,\n  unknown,\n  unknown\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIHuggingFaceArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('HuggingFace API key not set');\n    }\n    const Config = {\n      ...axAIHuggingFaceDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIHuggingFaceImpl(Config);\n\n    super(aiImpl, {\n      name: 'HuggingFace',\n      apiURL: 'https://api-inference.huggingface.co',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo: axModelInfoHuggingFace,\n      defaults: { model: Config.model },\n      options,\n      supportFor: { functions: false, streaming: false },\n      models,\n    });\n  }\n}\n", "// cspell:ignore mistral, mixtral, codestral, nemo\n\nexport enum AxAIMistralModel {\n  Mistral7B = 'open-mistral-7b',\n  Mistral8x7B = 'open-mixtral-8x7b',\n  MistralSmall = 'mistral-small-latest',\n  MistralNemo = 'mistral-nemo-latest',\n  MistralLarge = 'mistral-large-latest',\n  Codestral = 'codestral-latest',\n  OpenCodestralMamba = 'open-codestral-mamba',\n  OpenMistralNemo = 'open-mistral-nemo-latest',\n}\n\nexport enum AxAIMistralEmbedModels {\n  MistralEmbed = 'mistral-embed',\n}\n", "// cspell:ignore mistral, mixtral, codestral, nemo\n\nimport type { AxModelInfo } from '../types.js';\n\nimport { AxAIMistralModel } from './types.js';\n\nexport const axModelInfoMistral: AxModelInfo[] = [\n  {\n    name: AxAIMistralModel.Mistral7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.Mistral8x7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.7,\n    completionTokenCostPer1M: 0.7,\n  },\n  {\n    name: AxAIMistralModel.MistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIMistralModel.MistralSmall,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.MistralLarge,\n    currency: 'USD',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 6,\n  },\n  {\n    name: AxAIMistralModel.Codestral,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.OpenCodestralMamba,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.OpenMistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.3,\n  },\n];\n", "import { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type {\n  AxAIOpenAIChatRequest,\n  AxAIOpenAIConfig,\n} from '../openai/chat_types.js';\nimport type { AxAIServiceOptions, AxModelInfo } from '../types.js';\n\nimport { axModelInfoMistral } from './info.js';\nimport { type AxAIMistralEmbedModels, AxAIMistralModel } from './types.js';\n\ntype AxAIMistralConfig = AxAIOpenAIConfig<\n  AxAIMistralModel,\n  AxAIMistralEmbedModels\n>;\n\nexport const axAIMistralDefaultConfig = (): AxAIMistralConfig =>\n  structuredClone({\n    model: AxAIMistralModel.MistralSmall,\n    ...axBaseAIDefaultConfig(),\n    topP: 1,\n  });\n\nexport const axAIMistralBestConfig = (): AxAIMistralConfig =>\n  structuredClone({\n    ...axAIMistralDefaultConfig(),\n    model: AxAIMistralModel.MistralLarge,\n  });\n\nexport type AxAIMistralChatRequest = Omit<\n  AxAIOpenAIChatRequest<AxAIMistralModel>,\n  'max_completion_tokens' | 'stream_options' | 'messages'\n> & {\n  max_tokens?: number;\n  messages: (\n    | { role: 'system'; content: string }\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | {\n                  type: 'text';\n                  text: string;\n                }\n              | {\n                  type: 'image_url';\n                  image_url: string;\n                }\n            )[];\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content: string;\n        name?: string;\n        tool_calls?: {\n          type: 'function';\n          function: {\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments?: string;\n          };\n        }[];\n      }\n    | { role: 'tool'; content: string; tool_call_id: string }\n  )[];\n};\n\nexport type AxAIMistralArgs = AxAIOpenAIArgs<\n  'mistral',\n  AxAIMistralModel,\n  AxAIMistralEmbedModels\n> & {\n  options?: Readonly<AxAIServiceOptions> & { tokensPerMinute?: number };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIMistral extends AxAIOpenAIBase<\n  AxAIMistralModel,\n  AxAIMistralEmbedModels\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIMistralArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Mistral API key not set');\n    }\n    const Config = {\n      ...axAIMistralDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoMistral, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n    };\n\n    // Chat request updater to add Grok's search parameters\n    const chatReqUpdater = (\n      req: Readonly<AxAIOpenAIChatRequest<AxAIMistralModel>>\n    ): AxAIMistralChatRequest => {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const { max_completion_tokens, messages, ...result } =\n        req as AxAIOpenAIChatRequest<AxAIMistralModel>;\n\n      return {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ...(result as any),\n        messages: this.updateMessages(messages),\n        max_tokens: max_completion_tokens,\n      };\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.mistral.ai/v1',\n      modelInfo,\n      models,\n      supportFor,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      chatReqUpdater: chatReqUpdater as any,\n    });\n\n    super.setName('Mistral');\n  }\n\n  private updateMessages(\n    messages: AxAIOpenAIChatRequest<AxAIMistralModel>['messages']\n  ) {\n    const messagesUpdated: AxAIOpenAIChatRequest<AxAIMistralModel>['messages'] =\n      [];\n\n    if (!Array.isArray(messages)) {\n      return messages;\n    }\n\n    for (const message of messages) {\n      if (message.role === 'user' && Array.isArray(message.content)) {\n        const contentUpdated = message.content.map((item) => {\n          if (\n            typeof item === 'object' &&\n            item !== null &&\n            'image_url' in item\n          ) {\n            return {\n              type: 'image_url' as const,\n              image_url: { url: item.image_url?.url },\n            };\n          }\n          return item;\n        });\n        messagesUpdated.push({ ...message, content: contentUpdated });\n      } else {\n        messagesUpdated.push(message);\n      }\n    }\n\n    return messagesUpdated;\n  }\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\nimport { randomUUID } from '../../util/crypto.js';\n\nimport type {\n  AxAIModelList,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxModelInfoWithProvider,\n} from '../types.js';\n\nexport type AxMockAIServiceConfig = {\n  name?: string;\n  id?: string;\n  modelInfo?: Partial<AxModelInfoWithProvider>;\n  embedModelInfo?: AxModelInfoWithProvider;\n  features?: { functions?: boolean; streaming?: boolean };\n  models?: AxAIModelList;\n  options?: AxAIServiceOptions;\n  chatResponse?:\n    | AxChatResponse\n    | ReadableStream<AxChatResponse>\n    | (() => Promise<AxChatResponse | ReadableStream<AxChatResponse>>)\n    | ((\n        req: Readonly<AxChatRequest<unknown>>,\n        options?: Readonly<\n          AxAIPromptConfig & AxAIServiceActionOptions<unknown, unknown>\n        >\n      ) => Promise<AxChatResponse | ReadableStream<AxChatResponse>>);\n\n  embedResponse?:\n    | AxEmbedResponse\n    | ((\n        req: Readonly<AxEmbedRequest>\n      ) => AxEmbedResponse | Promise<AxEmbedResponse>);\n  shouldError?: boolean;\n  errorMessage?: string;\n  latencyMs?: number;\n};\n\nexport class AxMockAIService implements AxAIService {\n  private metrics: AxAIServiceMetrics = {\n    latency: {\n      chat: { mean: 0, p95: 0, p99: 0, samples: [] },\n      embed: { mean: 0, p95: 0, p99: 0, samples: [] },\n    },\n    errors: {\n      chat: { count: 0, rate: 0, total: 0 },\n      embed: { count: 0, rate: 0, total: 0 },\n    },\n  };\n\n  constructor(private readonly config: AxMockAIServiceConfig = {}) {\n    this.config.id = this.config.id ?? randomUUID();\n  }\n  getLastUsedChatModel(): unknown {\n    return this.config.modelInfo?.name ?? 'mock-model';\n  }\n  getLastUsedEmbedModel(): unknown {\n    return this.config.embedModelInfo?.name ?? 'mock-embed-model';\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.config.modelInfo\n      ? {\n          maxTokens: this.config.modelInfo.maxTokens,\n          temperature: 0.7, // Default temperature\n          stream: this.config.features?.streaming ?? false,\n        }\n      : undefined;\n  }\n\n  getName(): string {\n    return this.config.name ?? 'mock-ai-service';\n  }\n\n  getId(): string {\n    return this.config.id ?? 'mock-ai-service-id';\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getFeatures(_model?: string): { functions: boolean; streaming: boolean } {\n    return {\n      functions: this.config.features?.functions ?? false,\n      streaming: this.config.features?.streaming ?? false,\n    };\n  }\n\n  getModelList(): AxAIModelList | undefined {\n    return this.config.models;\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.metrics;\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<unknown>>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<\n      AxAIPromptConfig & AxAIServiceActionOptions<unknown, unknown>\n    >\n  ) {\n    if (this.config.latencyMs) {\n      await new Promise((resolve) =>\n        setTimeout(resolve, this.config.latencyMs)\n      );\n    }\n\n    if (this.config.shouldError) {\n      throw new Error(this.config.errorMessage ?? 'Mock chat error');\n    }\n\n    this.updateMetrics('chat');\n\n    if (typeof this.config.chatResponse === 'function') {\n      return await this.config.chatResponse(req);\n    }\n\n    return (\n      this.config.chatResponse ?? {\n        results: [\n          {\n            index: 0,\n            content: 'Mock response',\n            finishReason: 'stop',\n          },\n        ],\n        modelUsage: {\n          ai: this.getName(),\n          model: 'mock-model',\n          tokens: {\n            promptTokens: 10,\n            completionTokens: 5,\n            totalTokens: 15,\n          },\n        },\n      }\n    );\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxAIServiceActionOptions>\n  ): Promise<AxEmbedResponse> {\n    if (this.config.latencyMs) {\n      await new Promise((resolve) =>\n        setTimeout(resolve, this.config.latencyMs)\n      );\n    }\n\n    if (this.config.shouldError) {\n      throw new Error(this.config.errorMessage ?? 'Mock embed error');\n    }\n\n    this.updateMetrics('embed');\n\n    if (typeof this.config.embedResponse === 'function') {\n      return this.config.embedResponse(req);\n    }\n\n    return (\n      this.config.embedResponse ?? {\n        embeddings: [[0.1, 0.2, 0.3]],\n        modelUsage: {\n          ai: this.getName(),\n          model: 'mock-model',\n          tokens: {\n            promptTokens: 5,\n            completionTokens: 0,\n            totalTokens: 5,\n          },\n        },\n      }\n    );\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.config.options = options;\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.config.options ?? {};\n  }\n\n  getLogger(): AxLoggerFunction {\n    return (\n      this.config.options?.logger ??\n      ((message: string) => {\n        process.stdout.write(message);\n      })\n    );\n  }\n\n  private updateMetrics(type: 'chat' | 'embed'): void {\n    const latency = this.config.latencyMs ?? 0;\n    this.metrics.latency[type].samples.push(latency);\n    const samples = this.metrics.latency[type].samples;\n\n    // Update mean\n    this.metrics.latency[type].mean =\n      samples.reduce((a, b) => a + b, 0) / samples.length;\n\n    // Calculate percentiles only if we have enough samples\n    if (samples.length > 0) {\n      const sortedSamples = [...samples].sort((a, b) => a - b);\n\n      // For p95, we need at least 20 samples for meaningful calculation (1/0.05)\n      const p95Index = Math.max(0, Math.floor(sortedSamples.length * 0.95) - 1);\n      this.metrics.latency[type].p95 = sortedSamples[p95Index] ?? latency;\n\n      // For p99, we need at least 100 samples for meaningful calculation (1/0.01)\n      const p99Index = Math.max(0, Math.floor(sortedSamples.length * 0.99) - 1);\n      this.metrics.latency[type].p99 = sortedSamples[p99Index] ?? latency;\n    }\n\n    if (this.config.shouldError) {\n      this.metrics.errors[type].count++;\n      this.metrics.errors[type].total++;\n\n      // Calculate error rate against total requests, not just samples\n      const totalRequests = this.metrics.latency[type].samples.length;\n      this.metrics.errors[type].rate =\n        totalRequests > 0 ? this.metrics.errors[type].count / totalRequests : 0;\n    }\n  }\n}\n\n// Example usage:\n/*\nconst mockService = new MockAIService({\n  name: 'test-service',\n  modelInfo: {\n    name: 'test-model',\n    provider: 'test-provider',\n    promptTokenCostPer1M: 200,\n    completionTokenCostPer1M: 150,\n  },\n  features: {\n    functions: true,\n    streaming: true,\n  },\n  chatResponse: async (req) => ({\n    results: [\n      {\n        content: `Processed request with ${req.chatPrompt.length} messages`,\n        finishReason: 'stop',\n      },\n    ],\n    modelUsage: {\n      promptTokens: 20,\n      completionTokens: 10,\n      totalTokens: 30,\n    },\n  }),\n  latencyMs: 100,\n})\n*/\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport type {\n  AxAIModelList,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n} from './types.js';\n\ntype AxAIServiceListItem<TModel = unknown, TEmbedModel = unknown> = {\n  key: string;\n  service: AxAIService<TModel, TEmbedModel>;\n  description: string;\n  isInternal?: boolean;\n};\n\nexport class AxMultiServiceRouter implements AxAIService<string, string> {\n  private options?: AxAIServiceOptions;\n  private lastUsedService?: AxAIService<string, string>;\n\n  private services: Map<\n    string,\n    {\n      isInternal?: boolean;\n      description: string;\n      model?: string;\n      embedModel?: string;\n      service: AxAIService<string, string>;\n    }\n  > = new Map();\n  /**\n   * Constructs a new multi-service router.\n   * It validates that each service provides a unique set of model keys,\n   * then builds a lookup (map) for routing the chat/embed requests.\n   */\n  constructor(\n    services: (\n      | AxAIServiceListItem<string, string>\n      | AxAIService<string, string>\n    )[]\n  ) {\n    if (services.length === 0) {\n      throw new Error('No AI services provided.');\n    }\n\n    // Determine input type based on first element (assuming homogeneous array)\n\n    for (const [index, item] of services.entries()) {\n      const isKeyBased = 'key' in item;\n\n      if (isKeyBased) {\n        if (this.services.has(item.key)) {\n          throw new Error(`Duplicate model key: ${item.key}`);\n        }\n\n        const { service, description, isInternal } = item;\n\n        this.services.set(item.key, {\n          service: service as AxAIService<string, string>,\n          description,\n          isInternal,\n        });\n      } else {\n        const modelList = item.getModelList() as AxAIModelList | undefined;\n\n        if (!modelList) {\n          throw new Error(\n            `Service ${index} \\`${item.getName()}\\` has no model list.`\n          );\n        }\n\n        for (const v of modelList) {\n          if (this.services.has(v.key)) {\n            const otherService = this.services.get(v.key)?.service;\n            throw new Error(\n              `Service ${index} \\`${item.getName()}\\` has duplicate model key: ${v.key} as service ${otherService?.getName()}`\n            );\n          }\n          if ('model' in v && typeof v.model) {\n            this.services.set(v.key, {\n              description: v.description,\n              service: item as AxAIService<string, string>,\n              model: v.model,\n            });\n          } else if ('embedModel' in v && v.embedModel) {\n            this.services.set(v.key, {\n              description: v.description,\n              service: item as AxAIService<string, string>,\n              embedModel: v.embedModel,\n            });\n          } else {\n            throw new Error(\n              `Key ${v.key} in model list for service ${index} \\`${item.getName()}\\` is missing a model or embedModel property.`\n            );\n          }\n        }\n      }\n    }\n  }\n  getLastUsedChatModel(): string | undefined {\n    return this.lastUsedService?.getLastUsedChatModel();\n  }\n  getLastUsedEmbedModel(): string | undefined {\n    return this.lastUsedService?.getLastUsedEmbedModel();\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.lastUsedService?.getLastUsedModelConfig();\n  }\n\n  /**\n   * Delegates the chat call to the service matching the provided model key.\n   */\n  async chat(\n    req: Readonly<AxChatRequest<string>>,\n    options?: Readonly<\n      AxAIPromptConfig & AxAIServiceActionOptions<string, string>\n    >\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const modelKey = req.model;\n    if (!modelKey) {\n      throw new Error('Model key must be specified for multi-service');\n    }\n\n    const item = this.services.get(modelKey);\n    if (!item) {\n      throw new Error(`No service found for model key: ${modelKey}`);\n    }\n\n    this.lastUsedService = item.service;\n\n    if (!item.model) {\n      const { model: _, ...reqWithoutModel } = req;\n      return await item.service.chat(reqWithoutModel, options);\n    }\n\n    return await item.service.chat({ model: modelKey, ...req }, options);\n  }\n\n  /**\n   * Delegates the embed call to the service matching the provided embed model key.\n   */\n  async embed(\n    req: Readonly<AxEmbedRequest<string>>,\n    options?: Readonly<AxAIServiceActionOptions<string, string>>\n  ): Promise<AxEmbedResponse> {\n    const embedModelKey = req.embedModel;\n    if (!embedModelKey) {\n      throw new Error('Embed model key must be specified for multi-service');\n    }\n\n    const item = this.services.get(embedModelKey);\n    if (!item) {\n      throw new Error(`No service found for embed model key: ${embedModelKey}`);\n    }\n\n    this.lastUsedService = item.service;\n\n    if (!item.model) {\n      const { embedModel: _, ...reqWithoutEmbedModel } = req;\n      return await item.service.embed(reqWithoutEmbedModel, options);\n    }\n\n    return await item.service.embed(\n      { embedModel: embedModelKey, ...req },\n      options\n    );\n  }\n\n  /**\n   * Returns a composite ID built from the IDs of the underlying services.\n   */\n  getId(): string {\n    return `MultiServiceRouter:${Array.from(this.services.values())\n      .map((s) => s.service.getId())\n      .join(',')}`;\n  }\n\n  /**\n   * Returns the name of this router.\n   */\n  getName(): string {\n    return 'MultiServiceRouter';\n  }\n\n  /**\n   * Aggregates all available models across the underlying services.\n   */\n  getModelList(): AxAIModelList {\n    return Array.from(this.services)\n      .filter(([, value]) => !value.isInternal)\n      .map(([key, v]) => {\n        if (v.model) {\n          return { key, description: v.description, model: v.model };\n        }\n        if (v.embedModel) {\n          return { key, description: v.description, embedModel: v.embedModel };\n        }\n        throw new Error(`Service ${key} has no model or embedModel`);\n      });\n  }\n\n  /**\n   * If a model key is provided, delegate to the corresponding service's features.\n   * Otherwise, returns a default feature set.\n   */\n  getFeatures(model?: string): {\n    functions: boolean;\n    streaming: boolean;\n    functionCot?: boolean;\n  } {\n    if (model) {\n      const service = this.services.get(model);\n      if (service) {\n        return service.service.getFeatures(model);\n      }\n    }\n    return { functions: false, streaming: false };\n  }\n\n  /**\n   * Returns aggregated metrics from the underlying service.\n   * Uses the metrics from the last service that was used,\n   * or falls back to the first service if none has been used.\n   */\n  getMetrics(): AxAIServiceMetrics {\n    let serviceInstance = this.lastUsedService;\n    if (!serviceInstance) {\n      const firstServiceEntry = this.services.values().next().value;\n      if (firstServiceEntry) {\n        // Check if it's the service directly or the wrapped object\n        serviceInstance =\n          'service' in firstServiceEntry\n            ? firstServiceEntry.service\n            : firstServiceEntry;\n      }\n    }\n\n    if (!serviceInstance) {\n      throw new Error('No service available to get metrics.');\n    }\n    return serviceInstance.getMetrics();\n  }\n\n  /**\n   * Sets options on all underlying services.\n   */\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    for (const service of this.services.values()) {\n      service.service.setOptions(options);\n    }\n    this.options = options;\n  }\n\n  /**\n   * Returns the options from the last used service,\n   * or falls back to the first service if none has been used.\n   */\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.options ?? {};\n  }\n\n  /**\n   * Returns the logger from the last used service,\n   * or falls back to the first service if none has been used.\n   */\n  getLogger(): AxLoggerFunction {\n    let serviceInstance = this.lastUsedService;\n    if (!serviceInstance) {\n      const firstServiceEntry = this.services.values().next().value;\n      if (firstServiceEntry) {\n        serviceInstance = firstServiceEntry.service;\n      }\n    }\n\n    if (!serviceInstance) {\n      // Return a default logger if no service is available\n      return (message: string) => {\n        process.stdout.write(message);\n      };\n    }\n    return serviceInstance.getLogger();\n  }\n\n  /**\n   * Sets a service entry for a given key. This method is intended for testing purposes.\n   * @param key - The model key\n   * @param entry - The service entry to set\n   */\n  setServiceEntry(\n    key: string,\n    entry: {\n      isInternal?: boolean;\n      description: string;\n      model?: string;\n      embedModel?: string;\n      service: AxAIService<string, string>;\n    }\n  ): void {\n    this.services.set(key, entry);\n  }\n}\n", "import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nexport type AxAIOllamaAIConfig = AxAIOpenAIConfig<string, string>;\n\nexport const axAIOllamaDefaultConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  });\n\nexport const axAIOllamaDefaultCreativeConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultCreativeConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  });\n\nexport type AxAIOllamaArgs = AxAIOpenAIArgs<'ollama', string, string> & {\n  model?: string;\n  embedModel?: string;\n  url?: string;\n};\n\n/**\n * OllamaAI: AI Service\n */\nexport class AxAIOllama extends AxAIOpenAIBase<string, string> {\n  constructor({\n    apiKey = 'not-set',\n    url = 'http://localhost:11434/v1',\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIOllamaArgs, 'name'>>) {\n    const Config = {\n      ...axAIOllamaDefaultConfig(),\n      ...config,\n    };\n    super({\n      apiKey,\n      options,\n      config: Config,\n      apiURL: url,\n      models,\n      modelInfo: [],\n      supportFor: {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: false,\n        hasShowThoughts: false,\n      },\n    });\n\n    super.setName('Ollama');\n  }\n}\n", "import type {\n  AxAIOpenAIEmbedRequest,\n  AxAIOpenAIEmbedResponse,\n  AxAPI,\n} from '@ax-llm/ax/index.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport type {\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\nimport type {\n  AxAIOpenAIResponsesCodeInterpreterToolCall,\n  AxAIOpenAIResponsesComputerToolCall,\n  AxAIOpenAIResponsesConfig,\n  AxAIOpenAIResponsesDefineFunctionTool,\n  AxAIOpenAIResponsesFileSearchToolCall,\n  AxAIOpenAIResponsesImageGenerationToolCall,\n  AxAIOpenAIResponsesInputContentPart,\n  AxAIOpenAIResponsesInputItem,\n  AxAIOpenAIResponsesInputMessageItem,\n  AxAIOpenAIResponsesLocalShellToolCall,\n  AxAIOpenAIResponsesMCPToolCall,\n  AxAIOpenAIResponsesOutputRefusalContentPart,\n  AxAIOpenAIResponsesOutputTextContentPart,\n  AxAIOpenAIResponsesRequest,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n  AxAIOpenAIResponsesStreamEvent,\n  AxAIOpenAIResponsesToolDefinition,\n  AxAIOpenAIResponsesWebSearchToolCall,\n  Mutable,\n  RequestFunctionDefinition,\n  ResponsesReqUpdater,\n  UserMessageContentItem,\n} from './responses_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n/**\n * Checks if the given OpenAI Responses model is a thinking/reasoning model.\n * Thinking models (o1, o3, o4 series) have different parameter restrictions.\n */\nexport const isOpenAIResponsesThinkingModel = (model: string): boolean => {\n  const thinkingModels = [\n    AxAIOpenAIResponsesModel.O1,\n    AxAIOpenAIResponsesModel.O1Mini,\n    AxAIOpenAIResponsesModel.O1Pro,\n    AxAIOpenAIResponsesModel.O3,\n    AxAIOpenAIResponsesModel.O3Mini,\n    AxAIOpenAIResponsesModel.O3Pro,\n    AxAIOpenAIResponsesModel.O4Mini,\n  ];\n  return thinkingModels.includes(model as AxAIOpenAIResponsesModel);\n};\n\nexport class AxAIOpenAIResponsesImpl<\n  TModel,\n  TEmbedModel, // Kept for interface compatibility, but not used by this impl.\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> implements\n    AxAIServiceImpl<\n      TModel,\n      TEmbedModel,\n      Readonly<AxAIOpenAIResponsesRequest<TModel>>, // ChatReq (now ResponsesReq)\n      Readonly<AxAIOpenAIEmbedRequest<TEmbedModel>>, // EmbedReq\n      Readonly<AxAIOpenAIResponsesResponse>, // ChatResp (now ResponsesResp)\n      Readonly<AxAIOpenAIResponsesResponseDelta>, // ChatRespDelta (now ResponsesRespDelta)\n      Readonly<AxAIOpenAIEmbedResponse> // EmbedResp\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private readonly config: Readonly<\n      AxAIOpenAIResponsesConfig<TModel, TEmbedModel>\n    >,\n    private readonly streamingUsage: boolean, // If /v1/responses supports include_usage for streams\n    private readonly responsesReqUpdater?: ResponsesReqUpdater<\n      TModel,\n      TResponsesReq\n    >\n  ) {}\n\n  getTokenUsage(): Readonly<AxTokenUsage> | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): Readonly<AxModelConfig> {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens, // maps to max_output_tokens\n      temperature: config.temperature,\n      // presencePenalty, frequencyPenalty are not direct params in /v1/responses\n      stopSequences: config.stopSequences, // /v1/responses uses 'truncation' or relies on item structure\n      topP: config.topP,\n      // n: config.n, // Not a direct parameter in /v1/responses\n      stream: config.stream,\n    };\n  }\n\n  private mapInternalContentToResponsesInput(\n    content: ReadonlyArray<UserMessageContentItem> // Expects an array of content items, string case handled by caller\n  ): ReadonlyArray<AxAIOpenAIResponsesInputContentPart> {\n    const mappedParts: Mutable<AxAIOpenAIResponsesInputContentPart>[] =\n      content.map((part: UserMessageContentItem) => {\n        // AxUserMessageContentItem ensures part is one of {type: text}, {type: image}, {type: audio}\n        if (part.type === 'text') {\n          return { type: 'text', text: part.text };\n        }\n        if (part.type === 'image') {\n          const url = `data:${part.mimeType};base64,${part.image}`;\n          return {\n            type: 'image_url',\n            image_url: { url, details: part.details ?? 'auto' },\n          };\n        }\n        if (part.type === 'audio') {\n          return {\n            type: 'input_audio',\n            input_audio: { data: part.data, format: part.format ?? 'wav' },\n          };\n        }\n        // This should be exhaustive given AxUserMessageContentItem's definition\n        const ExhaustiveCheck: never = part;\n        throw new Error(\n          `Unsupported content part: ${JSON.stringify(ExhaustiveCheck)}`\n        );\n      });\n    return mappedParts as ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n  }\n\n  private createResponsesReqInternalInput(\n    chatPrompt: ReadonlyArray<AxChatRequest<TModel>['chatPrompt'][number]>,\n    excludeSystemMessages = false // New parameter\n  ): ReadonlyArray<AxAIOpenAIResponsesInputItem> {\n    // Map from AxChatPromptItemType roles to AxAIOpenAI /v1/responses API roles:\n    // - 'system' -> 'system' (may be skipped if excludeSystemMessages is true)\n    // - 'user' -> 'user'\n    // - 'assistant' -> 'assistant'\n    // - 'function' -> Special handling for function call outputs (different structure)\n    //\n    // Note: AxAIOpenAI's /v1/responses API also supports a 'developer' role that isn't\n    // currently mapped from our AxChatPromptItemType structure.\n\n    const items: Mutable<AxAIOpenAIResponsesInputItem>[] = [];\n    for (const msg of chatPrompt) {\n      if (excludeSystemMessages && msg.role === 'system') {\n        continue; // Skip system messages if they are handled by top-level 'instructions'\n      }\n\n      let mappedContent:\n        | string\n        | ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n      // Type guard for content based on role\n      if (\n        msg.role === 'system' ||\n        msg.role === 'user' ||\n        (msg.role === 'assistant' && msg.content)\n      ) {\n        if (typeof msg.content === 'string') {\n          mappedContent = msg.content;\n        } else if (Array.isArray(msg.content)) {\n          // Only for user role typically\n          mappedContent = this.mapInternalContentToResponsesInput(\n            msg.content as ReadonlyArray<UserMessageContentItem>\n          );\n        } else {\n          // Handle cases where content might be undefined for assistant, or unexpected type\n          if (msg.role === 'assistant' && !msg.content && msg.functionCalls) {\n            // This is fine, assistant message can be just functionCalls\n          } else {\n            throw new Error(`Invalid content type for role ${msg.role}`);\n          }\n          mappedContent = ''; // Default or skip\n        }\n      } else if (msg.role === 'function') {\n        // Function role does not have 'content' in the same way, it has 'result'\n        mappedContent = ''; // Placeholder, not directly used for content field in function_call_output\n      } else {\n        mappedContent = ''; // Default for roles that might not have content or are handled differently\n      }\n\n      switch (msg.role) {\n        case 'system': // Will be skipped if excludeSystemMessages is true\n          items.push({\n            type: 'message',\n            role: 'system',\n            content: mappedContent as string,\n          });\n          break;\n        case 'user':\n          items.push({\n            type: 'message',\n            role: 'user',\n            content: mappedContent,\n            name: msg.name,\n          });\n          break;\n        case 'assistant':\n          if (msg.content || msg.functionCalls) {\n            // Assistant can have content, functionCalls, or both\n            const assistantMessage: Mutable<AxAIOpenAIResponsesInputMessageItem> =\n              {\n                type: 'message',\n                role: 'assistant',\n                content: '',\n              }; // Start with empty content\n            if (msg.content) {\n              assistantMessage.content = mappedContent;\n            }\n            if (msg.name) {\n              assistantMessage.name = msg.name;\n            }\n            // If only function calls, content might remain empty or not be applicable in the same way for AxAIOpenAI item\n            // AxAIOpenAI /v1/responses expects assistant messages with tool calls to be structured carefully.\n            // For now, pushing the textual content if present. Tool calls are separate items.\n            if (msg.content)\n              items.push(\n                assistantMessage as AxAIOpenAIResponsesInputMessageItem\n              );\n\n            if (msg.functionCalls) {\n              for (const call of msg.functionCalls) {\n                items.push({\n                  type: 'function_call',\n                  call_id: call.id,\n                  name: call.function.name,\n                  arguments:\n                    typeof call.function.params === 'object'\n                      ? JSON.stringify(call.function.params)\n                      : call.function.params || '',\n                });\n              }\n            }\n          }\n          break;\n        case 'function': // This is a tool result\n          items.push({\n            type: 'function_call_output',\n            call_id: msg.functionId!,\n            output: msg.result!,\n          });\n          break;\n        default: {\n          // Fix for any type\n          const invalidRole = (msg as { role: string }).role;\n          throw new Error(`Invalid role in chat prompt: ${invalidRole}`);\n        }\n      }\n    }\n    return items as ReadonlyArray<AxAIOpenAIResponsesInputItem>;\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<TModel>>,\n    config: Readonly<AxAIPromptConfig>\n  ): [Readonly<AxAPI>, Readonly<AxAIOpenAIResponsesRequest<TModel>>] {\n    const model = req.model;\n    const apiConfig: Readonly<AxAPI> = { name: '/responses' };\n\n    let instructionsFromPrompt: string | null = null;\n    let systemMessageFoundAndUsed = false;\n    if (req.chatPrompt) {\n      for (const item of req.chatPrompt) {\n        if (item.role === 'system' && typeof item.content === 'string') {\n          instructionsFromPrompt = item.content;\n          systemMessageFoundAndUsed = true;\n          break;\n        }\n      }\n    }\n\n    const finalInstructions =\n      instructionsFromPrompt ?? this.config.systemPrompt ?? null;\n\n    const tools: ReadonlyArray<AxAIOpenAIResponsesToolDefinition> | undefined =\n      req.functions?.map(\n        (\n          v: Readonly<RequestFunctionDefinition>\n        ): AxAIOpenAIResponsesDefineFunctionTool => ({\n          type: 'function' as const,\n          name: v.name,\n          description: v.description,\n          parameters: v.parameters ?? {},\n        })\n      );\n\n    // Set include field based on showThoughts option, but override if thinkingTokenBudget is 'none'\n    const includeFields: // | 'file_search_call.results'\n    'message.input_image.image_url'[] =\n      // | 'computer_call_output.output.image_url'\n      // | 'reasoning.encrypted_content'\n      // | 'code_interpreter_call.outputs'\n      [];\n\n    const isThinkingModel = isOpenAIResponsesThinkingModel(model as string);\n\n    let reasoningSummary = this.config.reasoningSummary;\n\n    if (!config?.showThoughts) {\n      reasoningSummary = undefined;\n    } else if (!reasoningSummary) {\n      reasoningSummary = 'auto';\n    }\n\n    let reasoningEffort = this.config.reasoningEffort;\n\n    // Handle thinkingTokenBudget config parameter\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          reasoningEffort = undefined;\n          break;\n        case 'minimal':\n          reasoningEffort = 'low';\n          break;\n        case 'low':\n          reasoningEffort = 'medium';\n          break;\n        case 'medium':\n        case 'high':\n        case 'highest':\n          reasoningEffort = 'high';\n          break;\n      }\n    }\n\n    const mutableReq: Mutable<AxAIOpenAIResponsesRequest<TModel>> = {\n      model,\n      input: '', // Will be set below\n      instructions: finalInstructions,\n      tools: tools?.length ? tools : undefined,\n      tool_choice:\n        req.functionCall === 'none' ||\n        req.functionCall === 'auto' ||\n        req.functionCall === 'required'\n          ? req.functionCall\n          : typeof req.functionCall === 'object' && req.functionCall.function\n            ? { type: 'function', name: req.functionCall.function.name }\n            : undefined,\n      // For thinking models, don't set these parameters as they're not supported\n      ...(isThinkingModel\n        ? {\n            max_output_tokens:\n              req.modelConfig?.maxTokens ?? this.config.maxTokens ?? undefined,\n          }\n        : {\n            temperature:\n              req.modelConfig?.temperature ??\n              this.config.temperature ??\n              undefined,\n            top_p: req.modelConfig?.topP ?? this.config.topP ?? undefined,\n            presence_penalty:\n              req.modelConfig?.presencePenalty ??\n              this.config.presencePenalty ??\n              undefined,\n            frequency_penalty:\n              req.modelConfig?.frequencyPenalty ??\n              this.config.frequencyPenalty ??\n              undefined,\n          }),\n      stream: req.modelConfig?.stream ?? this.config.stream ?? false, // Sourced from modelConfig or global config\n      // Optional fields from AxAIOpenAIResponsesRequest that need to be in Mutable for initialization\n      background: undefined,\n      include: includeFields.length > 0 ? includeFields : undefined,\n      metadata: undefined,\n      parallel_tool_calls: this.config.parallelToolCalls,\n      previous_response_id: undefined,\n      ...(reasoningEffort\n        ? {\n            reasoning: {\n              effort: reasoningEffort,\n              summary: reasoningSummary,\n            },\n          }\n        : {}),\n      service_tier: this.config.serviceTier,\n      store: this.config.store,\n      text: undefined,\n      truncation: undefined,\n      user: this.config.user,\n      seed: this.config.seed,\n    };\n\n    // Populate from this.config if properties exist on AxAIOpenAIConfig\n    if (this.config.user) mutableReq.user = this.config.user;\n    if (this.config.parallelToolCalls !== undefined)\n      mutableReq.parallel_tool_calls = this.config.parallelToolCalls;\n    if (this.config.responseFormat)\n      mutableReq.text = {\n        format: {\n          type: this.config.responseFormat as\n            | 'text'\n            | 'json_object'\n            | 'json_schema',\n        },\n      };\n    if (this.config.seed) mutableReq.seed = this.config.seed;\n    // TODO: Check AxAIOpenAIConfig for other fields like store, background, include, metadata, service_tier, truncation\n\n    const inputItems = req.chatPrompt\n      ? this.createResponsesReqInternalInput(\n          req.chatPrompt,\n          systemMessageFoundAndUsed\n        )\n      : [];\n\n    if (inputItems.length > 0) {\n      mutableReq.input = inputItems;\n    } else if (\n      req.chatPrompt &&\n      req.chatPrompt.length === 1 &&\n      req.chatPrompt[0]?.role === 'user' &&\n      req.chatPrompt[0]?.content &&\n      typeof req.chatPrompt[0].content === 'string' &&\n      !finalInstructions\n    ) {\n      // Fallback to simple string input if only one user message and no instructions\n      mutableReq.input = req.chatPrompt[0].content;\n    } else if (inputItems.length === 0 && !finalInstructions) {\n      throw new Error('Responses API request must have input or instructions.');\n    }\n\n    let currentReasoning = mutableReq.reasoning ?? {};\n    if (this.config.reasoningEffort) {\n      currentReasoning = {\n        ...currentReasoning,\n        effort: this.config.reasoningEffort,\n      };\n    }\n\n    // Handle thinkingTokenBudget config parameter\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          // When thinkingTokenBudget is 'none', remove reasoning entirely\n          currentReasoning = {};\n          break;\n        case 'minimal':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'low',\n          };\n          break;\n        case 'low':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'medium',\n          };\n          break;\n        case 'medium':\n        case 'high':\n        case 'highest':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'high',\n          };\n          break;\n      }\n    }\n\n    if (Object.keys(currentReasoning).length > 0 && currentReasoning.effort) {\n      mutableReq.reasoning = currentReasoning;\n    } else {\n      mutableReq.reasoning = undefined; // Ensure reasoning is not sent if empty or only has non-effort keys by mistake\n    }\n\n    let finalReqToProcess: Readonly<AxAIOpenAIResponsesRequest<TModel>> =\n      mutableReq as Readonly<AxAIOpenAIResponsesRequest<TModel>>;\n\n    if (this.responsesReqUpdater) {\n      finalReqToProcess = this.responsesReqUpdater(\n        finalReqToProcess as Readonly<TResponsesReq>\n      );\n    }\n\n    return [apiConfig, finalReqToProcess];\n  }\n\n  // Create Chat Response from /v1/responses (non-streaming)\n  createChatResp(\n    resp: Readonly<AxAIOpenAIResponsesResponse>\n  ): Readonly<AxChatResponse> {\n    const { id, output, usage } = resp;\n\n    if (usage) {\n      this.tokensUsed = {\n        promptTokens: usage.prompt_tokens,\n        completionTokens: usage.completion_tokens,\n        totalTokens: usage.total_tokens,\n      };\n    }\n\n    const currentResult: Partial<AxChatResponseResult> = {};\n\n    for (const item of output ?? []) {\n      switch (item.type) {\n        case 'message':\n          currentResult.id = item.id;\n          currentResult.content = contentToText(item.content, id);\n          currentResult.finishReason =\n            item.status === 'completed' ? 'stop' : 'content_filter';\n          break;\n\n        case 'reasoning':\n          currentResult.id = item.id;\n          // Use encrypted_content if available (when showThoughts is enabled), otherwise use summary\n          if (item.encrypted_content) {\n            currentResult.thought = item.encrypted_content;\n          } else {\n            currentResult.thought = item.summary\n              .map((s: string | object) =>\n                typeof s === 'object' ? JSON.stringify(s) : s\n              )\n              .join('\\n');\n          }\n          break;\n\n        case 'file_search_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'file_search',\n                params: {\n                  queries: item.queries,\n                  results: item.results,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'web_search_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'web_search',\n                params: {\n                  queries: item.queries,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'computer_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'computer_use',\n                params: {\n                  action: item.action,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'code_interpreter_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'code_interpreter',\n                params: {\n                  code: item.code,\n                  results: item.results,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'image_generation_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'image_generation',\n                params: {\n                  result: item.result,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'local_shell_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'local_shell',\n                params: {\n                  action: item.action,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'mcp_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'mcp',\n                params: {\n                  name: item.name,\n                  args: item.args,\n                  serverLabel: item.server_label,\n                  output: item.output,\n                  error: item.error,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'function_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: item.name,\n                params: item.arguments,\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n      }\n    }\n\n    return {\n      results: [{ ...currentResult, index: 0 }],\n      remoteId: id,\n    };\n  }\n\n  // Create Chat Stream Response from /v1/responses stream events\n  createChatStreamResp(\n    streamEvent: Readonly<AxAIOpenAIResponsesResponseDelta>\n  ): Readonly<AxChatResponse> {\n    // Handle new streaming event format\n    const event = streamEvent as AxAIOpenAIResponsesStreamEvent;\n\n    // Create a basic result structure\n    const baseResult: AxChatResponseResult = {\n      index: 0,\n      id: '',\n      content: '',\n      finishReason: 'stop',\n    };\n\n    let remoteId: string | undefined;\n\n    switch (event.type) {\n      case 'response.created':\n      case 'response.in_progress':\n      case 'response.queued':\n        // Response lifecycle events - return empty content with metadata\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_res_0`;\n        break;\n\n      case 'response.output_item.added':\n        // New output item added\n        switch (event.item.type) {\n          case 'message':\n            baseResult.id = event.item.id;\n            baseResult.content = contentToText(\n              event.item.content,\n              event.item.id\n            );\n            break;\n          case 'function_call':\n            baseResult.id = event.item.id;\n            baseResult.functionCalls = [\n              {\n                id: event.item.id,\n                type: 'function' as const,\n                function: {\n                  name: event.item.name,\n                  params: event.item.arguments,\n                },\n              },\n            ];\n            break;\n          case 'file_search_call':\n            {\n              const fileSearchItem =\n                event.item as AxAIOpenAIResponsesFileSearchToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: fileSearchItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'file_search',\n                    params: {\n                      queries: fileSearchItem.queries || [],\n                      results: fileSearchItem.results?.map((r) => ({\n                        fileId: r.file_id,\n                        filename: r.filename,\n                        score: r.score,\n                        text: r.text,\n                        attributes: r.attributes,\n                      })),\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'web_search_call':\n            {\n              const webSearchItem =\n                event.item as AxAIOpenAIResponsesWebSearchToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: webSearchItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'web_search',\n                    params: {\n                      queries: webSearchItem.queries || [],\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'computer_call':\n            {\n              const computerItem =\n                event.item as AxAIOpenAIResponsesComputerToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: computerItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'computer_use',\n                    params: {\n                      action: computerItem.action || {},\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'code_interpreter_call':\n            {\n              const codeItem =\n                event.item as AxAIOpenAIResponsesCodeInterpreterToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: codeItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'code_interpreter',\n                    params: {\n                      code: codeItem.code || '',\n                      results: codeItem.results,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'image_generation_call':\n            {\n              const imageItem =\n                event.item as AxAIOpenAIResponsesImageGenerationToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: imageItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'image_generation',\n                    params: {\n                      result: imageItem.result,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'local_shell_call':\n            {\n              const shellItem =\n                event.item as AxAIOpenAIResponsesLocalShellToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: shellItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'local_shell',\n                    params: {\n                      action: shellItem.action || {},\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'mcp_call':\n            {\n              const mcpItem = event.item as AxAIOpenAIResponsesMCPToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: mcpItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'mcp',\n                    params: {\n                      name: mcpItem.name || '',\n                      args: mcpItem.args || '',\n                      serverLabel: mcpItem.server_label || '',\n                      output: mcpItem.output,\n                      error: mcpItem.error,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          // case 'reasoning':\n          //     {\n          //         const reasoningItem =\n          //             event.item as AxAIOpenAIResponsesReasoningItem\n          //         baseResult.id = event.item.id\n          //         // Use encrypted_content if available (when showThoughts is enabled), otherwise use summary\n          //         if (reasoningItem.encrypted_content) {\n          //             baseResult.thought = reasoningItem.encrypted_content\n          //         } else if (reasoningItem.summary) {\n          //             baseResult.thought = reasoningItem.summary\n          //                 .map((s: string | object) =>\n          //                     typeof s === 'object' ? JSON.stringify(s) : s\n          //                 )\n          //                 .join('\\n')\n          //         }\n          //     }\n          //     break\n        }\n        break;\n\n      case 'response.content_part.added':\n        // Content part added - return the initial text if any\n        baseResult.id = event.item_id;\n        baseResult.content = contentToText([event.part], event.item_id);\n        break;\n\n      case 'response.output_text.delta':\n        // Text delta - return just the delta content\n        baseResult.id = event.item_id;\n        baseResult.content = event.delta;\n        break;\n\n      case 'response.output_text.done':\n        break;\n\n      case 'response.function_call_arguments.delta':\n        // Function call arguments delta - return delta with empty name\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.delta,\n            },\n          },\n        ];\n        break;\n\n      // case 'response.function_call_arguments.done':\n      //     // Function call arguments done - don't return function calls here\n      //     // The mergeFunctionCalls will handle combining name and arguments\n      //     baseResult.id = event.item_id\n      //     baseResult.finishReason = 'function_call'\n      //     break\n\n      case 'response.reasoning_summary_text.delta':\n        // Reasoning summary delta\n        baseResult.id = event.item_id;\n        baseResult.thought = event.delta;\n        break;\n\n      // case 'response.reasoning_summary_text.done':\n      //     // Reasoning summary done\n      //     baseResult.id = event.item_id\n      //     baseResult.thought = event.text\n      //     break\n\n      // File search tool events\n      case 'response.file_search_call.in_progress':\n      case 'response.file_search_call.searching':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.file_search_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      // Web search tool events\n      case 'response.web_search_call.in_progress':\n      case 'response.web_search_call.searching':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.web_search_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      // Image generation tool events\n      case 'response.image_generation_call.in_progress':\n      case 'response.image_generation_call.generating':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.image_generation_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.image_generation_call.partial_image':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        // Could potentially add partial image data to content or a special field\n        break;\n\n      // MCP tool events\n      case 'response.mcp_call.in_progress':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.mcp_call.arguments.delta':\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.delta,\n            },\n          },\n        ];\n        break;\n\n      case 'response.mcp_call.arguments.done':\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.arguments,\n            },\n          },\n        ];\n        break;\n\n      case 'response.mcp_call.completed':\n      case 'response.mcp_call.failed':\n        // These events don't have item_id, use a generic ID\n        baseResult.id = 'mcp_call_event';\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.mcp_list_tools.in_progress':\n      case 'response.mcp_list_tools.completed':\n      case 'response.mcp_list_tools.failed':\n        // MCP list tools events don't have item_id\n        baseResult.id = 'mcp_list_tools_event';\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.output_item.done':\n        // Item completion\n\n        switch (event.item.type) {\n          case 'message':\n            baseResult.id = event.item.id;\n            baseResult.finishReason =\n              event.item.status === 'completed' ? 'stop' : 'error';\n            break;\n          case 'function_call':\n          case 'file_search_call':\n          case 'web_search_call':\n          case 'computer_call':\n          case 'code_interpreter_call':\n          case 'image_generation_call':\n          case 'local_shell_call':\n          case 'mcp_call':\n            // Tool calls completed - finishReason indicates function execution needed\n            baseResult.id = event.item.id;\n            baseResult.finishReason = 'function_call';\n            break;\n          // case 'reasoning':\n          //     // Reasoning completed\n          //     baseResult.id = event.item.id\n          //     break\n        }\n        break;\n\n      case 'response.completed':\n        // Response completion - handle usage\n        if (event.response.usage) {\n          this.tokensUsed = {\n            promptTokens: event.response.usage.prompt_tokens,\n            completionTokens: event.response.usage.completion_tokens,\n            totalTokens: event.response.usage.total_tokens,\n          };\n        }\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_completed`;\n        baseResult.finishReason = 'stop';\n        break;\n\n      case 'response.failed':\n        // Response failure\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_failed`;\n        baseResult.finishReason = 'error';\n        break;\n\n      case 'response.incomplete':\n        // Response incomplete\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_incomplete`;\n        baseResult.finishReason = 'length';\n        break;\n\n      case 'error':\n        // Error event\n        baseResult.id = 'error';\n        baseResult.content = `Error: ${event.message}`;\n        baseResult.finishReason = 'error';\n        break;\n\n      default:\n        // For unhandled events, return empty result\n        baseResult.id = 'unknown';\n        break;\n    }\n\n    return {\n      results: [baseResult],\n      remoteId,\n    } as Readonly<AxChatResponse>;\n  }\n\n  createEmbedReq(\n    req: Readonly<AxInternalEmbedRequest<TEmbedModel>>\n  ): [AxAPI, AxAIOpenAIEmbedRequest<TEmbedModel>] {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embeddings',\n    };\n\n    const reqValue = {\n      model: model,\n      input: req.texts,\n      dimensions: this.config.dimensions,\n    };\n\n    return [apiConfig, reqValue];\n  }\n}\n\n// const getThought = (item: AxAIOpenAIResponsesReasoningItem): string => {\n//     if (item.encrypted_content) {\n//         return item.encrypted_content\n//     }\n//     return item.summary.map((s) => s.text).join('\\n')\n// }\n\nconst contentToText = (\n  content: ReadonlyArray<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >,\n  responseId?: string\n): string => {\n  // Check for refusal content and throw exception\n  const refusalContent = content.filter((c) => c.type === 'refusal');\n  if (refusalContent.length > 0) {\n    const refusalMessage = refusalContent.map((c) => c.refusal).join('\\n');\n    throw new AxAIRefusalError(refusalMessage, undefined, responseId);\n  }\n\n  // Return only text content\n  return content\n    .filter((c) => c.type === 'output_text')\n    .map((c) => c.text)\n    .join('\\n');\n};\n", "import { getModelInfo } from '@ax-llm/ax/dsp/modelinfo.js';\nimport type { AxAIOpenAIResponsesConfig } from '@ax-llm/ax/index.js';\nimport type { AxAIFeatures } from '../base.js';\nimport { AxBaseAI } from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceOptions,\n  AxModelInfo,\n} from '../types.js';\nimport type {\n  AxAIOpenAIEmbedRequest,\n  AxAIOpenAIEmbedResponse,\n} from './chat_types.js';\nimport { AxAIOpenAIEmbedModel } from './chat_types.js';\nimport { axModelInfoOpenAIResponses } from './info.js';\nimport { AxAIOpenAIResponsesImpl } from './responses_api.js';\nimport type {\n  AxAIOpenAIResponsesRequest,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n} from './responses_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n// Helper functions to create default configurations\nexport const axAIOpenAIResponsesDefaultConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  embedModel: AxAIOpenAIEmbedModel.TextEmbeddingAda002,\n  temperature: 0.7,\n  topP: 1,\n  stream: true,\n  //   reasoningEffort: 'medium',\n});\n\nexport const axAIOpenAIResponsesBestConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIResponsesDefaultConfig(),\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  temperature: 0.5,\n});\n\nexport const axAIOpenAIResponsesCreativeConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIResponsesDefaultConfig(),\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  temperature: 0.9,\n});\n\n// Arguments for AxAIOpenAIResponsesBase constructor\ninterface AxAIOpenAIResponsesBaseArgs<\n  TModel,\n  TEmbedModel,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> {\n  apiKey: string;\n  config: AxAIOpenAIResponsesConfig<TModel, TEmbedModel>;\n  options?: {\n    streamingUsage?: boolean;\n  } & AxAIServiceOptions;\n  apiURL?: string;\n  modelInfo?: ReadonlyArray<AxModelInfo>;\n  models?: AxAIInputModelList<TModel, TEmbedModel>;\n  responsesReqUpdater?: (\n    req: Readonly<TResponsesReq>\n  ) => Readonly<TResponsesReq>;\n  supportFor?: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n}\n\n/**\n * Base class for OpenAI AI services using the /v1/responses API endpoint\n */\nexport class AxAIOpenAIResponsesBase<\n  TModel,\n  TEmbedModel,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> extends AxBaseAI<\n  TModel,\n  TEmbedModel,\n  AxAIOpenAIResponsesRequest<TModel>,\n  AxAIOpenAIEmbedRequest<TEmbedModel>,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n  AxAIOpenAIEmbedResponse\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = [],\n    models,\n    responsesReqUpdater,\n    supportFor = { functions: true, streaming: true },\n  }: Readonly<\n    AxAIOpenAIResponsesBaseArgs<TModel, TEmbedModel, TResponsesReq>\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    const aiImpl = new AxAIOpenAIResponsesImpl<\n      TModel,\n      TEmbedModel,\n      TResponsesReq\n    >(config, options?.streamingUsage ?? true, responsesReqUpdater);\n\n    // Convert models to the expected format if needed\n    const formattedModels = models as\n      | AxAIInputModelList<TModel, TEmbedModel>\n      | undefined;\n\n    super(aiImpl, {\n      name: 'OpenAI',\n      apiURL: apiURL ? apiURL : 'https://api.openai.com/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo,\n      defaults: {\n        model: config.model,\n        embedModel: config.embedModel,\n      },\n      options,\n      supportFor,\n      models: formattedModels,\n    });\n  }\n}\n\n/**\n * Ready-to-use implementation of the OpenAI Responses API client\n * This class uses OpenAI's /v1/responses API endpoint which supports text, image, and audio inputs\n */\n\nexport interface AxAIOpenAIResponsesArgs<\n  TName = 'openai-responses',\n  TModel = AxAIOpenAIResponsesModel,\n  TEmbedModel = AxAIOpenAIEmbedModel,\n  TChatReq extends\n    AxAIOpenAIResponsesRequest<TModel> = AxAIOpenAIResponsesRequest<TModel>,\n> extends Omit<\n    AxAIOpenAIResponsesBaseArgs<TModel, TEmbedModel, TChatReq>,\n    'config' | 'supportFor' | 'modelInfo'\n  > {\n  name: TName;\n  modelInfo?: AxModelInfo[];\n  config?: Partial<\n    AxAIOpenAIResponsesBaseArgs<TModel, TEmbedModel, TChatReq>['config']\n  >;\n}\n\nexport class AxAIOpenAIResponses extends AxAIOpenAIResponsesBase<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIResponsesRequest<AxAIOpenAIResponsesModel>\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIOpenAIResponsesArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    // Use the original OpenAI model info since it contains both chat and embed models\n    modelInfo = [...axModelInfoOpenAIResponses, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIResponsesModel) => {\n      const mi = getModelInfo<AxAIOpenAIResponsesModel, AxAIOpenAIEmbedModel>({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n      };\n    };\n\n    super({\n      apiKey,\n      config: {\n        ...axAIOpenAIResponsesDefaultConfig(),\n        ...config,\n      },\n      options,\n      modelInfo,\n      models,\n      supportFor,\n    });\n  }\n}\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIRekaModel {\n  RekaCore = 'reka-core',\n  RekaFlash = 'reka-flash',\n  RekaEdge = 'reka-edge',\n}\n\nexport type AxAIRekaConfig = Omit<AxModelConfig, 'topK'> & {\n  model: AxAIRekaModel;\n  stop?: readonly string[];\n  useSearchEngine?: boolean;\n};\n\nexport type AxAIRekaUsage = {\n  input_tokens: number;\n  output_tokens: number;\n};\n\nexport type AxAIRekaChatRequest = {\n  model: string;\n  messages: (\n    | {\n        role: 'user';\n        content:\n          | string\n          | {\n              type: 'text';\n              text: string;\n            }[];\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | {\n              type: 'text';\n              text: string;\n            }[];\n      }\n  )[];\n  usage?: AxAIRekaUsage;\n  response_format?: { type: string };\n  max_tokens?: number;\n  temperature?: number;\n  top_p?: number;\n  top_k?: number;\n  stream?: boolean;\n  stop?: readonly string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  use_search_engine?: boolean;\n};\n\nexport type AxAIRekaChatResponse = {\n  id: string;\n  model: string;\n  responses: {\n    message: {\n      content:\n        | string\n        | {\n            type: 'text';\n            text: string;\n          };\n    };\n    finish_reason: 'stop' | 'length' | 'context';\n  }[];\n  usage?: AxAIRekaUsage;\n};\n\nexport type AxAIRekaChatResponseDelta = {\n  id: string;\n  model: string;\n  responses: {\n    chunk: AxAIRekaChatResponse['responses'][0]['message'];\n    finish_reason: AxAIRekaChatResponse['responses'][0]['finish_reason'];\n  }[];\n  usage?: AxAIRekaUsage;\n};\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIRekaModel } from './types.js';\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoReka: AxModelInfo[] = [\n  {\n    name: AxAIRekaModel.RekaCore,\n    currency: 'usd',\n    promptTokenCostPer1M: 3,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIRekaModel.RekaFlash,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2,\n  },\n  {\n    name: AxAIRekaModel.RekaEdge,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1,\n  },\n];\n", "import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIPromptConfig,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoReka } from './info.js';\nimport {\n  type AxAIRekaChatRequest,\n  type AxAIRekaChatResponse,\n  type AxAIRekaChatResponseDelta,\n  type AxAIRekaConfig,\n  AxAIRekaModel,\n} from './types.js';\n\nexport const axAIRekaDefaultConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIRekaBestConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    ...axAIRekaDefaultConfig(),\n    model: AxAIRekaModel.RekaCore,\n  });\n\nexport const axAIRekaCreativeConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport const axAIRekaFastConfig = (): AxAIRekaConfig => ({\n  ...axAIRekaDefaultConfig(),\n  model: AxAIRekaModel.RekaFlash,\n});\n\nexport interface AxAIRekaArgs {\n  name: 'reka';\n  apiKey: string;\n  apiURL?: string;\n  config?: Readonly<Partial<AxAIRekaConfig>>;\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>;\n  modelInfo?: Readonly<AxModelInfo[]>;\n  models?: AxAIInputModelList<AxAIRekaModel, undefined>;\n}\n\nclass AxAIRekaImpl\n  implements\n    AxAIServiceImpl<\n      AxAIRekaModel,\n      undefined,\n      AxAIRekaChatRequest,\n      unknown,\n      AxAIRekaChatResponse,\n      AxAIRekaChatResponseDelta,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAIRekaConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    };\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest<AxAIRekaModel>>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _config: Readonly<AxAIPromptConfig>\n  ): [AxAPI, AxAIRekaChatRequest] => {\n    const model = req.model;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    };\n\n    const messages = createMessages(req);\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;\n\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    const reqValue: AxAIRekaChatRequest = {\n      model,\n      messages,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      top_k: req.modelConfig?.n ?? this.config.n,\n      top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,\n      stop: req.modelConfig?.stopSequences ?? this.config.stop,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      ...(frequencyPenalty ? { frequency_penalty: frequencyPenalty } : {}),\n      ...(stream ? { stream: true } : {}),\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (resp: Readonly<AxAIRekaChatResponse>): AxChatResponse => {\n    const { id, usage, responses } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined;\n\n    const results = responses.map((res, index) => {\n      const finishReason = mapFinishReason(res.finish_reason);\n      let content: string;\n      if (typeof res.message.content === 'string') {\n        content = res.message.content;\n      } else {\n        content = res.message.content.text;\n      }\n\n      return {\n        index,\n        id: `${id}`,\n        content,\n        finishReason,\n      };\n    });\n\n    return { results, remoteId: id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIRekaChatResponseDelta>\n  ): AxChatResponse => {\n    const { id, usage, responses } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined;\n\n    const results = responses.map((res, index) => {\n      const finishReason = mapFinishReason(res.finish_reason);\n      let content: string;\n      if (typeof res.chunk.content === 'string') {\n        content = res.chunk.content;\n      } else {\n        content = res.chunk.content.text;\n      }\n\n      return {\n        index,\n        id: `${id}`,\n        content,\n        finishReason,\n      };\n    });\n\n    return { results };\n  };\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIRekaChatResponse['responses'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const;\n    case 'context':\n      return 'length' as const;\n    case 'length':\n      return 'length' as const;\n  }\n};\n\nfunction createMessages(\n  req: Readonly<AxChatRequest>\n): AxAIRekaChatRequest['messages'] {\n  return req.chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return { role: 'user' as const, content: msg.content };\n\n      case 'user':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'user' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  throw new Error('Image type not supported');\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            }),\n          };\n        }\n        return { role: 'user' as const, content: msg.content };\n\n      case 'assistant':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'assistant' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  throw new Error('Image type not supported');\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            }),\n          };\n        }\n        if (!msg.content) {\n          throw new Error('Assistant content is empty');\n        }\n        return { role: 'user' as const, content: msg.content };\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n}\n\nexport class AxAIReka extends AxBaseAI<\n  AxAIRekaModel,\n  undefined,\n  AxAIRekaChatRequest,\n  unknown,\n  AxAIRekaChatResponse,\n  AxAIRekaChatResponseDelta,\n  unknown\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = axModelInfoReka,\n    models,\n  }: Readonly<Omit<AxAIRekaArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Reka API key not set');\n    }\n    const Config = {\n      ...axAIRekaDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIRekaImpl(Config);\n\n    super(aiImpl, {\n      name: 'Reka',\n      apiURL: apiURL ? apiURL : 'https://api.reka.ai/v1/chat',\n      headers: async () => ({ 'X-Api-Key': apiKey }),\n      modelInfo,\n      defaults: {\n        model: Config.model,\n      },\n      options,\n      supportFor: { functions: true, streaming: true },\n      models,\n    });\n  }\n}\n", "import type { AxModelInfo } from '../types.js';\n\nexport const axModelInfoTogether: AxModelInfo[] = [];\n", "import { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nimport { axModelInfoTogether } from './info.js';\n\ntype TogetherAIConfig = AxAIOpenAIConfig<string, unknown>;\n\nexport const axAITogetherDefaultConfig = (): TogetherAIConfig =>\n  structuredClone({\n    // cspell:disable-next-line\n    model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport type AxAITogetherArgs = AxAIOpenAIArgs<'together', string, unknown>;\n\nexport class AxAITogether extends AxAIOpenAIBase<string, unknown> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAITogetherArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Together API key not set');\n    }\n    const Config = {\n      ...axAITogetherDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoTogether, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.together.xyz/v1',\n      modelInfo,\n      models,\n      supportFor,\n    });\n\n    super.setName('Together');\n  }\n}\n", "import type { AxChatRequest, AxChatResponseResult } from './types.js';\n\ntype AxChatRequestMessage = AxChatRequest['chatPrompt'][number];\n\n/**\n * Validates a chat request message item to ensure it meets the required criteria\n * @param item - The chat request message to validate\n * @throws {Error} When validation fails with a descriptive error message\n */\nexport function axValidateChatRequestMessage(item: AxChatRequestMessage): void {\n  const value = (v: unknown) => JSON.stringify(v, null, 2);\n\n  if (!item) {\n    throw new Error(\n      `Chat request message item cannot be null or undefined, received: ${value(item)}`\n    );\n  }\n\n  const role = (item as { role?: string })?.role;\n  if (!role) {\n    throw new Error(\n      `Chat request message must have a role, received: ${value(role)}`\n    );\n  }\n\n  switch (role) {\n    case 'system': {\n      const systemItem = item as { role: 'system'; content: string };\n      if (!systemItem.content || systemItem.content.trim() === '') {\n        throw new Error(\n          `System message content cannot be empty or whitespace-only, received: ${value(systemItem.content)}`\n        );\n      }\n      break;\n    }\n\n    case 'user': {\n      const userItem = item as { role: 'user'; content: string | object[] };\n      if (!userItem.content) {\n        throw new Error(\n          `User message content cannot be undefined, received: ${value(userItem.content)}`\n        );\n      }\n\n      if (typeof userItem.content === 'string') {\n        if (userItem.content.trim() === '') {\n          throw new Error(\n            `User message content cannot be empty or whitespace-only, received: ${value(userItem.content)}`\n          );\n        }\n      } else if (Array.isArray(userItem.content)) {\n        if (userItem.content.length === 0) {\n          throw new Error(\n            `User message content array cannot be empty, received: ${value(userItem.content)}`\n          );\n        }\n\n        for (let index = 0; index < userItem.content.length; index++) {\n          const contentItem = userItem.content[index];\n          if (!contentItem || typeof contentItem !== 'object') {\n            throw new Error(\n              `User message content item at index ${index} must be an object, received: ${value(contentItem)}`\n            );\n          }\n\n          const contentType = (contentItem as { type?: string })?.type;\n          if (!contentType) {\n            throw new Error(\n              `User message content item at index ${index} must have a type, received: ${value(contentType)}`\n            );\n          }\n\n          switch (contentType) {\n            case 'text': {\n              const textItem = contentItem as { type: 'text'; text: string };\n              if (!textItem.text || textItem.text.trim() === '') {\n                throw new Error(\n                  `User message text content at index ${index} cannot be empty or whitespace-only, received: ${value(textItem.text)}`\n                );\n              }\n              break;\n            }\n            case 'image': {\n              const imageItem = contentItem as {\n                type: 'image';\n                image: string;\n                mimeType: string;\n              };\n              if (!imageItem.image || imageItem.image.trim() === '') {\n                throw new Error(\n                  `User message image content at index ${index} cannot be empty, received: ${value(imageItem.image)}`\n                );\n              }\n              if (!imageItem.mimeType || imageItem.mimeType.trim() === '') {\n                throw new Error(\n                  `User message image content at index ${index} must have a mimeType, received: ${value(imageItem.mimeType)}`\n                );\n              }\n              break;\n            }\n            case 'audio': {\n              const audioItem = contentItem as { type: 'audio'; data: string };\n              if (!audioItem.data || audioItem.data.trim() === '') {\n                throw new Error(\n                  `User message audio content at index ${index} cannot be empty, received: ${value(audioItem.data)}`\n                );\n              }\n              break;\n            }\n            default:\n              throw new Error(\n                `User message content item at index ${index} has unsupported type: ${value(contentType)}`\n              );\n          }\n        }\n      } else {\n        throw new Error(\n          `User message content must be a string or array of content objects, received: ${value(userItem.content)}`\n        );\n      }\n      break;\n    }\n\n    case 'assistant': {\n      const assistantItem = item as {\n        role: 'assistant';\n        content?: string;\n        functionCalls?: object[];\n      };\n      // Assistant messages can have empty content if they have function calls\n      if (!assistantItem.content && !assistantItem.functionCalls) {\n        throw new Error(\n          `Assistant message must have either content or function calls, received content: ${value(assistantItem.content)}, functionCalls: ${value(assistantItem.functionCalls)}`\n        );\n      }\n\n      if (assistantItem.content && typeof assistantItem.content !== 'string') {\n        throw new Error(\n          `Assistant message content must be a string, received: ${value(assistantItem.content)}`\n        );\n      }\n\n      if (\n        assistantItem.functionCalls &&\n        !Array.isArray(assistantItem.functionCalls)\n      ) {\n        throw new Error(\n          `Assistant message function calls must be an array, received: ${value(assistantItem.functionCalls)}`\n        );\n      }\n      break;\n    }\n\n    case 'function': {\n      const functionItem = item as {\n        role: 'function';\n        functionId: string;\n        result: string;\n      };\n      if (!functionItem.functionId || functionItem.functionId.trim() === '') {\n        throw new Error(\n          `Function message must have a non-empty functionId, received: ${value(functionItem.functionId)}`\n        );\n      }\n\n      if (functionItem.result === undefined || functionItem.result === null) {\n        throw new Error(\n          `Function message must have a result, received: ${value(functionItem.result)}`\n        );\n      }\n\n      if (typeof functionItem.result !== 'string') {\n        throw new Error(\n          `Function message result must be a string, received: ${value(functionItem.result)}`\n        );\n      }\n      break;\n    }\n\n    default:\n      throw new Error(`Unsupported message role: ${value(role)}`);\n  }\n}\n\n/**\n * Validates a chat response result to ensure it meets the required criteria\n * @param results - The chat response results to validate (single result or array)\n * @throws {Error} When validation fails with a descriptive error message\n */\nexport function axValidateChatResponseResult(\n  results: Readonly<AxChatResponseResult[]> | Readonly<AxChatResponseResult>\n): void {\n  const value = (v: unknown) => JSON.stringify(v, null, 2);\n  const resultsArray = Array.isArray(results) ? results : [results];\n\n  if (resultsArray.length === 0) {\n    throw new Error(\n      `Chat response results cannot be empty, received: ${value(resultsArray)}`\n    );\n  }\n\n  for (let arrayIndex = 0; arrayIndex < resultsArray.length; arrayIndex++) {\n    const result = resultsArray[arrayIndex];\n    if (!result) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} cannot be null or undefined, received: ${value(result)}`\n      );\n    }\n\n    // Validate index\n    if (typeof result.index !== 'number') {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have a numeric index, received: ${value(result.index)}`\n      );\n    }\n\n    if (result.index < 0) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have a non-negative index, received: ${value(result.index)}`\n      );\n    }\n\n    // Validate that at least one meaningful field is present\n    if (\n      !result.content &&\n      !result.thought &&\n      !result.functionCalls &&\n      !result.finishReason\n    ) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have at least one of: content, thought, functionCalls, or finishReason, received: ${value({ content: result.content, thought: result.thought, functionCalls: result.functionCalls, finishReason: result.finishReason })}`\n      );\n    }\n\n    // Validate content if present\n    if (result.content !== undefined && typeof result.content !== 'string') {\n      throw new Error(\n        `Chat response result content at index ${arrayIndex} must be a string, received: ${value(result.content)}`\n      );\n    }\n\n    // Validate thought if present\n    if (result.thought !== undefined && typeof result.thought !== 'string') {\n      throw new Error(\n        `Chat response result thought at index ${arrayIndex} must be a string, received: ${value(result.thought)}`\n      );\n    }\n\n    // Validate name if present\n    if (result.name !== undefined) {\n      if (typeof result.name !== 'string') {\n        throw new Error(\n          `Chat response result name at index ${arrayIndex} must be a string, received: ${value(result.name)}`\n        );\n      }\n      if (result.name.trim() === '') {\n        throw new Error(\n          `Chat response result name at index ${arrayIndex} cannot be empty or whitespace-only, received: ${value(result.name)}`\n        );\n      }\n    }\n\n    // Validate annotations if present\n    if (result.annotations !== undefined) {\n      if (!Array.isArray(result.annotations)) {\n        throw new Error(\n          `Chat response result annotations at index ${arrayIndex} must be an array, received: ${value(result.annotations)}`\n        );\n      }\n      for (let i = 0; i < result.annotations.length; i++) {\n        const annotation = result.annotations[i];\n        if (!annotation || typeof annotation !== 'object') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must be an object, received: ${value(annotation)}`\n          );\n        }\n        if (annotation.type !== 'url_citation') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must have type 'url_citation', received: ${value(annotation.type)}`\n          );\n        }\n        if (\n          !annotation.url_citation ||\n          typeof annotation.url_citation !== 'object'\n        ) {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must have a valid url_citation object, received: ${value(annotation.url_citation)}`\n          );\n        }\n        if (typeof annotation.url_citation.url !== 'string') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] url_citation.url must be a string, received: ${value(annotation.url_citation.url)}`\n          );\n        }\n      }\n    }\n\n    // Validate id if present\n    if (result.id !== undefined) {\n      if (typeof result.id !== 'string') {\n        throw new Error(\n          `Chat response result id at index ${arrayIndex} must be a string, received: ${value(result.id)}`\n        );\n      }\n      if (result.id.trim() === '') {\n        throw new Error(\n          `Chat response result id at index ${arrayIndex} cannot be empty or whitespace-only, received: ${value(result.id)}`\n        );\n      }\n    }\n\n    // Validate functionCalls if present\n    if (result.functionCalls !== undefined) {\n      if (!Array.isArray(result.functionCalls)) {\n        throw new Error(\n          `Chat response result functionCalls at index ${arrayIndex} must be an array, received: ${value(result.functionCalls)}`\n        );\n      }\n\n      for (\n        let callIndex = 0;\n        callIndex < result.functionCalls.length;\n        callIndex++\n      ) {\n        const functionCall = result.functionCalls[callIndex];\n        if (!functionCall) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} cannot be null or undefined, received: ${value(functionCall)}`\n          );\n        }\n\n        if (\n          !functionCall.id ||\n          typeof functionCall.id !== 'string' ||\n          functionCall.id.trim() === ''\n        ) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a non-empty string id, received: ${value(functionCall.id)}`\n          );\n        }\n\n        if (functionCall.type !== 'function') {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have type 'function', received: ${value(functionCall.type)}`\n          );\n        }\n\n        if (!functionCall.function) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a function object, received: ${value(functionCall.function)}`\n          );\n        }\n\n        if (\n          !functionCall.function.name ||\n          typeof functionCall.function.name !== 'string' ||\n          functionCall.function.name.trim() === ''\n        ) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a non-empty function name, received: ${value(functionCall.function.name)}`\n          );\n        }\n\n        if (functionCall.function.params !== undefined) {\n          if (\n            typeof functionCall.function.params !== 'string' &&\n            typeof functionCall.function.params !== 'object'\n          ) {\n            throw new Error(\n              `Function call params at index ${callIndex} in result ${arrayIndex} must be a string or object, received: ${value(functionCall.function.params)}`\n            );\n          }\n        }\n      }\n    }\n\n    // Validate finishReason if present\n    if (result.finishReason !== undefined) {\n      const validFinishReasons = [\n        'stop',\n        'length',\n        'function_call',\n        'content_filter',\n        'error',\n      ];\n      if (!validFinishReasons.includes(result.finishReason)) {\n        throw new Error(\n          `Chat response result finishReason at index ${arrayIndex} must be one of: ${validFinishReasons.join(', ')}, received: ${value(result.finishReason)}`\n        );\n      }\n    }\n  }\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport { AxAIAnthropic, type AxAIAnthropicArgs } from './anthropic/api.js';\nimport type { AxAIAnthropicModel } from './anthropic/types.js';\nimport {\n  AxAIAzureOpenAI,\n  type AxAIAzureOpenAIArgs,\n} from './azure-openai/api.js';\nimport { AxAICohere, type AxAICohereArgs } from './cohere/api.js';\nimport type { AxAICohereEmbedModel, AxAICohereModel } from './cohere/types.js';\nimport { AxAIDeepSeek, type AxAIDeepSeekArgs } from './deepseek/api.js';\nimport type { AxAIDeepSeekModel } from './deepseek/types.js';\nimport {\n  AxAIGoogleGemini,\n  type AxAIGoogleGeminiArgs,\n} from './google-gemini/api.js';\nimport type {\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiModel,\n} from './google-gemini/types.js';\nimport { AxAIGroq, type AxAIGroqArgs } from './groq/api.js';\nimport type { AxAIGroqModel } from './groq/types.js';\nimport {\n  AxAIHuggingFace,\n  type AxAIHuggingFaceArgs,\n} from './huggingface/api.js';\nimport type { AxAIHuggingFaceModel } from './huggingface/types.js';\nimport { AxAIMistral, type AxAIMistralArgs } from './mistral/api.js';\nimport type { AxAIMistralModel } from './mistral/types.js';\nimport { AxAIOllama, type AxAIOllamaArgs } from './ollama/api.js';\nimport { AxAIOpenAI, type AxAIOpenAIArgs } from './openai/api.js';\nimport type {\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIModel,\n} from './openai/chat_types.js';\nimport {\n  AxAIOpenAIResponses,\n  type AxAIOpenAIResponsesArgs,\n} from './openai/responses_api_base.js';\nimport { AxAIReka, type AxAIRekaArgs } from './reka/api.js';\nimport { AxAITogether, type AxAITogetherArgs } from './together/api.js';\nimport type {\n  AxAIModelList,\n  AxAIPromptConfig,\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n} from './types.js';\n\nexport type AxAIArgs =\n  | AxAIOpenAIArgs\n  | AxAIOpenAIResponsesArgs\n  | AxAIAzureOpenAIArgs\n  | AxAITogetherArgs\n  | AxAIAnthropicArgs\n  | AxAIGroqArgs\n  | AxAIGoogleGeminiArgs\n  | AxAICohereArgs\n  | AxAIHuggingFaceArgs\n  | AxAIMistralArgs\n  | AxAIDeepSeekArgs\n  | AxAIOllamaArgs\n  | AxAIRekaArgs;\n\nexport type AxAIModels =\n  | AxAIOpenAIModel\n  | AxAIAnthropicModel\n  | AxAIGroqModel\n  | AxAIGoogleGeminiModel\n  | AxAICohereModel\n  | AxAIHuggingFaceModel\n  | AxAIMistralModel\n  | AxAIDeepSeekModel;\n\nexport type AxAIEmbedModels =\n  | AxAIOpenAIEmbedModel\n  | AxAIGoogleGeminiEmbedModel\n  | AxAICohereEmbedModel;\n\nexport class AxAI implements AxAIService {\n  private ai: AxAIService;\n\n  constructor(options: Readonly<AxAIArgs>) {\n    switch (options.name) {\n      case 'openai':\n        this.ai = new AxAIOpenAI(options);\n        break;\n      case 'openai-responses':\n        this.ai = new AxAIOpenAIResponses(options);\n        break;\n      case 'azure-openai':\n        this.ai = new AxAIAzureOpenAI(options);\n        break;\n      case 'huggingface':\n        this.ai = new AxAIHuggingFace(options);\n        break;\n      case 'groq':\n        this.ai = new AxAIGroq(options);\n        break;\n      case 'together':\n        this.ai = new AxAITogether(options);\n        break;\n      case 'cohere':\n        this.ai = new AxAICohere(options);\n        break;\n      case 'google-gemini':\n        this.ai = new AxAIGoogleGemini(options);\n        break;\n      case 'anthropic':\n        this.ai = new AxAIAnthropic(options);\n        break;\n      case 'mistral':\n        this.ai = new AxAIMistral(options);\n        break;\n      case 'deepseek':\n        this.ai = new AxAIDeepSeek(options);\n        break;\n      case 'ollama':\n        this.ai = new AxAIOllama(options);\n        break;\n      case 'reka':\n        this.ai = new AxAIReka(options);\n        break;\n      default:\n        throw new Error('Unknown AI');\n    }\n  }\n\n  getName(): string {\n    return this.ai.getName();\n  }\n\n  getId(): string {\n    return this.ai.getId();\n  }\n\n  getFeatures(model?: string): { functions: boolean; streaming: boolean } {\n    return this.ai.getFeatures(model);\n  }\n\n  getModelList() {\n    return this.ai.getModelList() as AxAIModelList | undefined;\n  }\n\n  getLastUsedChatModel() {\n    return this.ai.getLastUsedChatModel();\n  }\n\n  getLastUsedEmbedModel() {\n    return this.ai.getLastUsedEmbedModel();\n  }\n\n  getLastUsedModelConfig() {\n    return this.ai.getLastUsedModelConfig();\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.ai.getMetrics();\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest>,\n    options?: Readonly<AxAIPromptConfig & AxAIServiceActionOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    return await this.ai.chat(req, options);\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    options?: Readonly<AxAIServiceActionOptions & AxAIServiceActionOptions>\n  ): Promise<AxEmbedResponse> {\n    return await this.ai.embed(req, options);\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.ai.setOptions(options);\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.ai.getOptions();\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.ai.getLogger();\n  }\n}\n", "// cspell:ignore grok\n\nexport enum AxAIGrokModel {\n  Grok3 = 'grok-3',\n  Grok3Mini = 'grok-3-mini',\n  Grok3Fast = 'grok-3-fast',\n  Grok3MiniFast = 'grok-3-mini-fast',\n}\n\nexport enum AxAIGrokEmbedModels {\n  GrokEmbedSmall = 'grok-embed-small', // Placeholder, update if actual models are known\n}\n", "// cspell:ignore grok\n\nimport type { AxModelInfo } from '../types.js';\n\nimport { AxAIGrokModel } from './types.js';\n\nexport const axModelInfoGrok: AxModelInfo[] = [\n  {\n    name: AxAIGrokModel.Grok3,\n    currency: 'USD',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n  },\n  {\n    name: AxAIGrokModel.Grok3Mini,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.5,\n    hasThinkingBudget: true,\n  },\n  {\n    name: AxAIGrokModel.Grok3Fast,\n    currency: 'USD',\n    promptTokenCostPer1M: 5.0,\n    completionTokenCostPer1M: 25.0,\n  },\n  {\n    name: AxAIGrokModel.Grok3MiniFast,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.6,\n    completionTokenCostPer1M: 4.0,\n    hasThinkingBudget: true,\n  },\n];\n", "import { getModelInfo } from '@ax-llm/ax/dsp/modelinfo.js';\nimport { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type {\n  AxAIOpenAIChatRequest,\n  AxAIOpenAIConfig,\n} from '../openai/chat_types.js';\nimport type { AxAIServiceOptions, AxModelInfo } from '../types.js';\nimport { axModelInfoGrok } from './info.js';\nimport { type AxAIGrokEmbedModels, AxAIGrokModel } from './types.js';\n\nexport const axAIGrokDefaultConfig = (): AxAIOpenAIConfig<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels\n> =>\n  structuredClone({\n    model: AxAIGrokModel.Grok3Mini,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIGrokBestConfig = (): AxAIOpenAIConfig<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels\n> =>\n  structuredClone({\n    ...axAIGrokDefaultConfig(),\n    model: AxAIGrokModel.Grok3,\n  });\n\nexport interface AxAIGrokSearchSource {\n  type: 'web' | 'x' | 'news' | 'rss';\n  country?: string; // ISO alpha-2 code for web and news\n  excludedWebsites?: string[]; // Max 5 websites for web and news\n  allowedWebsites?: string[]; // Max 5 websites for web only\n  safeSearch?: boolean; // For web and news, default true\n  xHandles?: string[]; // For X source\n  links?: string[]; // For RSS source, max 1 link\n}\n\nexport interface AxAIGrokOptionsTools {\n  searchParameters?: {\n    mode?: 'auto' | 'on' | 'off';\n    returnCitations?: boolean;\n    fromDate?: string; // ISO8601 format YYYY-MM-DD\n    toDate?: string; // ISO8601 format YYYY-MM-DD\n    maxSearchResults?: number; // Default 20\n    sources?: AxAIGrokSearchSource[];\n  };\n}\n\nexport type AxAIGrokChatRequest = AxAIOpenAIChatRequest<AxAIGrokModel> & {\n  search_parameters?: {\n    mode?: 'auto' | 'on' | 'off';\n    return_citations?: boolean;\n    from_date?: string;\n    to_date?: string;\n    max_search_results?: number;\n    sources?: AxAIGrokSearchSource[];\n  };\n};\n\nexport type AxAIGrokArgs = AxAIOpenAIArgs<\n  'grok',\n  AxAIGrokModel,\n  AxAIGrokEmbedModels,\n  AxAIGrokChatRequest\n> & {\n  options?: Readonly<AxAIServiceOptions & AxAIGrokOptionsTools> & {\n    tokensPerMinute?: number;\n  };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIGrok extends AxAIOpenAIBase<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels,\n  AxAIGrokChatRequest\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGrokArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Grok API key not set');\n    }\n\n    const Config = {\n      ...axAIGrokDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoGrok, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIGrokModel) => {\n      const mi = getModelInfo<AxAIGrokModel, AxAIGrokEmbedModels>({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n      };\n    };\n\n    // Chat request updater to add Grok's search parameters\n    const chatReqUpdater = (req: AxAIGrokChatRequest): AxAIGrokChatRequest => {\n      if (options?.searchParameters) {\n        const searchParams = options.searchParameters;\n        return {\n          ...req,\n          search_parameters: {\n            mode: searchParams.mode,\n            return_citations: searchParams.returnCitations,\n            from_date: searchParams.fromDate,\n            to_date: searchParams.toDate,\n            max_search_results: searchParams.maxSearchResults,\n            sources: searchParams.sources?.map((source) => ({\n              type: source.type,\n              country: source.country,\n              excluded_websites: source.excludedWebsites,\n              allowed_websites: source.allowedWebsites,\n              safe_search: source.safeSearch,\n              x_handles: source.xHandles,\n              links: source.links,\n            })),\n          },\n        };\n      }\n      return req;\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.x.ai/v1',\n      modelInfo,\n      models,\n      supportFor,\n      chatReqUpdater,\n    });\n\n    super.setName('Grok');\n  }\n}\n", "import { type Span, SpanKind, type Tracer } from '@opentelemetry/api';\n\nimport { axSpanAttributes } from '../trace/trace.js';\n\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport interface AxDBBaseArgs {\n  fetch?: typeof fetch;\n  tracer?: Tracer;\n}\n\nexport interface AxDBBaseOpOptions {\n  span?: Span;\n}\n\nexport class AxDBBase implements AxDBService {\n  protected name: string;\n  protected fetch?: typeof fetch;\n  private tracer?: Tracer;\n\n  _upsert?: (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>;\n\n  _batchUpsert?: (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>;\n\n  _query?: (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBQueryResponse>;\n\n  constructor({\n    name,\n    fetch,\n    tracer,\n  }: Readonly<AxDBBaseArgs & { name: string }>) {\n    this.name = name;\n    this.fetch = fetch;\n    this.tracer = tracer;\n  }\n\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._upsert) {\n      throw new Error('upsert() not implemented');\n    }\n\n    if (!this.tracer) {\n      return await this._upsert(req, update);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._upsert!(req, update, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n\n  async batchUpsert(\n    req: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._batchUpsert) {\n      throw new Error('batchUpsert() not implemented');\n    }\n    if (req.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    if (!req[0]) {\n      throw new Error('Batch request is invalid first element is undefined');\n    }\n\n    if (!this.tracer) {\n      return await this._batchUpsert(req, update);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Batch Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req[0].table,\n          [axSpanAttributes.DB_NAMESPACE]: req[0].namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._batchUpsert!(req, update, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    if (!this._query) {\n      throw new Error('query() not implemented');\n    }\n    if (!this.tracer) {\n      return await this._query(req);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Query Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'query',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._query!(req, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n}\n", "import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nconst baseURL = 'https://api.cloudflare.com/client/v4/accounts/';\n\nexport type AxDBCloudflareOpOptions = AxDBBaseOpOptions;\n\ntype AxCloudflareUpsertResponse = {\n  success: boolean;\n  errors?: { message: string }[];\n  result: { ids: string[] };\n};\n\ntype AxCloudflareQueryResponse = {\n  success: boolean;\n  errors?: { message: string }[];\n  result: {\n    matches: {\n      id: string;\n      score: number;\n      values: number[];\n      metadata: object;\n    }[];\n  };\n};\n\nexport interface AxDBCloudflareArgs extends AxDBBaseArgs {\n  name: 'cloudflare';\n  apiKey: string;\n  accountId: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Cloudflare: DB Service\n */\nexport class AxDBCloudflare extends AxDBBase {\n  private apiKey: string;\n  private accountId: string;\n\n  constructor({\n    apiKey,\n    accountId,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBCloudflareArgs, 'name'>>) {\n    if (!apiKey || !accountId) {\n      throw new Error('Cloudflare credentials not set');\n    }\n    super({ name: 'Cloudflare', fetch, tracer });\n    this.apiKey = apiKey;\n    this.accountId = accountId;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    _update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }\n    )) as AxCloudflareUpsertResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare upsert failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.result.ids,\n    };\n  };\n\n  override batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update');\n    }\n    if (batchReq.length < 1) {\n      throw new Error('Batch request is empty');\n    }\n    if (!batchReq[0] || !batchReq[0].table) {\n      throw new Error('Table name is empty');\n    }\n    const table = batchReq[0].table;\n\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map((req) => ({\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }))\n    )) as AxCloudflareUpsertResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare batch upsert failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.result.ids,\n    };\n  };\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/query`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        vector: req.values,\n        topK: req.limit || 10,\n        returnValues: true,\n      }\n    )) as AxCloudflareQueryResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare query failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      );\n    }\n\n    const matches = res.result.matches.map(\n      ({ id, score, values, metadata }) => ({\n        id,\n        score,\n        values,\n        metadata,\n      })\n    );\n    return { matches } as AxDBQueryResponse;\n  };\n}\n", "import { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBMemoryOpOptions = AxDBBaseOpOptions;\n\nexport interface AxDBMemoryArgs extends AxDBBaseArgs {\n  name: 'memory';\n}\n\nexport type AxDBState = Record<string, Record<string, AxDBUpsertRequest>>;\n\n/**\n * MemoryDB: DB Service\n */\nexport class AxDBMemory extends AxDBBase {\n  private state: AxDBState;\n\n  constructor({ tracer }: Readonly<Omit<AxDBMemoryArgs, 'name'>> = {}) {\n    super({ name: 'Memory', tracer });\n    this.state = {};\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (!this.state[req.table]) {\n      this.state[req.table] = {\n        [req.id]: req,\n      };\n    } else {\n      const obj = this.state[req.table];\n      if (!obj) {\n        throw new Error(`Table not found: ${req.table}`);\n      }\n      obj[req.id] = req;\n    }\n\n    return { ids: [req.id] };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const ids: string[] = [];\n    for (const req of batchReq) {\n      const res = await this.upsert(req, update);\n      ids.push(...res.ids);\n    }\n\n    return { ids };\n  };\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const table = this.state[req.table];\n    if (!table) {\n      return { matches: [] };\n    }\n\n    const matches: AxDBQueryResponse['matches'] = [];\n\n    Object.entries(table).forEach(([id, data]) => {\n      if (req.values && data.values) {\n        const score = distance(req.values, data.values);\n        matches.push({ id: id, score: score, metadata: data.metadata });\n      }\n    });\n\n    matches.sort((a, b) => a.score - b.score);\n    if (req.limit) {\n      matches.length = req.limit;\n    }\n\n    return { matches };\n  };\n\n  public getDB = () => {\n    return structuredClone(this.state);\n  };\n\n  public setDB = (state: AxDBState) => {\n    this.state = structuredClone(state);\n  };\n\n  public clearDB = () => {\n    this.state = {};\n  };\n}\n\nconst distance = (a: readonly number[], b: readonly number[]): number => {\n  if (a.length !== b.length) {\n    throw new Error('Vectors must be of the same length.');\n  }\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n  let zeroVectorA = true;\n  let zeroVectorB = true;\n\n  const vectorA = new Float64Array(a);\n  const vectorB = new Float64Array(b);\n\n  for (let i = 0; i < vectorA.length; i++) {\n    dotProduct += vectorA[i]! * vectorB[i]!;\n    normA += vectorA[i]! * vectorA[i]!;\n    normB += vectorB[i]! * vectorB[i]!;\n    if (vectorA[i] !== 0) zeroVectorA = false;\n    if (vectorB[i] !== 0) zeroVectorB = false;\n  }\n\n  if (zeroVectorA || zeroVectorB) {\n    return 1; // Return maximum distance if one vector is zero\n  }\n\n  const sqrtNormA = Math.sqrt(normA);\n  const sqrtNormB = Math.sqrt(normB);\n  const similarity = dotProduct / (sqrtNormA * sqrtNormB);\n  return 1 - similarity; // Returning distance as 1 - cosine similarity.\n};\n", "import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBPineconeOpOptions = AxDBBaseOpOptions;\n\ntype AxPineconeQueryRequest = {\n  namespace?: string;\n  topK: number;\n  filter?: Record<string, string>;\n  includeValues: boolean;\n  includeMetadata: boolean;\n  vector: readonly number[];\n  id?: string;\n};\n\ntype AxPineconeQueryResponse = {\n  matches: {\n    id: string;\n    score: number;\n    values: number[];\n    metadata?: Record<string, string>;\n  }[];\n};\n\nconst createPineconeQueryRequest = (\n  req: Readonly<AxDBQueryRequest>\n): AxPineconeQueryRequest => {\n  const pineconeQueryRequest: AxPineconeQueryRequest = {\n    namespace: req.namespace,\n    topK: req.limit || 10,\n    filter: {},\n    includeValues: true,\n    includeMetadata: true,\n    vector: req.values ?? [],\n    id: req.id,\n  };\n\n  return pineconeQueryRequest;\n};\n\nexport interface AxDBPineconeArgs extends AxDBBaseArgs {\n  name: 'pinecone';\n  apiKey: string;\n  host: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Pinecone: DB Service\n */\nexport class AxDBPinecone extends AxDBBase {\n  private apiKey: string;\n  private apiURL: string;\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBPineconeArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Pinecone API key not set');\n    }\n    super({ name: 'Pinecone', fetch, tracer });\n    this.apiKey = apiKey;\n    this.apiURL = host;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    await this._batchUpsert([req], update, options);\n    return { ids: [req.id] };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    _update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/vectors/upsert',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map(({ id, values = [], metadata }) => ({\n        id,\n        values,\n        metadata,\n      }))\n    );\n\n    return { ids: batchReq.map(({ id }) => id) };\n  };\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    if (req.text) {\n      throw new Error('Pinecone does not support text');\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/query',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      createPineconeQueryRequest(req)\n    )) as AxPineconeQueryResponse;\n\n    const matches = res.matches.map(({ id, score, values, metadata }) => ({\n      id,\n      score,\n      metadata,\n      values,\n    }));\n\n    return { matches };\n  };\n}\n", "import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBWeaviateOpOptions = AxDBBaseOpOptions;\n\ntype AxWeaviateUpsertResponse = {\n  id: string;\n  result?: { errors?: { error: { message: string }[] } };\n};\n\ntype AxWeaviateQueryResponse = {\n  errors?: { location: string; message: string; path: string }[];\n  data: {\n    Get: {\n      [key: string]: {\n        [key: string]: unknown;\n      }[];\n    };\n  };\n};\n\nexport interface AxDBWeaviateArgs extends AxDBBaseArgs {\n  name: 'weaviate';\n  apiKey: string;\n  host: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Weaviate: DB Service\n */\nexport class AxDBWeaviate extends AxDBBase {\n  private apiKey: string;\n  private apiURL: string;\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBWeaviateArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Weaviate API key not set');\n    }\n    super({ name: 'Weaviate', fetch, tracer });\n    this.apiKey = apiKey;\n    this.apiURL = host;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: `/v1/objects/${req.table}/${req.id}`,\n        put: !!update,\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        class: req.table,\n        tenant: req.namespace,\n        vector: req.values,\n        properties: req.metadata ?? {},\n      }\n    )) as AxWeaviateUpsertResponse;\n\n    if (res?.result?.errors) {\n      throw new Error(\n        `Weaviate upsert failed: ${res.result.errors.error\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: [res.id],\n    };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update');\n    }\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    const objects = batchReq.map((req) => ({\n      id: req.id,\n      class: req.table,\n      tenant: req.namespace,\n      vector: req.values,\n      properties: req.metadata ?? {},\n    }));\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/batch/objects',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      { objects }\n    )) as AxWeaviateUpsertResponse[];\n\n    if (res?.some(({ result }) => result?.errors)) {\n      throw new Error(\n        `Weaviate batch upsert failed: ${res\n          .map(({ result }) =>\n            result?.errors?.error.map(({ message }) => message).join(', ')\n          )\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.map(({ id }) => id),\n    };\n  };\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    let filter = '';\n\n    if (req.columns && req.columns.length === 0) {\n      throw new Error('Weaviate requires at least one column');\n    }\n\n    if (req.values) {\n      filter = `nearVector: {\n            vector: [${req.values.join(',')}],\n        }`;\n    } else if (req.text) {\n      filter = `nearText: {\n            concepts: ['${req.text}'],\n        }`;\n    } else {\n      throw new Error('Weaviate requires either text or values');\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/graphql',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        query: `{\n          Get {\n            ${req.table} (\n              limit: ${req.limit || 10},\n              ${filter}\n            ) {\n                ${req.columns?.join('\\n')}\n            }\n          }\n        }`,\n      }\n    )) as AxWeaviateQueryResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Weaviate query failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    const resMatches = res.data.Get[req.table];\n\n    if (!resMatches) {\n      return { matches: [] };\n    }\n\n    const matches = resMatches.map((match) => {\n      return {\n        id: match.id as string,\n        score: 1,\n        metadata: match,\n      };\n    });\n    return { matches } as AxDBQueryResponse;\n  };\n}\n", "import { AxDBCloudflare, type AxDBCloudflareArgs } from './cloudflare.js';\nimport { AxDBMemory, type AxDBMemoryArgs } from './memory.js';\nimport { AxDBPinecone, type AxDBPineconeArgs } from './pinecone.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\nimport { AxDBWeaviate, type AxDBWeaviateArgs } from './weaviate.js';\n\nexport type AxDBArgs =\n  | AxDBCloudflareArgs\n  | AxDBPineconeArgs\n  | AxDBWeaviateArgs\n  | AxDBMemoryArgs;\n\nexport class AxDB implements AxDBService {\n  private db: AxDBService;\n  constructor(args: Readonly<AxDBArgs>) {\n    switch (args.name) {\n      case 'weaviate':\n        this.db = new AxDBWeaviate(args);\n        break;\n      case 'pinecone':\n        this.db = new AxDBPinecone(args);\n        break;\n      case 'cloudflare':\n        this.db = new AxDBCloudflare(args);\n        break;\n      case 'memory':\n        this.db = new AxDBMemory(args);\n        break;\n      default:\n        throw new Error('Unknown DB');\n    }\n  }\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.upsert(req, update);\n  }\n\n  async batchUpsert(\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.batchUpsert(batchReq, update);\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    return await this.db.query(req);\n  }\n}\n", "import type { AxAIService } from '../ai/types.js';\nimport type { AxDBQueryResponse, AxDBService } from '../db/types.js';\nimport type { AxProgram } from '../dsp/program.js';\n\nexport type AxRewriteIn = { query: string };\nexport type AxRewriteOut = { rewrittenQuery: string };\n\nexport type AxRerankerIn = { query: string; items: string[] };\nexport type AxRerankerOut = { rankedItems: string[] };\n\nexport interface AxDBLoaderOptions {\n  chunker?: (text: string) => string[];\n  rewriter?: AxProgram<AxRewriteIn, AxRewriteOut>;\n  reranker?: AxProgram<AxRerankerIn, AxRerankerOut>;\n}\n\nexport interface AxDBManagerArgs {\n  ai: AxAIService;\n  db: AxDBService;\n  config?: AxDBLoaderOptions;\n}\n\nexport interface AxDBMatch {\n  score: number;\n  text: string;\n}\n\nconst table = '_internal';\n\nexport class AxDBManager {\n  private ai: AxAIService;\n  private db: AxDBService;\n  private chunker: (text: string) => string[];\n  private rewriter?: AxProgram<AxRewriteIn, AxRewriteOut>;\n  private reranker?: AxProgram<AxRerankerIn, AxRerankerOut>;\n\n  constructor({ ai, db, config }: Readonly<AxDBManagerArgs>) {\n    this.ai = ai;\n    this.db = db;\n    this.chunker = config?.chunker ?? this.defaultChunker;\n    this.reranker = config?.reranker;\n    this.rewriter = config?.rewriter;\n  }\n\n  private defaultChunker = (text: string): string[] => {\n    // Default chunking by paragraphs\n    return text.split(/\\n\\n+/);\n  };\n\n  insert = async (\n    text: Readonly<string | string[]>,\n    options?: Readonly<{\n      batchSize?: number;\n      maxWordsPerChunk?: number;\n      minWordsPerChunk?: number;\n      abortSignal?: AbortSignal;\n    }>\n  ): Promise<void> => {\n    try {\n      const chunkerInput = Array.isArray(text)\n        ? text.join('\\n\\n')\n        : (text as string);\n\n      // Chunk the text using the specified or default chunking function\n      const initialChunks = this.chunker(chunkerInput).filter(\n        (chunk) => chunk.length > 0\n      );\n\n      const maxWordsPerChunk = options?.maxWordsPerChunk;\n      const minWordsPerChunk = options?.minWordsPerChunk;\n\n      const chunks = processChunks({\n        initialChunks,\n        minWordsPerChunk,\n        maxWordsPerChunk,\n      });\n\n      const bs = options?.batchSize ?? 10;\n\n      // Process chunks in batches of 10\n      for (let i = 0; i < chunks.length; i += bs) {\n        const batch = chunks.slice(i, i + bs);\n\n        // Get embeddings for the whole batch from the AI service in one call\n        const ret = await this.ai.embed(\n          { texts: batch },\n          {\n            abortSignal: options?.abortSignal,\n          }\n        );\n\n        // Prepare batch for bulk upsert\n        const embeddings = ret.embeddings\n          .map((embedding, index) => ({\n            id: `chunk_${Date.now() + index}`, // Unique ID for each chunk, adjusted by index\n            table,\n            values: embedding,\n            metadata: { text: batch[index] ?? '' },\n          }))\n          .filter((v) => v.metadata?.text && v.metadata?.text.length > 0);\n\n        // Batch upsert embeddings\n        await this.db.batchUpsert(embeddings);\n      }\n    } catch (error) {\n      throw new Error(`Error processing text: ${error}`);\n    }\n  };\n\n  query = async (\n    query: Readonly<string | string[] | number | number[]>,\n    {\n      topPercent,\n      abortSignal,\n    }:\n      | Readonly<{ topPercent?: number; abortSignal?: AbortSignal }>\n      | undefined = {}\n  ): Promise<AxDBMatch[][]> => {\n    const texts = Array.isArray(query) ? query : [query];\n\n    if (typeof texts[0] === 'string' && this.rewriter) {\n      for (const [i, text] of texts.entries()) {\n        const { rewrittenQuery } = await this.rewriter.forward(this.ai, {\n          query: text,\n        });\n        texts[i] = rewrittenQuery;\n      }\n    }\n\n    let queries: Promise<AxDBQueryResponse>[];\n\n    if (typeof texts[0] === 'string') {\n      const embedResults = await this.ai.embed(\n        { texts },\n        {\n          abortSignal,\n        }\n      );\n      queries = embedResults.embeddings.map((values) =>\n        this.db.query({ table, values })\n      );\n    } else {\n      queries = texts.map((values) => this.db.query({ table, values }));\n    }\n\n    const queryResults = await Promise.all(queries);\n    const res: AxDBMatch[][] = [];\n\n    for (const { matches } of queryResults) {\n      const m = matches\n        .filter((v) => v.metadata?.text && v.metadata?.text.length > 0)\n        .map(({ score, metadata }) => ({\n          score,\n          text: metadata?.text ?? '',\n        }));\n\n      const tp = topPercent && topPercent > 1 ? topPercent / 100 : topPercent;\n      const resultItems = tp ? getTopInPercent(m, tp) : m;\n\n      if (this.reranker) {\n        const { rankedItems } = await this.reranker.forward(this.ai, {\n          query: texts[0] as string,\n          items: resultItems.map((item) => item.text),\n        });\n\n        const items = rankedItems\n          .map((item) => resultItems.find((r) => r.text === item))\n          .filter((v) => v !== undefined) as AxDBMatch[];\n\n        res.push(items);\n      } else {\n        res.push(resultItems);\n      }\n    }\n\n    return res;\n  };\n}\n\nconst processChunks = ({\n  initialChunks,\n  maxWordsPerChunk = 350,\n  minWordsPerChunk = 250,\n}: Readonly<{\n  initialChunks: readonly string[];\n  maxWordsPerChunk?: number;\n  minWordsPerChunk?: number;\n}>): string[] => {\n  const chunks: string[] = [];\n\n  let currentChunk = '';\n  let currentWordCount = 0;\n\n  initialChunks.forEach((chunk) => {\n    const words = chunk.split(/\\s+/); // Split the chunk into words\n    const wordCount = words.length; // Count words in the current chunk\n\n    if (currentWordCount + wordCount <= maxWordsPerChunk) {\n      // Add to the current chunk if within the max size limit\n      currentChunk += `${chunk}\\n\\n`;\n      currentWordCount += wordCount;\n    } else if (\n      currentWordCount > 0 &&\n      currentWordCount + wordCount <= maxWordsPerChunk * 1.5\n    ) {\n      // If the total word count exceeds the limit but is less than 150% of the maxWordsPerChunk\n      currentChunk += `${chunk}\\n\\n`;\n      currentWordCount += wordCount;\n    } else {\n      // If the current chunk is not empty and adding the new chunk exceeds the adjusted limit\n      if (currentWordCount > minWordsPerChunk) {\n        chunks.push(currentChunk.trim());\n        currentChunk = '';\n        currentWordCount = 0;\n      }\n      // Handle the case where the chunk itself is larger than the limit\n      if (wordCount > maxWordsPerChunk) {\n        const remainingWords = words;\n        while (remainingWords.length > maxWordsPerChunk * 1.5) {\n          const slice = remainingWords.splice(0, maxWordsPerChunk);\n          chunks.push(slice.join(' '));\n        }\n        // Add the last portion if it fits the condition of being within 150% of maxWordsPerChunk\n        if (remainingWords.length > 0) {\n          currentChunk += `${remainingWords.join(' ')}\\n\\n`;\n          currentWordCount += remainingWords.length;\n        }\n      } else {\n        // If the new chunk is smaller than the maximum words per chunk\n        currentChunk = `${chunk}\\n\\n`;\n        currentWordCount = wordCount;\n      }\n    }\n  });\n\n  // Push the last chunk if it exists and meets the minimum words condition\n  if (currentWordCount > minWordsPerChunk || chunks.length === 0) {\n    chunks.push(currentChunk.trim());\n  }\n  return chunks;\n};\n\nconst getTopInPercent = (\n  entries: readonly AxDBMatch[],\n  percent = 0.1\n): AxDBMatch[] => {\n  // Sort entries by score in ascending order\n  const sortedEntries = [...entries].sort((a, b) => a.score - b.score);\n\n  // Calculate the number of entries to take (top 10%)\n  const topTenPercentCount = Math.ceil(sortedEntries.length * percent);\n\n  // Return the top 10% of entries\n  return sortedEntries.slice(0, topTenPercentCount);\n};\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport {\n  type Context,\n  context,\n  type Meter,\n  type Span,\n  SpanKind,\n  trace,\n} from '@opentelemetry/api';\n\nimport { validateAxMessageArray } from '../ai/base.js';\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunction,\n} from '../ai/types.js';\nimport { AxMemory } from '../mem/memory.js';\nimport type { AxAIMemory } from '../mem/types.js';\nimport { AxAIServiceStreamTerminatedError } from '../util/apicall.js';\n\nimport {\n  type AxAssertion,\n  AxAssertionError,\n  type AxStreamingAssertion,\n} from './asserts.js';\nimport { ValidationError } from './errors.js';\nimport type { extractionState } from './extract.js';\nimport type { AxFieldProcessor } from './fieldProcessor.js';\nimport {\n  type AxChatResponseFunctionCall,\n  createFunctionConfig,\n  parseFunctions,\n} from './functions.js';\nimport {\n  type AxGenMetricsInstruments,\n  getOrCreateGenMetricsInstruments,\n  recordErrorCorrectionMetric,\n  recordFieldProcessingMetric,\n  recordFunctionCallingMetric,\n  recordGenerationMetric,\n  recordMultiStepMetric,\n  recordPerformanceMetric,\n  recordSamplesMetric,\n  recordSignatureComplexityMetrics,\n  recordStreamingMetric,\n  recordValidationErrorMetric,\n} from './metrics.js';\nimport {\n  processResponse,\n  processStreamingResponse,\n  shouldContinueSteps,\n} from './processResponse.js';\nimport {\n  type AsyncGenDeltaOut,\n  type AxGenDeltaOut,\n  type AxGenStreamingOut,\n  AxProgram,\n  type AxProgramExamples,\n  type AxProgramForwardOptions,\n  type AxProgramStreamingForwardOptions,\n  type AxResultPickerFunction,\n  type AxSetExamplesOptions,\n} from './program.js';\nimport { AxPromptTemplate } from './prompt.js';\nimport { selectFromSamples, selectFromSamplesInMemory } from './samples.js';\nimport type { AxIField, AxSignature } from './sig.js';\nimport type {\n  AxGenIn,\n  AxGenIn as AxGenInType,\n  AxGenOut,\n  AxGenOut as AxGenOutType,\n  AxMessage,\n} from './types.js';\nimport { mergeDeltas } from './util.js';\nimport { handleValidationError } from './validate.js';\n\nexport type AxGenerateResult<OUT extends AxGenOutType> = OUT & {\n  thought?: string;\n};\n\nexport interface AxResponseHandlerArgs<T> {\n  ai: Readonly<AxAIService>;\n  model?: string;\n  res: T;\n  mem: AxAIMemory;\n  sessionId?: string;\n  traceId?: string;\n  functions: Readonly<AxFunction[]>;\n  strictMode?: boolean;\n  span?: Span;\n}\n\nexport interface AxStreamingEvent<T> {\n  event: 'delta' | 'done' | 'error';\n  data: {\n    contentDelta?: string;\n    partialValues?: Partial<T>;\n    error?: string;\n    functions?: AxChatResponseFunctionCall[];\n  };\n}\n\nexport type InternalAxGenState = {\n  index: number;\n  values: AxGenOutType;\n  content: string;\n  functionsExecuted: Set<string>;\n  functionCalls: NonNullable<AxChatResponseResult['functionCalls']>;\n  xstate: extractionState;\n};\n\nexport class AxGen<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> extends AxProgram<IN, OUT> {\n  private promptTemplate: AxPromptTemplate;\n  private asserts: AxAssertion[];\n  private streamingAsserts: AxStreamingAssertion[];\n  private options?: Omit<AxProgramForwardOptions, 'functions'>;\n  private functions?: AxFunction[];\n  private fieldProcessors: AxFieldProcessor[] = [];\n  private streamingFieldProcessors: AxFieldProcessor[] = [];\n  private excludeContentFromTrace = false;\n  private thoughtFieldName: string;\n\n  constructor(\n    signature: NonNullable<ConstructorParameters<typeof AxSignature>[0]>,\n    options?: Readonly<AxProgramForwardOptions>\n  ) {\n    super(signature, {\n      description: options?.description,\n      traceLabel: options?.traceLabel,\n    });\n\n    this.options = options;\n    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought';\n    const promptTemplateOptions = {\n      functions: options?.functions,\n      thoughtFieldName: this.thoughtFieldName,\n    };\n    this.promptTemplate = new (options?.promptTemplate ?? AxPromptTemplate)(\n      this.signature,\n      promptTemplateOptions\n    );\n    this.asserts = this.options?.asserts ?? [];\n    this.streamingAsserts = this.options?.streamingAsserts ?? [];\n    this.excludeContentFromTrace = options?.excludeContentFromTrace ?? false;\n    this.usage = [];\n\n    if (options?.functions) {\n      this.functions = parseFunctions(options.functions);\n    }\n  }\n\n  private getSignatureName(): string {\n    return this.signature.getDescription() || 'unknown_signature';\n  }\n\n  private getMetricsInstruments(): AxGenMetricsInstruments | undefined {\n    return getOrCreateGenMetricsInstruments();\n  }\n\n  public updateMeter(meter?: Meter): void {\n    // This now just updates the global singleton, no need to store locally\n    getOrCreateGenMetricsInstruments(meter);\n  }\n\n  private createStates(n: number) {\n    return Array.from({ length: n }, (_, index) => ({\n      index,\n      functionCalls: [],\n      values: {},\n      content: '',\n      functionsExecuted: new Set<string>(),\n      xstate: {\n        extractedFields: [],\n        streamedIndex: {},\n        s: -1,\n      },\n    }));\n  }\n\n  public addAssert = (fn: AxAssertion['fn'], message?: string) => {\n    this.asserts.push({ fn, message });\n  };\n\n  public addStreamingAssert = (\n    fieldName: string,\n    fn: AxStreamingAssertion['fn'],\n    message?: string\n  ) => {\n    this.streamingAsserts.push({ fieldName, fn, message });\n  };\n\n  private addFieldProcessorInternal = (\n    fieldName: string,\n    fn: AxFieldProcessor['process'],\n    streaming = false\n  ) => {\n    const field = this.signature\n      .getOutputFields()\n      .find((f) => f.name === fieldName);\n\n    if (!field) {\n      throw new Error(`addFieldProcessor: field ${fieldName} not found`);\n    }\n\n    if (streaming) {\n      const ft = field.type?.name;\n      const isText = !ft || ft === 'string' || ft === 'code';\n\n      if (!isText) {\n        throw new Error(\n          `addFieldProcessor: field ${fieldName} is must be a text field`\n        );\n      }\n      this.streamingFieldProcessors.push({ field, process: fn });\n    } else {\n      this.fieldProcessors.push({ field, process: fn });\n    }\n  };\n\n  public addStreamingFieldProcessor = (\n    fieldName: string,\n    fn: AxFieldProcessor['process']\n  ) => {\n    this.addFieldProcessorInternal(fieldName, fn, true);\n  };\n\n  public addFieldProcessor = (\n    fieldName: string,\n    fn: AxFieldProcessor['process']\n  ) => {\n    this.addFieldProcessorInternal(fieldName, fn, false);\n  };\n\n  private async forwardSendRequest({\n    ai,\n    mem,\n    options,\n    traceContext,\n    functions,\n    functionCall,\n  }: Readonly<{\n    ai: Readonly<AxAIService>;\n    mem: AxAIMemory;\n    options?: Omit<AxProgramForwardOptions, 'ai' | 'mem'>;\n    traceContext?: Context;\n    functions: AxFunction[];\n    functionCall: AxChatRequest['functionCall'] | undefined;\n  }>) {\n    const {\n      sessionId,\n      traceId,\n      model,\n      rateLimiter,\n      stream,\n      thinkingTokenBudget,\n      showThoughts,\n    } = options ?? {};\n\n    // Use selectFromSamplesInMemory to choose the best sample before getting history\n    const selectedIndex = await selectFromSamplesInMemory<OUT>(mem, sessionId, {\n      resultPicker: options?.resultPicker as\n        | AxResultPickerFunction<OUT>\n        | undefined,\n    });\n\n    const chatPrompt = mem?.history(selectedIndex, sessionId) ?? [];\n\n    if (chatPrompt.length === 0) {\n      throw new Error('No chat prompt found');\n    }\n    const modelConfig = {\n      ...options?.modelConfig,\n      ...(options?.sampleCount ? { n: options.sampleCount } : {}),\n      ...(options?.sampleCount && options?.modelConfig?.temperature === 1\n        ? { temperature: 0.8 }\n        : {}),\n    };\n\n    const res = await ai.chat(\n      {\n        chatPrompt,\n        functions,\n        functionCall,\n        modelConfig,\n        model,\n      },\n      {\n        sessionId,\n        traceId,\n        rateLimiter,\n        stream,\n        debug: false, // we do our own debug logging\n        thinkingTokenBudget,\n        showThoughts,\n        traceContext,\n        abortSignal: options?.abortSignal,\n      }\n    );\n\n    return res;\n  }\n\n  private async *forwardCore({\n    ai,\n    mem,\n    options,\n    firstStep,\n    span,\n    traceContext,\n  }: Readonly<{\n    ai: Readonly<AxAIService>;\n    mem: AxAIMemory;\n    options: Omit<AxProgramForwardOptions, 'ai' | 'mem'>;\n    firstStep: boolean;\n    span?: Span;\n    traceContext?: Context;\n  }>): AsyncGenDeltaOut<OUT> {\n    const { sessionId, traceId, functions: functionList } = options ?? {};\n    const definedFunctionCall =\n      options?.functionCall ?? this.options?.functionCall;\n    const strictMode = options?.strictMode ?? false;\n    const model = options.model;\n    const states = this.createStates(options.sampleCount ?? 1);\n    const usage = this.usage;\n\n    const { functions, functionCall } = createFunctionConfig(\n      functionList,\n      definedFunctionCall,\n      firstStep\n    );\n\n    const res = await this.forwardSendRequest({\n      ai,\n      mem,\n      options,\n      traceContext,\n      functions,\n      functionCall,\n    });\n\n    if (res instanceof ReadableStream) {\n      yield* processStreamingResponse({\n        ai,\n        model,\n        res,\n        mem,\n        traceId,\n        sessionId,\n        functions,\n        strictMode,\n        span,\n        states,\n        usage,\n        asserts: this.asserts,\n        streamingAsserts: this.streamingAsserts,\n        fieldProcessors: this.fieldProcessors,\n        streamingFieldProcessors: this.streamingFieldProcessors,\n        thoughtFieldName: this.thoughtFieldName,\n        excludeContentFromTrace: this.excludeContentFromTrace,\n        signature: this.signature,\n        functionResultFormatter:\n          options?.functionResultFormatter ??\n          this.options?.functionResultFormatter,\n      });\n    } else {\n      yield* processResponse({\n        ai,\n        model,\n        res,\n        mem,\n        traceId,\n        sessionId,\n        functions,\n        span,\n        strictMode,\n        states,\n        usage,\n        asserts: this.asserts,\n        fieldProcessors: this.fieldProcessors,\n        thoughtFieldName: this.thoughtFieldName,\n        excludeContentFromTrace: this.excludeContentFromTrace,\n        signature: this.signature,\n        functionResultFormatter:\n          options?.functionResultFormatter ??\n          this.options?.functionResultFormatter,\n      });\n    }\n\n    this.getLogger(ai, options)?.('', { tags: ['responseEnd'] });\n  }\n\n  private async *_forward2(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    states: InternalAxGenState[],\n    options: Readonly<AxProgramForwardOptions>,\n    span?: Span,\n    traceContext?: Context\n  ): AxGenStreamingOut<OUT> {\n    const stopFunction = (\n      options?.stopFunction ?? this.options?.stopFunction\n    )?.toLowerCase();\n\n    const maxRetries = options.maxRetries ?? this.options?.maxRetries ?? 10;\n    const maxSteps = options.maxSteps ?? this.options?.maxSteps ?? 10;\n    const debugHideSystemPrompt = options.debugHideSystemPrompt;\n    const memOptions = {\n      debug: this.isDebug(ai, options),\n      debugHideSystemPrompt,\n      logger: this.getLogger(ai, options),\n    };\n\n    const mem = options.mem ?? this.options?.mem ?? new AxMemory(memOptions);\n\n    let err: ValidationError | AxAssertionError | undefined;\n\n    if (options?.functions && options.functions.length > 0) {\n      const promptTemplateClass =\n        this.options?.promptTemplate ?? AxPromptTemplate;\n      const currentPromptTemplateOptions = {\n        functions: options.functions,\n        thoughtFieldName: this.thoughtFieldName,\n      };\n      this.promptTemplate = new promptTemplateClass(\n        this.signature,\n        currentPromptTemplateOptions\n      );\n    }\n\n    // New logic:\n    let prompt: AxChatRequest['chatPrompt'];\n\n    // Track prompt rendering performance\n    const promptRenderStart = performance.now();\n\n    if (Array.isArray(values)) {\n      // Validate AxMessage array items\n      validateAxMessageArray(values);\n\n      // We'll need to decide how to get the 'individual' IN for demos/examples if needed by render.\n      // For now, assume render will handle the array directly.\n      // The generic type for render might need to be T (from render<T extends ...>)\n      // and T will be inferred as ReadonlyArray<AxMessage>\n      prompt = this.promptTemplate.render(values, {\n        examples: this.examples,\n        demos: this.demos,\n      });\n    } else {\n      // Ensure `values` here is correctly inferred as AxGenInType\n      prompt = this.promptTemplate.render(values as AxGenInType, {\n        // Cast if necessary\n        examples: this.examples,\n        demos: this.demos,\n      });\n    }\n\n    const promptRenderDuration = performance.now() - promptRenderStart;\n\n    // Record prompt render performance metric\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'prompt_render',\n        promptRenderDuration,\n        this.getSignatureName()\n      );\n    }\n\n    // Track memory update performance\n    const memoryUpdateStart = performance.now();\n    mem.addRequest(prompt, options.sessionId);\n    const memoryUpdateDuration = performance.now() - memoryUpdateStart;\n\n    // Record memory update performance metric\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'memory_update',\n        memoryUpdateDuration,\n        this.getSignatureName()\n      );\n    }\n\n    multiStepLoop: for (let n = 0; n < maxSteps; n++) {\n      const firstStep = n === 0;\n      for (let errCount = 0; errCount < maxRetries; errCount++) {\n        try {\n          const generator = this.forwardCore({\n            options,\n            ai,\n            mem,\n            firstStep,\n            span,\n            traceContext,\n          });\n\n          for await (const result of generator) {\n            if (result !== undefined) {\n              yield {\n                version: errCount,\n                index: result.index,\n                delta: result.delta,\n              };\n            }\n          }\n\n          const shouldContinue = shouldContinueSteps(\n            mem,\n            stopFunction,\n            states,\n            options?.sessionId\n          );\n\n          if (shouldContinue) {\n            // Record multi-step generation metric\n            const metricsInstruments = this.getMetricsInstruments();\n            if (metricsInstruments) {\n              recordMultiStepMetric(\n                metricsInstruments,\n                n + 1,\n                maxSteps,\n                this.getSignatureName()\n              );\n            }\n            continue multiStepLoop;\n          }\n\n          // Record successful completion metrics\n          const metricsInstruments = this.getMetricsInstruments();\n          if (metricsInstruments) {\n            recordMultiStepMetric(\n              metricsInstruments,\n              n + 1,\n              maxSteps,\n              this.getSignatureName()\n            );\n\n            // Count unique functions executed across all states\n            const allFunctionsExecuted = new Set<string>();\n            states.forEach((state) => {\n              state.functionsExecuted.forEach((func) =>\n                allFunctionsExecuted.add(func)\n              );\n            });\n\n            // Record function metrics if functions were used\n            if (allFunctionsExecuted.size > 0) {\n              recordFunctionCallingMetric(\n                metricsInstruments,\n                true,\n                allFunctionsExecuted.size,\n                true,\n                false,\n                this.getSignatureName()\n              );\n            }\n\n            // Record field processing metrics\n            recordFieldProcessingMetric(\n              metricsInstruments,\n              this.fieldProcessors.length,\n              this.streamingFieldProcessors.length,\n              this.getSignatureName()\n            );\n          }\n\n          return;\n        } catch (e) {\n          let errorFields: AxIField[] | undefined;\n\n          span?.recordException(e as Error);\n\n          if (e instanceof ValidationError) {\n            errorFields = e.getFixingInstructions();\n            err = e;\n\n            // Record validation error metric\n            const metricsInstruments = this.getMetricsInstruments();\n            if (metricsInstruments) {\n              recordValidationErrorMetric(\n                metricsInstruments,\n                'validation',\n                this.getSignatureName()\n              );\n            }\n\n            // Add telemetry event for validation error\n            if (span) {\n              span.addEvent('validation.error', {\n                message: e.toString(),\n                fixing_instructions:\n                  errorFields?.map((f) => f.title).join(', ') ?? '',\n              });\n            }\n          } else if (e instanceof AxAssertionError) {\n            const e1 = e as AxAssertionError;\n            errorFields = e1.getFixingInstructions();\n            err = e;\n\n            // Record assertion error metric\n            const assertionMetricsInstruments = this.getMetricsInstruments();\n            if (assertionMetricsInstruments) {\n              recordValidationErrorMetric(\n                assertionMetricsInstruments,\n                'assertion',\n                this.getSignatureName()\n              );\n            }\n\n            // Add telemetry event for assertion error\n            if (span) {\n              span.addEvent('assertion.error', {\n                message: e1.toString(),\n                fixing_instructions:\n                  errorFields?.map((f) => f.title).join(', ') ?? '',\n              });\n            }\n          } else if (e instanceof AxAIServiceStreamTerminatedError) {\n            // Do nothing allow error correction to happen\n          } else {\n            throw enhanceError(e, ai, this.signature);\n          }\n\n          if (errorFields) {\n            handleValidationError(\n              mem,\n              errorFields,\n              ai,\n              this.promptTemplate,\n              options.sessionId\n            );\n          }\n        }\n      }\n\n      // Record max retries reached\n      const metricsInstruments = this.getMetricsInstruments();\n      if (metricsInstruments) {\n        recordErrorCorrectionMetric(\n          metricsInstruments,\n          maxRetries,\n          false, // failed\n          maxRetries,\n          this.getSignatureName()\n        );\n      }\n\n      throw enhanceError(\n        new Error(`Unable to fix validation error: ${err?.toString()}`),\n        ai,\n        this.signature\n      );\n    }\n\n    // Record max steps reached\n    if (metricsInstruments) {\n      recordMultiStepMetric(\n        metricsInstruments,\n        maxSteps,\n        maxSteps,\n        this.getSignatureName()\n      );\n    }\n\n    throw enhanceError(\n      new Error(`Max steps reached: ${maxSteps}`),\n      ai,\n      this.signature\n    );\n  }\n\n  public async *_forward1(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options: Readonly<AxProgramForwardOptions>\n  ): AxGenStreamingOut<OUT> {\n    // Track state creation performance\n    const stateCreationStart = performance.now();\n    const states = this.createStates(options.sampleCount ?? 1);\n    const stateCreationDuration = performance.now() - stateCreationStart;\n\n    // Record state creation performance metric\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'state_creation',\n        stateCreationDuration,\n        this.getSignatureName()\n      );\n    }\n\n    const tracer =\n      options?.tracer ?? this.options?.tracer ?? ai.getOptions().tracer;\n\n    let functions: AxFunction[] | undefined = this.functions;\n\n    if (options?.functions) {\n      functions = parseFunctions(options.functions, this.functions);\n    }\n\n    if (!tracer) {\n      yield* this._forward2(ai, values, states, {\n        ...options,\n        functions,\n      });\n      return;\n    }\n\n    const funcNames = functions?.map((f) => f.name).join(',');\n\n    const attributes = {\n      signature: JSON.stringify(this.signature.toJSON(), null, 2),\n      ...(this.examples\n        ? { examples: JSON.stringify(this.examples, null, 2) }\n        : {}),\n      ...(funcNames ? { provided_functions: funcNames } : {}),\n      ...(options?.model ? { model: options.model } : {}),\n      ...(options?.thinkingTokenBudget\n        ? { thinking_token_budget: options.thinkingTokenBudget }\n        : {}),\n      ...(options?.showThoughts ? { show_thoughts: options.showThoughts } : {}),\n      ...(options?.maxSteps ? { max_steps: options.maxSteps } : {}),\n      ...(options?.maxRetries ? { max_retries: options.maxRetries } : {}),\n    };\n\n    const traceLabel =\n      this.traceLabel && options.traceLabel\n        ? `${this.traceLabel} > ${options.traceLabel}`\n        : (options.traceLabel ?? this.traceLabel);\n    const spanName = traceLabel ? `AxGen > ${traceLabel}` : 'AxGen';\n\n    const span = tracer.startSpan(spanName, {\n      kind: SpanKind.SERVER,\n      attributes,\n    });\n\n    const currentContext = context.active();\n    const traceContext = trace.setSpan(currentContext, span);\n\n    try {\n      if (!this.excludeContentFromTrace) {\n        span.addEvent('input', { content: JSON.stringify(values, null, 2) });\n      }\n\n      yield* this._forward2(\n        ai,\n        values,\n        states,\n        {\n          ...options,\n          functions,\n        },\n        span,\n        traceContext\n      );\n\n      if (!this.excludeContentFromTrace) {\n        const valuesList = states.map((s) => s.values);\n        const values = valuesList.length === 1 ? valuesList[0] : valuesList;\n        span.addEvent('output', {\n          content: JSON.stringify(values, null, 2),\n        });\n      }\n    } finally {\n      span.end();\n    }\n  }\n\n  public override async forward(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<OUT> {\n    const startTime = performance.now();\n    const signatureName = this.getSignatureName();\n    const isStreaming = options?.stream ?? false;\n    let success = false;\n    let errorCorrectionAttempts = 0;\n    let functionsEnabled = false;\n    const functionsExecuted = 0;\n    let resultPickerUsed = false;\n\n    try {\n      // Record signature complexity metrics\n      const metricsInstruments = this.getMetricsInstruments();\n      if (metricsInstruments) {\n        recordSignatureComplexityMetrics(\n          metricsInstruments,\n          this.signature.getInputFields().length,\n          this.signature.getOutputFields().length,\n          this.examples?.length ?? 0,\n          this.demos?.length ?? 0,\n          signatureName\n        );\n      }\n\n      // Check if functions are enabled\n      functionsEnabled = !!(options?.functions || this.functions);\n\n      const generator = this._forward1(ai, values, options ?? {});\n\n      let buffer: AxGenDeltaOut<OUT>[] = [];\n      let currentVersion = 0;\n      let deltasEmitted = 0;\n\n      for await (const delta of generator) {\n        if (delta.version !== currentVersion) {\n          buffer = [];\n        }\n        currentVersion = delta.version;\n        buffer = mergeDeltas<OUT>(buffer, delta);\n        deltasEmitted++;\n      }\n\n      // Track error correction attempts from the version count\n      errorCorrectionAttempts = currentVersion;\n\n      // Use result picker to select from multiple samples\n      const resultPickerStart = performance.now();\n      resultPickerUsed = !!options?.resultPicker;\n\n      const selectedIndex = await selectFromSamples(\n        buffer,\n        {\n          resultPicker: options?.resultPicker as\n            | AxResultPickerFunction<OUT>\n            | undefined,\n        },\n        // Pass memory to enable function result selection\n        options?.mem,\n        options?.sessionId\n      );\n\n      const resultPickerLatency = performance.now() - resultPickerStart;\n\n      const selectedResult = buffer[selectedIndex];\n      const result = selectedResult?.delta ?? {};\n      this.trace = { ...values, ...result } as unknown as OUT;\n\n      success = true;\n\n      // Record samples metrics\n      if (metricsInstruments) {\n        recordSamplesMetric(\n          metricsInstruments,\n          buffer.length,\n          resultPickerUsed,\n          resultPickerUsed ? resultPickerLatency : undefined,\n          signatureName\n        );\n\n        // Record streaming metrics\n        recordStreamingMetric(\n          metricsInstruments,\n          isStreaming,\n          deltasEmitted,\n          undefined, // finalization latency not applicable here\n          signatureName\n        );\n      }\n\n      return result as unknown as OUT;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n\n      // Record generation metrics\n      const finalMetricsInstruments = this.getMetricsInstruments();\n      if (finalMetricsInstruments) {\n        recordGenerationMetric(\n          finalMetricsInstruments,\n          duration,\n          success,\n          signatureName,\n          ai.getName(),\n          options?.model\n        );\n\n        // Record function calling metrics if functions were used\n        if (functionsEnabled) {\n          recordFunctionCallingMetric(\n            finalMetricsInstruments,\n            functionsEnabled,\n            functionsExecuted,\n            functionsExecuted > 0,\n            false, // function error correction tracking would need more complex logic\n            signatureName\n          );\n        }\n\n        // Record error correction metrics\n        if (errorCorrectionAttempts > 0) {\n          recordErrorCorrectionMetric(\n            finalMetricsInstruments,\n            errorCorrectionAttempts,\n            success,\n            options?.maxRetries ?? 10,\n            signatureName\n          );\n        }\n      }\n    }\n  }\n\n  override async *streamingForward(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptions>\n  ): AxGenStreamingOut<OUT> {\n    // If no result picker, use normal streaming\n    if (!options?.resultPicker) {\n      yield* this._forward1(ai, values, {\n        ...options,\n        stream: true,\n      });\n      return;\n    }\n\n    // For result picker, we need to buffer all results first\n    const generator = this._forward1(ai, values, {\n      ...options,\n      stream: true,\n    });\n\n    let buffer: AxGenDeltaOut<OUT>[] = [];\n    let currentVersion = 0;\n\n    for await (const delta of generator) {\n      if (delta.version !== currentVersion) {\n        buffer = [];\n      }\n      currentVersion = delta.version;\n      buffer = mergeDeltas<OUT>(buffer, delta);\n    }\n\n    // Use result picker to select from samples\n    const selectedIndex = await selectFromSamples(\n      buffer,\n      {\n        resultPicker: options?.resultPicker as\n          | AxResultPickerFunction<OUT>\n          | undefined,\n      },\n      // Pass memory to enable function result selection\n      options?.mem,\n      options?.sessionId\n    );\n\n    // Yield the selected result\n    const selectedResult = buffer[selectedIndex];\n    if (selectedResult) {\n      yield {\n        version: currentVersion,\n        index: selectedIndex,\n        delta: selectedResult.delta,\n      };\n    }\n  }\n\n  public override setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    super.setExamples(examples, options);\n    // No need to update prompt template - all fields can be missing in examples\n  }\n\n  private isDebug(\n    ai: Readonly<AxAIService>,\n    options?: Readonly<AxProgramForwardOptions>\n  ) {\n    return (\n      options?.debug ?? this.options?.debug ?? ai.getOptions().debug ?? false\n    );\n  }\n\n  private getLogger(\n    ai: Readonly<AxAIService>,\n    options?: Readonly<AxProgramForwardOptions>\n  ) {\n    return options?.logger ?? this.options?.logger ?? ai.getLogger();\n  }\n}\n\nexport type AxGenerateErrorDetails = {\n  model?: string;\n  maxTokens?: number;\n  streaming: boolean;\n  signature: {\n    input: Readonly<AxIField[]>;\n    output: Readonly<AxIField[]>;\n    description?: string;\n  };\n};\n\ntype ErrorOptions = { cause?: Error };\n\nexport class AxGenerateError extends Error {\n  public readonly details: AxGenerateErrorDetails;\n\n  constructor(\n    message: string,\n    details: Readonly<AxGenerateErrorDetails>,\n    options?: ErrorOptions\n  ) {\n    super(message);\n    this.name = 'AxGenerateError';\n    this.details = details;\n    // Set cause property dynamically to avoid TypeScript issues\n    if (options?.cause) {\n      (this as ErrorOptions).cause = options.cause;\n    }\n  }\n}\n\nfunction enhanceError(\n  e: unknown,\n  ai: Readonly<AxAIService>,\n  signature: Readonly<AxSignature>\n): Error {\n  const originalError = e instanceof Error ? e : new Error(String(e));\n  const model = ai.getLastUsedChatModel() as string | undefined;\n  const modelConfig = ai.getLastUsedModelConfig();\n\n  const details = {\n    model: model,\n    maxTokens: modelConfig?.maxTokens,\n    streaming: modelConfig?.stream ?? false,\n    signature: {\n      input: signature.getInputFields(),\n      output: signature.getOutputFields(),\n      description: signature.getDescription(),\n    },\n  };\n\n  // Return custom error with short message and details as object property\n  return new AxGenerateError('Generate failed', details, {\n    cause: originalError,\n  });\n}\n", "import {\n  logChatRequest,\n  logChatRequestMessage,\n  logFunctionResults,\n  logResponseDelta,\n  logResponseResult,\n} from '../ai/debug.js';\nimport type {\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunctionResult,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport {\n  axValidateChatRequestMessage,\n  axValidateChatResponseResult,\n} from '../ai/validate.js';\n\nimport type { AxAIMemory, AxMemoryData } from './types.js';\n\nexport class MemoryImpl {\n  private data: AxMemoryData = [];\n\n  constructor(\n    private options?: {\n      debug?: boolean;\n      debugHideSystemPrompt?: boolean;\n      logger?: AxLoggerFunction;\n    }\n  ) {}\n\n  addRequest(items: AxChatRequest['chatPrompt'], index: number): void {\n    this.data.push(\n      ...items.map((item) => {\n        const value = structuredClone(item);\n        return {\n          role: item.role,\n          chat: [{ index, value }],\n        };\n      })\n    );\n\n    if (this.options?.debug) {\n      debugRequest(\n        items,\n        this.options?.debugHideSystemPrompt,\n        this.options?.logger\n      );\n    }\n  }\n\n  addFunctionResults(results: Readonly<AxFunctionResult[]>): void {\n    const chat = results.map(({ index, ...value }) => ({\n      index,\n      value: structuredClone(value),\n    }));\n\n    const lastItem = this.getLast();\n    if (lastItem?.role === 'function') {\n      lastItem.chat.push(...chat);\n    } else {\n      this.data.push({ role: 'function', chat });\n    }\n\n    if (this.options?.debug) {\n      debugFunctionResults(results, this.options?.logger);\n    }\n  }\n\n  addResponse(results: Readonly<AxChatResponseResult[]>): void {\n    const chat = results.map(({ index, ...value }) => ({\n      index,\n      value: structuredClone(value),\n    }));\n\n    this.data.push({ role: 'assistant', chat });\n\n    if (this.options?.debug) {\n      for (const result of results) {\n        debugResponse(result, this.options?.logger);\n      }\n    }\n  }\n\n  updateResult({\n    content,\n    name,\n    functionCalls,\n    delta,\n    index,\n  }: Readonly<AxChatResponseResult & { delta?: string; index: number }>): void {\n    const lastItem = this.data.at(-1);\n\n    const log = (logger?: AxLoggerFunction) => {\n      if (this.options?.debug) {\n        if (delta && typeof delta === 'string') {\n          debugResponseDelta(delta, logger);\n        } else {\n          debugResponse({ content, name, functionCalls, index }, logger);\n        }\n      }\n    };\n\n    if (\n      !lastItem ||\n      lastItem.role !== 'assistant' ||\n      (lastItem.role === 'assistant' && !lastItem.updatable)\n    ) {\n      this.data.push({\n        role: 'assistant',\n        updatable: true,\n        chat: [\n          { index, value: structuredClone({ content, name, functionCalls }) },\n        ],\n      });\n      log(this.options?.logger);\n      return;\n    }\n\n    const chat = lastItem.chat.find((v) => v.index === index);\n\n    if (!chat) {\n      lastItem.chat.push({\n        index,\n        value: structuredClone({ content, name, functionCalls }),\n      });\n      log(this.options?.logger);\n      return;\n    }\n\n    if (typeof content === 'string' && content.trim() !== '') {\n      (chat.value as { content: string }).content = content;\n    }\n\n    if (typeof name === 'string' && name.trim() !== '') {\n      (chat.value as { name: string }).name = name;\n    }\n\n    if (Array.isArray(functionCalls) && functionCalls.length > 0) {\n      (chat.value as { functionCalls: typeof functionCalls }).functionCalls =\n        functionCalls;\n    }\n\n    log(this.options?.logger);\n  }\n\n  addTag(name: string): void {\n    const lastItem = this.data.at(-1);\n    if (!lastItem) {\n      return;\n    }\n\n    if (!lastItem.tags) {\n      lastItem.tags = [];\n    }\n\n    if (!lastItem.tags.includes(name)) {\n      lastItem.tags.push(name);\n    }\n  }\n\n  rewindToTag(name: string): AxMemoryData {\n    const tagIndex = this.data.findIndex((item) => item.tags?.includes(name));\n    if (tagIndex === -1) {\n      throw new Error(`Tag \"${name}\" not found`);\n    }\n\n    // Remove and return the tagged item and everything after it\n    return this.data.splice(tagIndex);\n  }\n\n  removeByTag(name: string): AxMemoryData {\n    const indices = this.data.reduce<number[]>((acc, item, index) => {\n      if (item.tags?.includes(name)) {\n        acc.push(index);\n      }\n      return acc;\n    }, []);\n\n    if (indices.length === 0) {\n      throw new Error(`No items found with tag \"${name}\"`);\n    }\n\n    return indices\n      .reverse()\n      .map((index) => this.data.splice(index, 1).at(0))\n      .filter((item) => item !== undefined)\n      .reverse();\n  }\n\n  history(index: number): AxChatRequest['chatPrompt'] {\n    const result: AxChatRequest['chatPrompt'] = [];\n\n    for (const { role, chat } of this.data) {\n      let values: unknown;\n\n      if (role === 'function') {\n        values = chat.filter((v) => v.index === index).map((v) => v.value);\n      } else {\n        values = chat.find((v) => v.index === index)?.value;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        result.push(\n          ...values.map(\n            (v) => ({ ...v, role }) as AxChatRequest['chatPrompt'][number]\n          )\n        );\n      } else if (typeof values === 'object' && values !== null) {\n        result.push({ ...values, role } as AxChatRequest['chatPrompt'][number]);\n      }\n      // Skip when values is undefined (no matching index found)\n    }\n    return result;\n  }\n\n  getLast(): AxMemoryData[number] | undefined {\n    return this.data.at(-1);\n  }\n\n  reset(): void {\n    this.data = [];\n  }\n}\n\nexport class AxMemory implements AxAIMemory {\n  private memories = new Map<string, MemoryImpl>();\n  private defaultMemory: MemoryImpl;\n\n  constructor(\n    private options?: {\n      debug?: boolean;\n      debugHideSystemPrompt?: boolean;\n    }\n  ) {\n    this.defaultMemory = new MemoryImpl(options);\n  }\n\n  private getMemory(sessionId?: string): MemoryImpl {\n    if (!sessionId) {\n      return this.defaultMemory;\n    }\n\n    if (!this.memories.has(sessionId)) {\n      this.memories.set(sessionId, new MemoryImpl(this.options));\n    }\n\n    return this.memories.get(sessionId) as MemoryImpl;\n  }\n\n  addRequest(value: AxChatRequest['chatPrompt'], sessionId?: string): void {\n    for (const item of value) {\n      axValidateChatRequestMessage(item);\n    }\n    this.getMemory(sessionId).addRequest(value, 0);\n  }\n\n  addResponse(\n    results: Readonly<AxChatResponseResult[]>,\n    sessionId?: string\n  ): void {\n    axValidateChatResponseResult(results);\n    this.getMemory(sessionId).addResponse(results);\n  }\n\n  addFunctionResults(\n    results: Readonly<AxFunctionResult[]>,\n    sessionId?: string\n  ): void {\n    this.getMemory(sessionId).addFunctionResults(results);\n  }\n\n  updateResult(\n    result: Readonly<AxChatResponseResult & { delta?: string }>,\n    sessionId?: string\n  ): void {\n    this.getMemory(sessionId).updateResult(result);\n  }\n\n  addTag(name: string, sessionId?: string) {\n    this.getMemory(sessionId).addTag(name);\n  }\n\n  rewindToTag(name: string, sessionId?: string) {\n    return this.getMemory(sessionId).rewindToTag(name);\n  }\n\n  history(index: number, sessionId?: string) {\n    return this.getMemory(sessionId).history(index);\n  }\n\n  getLast(sessionId?: string) {\n    return this.getMemory(sessionId).getLast();\n  }\n\n  reset(sessionId?: string): void {\n    if (!sessionId) {\n      this.defaultMemory.reset();\n    } else {\n      this.memories.set(sessionId, new MemoryImpl(this.options));\n    }\n  }\n}\n\nfunction debugRequest(\n  value: AxChatRequest['chatPrompt'][number] | AxChatRequest['chatPrompt'],\n  hideSystemPrompt?: boolean,\n  logger?: AxLoggerFunction\n) {\n  if (Array.isArray(value)) {\n    logChatRequest(value, hideSystemPrompt, logger);\n  } else {\n    logChatRequestMessage(value, hideSystemPrompt, logger);\n  }\n}\n\nfunction debugResponse(\n  value: Readonly<AxChatResponseResult & { index: number }>,\n  logger?: AxLoggerFunction\n) {\n  logResponseResult(value, logger);\n}\n\nfunction debugResponseDelta(delta: string, logger?: AxLoggerFunction) {\n  logResponseDelta(delta, logger);\n}\n\nfunction debugFunctionResults(\n  results: Readonly<AxFunctionResult[]>,\n  logger?: AxLoggerFunction\n) {\n  logFunctionResults(results, logger);\n}\n", "import type { extractionState } from './extract.js';\n\nexport interface AxAssertion {\n  fn(\n    values: Record<string, unknown>\n  ): Promise<boolean | undefined> | boolean | undefined;\n  message?: string;\n}\n\nexport interface AxStreamingAssertion {\n  fieldName: string;\n  fn(content: string, done?: boolean): boolean | undefined;\n  message?: string;\n}\n\nexport class AxAssertionError extends Error {\n  constructor({\n    message,\n  }: Readonly<{\n    message: string;\n  }>) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n  public getFixingInstructions = () => {\n    const extraFields = [];\n    const message = this.message.trim();\n\n    extraFields.push({\n      name: 'error',\n      title: 'Follow these instructions',\n      description: message + (message.endsWith('.') ? '' : '.'),\n    });\n\n    return extraFields;\n  };\n\n  override toString(): string {\n    return `${this.name}: ${this.message}`;\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport const assertAssertions = async (\n  asserts: readonly AxAssertion[],\n  values: Record<string, unknown>\n) => {\n  for (const assert of asserts) {\n    const { fn, message } = assert;\n\n    const res = await fn(values);\n    if (res === undefined) {\n      continue;\n    }\n\n    if (!res) {\n      if (!message) {\n        throw new Error('Assertion Failed: No message provided for assertion');\n      }\n      throw new AxAssertionError({ message });\n    }\n  }\n};\n\nexport const assertStreamingAssertions = async (\n  asserts: readonly AxStreamingAssertion[],\n  xstate: Readonly<extractionState>,\n  content: string,\n  final = false\n) => {\n  if (\n    !xstate.currField ||\n    xstate.s === -1 ||\n    !asserts ||\n    asserts.length === 0\n  ) {\n    return;\n  }\n\n  const fieldAsserts = asserts.filter(\n    (a) => a.fieldName === xstate.currField?.name\n  );\n\n  if (fieldAsserts.length === 0) {\n    return;\n  }\n\n  const currValue = content.substring(xstate.s);\n\n  for (const assert of fieldAsserts) {\n    const { message, fn } = assert;\n\n    const res = await fn(currValue, final);\n    if (res === undefined) {\n      continue;\n    }\n\n    if (!res && message) {\n      throw new AxAssertionError({ message });\n    }\n  }\n};\n", "import type { AxField } from './sig.js';\n\nexport class ValidationError extends Error {\n  private fields: AxField[];\n\n  constructor({\n    message,\n    fields,\n  }: Readonly<{\n    message: string;\n    fields: AxField[];\n    value?: string;\n  }>) {\n    super(message);\n    this.fields = fields;\n    this.name = this.constructor.name;\n  }\n\n  public getFixingInstructions = () => {\n    const toFieldType = (type: Readonly<AxField['type']>) => {\n      const baseType = (() => {\n        switch (type?.name) {\n          case 'string':\n            return 'string';\n          case 'number':\n            return 'number';\n          case 'boolean':\n            return 'boolean';\n          case 'date':\n            return 'date (\"YYYY-MM-DD\" format)';\n          case 'datetime':\n            return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n          case 'json':\n            return 'JSON object';\n          case 'class':\n            return 'classification class';\n          case 'code':\n            return 'code';\n          default:\n            return 'string';\n        }\n      })();\n\n      return type?.isArray ? `json array of ${baseType} items` : baseType;\n    };\n\n    return this.fields.map((field) => ({\n      name: 'outputError',\n      title: 'Output Correction Required',\n      description: `The section labeled '${field.title}' does not match the expected format of '${toFieldType(field.type)}'. ${this.message} Please revise your response to ensure it conforms to the specified format.`,\n    }));\n  };\n\n  override toString(): string {\n    const toFieldType = (type: Readonly<AxField['type']>) => {\n      const baseType = (() => {\n        switch (type?.name) {\n          case 'string':\n            return 'string';\n          case 'number':\n            return 'number';\n          case 'boolean':\n            return 'boolean';\n          case 'date':\n            return 'date (\"YYYY-MM-DD\" format)';\n          case 'datetime':\n            return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n          case 'json':\n            return 'JSON object';\n          case 'class':\n            return 'classification class';\n          case 'code':\n            return 'code';\n          default:\n            return 'string';\n        }\n      })();\n\n      return type?.isArray ? `json array of ${baseType} items` : baseType;\n    };\n\n    return [\n      `${this.name}: ${this.message}`,\n      ...this.fields.map(\n        (field) =>\n          `  - ${field.title}: Expected format '${toFieldType(field.type)}'`\n      ),\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n", "import type { AxFunctionJSONSchema } from '../ai/types.js';\n\n// Extended type to handle flexible JSON schemas with union types\ntype FlexibleJSONSchema = AxFunctionJSONSchema & {\n  anyOf?: FlexibleJSONSchema[];\n  oneOf?: FlexibleJSONSchema[];\n  allOf?: FlexibleJSONSchema[];\n  properties?: Record<string, FlexibleJSONSchema | undefined>;\n};\n\ninterface ValidationError {\n  path: string;\n  issue: string;\n  fix: string;\n  example?: string;\n}\n\nexport const validateJSONSchema = (\n  schema: Readonly<AxFunctionJSONSchema>\n): void => {\n  const errors: ValidationError[] = [];\n\n  const validateSchemaObject = (\n    schema: Readonly<FlexibleJSONSchema | undefined>,\n    path = ''\n  ): void => {\n    // Skip validation if schema is undefined or null\n    if (!schema || typeof schema !== 'object') {\n      return;\n    }\n\n    const validTypes = [\n      'array',\n      'integer',\n      'number',\n      'string',\n      'boolean',\n      'null',\n      'object',\n    ];\n\n    // Handle schemas with anyOf (union types)\n    if (schema.anyOf && Array.isArray(schema.anyOf)) {\n      if (schema.anyOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'anyOf array is empty',\n          fix: 'Add at least one schema to the anyOf array',\n          example: 'anyOf: [{ type: \"string\" }, { type: \"null\" }]',\n        });\n      }\n      // Validate each schema in anyOf\n      schema.anyOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}anyOf[${index}].`);\n      });\n      return;\n    }\n\n    // Handle schemas with oneOf\n    if (schema.oneOf && Array.isArray(schema.oneOf)) {\n      if (schema.oneOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'oneOf array is empty',\n          fix: 'Add at least one schema to the oneOf array',\n          example: 'oneOf: [{ type: \"string\" }, { type: \"number\" }]',\n        });\n      }\n      schema.oneOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}oneOf[${index}].`);\n      });\n      return;\n    }\n\n    // Handle schemas with allOf\n    if (schema.allOf && Array.isArray(schema.allOf)) {\n      if (schema.allOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'allOf array is empty',\n          fix: 'Add at least one schema to the allOf array',\n          example:\n            'allOf: [{ type: \"object\" }, { properties: { name: { type: \"string\" } } }]',\n        });\n      }\n      schema.allOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}allOf[${index}].`);\n      });\n      return;\n    }\n\n    // Skip validation if no type is specified (might be a reference or other valid schema)\n    if (!schema.type) {\n      return;\n    }\n\n    if (!validTypes.includes(schema.type)) {\n      errors.push({\n        path: path || 'root',\n        issue: `Invalid type '${schema.type}'`,\n        fix: `Change type to one of: ${validTypes.join(', ')}`,\n        example: `{ type: \"string\" } or { type: \"object\" }`,\n      });\n      return;\n    }\n\n    if (schema.type === 'object') {\n      if (schema.properties) {\n        if (\n          typeof schema.properties !== 'object' ||\n          Array.isArray(schema.properties)\n        ) {\n          errors.push({\n            path: path || 'root',\n            issue: 'properties must be an object, not an array or primitive',\n            fix: 'Change properties to be an object with property names as keys',\n            example:\n              'properties: { name: { type: \"string\" }, age: { type: \"number\" } }',\n          });\n        } else {\n          for (const key in schema.properties) {\n            const value = schema.properties[key];\n            // Skip undefined or null properties\n            if (value === undefined || value === null) {\n              continue;\n            }\n            if (typeof value !== 'object') {\n              errors.push({\n                path: `${path}${key}`,\n                issue: `Property schema must be an object, got ${typeof value}`,\n                fix: 'Define the property as a proper schema object',\n                example: `${key}: { type: \"string\", description: \"...\" }`,\n              });\n              continue;\n            }\n            validateSchemaObject(value, `${path}${key}.`);\n          }\n        }\n      }\n\n      if (schema.required) {\n        if (!Array.isArray(schema.required)) {\n          errors.push({\n            path: path || 'root',\n            issue: `'required' must be an array, got ${typeof schema.required}`,\n            fix: 'Change required to be an array of property names',\n            example:\n              'required: [\"name\", \"email\"] instead of required: \"name,email\"',\n          });\n        } else if (schema.required.length === 0) {\n          // This is valid but might be worth noting\n        } else {\n          // Validate that required properties exist in properties\n          if (schema.properties) {\n            for (const requiredProp of schema.required) {\n              if (typeof requiredProp !== 'string') {\n                errors.push({\n                  path: `${path}required`,\n                  issue: `Required property names must be strings, got ${typeof requiredProp}`,\n                  fix: 'Ensure all items in required array are strings',\n                  example:\n                    'required: [\"name\", \"email\"] not required: [123, \"email\"]',\n                });\n              } else if (!(requiredProp in schema.properties)) {\n                errors.push({\n                  path: `${path}required`,\n                  issue: `Required property '${requiredProp}' is not defined in properties`,\n                  fix: `Either add '${requiredProp}' to properties or remove it from required`,\n                  example: `properties: { ${requiredProp}: { type: \"string\" } }`,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (schema.type === 'array') {\n      if (schema.items) {\n        if (typeof schema.items !== 'object') {\n          errors.push({\n            path: `${path}items`,\n            issue: `Array items schema must be an object, got ${typeof schema.items}`,\n            fix: 'Define items as a proper schema object',\n            example:\n              'items: { type: \"string\" } or items: { type: \"object\", properties: {...} }',\n          });\n        } else {\n          validateSchemaObject(schema.items, `${path}items.`);\n        }\n      }\n    }\n  };\n\n  validateSchemaObject(schema);\n\n  if (errors.length > 0) {\n    const errorMessage = [\n      'JSON Schema validation failed:',\n      '',\n      ...errors.map((error, index) => {\n        const parts = [\n          `${index + 1}. Path: ${error.path}`,\n          `   Issue: ${error.issue}`,\n          `   Fix: ${error.fix}`,\n        ];\n        if (error.example) {\n          parts.push(`   Example: ${error.example}`);\n        }\n        return parts.join('\\n');\n      }),\n      '',\n      'Please fix these issues and try again.',\n    ].join('\\n');\n\n    throw new Error(errorMessage);\n  }\n};\n\n// Example Usage:\n\n/*\nconst validSchema: AxFunctionJSONSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'string' },\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    },\n    optionalField: {\n      anyOf: [\n        { type: 'string' },\n        { type: 'null' }\n      ]\n    }\n  },\n  required: ['id', 'name', 'email']\n};\n\nconst invalidSchema: any = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'unknownType' }, // Invalid type\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    }\n  },\n  required: 'id,name,email' // Invalid 'required' field\n};\n\ntry {\n  validateJSONSchema(validSchema);\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n\ntry {\n  validateJSONSchema(invalidSchema);\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n*/\n", "import type {\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunction,\n  AxFunctionResult,\n} from '../ai/types.js';\nimport type { AxMemory } from '../mem/memory.js';\n\nimport { axGlobals } from './globals.js';\nimport { validateJSONSchema } from './jsonschema.js';\n\nexport class AxFunctionError extends Error {\n  constructor(\n    private fields: {\n      field: string;\n      message: string;\n    }[]\n  ) {\n    super();\n    this.name = this.constructor.name;\n  }\n\n  getFields = () => this.fields;\n\n  override toString(): string {\n    return [\n      `${this.name}: Function validation error`,\n      ...this.fields.map((field) => `  - ${field.field}: ${field.message}`),\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\ntype FunctionFieldErrors = ConstructorParameters<typeof AxFunctionError>[0];\n\nexport class FunctionError extends Error {\n  constructor(\n    private readonly fields: FunctionFieldErrors,\n    private readonly func: Readonly<AxFunction>,\n    private readonly funcId?: string\n  ) {\n    super();\n  }\n\n  getFunctionId = () => this.funcId;\n\n  private getFieldDescription(fieldName: string): string {\n    if (!this.func.parameters?.properties?.[fieldName]) {\n      return '';\n    }\n\n    const fieldSchema = this.func.parameters.properties[fieldName];\n    let description = fieldSchema.description;\n\n    if (fieldSchema.enum?.length) {\n      description += ` Allowed values are: ${fieldSchema.enum.join(', ')}`;\n    }\n\n    return description;\n  }\n\n  public getFixingInstructions = () => {\n    const bulletPoints = this.fields.map((fieldError) => {\n      const schemaDescription =\n        this.getFieldDescription(fieldError.field) || '';\n      return `- \\`${fieldError.field}\\` - ${fieldError.message} (${schemaDescription}).`;\n    });\n\n    return `Errors In Function Arguments: Fix the following invalid arguments to '${this.func.name}'\\n${bulletPoints.join('\\n')}`;\n  };\n\n  override toString(): string {\n    return [\n      `${this.name}: Function execution error in '${this.func.name}'`,\n      ...this.fields.map((field) => {\n        const description = this.getFieldDescription(field.field);\n        return `  - ${field.field}: ${field.message}${description ? ` (${description})` : ''}`;\n      }),\n      this.funcId ? `  Function ID: ${this.funcId}` : '',\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport type AxChatResponseFunctionCall = {\n  id: string;\n  name: string;\n  args: string;\n};\n\nexport class AxFunctionProcessor {\n  private funcList: Readonly<AxFunction[]> = [];\n\n  constructor(funcList: Readonly<AxFunction[]>) {\n    this.funcList = funcList;\n  }\n\n  private executeFunction = async (\n    fnSpec: Readonly<AxFunction>,\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<AxAIServiceActionOptions>\n  ) => {\n    let args: unknown;\n\n    if (typeof func.args === 'string' && func.args.length > 0) {\n      args = JSON.parse(func.args);\n    } else {\n      args = func.args;\n    }\n\n    const opt = options\n      ? {\n          sessionId: options.sessionId,\n          traceId: options.traceId,\n          ai: options.ai,\n        }\n      : undefined;\n\n    let res: unknown;\n    if (!fnSpec.parameters) {\n      res =\n        fnSpec.func.length === 1 ? await fnSpec.func(opt) : await fnSpec.func();\n    } else {\n      res =\n        fnSpec.func.length === 2\n          ? await fnSpec.func(args, opt)\n          : await fnSpec.func(args);\n    }\n\n    // Use the formatter from options or fall back to globals\n    const formatter =\n      options?.functionResultFormatter ?? axGlobals.functionResultFormatter;\n    return formatter(res);\n  };\n\n  public execute = async (\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<AxAIServiceActionOptions>\n  ) => {\n    const fnSpec = this.funcList.find(\n      (v) => v.name.localeCompare(func.name) === 0\n    );\n    if (!fnSpec) {\n      throw new Error(`Function not found: ${func.name}`);\n    }\n    if (!fnSpec.func) {\n      throw new Error(`No handler for function: ${func.name}`);\n    }\n\n    // execute value function calls\n    try {\n      return await this.executeFunction(fnSpec, func, options);\n    } catch (e) {\n      if (e instanceof AxFunctionError) {\n        throw new FunctionError(e.getFields(), fnSpec, func.id);\n      }\n      throw e;\n    }\n  };\n}\n\nexport type AxInputFunctionType = (\n  | AxFunction\n  | {\n      toFunction: () => AxFunction | AxFunction[];\n    }\n)[];\n\nexport const parseFunctions = (\n  newFuncs: Readonly<AxInputFunctionType>,\n  existingFuncs?: readonly AxFunction[]\n): AxFunction[] => {\n  if (newFuncs.length === 0) {\n    return [...(existingFuncs ?? [])];\n  }\n\n  // biome-ignore lint/complexity/useFlatMap: cannot use flatMap here\n  const functions = newFuncs\n    .map((f) => {\n      if ('toFunction' in f) {\n        return f.toFunction();\n      }\n      return f;\n    })\n    .flat();\n\n  for (const fn of functions.filter((v) => v.parameters)) {\n    if (fn.parameters) {\n      validateJSONSchema(fn.parameters);\n    }\n  }\n\n  return [...(existingFuncs ?? []), ...functions];\n};\n\ntype ProcessFunctionsArgs = {\n  ai: Readonly<AxAIService>;\n  functionList: Readonly<AxFunction[]>;\n  functionCalls: readonly AxChatResponseFunctionCall[];\n  mem: Readonly<AxMemory>;\n  sessionId?: string;\n  traceId?: string;\n  span?: import('@opentelemetry/api').Span;\n  excludeContentFromTrace?: boolean;\n  index: number;\n  functionResultFormatter?: (result: unknown) => string;\n};\n\nexport const processFunctions = async ({\n  ai,\n  functionList,\n  functionCalls,\n  mem,\n  sessionId,\n  traceId,\n  span,\n  excludeContentFromTrace,\n  index,\n  functionResultFormatter,\n}: Readonly<ProcessFunctionsArgs>) => {\n  const funcProc = new AxFunctionProcessor(functionList);\n  const functionsExecuted = new Set<string>();\n\n  // Map each function call to a promise that resolves to the function result or null\n  const promises = functionCalls.map((func) => {\n    if (!func.id) {\n      throw new Error(`Function ${func.name} did not return an ID`);\n    }\n\n    const promise: Promise<AxFunctionResult | undefined> = funcProc\n      .execute(func, { sessionId, traceId, ai, functionResultFormatter })\n      .then((functionResult) => {\n        functionsExecuted.add(func.name.toLowerCase());\n\n        // Add telemetry event for successful function call\n        if (span) {\n          const eventData: { name: string; args?: string; result?: string } = {\n            name: func.name,\n          };\n          if (!excludeContentFromTrace) {\n            eventData.args = func.args;\n            eventData.result = functionResult ?? '';\n          }\n          span.addEvent('function.call', eventData);\n        }\n\n        return {\n          result: functionResult ?? '',\n          role: 'function' as const,\n          functionId: func.id,\n          index,\n        };\n      })\n      .catch((e) => {\n        if (!(e instanceof FunctionError)) {\n          throw e;\n        }\n        const result = e.getFixingInstructions();\n\n        // Add telemetry event for function error\n        if (span) {\n          const errorEventData: {\n            name: string;\n            args?: string;\n            message: string;\n            fixing_instructions?: string;\n          } = {\n            name: func.name,\n            message: e.toString(),\n          };\n          if (!excludeContentFromTrace) {\n            errorEventData.args = func.args;\n            errorEventData.fixing_instructions = result;\n          }\n          span.addEvent('function.error', errorEventData);\n        }\n\n        if (ai.getOptions().debug) {\n          const logger = ai.getLogger();\n          logger(` Function Error Correction:\\n${result}`, {\n            tags: ['error'],\n          });\n        }\n\n        return {\n          functionId: func.id,\n          isError: true,\n          index,\n          result,\n          role: 'function' as const,\n        };\n      });\n\n    return promise;\n  });\n\n  // Wait for all promises to resolve\n  const results = await Promise.all(promises);\n  const functionResults = results.filter((result) => result !== undefined);\n\n  mem.addFunctionResults(functionResults, sessionId);\n\n  if (functionResults.some((result) => result.isError)) {\n    mem.addTag('error', sessionId);\n  }\n\n  return functionsExecuted;\n};\n\nexport function parseFunctionCalls(\n  ai: Readonly<AxAIService>,\n  functionCalls: Readonly<AxChatResponseResult['functionCalls']>,\n  _values: Record<string, unknown>,\n  model?: string\n): AxChatResponseFunctionCall[] | undefined {\n  if (!functionCalls || functionCalls.length === 0) {\n    return;\n  }\n  if (!ai.getFeatures(model).functions) {\n    throw new Error('Functions are not supported by the AI service');\n  }\n\n  const funcs: AxChatResponseFunctionCall[] = functionCalls.map((f) => ({\n    id: f.id,\n    name: f.function.name,\n    args: f.function.params as string,\n  }));\n\n  // for (const [i, f] of funcs.entries()) {\n  //   values['functionName' + i] = f.name;\n  //   values['functionArguments' + i] =\n  //     typeof f.args === 'object' ? JSON.stringify(f.args) : f.args;\n  // }\n  return funcs;\n}\n\ntype FunctionCall = AxChatRequest['functionCall'] | undefined;\n\n/**\n * Utility function to parse a list of functions into AxFunction array\n */\nexport function createFunctionConfig(\n  functionList?: AxInputFunctionType,\n  definedFunctionCall?: FunctionCall,\n  firstStep?: boolean\n): { functions: AxFunction[]; functionCall: FunctionCall } {\n  const functionCall = definedFunctionCall;\n\n  if (\n    !firstStep &&\n    (functionCall === 'required' || typeof functionCall === 'function')\n  ) {\n    return { functions: [], functionCall: undefined };\n  }\n\n  if (!functionList) {\n    return { functions: [], functionCall: functionCall };\n  }\n\n  // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here\n  const functions = functionList\n    .map((f) => {\n      if ('toFunction' in f) {\n        return f.toFunction();\n      }\n      return f;\n    })\n    .flat();\n\n  return { functions, functionCall };\n}\n", "import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\nimport { axGlobals } from './globals.js';\n\n// Metrics configuration interface\nexport interface AxMetricsConfig {\n  enabled: boolean;\n  enabledCategories: (\n    | 'generation'\n    | 'streaming'\n    | 'functions'\n    | 'errors'\n    | 'performance'\n  )[];\n  maxLabelLength: number;\n  samplingRate: number;\n}\n\n// Default metrics configuration\nexport const axDefaultMetricsConfig: AxMetricsConfig = {\n  enabled: true,\n  enabledCategories: [\n    'generation',\n    'streaming',\n    'functions',\n    'errors',\n    'performance',\n  ],\n  maxLabelLength: 100,\n  samplingRate: 1.0,\n};\n\n// Standardized error categories for consistent error classification\nexport type AxErrorCategory =\n  | 'validation_error'\n  | 'assertion_error'\n  | 'timeout_error'\n  | 'abort_error'\n  | 'network_error'\n  | 'auth_error'\n  | 'rate_limit_error'\n  | 'function_error'\n  | 'parsing_error'\n  | 'unknown_error';\n\nexport interface AxGenMetricsInstruments {\n  // Generation flow metrics\n  generationLatencyHistogram?: Histogram;\n  generationRequestsCounter?: Counter;\n  generationErrorsCounter?: Counter;\n\n  // Multi-step flow metrics\n  multiStepGenerationsCounter?: Counter;\n  stepsPerGenerationHistogram?: Histogram;\n  maxStepsReachedCounter?: Counter;\n\n  // Error correction metrics\n  validationErrorsCounter?: Counter;\n  assertionErrorsCounter?: Counter;\n  errorCorrectionAttemptsHistogram?: Histogram;\n  errorCorrectionSuccessCounter?: Counter;\n  errorCorrectionFailureCounter?: Counter;\n  maxRetriesReachedCounter?: Counter;\n\n  // Function calling metrics\n  functionsEnabledGenerationsCounter?: Counter;\n  functionCallStepsCounter?: Counter;\n  functionsExecutedPerGenerationHistogram?: Histogram;\n  functionErrorCorrectionCounter?: Counter;\n\n  // Field processing metrics\n  fieldProcessorsExecutedCounter?: Counter;\n  streamingFieldProcessorsExecutedCounter?: Counter;\n\n  // Streaming specific metrics\n  streamingGenerationsCounter?: Counter;\n  streamingDeltasEmittedCounter?: Counter;\n  streamingFinalizationLatencyHistogram?: Histogram;\n\n  // Memory and samples metrics\n  samplesGeneratedHistogram?: Histogram;\n  resultPickerUsageCounter?: Counter;\n  resultPickerLatencyHistogram?: Histogram;\n\n  // Signature complexity metrics\n  inputFieldsGauge?: Gauge;\n  outputFieldsGauge?: Gauge;\n  examplesUsedGauge?: Gauge;\n  demosUsedGauge?: Gauge;\n\n  // Performance metrics\n  promptRenderLatencyHistogram?: Histogram;\n  extractionLatencyHistogram?: Histogram;\n  assertionLatencyHistogram?: Histogram;\n\n  // State management\n  stateCreationLatencyHistogram?: Histogram;\n  memoryUpdateLatencyHistogram?: Histogram;\n}\n\n// Singleton instance for metrics instruments\nlet globalGenMetricsInstruments: AxGenMetricsInstruments | undefined;\n\n// Function to get or create metrics instruments (singleton pattern)\nexport const getOrCreateGenMetricsInstruments = (\n  meter?: Meter\n): AxGenMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalGenMetricsInstruments) {\n    return globalGenMetricsInstruments;\n  }\n\n  // Try to use provided meter or fall back to global\n  const activeMeter = meter ?? axGlobals.meter;\n  if (activeMeter) {\n    globalGenMetricsInstruments = createGenMetricsInstruments(activeMeter);\n    return globalGenMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the singleton (useful for testing)\nexport const resetGenMetricsInstruments = (): void => {\n  globalGenMetricsInstruments = undefined;\n};\n\n// Health check for metrics system\nexport const axCheckMetricsHealth = (): {\n  healthy: boolean;\n  issues: string[];\n} => {\n  const issues: string[] = [];\n\n  if (!axGlobals.meter) {\n    issues.push('Global meter not initialized');\n  }\n\n  if (!globalGenMetricsInstruments && axGlobals.meter) {\n    issues.push('Metrics instruments not created despite available meter');\n  }\n\n  return {\n    healthy: issues.length === 0,\n    issues,\n  };\n};\n\nexport const createGenMetricsInstruments = (\n  meter: Meter\n): AxGenMetricsInstruments => {\n  return {\n    // Generation flow metrics\n    // Note: Histogram buckets should be configured at the exporter level\n    // Recommended buckets: [1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000] ms\n    generationLatencyHistogram: meter.createHistogram(\n      'ax_gen_generation_duration_ms',\n      {\n        description: 'End-to-end duration of AxGen generation requests',\n        unit: 'ms',\n      }\n    ),\n\n    generationRequestsCounter: meter.createCounter(\n      'ax_gen_generation_requests_total',\n      {\n        description: 'Total number of AxGen generation requests',\n      }\n    ),\n\n    generationErrorsCounter: meter.createCounter(\n      'ax_gen_generation_errors_total',\n      {\n        description: 'Total number of failed AxGen generations',\n      }\n    ),\n\n    // Multi-step flow metrics\n    multiStepGenerationsCounter: meter.createCounter(\n      'ax_gen_multistep_generations_total',\n      {\n        description: 'Total number of generations that required multiple steps',\n      }\n    ),\n\n    stepsPerGenerationHistogram: meter.createHistogram(\n      'ax_gen_steps_per_generation',\n      {\n        description: 'Number of steps taken per generation',\n      }\n    ),\n\n    maxStepsReachedCounter: meter.createCounter(\n      'ax_gen_max_steps_reached_total',\n      {\n        description: 'Total number of generations that hit max steps limit',\n      }\n    ),\n\n    // Error correction metrics\n    validationErrorsCounter: meter.createCounter(\n      'ax_gen_validation_errors_total',\n      {\n        description: 'Total number of validation errors encountered',\n      }\n    ),\n\n    assertionErrorsCounter: meter.createCounter(\n      'ax_gen_assertion_errors_total',\n      {\n        description: 'Total number of assertion errors encountered',\n      }\n    ),\n\n    errorCorrectionAttemptsHistogram: meter.createHistogram(\n      'ax_gen_error_correction_attempts',\n      {\n        description: 'Number of error correction attempts per generation',\n      }\n    ),\n\n    errorCorrectionSuccessCounter: meter.createCounter(\n      'ax_gen_error_correction_success_total',\n      {\n        description: 'Total number of successful error corrections',\n      }\n    ),\n\n    errorCorrectionFailureCounter: meter.createCounter(\n      'ax_gen_error_correction_failure_total',\n      {\n        description: 'Total number of failed error corrections',\n      }\n    ),\n\n    maxRetriesReachedCounter: meter.createCounter(\n      'ax_gen_max_retries_reached_total',\n      {\n        description: 'Total number of generations that hit max retries limit',\n      }\n    ),\n\n    // Function calling metrics\n    functionsEnabledGenerationsCounter: meter.createCounter(\n      'ax_gen_functions_enabled_generations_total',\n      {\n        description: 'Total number of generations with functions enabled',\n      }\n    ),\n\n    functionCallStepsCounter: meter.createCounter(\n      'ax_gen_function_call_steps_total',\n      {\n        description: 'Total number of steps that included function calls',\n      }\n    ),\n\n    functionsExecutedPerGenerationHistogram: meter.createHistogram(\n      'ax_gen_functions_executed_per_generation',\n      {\n        description: 'Number of unique functions executed per generation',\n      }\n    ),\n\n    functionErrorCorrectionCounter: meter.createCounter(\n      'ax_gen_function_error_correction_total',\n      {\n        description: 'Total number of function-related error corrections',\n      }\n    ),\n\n    // Field processing metrics\n    fieldProcessorsExecutedCounter: meter.createCounter(\n      'ax_gen_field_processors_executed_total',\n      {\n        description: 'Total number of field processors executed',\n      }\n    ),\n\n    streamingFieldProcessorsExecutedCounter: meter.createCounter(\n      'ax_gen_streaming_field_processors_executed_total',\n      {\n        description: 'Total number of streaming field processors executed',\n      }\n    ),\n\n    // Streaming specific metrics\n    streamingGenerationsCounter: meter.createCounter(\n      'ax_gen_streaming_generations_total',\n      {\n        description: 'Total number of streaming generations',\n      }\n    ),\n\n    streamingDeltasEmittedCounter: meter.createCounter(\n      'ax_gen_streaming_deltas_emitted_total',\n      {\n        description: 'Total number of streaming deltas emitted',\n      }\n    ),\n\n    streamingFinalizationLatencyHistogram: meter.createHistogram(\n      'ax_gen_streaming_finalization_duration_ms',\n      {\n        description: 'Duration of streaming response finalization',\n        unit: 'ms',\n      }\n    ),\n\n    // Memory and samples metrics\n    samplesGeneratedHistogram: meter.createHistogram(\n      'ax_gen_samples_generated',\n      {\n        description: 'Number of samples generated per request',\n      }\n    ),\n\n    resultPickerUsageCounter: meter.createCounter(\n      'ax_gen_result_picker_usage_total',\n      {\n        description: 'Total number of times result picker was used',\n      }\n    ),\n\n    resultPickerLatencyHistogram: meter.createHistogram(\n      'ax_gen_result_picker_duration_ms',\n      {\n        description: 'Duration of result picker execution',\n        unit: 'ms',\n      }\n    ),\n\n    // Signature complexity metrics\n    inputFieldsGauge: meter.createGauge('ax_gen_input_fields', {\n      description: 'Number of input fields in signature',\n    }),\n\n    outputFieldsGauge: meter.createGauge('ax_gen_output_fields', {\n      description: 'Number of output fields in signature',\n    }),\n\n    examplesUsedGauge: meter.createGauge('ax_gen_examples_used', {\n      description: 'Number of examples used in generation',\n    }),\n\n    demosUsedGauge: meter.createGauge('ax_gen_demos_used', {\n      description: 'Number of demos used in generation',\n    }),\n\n    // Performance metrics\n    promptRenderLatencyHistogram: meter.createHistogram(\n      'ax_gen_prompt_render_duration_ms',\n      {\n        description: 'Duration of prompt template rendering',\n        unit: 'ms',\n      }\n    ),\n\n    extractionLatencyHistogram: meter.createHistogram(\n      'ax_gen_extraction_duration_ms',\n      {\n        description: 'Duration of value extraction from responses',\n        unit: 'ms',\n      }\n    ),\n\n    assertionLatencyHistogram: meter.createHistogram(\n      'ax_gen_assertion_duration_ms',\n      {\n        description: 'Duration of assertion checking',\n        unit: 'ms',\n      }\n    ),\n\n    // State management\n    stateCreationLatencyHistogram: meter.createHistogram(\n      'ax_gen_state_creation_duration_ms',\n      {\n        description: 'Duration of state creation for multiple samples',\n        unit: 'ms',\n      }\n    ),\n\n    memoryUpdateLatencyHistogram: meter.createHistogram(\n      'ax_gen_memory_update_duration_ms',\n      {\n        description: 'Duration of memory updates during generation',\n        unit: 'ms',\n      }\n    ),\n  };\n};\n\n// Global metrics configuration\nlet currentMetricsConfig: AxMetricsConfig = axDefaultMetricsConfig;\n\n// Function to update metrics configuration\nexport const axUpdateMetricsConfig = (\n  config: Readonly<Partial<AxMetricsConfig>>\n): void => {\n  currentMetricsConfig = { ...currentMetricsConfig, ...config };\n};\n\n// Function to get current metrics configuration\nexport const axGetMetricsConfig = (): AxMetricsConfig => {\n  return { ...currentMetricsConfig };\n};\n\n// Utility function to sanitize metric labels\nconst sanitizeLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length based on configuration\n      const maxLength = currentMetricsConfig.maxLabelLength;\n      sanitized[key] =\n        stringValue.length > maxLength\n          ? stringValue.substring(0, maxLength)\n          : stringValue;\n    }\n  }\n  return sanitized;\n};\n\n// Recording functions for generation flow metrics\nexport const recordGenerationMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  duration: number,\n  success: boolean,\n  signatureName?: string,\n  aiService?: string,\n  model?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      success: success.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n      ...(aiService ? { ai_service: aiService } : {}),\n      ...(model ? { model } : {}),\n    });\n\n    if (instruments.generationLatencyHistogram) {\n      instruments.generationLatencyHistogram.record(duration, labels);\n    }\n\n    if (instruments.generationRequestsCounter) {\n      instruments.generationRequestsCounter.add(1, labels);\n    }\n\n    if (!success && instruments.generationErrorsCounter) {\n      instruments.generationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    // Log error but don't propagate to avoid breaking the main flow\n    console.warn('Failed to record generation metric:', error);\n  }\n};\n\n// Recording functions for multi-step metrics\nexport const recordMultiStepMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  stepsUsed: number,\n  maxSteps: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (stepsUsed > 1 && instruments.multiStepGenerationsCounter) {\n      instruments.multiStepGenerationsCounter.add(1, labels);\n    }\n\n    if (instruments.stepsPerGenerationHistogram) {\n      instruments.stepsPerGenerationHistogram.record(stepsUsed, labels);\n    }\n\n    if (stepsUsed >= maxSteps && instruments.maxStepsReachedCounter) {\n      instruments.maxStepsReachedCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record multi-step metric:', error);\n  }\n};\n\n// Recording functions for error correction metrics\nexport const recordValidationErrorMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  errorType: 'validation' | 'assertion',\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      error_type: errorType,\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (errorType === 'validation' && instruments.validationErrorsCounter) {\n      instruments.validationErrorsCounter.add(1, labels);\n    }\n\n    if (errorType === 'assertion' && instruments.assertionErrorsCounter) {\n      instruments.assertionErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record validation error metric:', error);\n  }\n};\n\nexport const recordErrorCorrectionMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  attempts: number,\n  success: boolean,\n  maxRetries: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      success: success.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.errorCorrectionAttemptsHistogram) {\n      instruments.errorCorrectionAttemptsHistogram.record(attempts, labels);\n    }\n\n    if (success && instruments.errorCorrectionSuccessCounter) {\n      instruments.errorCorrectionSuccessCounter.add(1, labels);\n    }\n\n    if (!success) {\n      if (instruments.errorCorrectionFailureCounter) {\n        instruments.errorCorrectionFailureCounter.add(1, labels);\n      }\n      if (attempts >= maxRetries && instruments.maxRetriesReachedCounter) {\n        instruments.maxRetriesReachedCounter.add(1, labels);\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to record error correction metric:', error);\n  }\n};\n\n// Recording functions for function calling metrics\nexport const recordFunctionCallingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  functionsEnabled: boolean,\n  functionsExecuted: number,\n  hadFunctionCalls: boolean,\n  functionErrorCorrection = false,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      functions_enabled: functionsEnabled.toString(),\n      had_function_calls: hadFunctionCalls.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (functionsEnabled && instruments.functionsEnabledGenerationsCounter) {\n      instruments.functionsEnabledGenerationsCounter.add(1, labels);\n    }\n\n    if (hadFunctionCalls && instruments.functionCallStepsCounter) {\n      instruments.functionCallStepsCounter.add(1, labels);\n    }\n\n    if (\n      functionsExecuted > 0 &&\n      instruments.functionsExecutedPerGenerationHistogram\n    ) {\n      instruments.functionsExecutedPerGenerationHistogram.record(\n        functionsExecuted,\n        labels\n      );\n    }\n\n    if (functionErrorCorrection && instruments.functionErrorCorrectionCounter) {\n      instruments.functionErrorCorrectionCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record function calling metric:', error);\n  }\n};\n\n// Recording functions for field processing metrics\nexport const recordFieldProcessingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  fieldProcessorsExecuted: number,\n  streamingFieldProcessorsExecuted: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (\n      fieldProcessorsExecuted > 0 &&\n      instruments.fieldProcessorsExecutedCounter\n    ) {\n      instruments.fieldProcessorsExecutedCounter.add(\n        fieldProcessorsExecuted,\n        labels\n      );\n    }\n\n    if (\n      streamingFieldProcessorsExecuted > 0 &&\n      instruments.streamingFieldProcessorsExecutedCounter\n    ) {\n      instruments.streamingFieldProcessorsExecutedCounter.add(\n        streamingFieldProcessorsExecuted,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record field processing metric:', error);\n  }\n};\n\n// Recording functions for streaming metrics\nexport const recordStreamingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  isStreaming: boolean,\n  deltasEmitted: number,\n  finalizationDuration?: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      is_streaming: isStreaming.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (isStreaming && instruments.streamingGenerationsCounter) {\n      instruments.streamingGenerationsCounter.add(1, labels);\n    }\n\n    if (deltasEmitted > 0 && instruments.streamingDeltasEmittedCounter) {\n      instruments.streamingDeltasEmittedCounter.add(deltasEmitted, labels);\n    }\n\n    if (\n      finalizationDuration &&\n      instruments.streamingFinalizationLatencyHistogram\n    ) {\n      instruments.streamingFinalizationLatencyHistogram.record(\n        finalizationDuration,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record streaming metric:', error);\n  }\n};\n\n// Recording functions for samples metrics\nexport const recordSamplesMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  samplesCount: number,\n  resultPickerUsed: boolean,\n  resultPickerLatency?: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      result_picker_used: resultPickerUsed.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.samplesGeneratedHistogram) {\n      instruments.samplesGeneratedHistogram.record(samplesCount, labels);\n    }\n\n    if (resultPickerUsed && instruments.resultPickerUsageCounter) {\n      instruments.resultPickerUsageCounter.add(1, labels);\n    }\n\n    if (resultPickerLatency && instruments.resultPickerLatencyHistogram) {\n      instruments.resultPickerLatencyHistogram.record(\n        resultPickerLatency,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record samples metric:', error);\n  }\n};\n\n// Recording functions for signature complexity metrics\nexport const recordSignatureComplexityMetrics = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  inputFields: number,\n  outputFields: number,\n  examplesCount: number,\n  demosCount: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.inputFieldsGauge) {\n      instruments.inputFieldsGauge.record(inputFields, labels);\n    }\n\n    if (instruments.outputFieldsGauge) {\n      instruments.outputFieldsGauge.record(outputFields, labels);\n    }\n\n    if (instruments.examplesUsedGauge) {\n      instruments.examplesUsedGauge.record(examplesCount, labels);\n    }\n\n    if (instruments.demosUsedGauge) {\n      instruments.demosUsedGauge.record(demosCount, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record signature complexity metrics:', error);\n  }\n};\n\n// Recording functions for performance metrics\nexport const recordPerformanceMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  metricType:\n    | 'prompt_render'\n    | 'extraction'\n    | 'assertion'\n    | 'state_creation'\n    | 'memory_update',\n  duration: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      metric_type: metricType,\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    switch (metricType) {\n      case 'prompt_render':\n        if (instruments.promptRenderLatencyHistogram) {\n          instruments.promptRenderLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'extraction':\n        if (instruments.extractionLatencyHistogram) {\n          instruments.extractionLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'assertion':\n        if (instruments.assertionLatencyHistogram) {\n          instruments.assertionLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'state_creation':\n        if (instruments.stateCreationLatencyHistogram) {\n          instruments.stateCreationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'memory_update':\n        if (instruments.memoryUpdateLatencyHistogram) {\n          instruments.memoryUpdateLatencyHistogram.record(duration, labels);\n        }\n        break;\n    }\n  } catch (error) {\n    console.warn('Failed to record performance metric:', error);\n  }\n};\n", "/* eslint-disable @typescript-eslint/naming-convention */\nimport { createHash } from '../util/crypto.js';\n\nimport type { AxChatResponseResult, AxModelInfo } from './types.js';\n\nexport const findItemByNameOrAlias = (\n  list: readonly AxModelInfo[],\n  name: string\n): AxModelInfo | undefined => {\n  for (const item of list) {\n    if (item.name === name || item.aliases?.includes(name)) {\n      return item;\n    }\n  }\n  return undefined;\n};\n\nexport const uniqBy = <T>(\n  array: readonly T[],\n  uniqueField: (value: T) => unknown\n): T[] => {\n  const uniqueValues = new Map();\n\n  array.forEach((value: T) => {\n    const field = uniqueField(value);\n\n    if (!uniqueValues.has(field)) {\n      uniqueValues.set(field, value);\n    }\n  });\n\n  return Array.from(uniqueValues.values());\n};\n\nconst functionCallRe = /(\\w+)\\((.*)\\)/s;\n\nexport const parseFunction = (\n  value: string\n): { name: string; args?: string } | undefined => {\n  let v: string[] | null;\n\n  // extract function calls\n  v = functionCallRe.exec(value);\n  if (v !== null) {\n    const name = v.at(1)?.trim();\n    const args = v.at(2)?.trim();\n    if (!name || name.length === 0) {\n      throw new Error(`Invalid function format: ${value}`);\n    }\n    return { name, args };\n  }\n  return;\n};\n\nexport interface mergeFunctionsState {\n  lastId?: string;\n}\n\nexport function mergeFunctionCalls(\n  functionCalls: NonNullable<AxChatResponseResult['functionCalls']>,\n  functionCallDeltas: Readonly<\n    NonNullable<AxChatResponseResult['functionCalls']>\n  >\n) {\n  for (const Fc of functionCallDeltas) {\n    const fc = functionCalls.find((fc) => fc.id === Fc.id);\n\n    if (fc) {\n      if (typeof Fc.function.name === 'string' && Fc.function.name.length > 0) {\n        fc.function.name += Fc.function.name;\n      }\n\n      if (\n        typeof Fc.function.params === 'string' &&\n        Fc.function.params.length > 0\n      ) {\n        fc.function.params += Fc.function.params;\n      }\n\n      if (typeof Fc.function.params === 'object') {\n        fc.function.params = Fc.function.params;\n      }\n    } else {\n      functionCalls.push(Fc);\n    }\n  }\n}\n\nexport const hashObject = (obj: object) => {\n  const hash = createHash('sha256');\n  hash.update(JSON.stringify(obj));\n  return hash.digest('hex');\n};\n", "import dayjs from 'dayjs';\nimport customParseFormat from 'dayjs/plugin/customParseFormat.js';\nimport timezone from 'dayjs/plugin/timezone.js';\nimport utc from 'dayjs/plugin/utc.js';\n\nimport { ValidationError } from './errors.js';\nimport type { AxField } from './sig.js';\n\n// Extend Day.js with required plugins\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(customParseFormat);\n\nexport function parseLLMFriendlyDate(\n  field: Readonly<AxField>,\n  dateStr: string,\n  required = false\n) {\n  try {\n    return ParseLlmFriendlyDate(dateStr);\n  } catch (err) {\n    if (field.isOptional && !required) {\n      return;\n    }\n    const message = (err as Error).message;\n    throw new ValidationError({ fields: [field], message, value: dateStr });\n  }\n}\n\nfunction ParseLlmFriendlyDate(dateStr: string) {\n  // Validate the date string format\n  if (!dayjs(dateStr, 'YYYY-MM-DD', true).isValid()) {\n    throw new Error(\n      'Invalid date format. Please provide the date in \"YYYY-MM-DD\" format.'\n    );\n  }\n\n  // Parse the date and create a UTC dayjs object at midnight\n  // @ts-ignore - utc method exists after plugin extension\n  const date = dayjs.utc(dateStr, 'YYYY-MM-DD').startOf('day');\n\n  return date.toDate();\n}\n\nexport function parseLLMFriendlyDateTime(\n  field: Readonly<AxField>,\n  dateStr: string,\n  required = false\n) {\n  try {\n    return ParseLlmFriendlyDateTime(dateStr);\n  } catch (err) {\n    if (field.isOptional && !required) {\n      return;\n    }\n    const message = (err as Error).message;\n    throw new ValidationError({ fields: [field], message, value: dateStr });\n  }\n}\n\nfunction ParseLlmFriendlyDateTime(dateTimeStr: string) {\n  // Validate the date and time string format\n  const dateTimeRegex = /^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}(?::\\d{2})?) (.+)$/;\n  const match = dateTimeStr.match(dateTimeRegex);\n  if (!match) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    );\n  }\n\n  const [, dateTime, timeZone] = match;\n\n  if (!dateTime || !timeZone) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    );\n  }\n\n  // Day.js doesn't have a direct equivalent to moment.tz.zone, so we attempt to parse and validate the timezone\n  try {\n    // Determine the format based on whether seconds are included\n    const format =\n      dateTime.includes(':') && dateTime.split(':').length === 3\n        ? 'YYYY-MM-DD HH:mm:ss'\n        : 'YYYY-MM-DD HH:mm';\n\n    // Parse the date and time in the specified time zone\n    // @ts-ignore - tz method exists after plugin extension\n    const date = dayjs.tz(dateTime, format, timeZone);\n\n    // Check if the date and time are valid\n    if (!date.isValid()) {\n      throw new Error(\n        'Invalid date and time values. Please ensure all components are correct.'\n      );\n    }\n\n    // Convert to UTC\n    // @ts-ignore - utc method exists after plugin extension\n    return date.utc().toDate();\n  } catch (_err) {\n    throw new Error(\n      `Unrecognized time zone ${timeZone}. Please provide a valid time zone name, abbreviation, or offset. For example, \"America/New_York\", or \"EST\".`\n    );\n  }\n}\n\nexport const formatDateWithTimezone = (date: Readonly<Date>) => {\n  // @ts-ignore - utc method exists after plugin extension\n  const dayjsDate = dayjs(date).utc();\n  return dayjsDate.format('YYYY-MM-DD HH:mm:ss [UTC]');\n};\n", "/* eslint-disable functional/prefer-immutable-types */\nimport { ColorLog } from '../util/log.js';\n\nimport type { AxExample, AxOptimizationStats } from './optimizer.js';\nimport type { AxGenDeltaOut, AxProgramUsage } from './program.js';\nimport type { AxField } from './sig.js';\nimport type { AxFieldValue, AxGenOut } from './types.js';\n\nconst colorLog = new ColorLog();\n\nexport const updateProgressBar = (\n  current: number,\n  total: number,\n  success: number,\n  _elapsedTime: number, // in seconds\n  msg: string,\n  progressBarWidth = 20 // Default width of the progress bar\n): void => {\n  const percentage = ((current / total) * 100).toFixed(1);\n  const filledBarLength = Math.round((progressBarWidth * current) / total);\n  const emptyBarLength = progressBarWidth - filledBarLength;\n  const filledBar = colorLog.blueBright(''.repeat(filledBarLength));\n  const emptyBar = ' '.repeat(emptyBarLength);\n  const successRate = total > 0 ? ((success / total) * 100).toFixed(1) : '0.0';\n\n  // More user-friendly message\n  const friendlyMsg = msg.includes('Running MIPROv2 optimization')\n    ? 'Testing prompt variations'\n    : msg.includes('Tuning Prompt')\n      ? 'Generating training examples'\n      : msg;\n\n  // Use newline instead of carriage return to avoid overwriting structured logs\n  process.stdout.write(\n    `  ${friendlyMsg}: ${current}/${total} (${colorLog.yellow(percentage)}%) |${filledBar}${emptyBar}| Success rate: ${colorLog.greenBright(successRate)}%\\n`\n  );\n};\n\nexport const validateValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): void => {\n  const ft = field.type ?? { name: 'string', isArray: false };\n\n  const validateSingleValue = (\n    expectedType: string,\n    val: Readonly<AxFieldValue>\n  ): boolean => {\n    switch (expectedType) {\n      case 'class':\n        return typeof val === 'string';\n      case 'code':\n        return typeof val === 'string';\n      case 'string':\n        return typeof val === 'string';\n      case 'number':\n        return typeof val === 'number';\n      case 'boolean':\n        return typeof val === 'boolean';\n      case 'date':\n        return val instanceof Date || typeof val === 'string';\n      case 'datetime':\n        return val instanceof Date || typeof val === 'string';\n      case 'json':\n        return typeof val === 'object' || typeof val === 'string';\n      default:\n        return false; // Unknown or unsupported type\n    }\n  };\n\n  const validImage = (val: Readonly<AxFieldValue>): boolean => {\n    if (\n      !val ||\n      typeof val !== 'object' ||\n      !('mimeType' in val) ||\n      !('data' in val)\n    ) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'image') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validImage(item)) {\n          msg = 'object ({ mimeType: string; data: string })';\n          break;\n        }\n      }\n    } else if (!validImage(value)) {\n      msg = 'object ({ mimeType: string; data: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  const validAudio = (val: Readonly<AxFieldValue>): boolean => {\n    if (!val || typeof val !== 'object' || !('data' in val)) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'audio') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validAudio(item)) {\n          msg = 'object ({ data: string; format?: string })';\n          break;\n        }\n      }\n    } else if (!validAudio(value)) {\n      msg = 'object ({ data: string; format?: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  let isValid = true;\n\n  if (ft.isArray) {\n    if (!Array.isArray(value)) {\n      isValid = false;\n    } else {\n      for (const item of value) {\n        if (!validateSingleValue(ft.name, item)) {\n          isValid = false;\n          break;\n        }\n      }\n    }\n  } else {\n    isValid = validateSingleValue(ft.name, value);\n  }\n\n  if (!isValid) {\n    const gotType = Array.isArray(value) ? 'array' : typeof value;\n    throw new Error(\n      `Validation failed: Expected '${field.name}' to be a ${field.type?.isArray ? 'an array of ' : ''}${ft.name} instead got '${gotType}' (${JSON.stringify(value)})`\n    );\n  }\n};\n\nexport function mergeProgramUsage(\n  usages: readonly AxProgramUsage[]\n): AxProgramUsage[] {\n  const usageMap: { [key: string]: AxProgramUsage } = {};\n\n  for (const usage of usages) {\n    const key = `${usage.ai}:${usage.model}`;\n\n    if (!usageMap[key]) {\n      usageMap[key] = { ...usage };\n      continue;\n    }\n\n    const currentUsage = usageMap[key];\n    if (currentUsage) {\n      const tokens = currentUsage.tokens ?? {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n      };\n      tokens.promptTokens += usage?.tokens?.promptTokens ?? 0;\n      tokens.completionTokens += usage?.tokens?.completionTokens ?? 0;\n      tokens.totalTokens += usage?.tokens?.totalTokens ?? 0;\n      currentUsage.tokens = tokens;\n    }\n  }\n\n  return Object.values(usageMap);\n}\n\n/**\n * Parses a markdown list from a string. This is a very forgiving parser that\n * will try to handle anything that looks vaguely like a markdown list.\n */\nexport const parseMarkdownList = (input: string): string[] => {\n  // Handle empty input\n  if (!input.trim()) {\n    return [];\n  }\n\n  const listBullets = new Set(['-', '*', '+']);\n  const numberedListRegex = /^\\d+[\\s]*[.)\\]]\\s*/;\n\n  const lines = input.split('\\n');\n  const list = [];\n\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    // Skip empty lines\n    if (!trimmedLine) {\n      continue;\n    }\n\n    // Check for bullet points\n    if (trimmedLine[0] && listBullets.has(trimmedLine[0])) {\n      list.push(trimmedLine.slice(1).trim());\n    }\n    // Check for numbered lists (e.g., \"1.\", \"2.\", etc.)\n    else if (numberedListRegex.test(trimmedLine)) {\n      list.push(trimmedLine.replace(numberedListRegex, '').trim());\n    }\n    // If it's not a list item and we haven't collected any items yet, do nothing\n    else if (list.length === 0) {\n      // Skip non-list lines at the beginning\n    }\n    // If we've already started collecting list items, then this non-list line\n    //is an error\n    else {\n      throw new Error('Could not parse markdown list: mixed content detected');\n    }\n  }\n\n  // If we didn't find any list items, throw error\n  if (list.length === 0) {\n    throw new Error('Could not parse markdown list: no valid list items found');\n  }\n\n  return list;\n};\n\nexport function mergeDeltas<OUT extends AxGenOut>(\n  base: AxGenDeltaOut<OUT>[],\n  currentDelta: AxGenDeltaOut<OUT>\n) {\n  type ValueTypeOfAxGenOut = AxGenOut[keyof AxGenOut];\n\n  const { index, delta, version } = currentDelta;\n\n  // Cast once for mutation  safe because we'll only assign validated keys\n  const target = base.find((b) => b.index === index)?.delta as Record<\n    string,\n    ValueTypeOfAxGenOut\n  >;\n\n  if (!target) {\n    base.push({ index, delta, version });\n    return base;\n  }\n\n  for (const key of Object.keys(delta)) {\n    const baseValue = target[key];\n    const deltaValue = (delta as Record<string, unknown>)[key];\n\n    if (baseValue === undefined && Array.isArray(deltaValue)) {\n      target[key] = [...deltaValue];\n    } else if (Array.isArray(baseValue) && Array.isArray(deltaValue)) {\n      // Concatenate arrays\n      target[key] = [...(baseValue as unknown[]), ...deltaValue];\n    } else if (\n      (baseValue === undefined || typeof baseValue === 'string') &&\n      typeof deltaValue === 'string'\n    ) {\n      // Concatenate strings\n      target[key] = `${baseValue ?? ''}${deltaValue}`;\n    } else {\n      // For all other types, overwrite with the new value\n      target[key] = deltaValue as ValueTypeOfAxGenOut;\n    }\n  }\n  return base;\n}\n\nexport class LRUCache<K, V> {\n  private cache = new Map<K, V>();\n  private readonly maxSize: number;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  get(key: K): V | undefined {\n    const value = this.cache.get(key);\n    if (value) {\n      // Refresh position by deleting and re-adding\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n    return value;\n  }\n\n  set(key: K, value: V): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxSize) {\n      // Remove oldest entry (first item in map)\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, value);\n  }\n}\n\nconst globalPrefixCache = new LRUCache<string, string[]>(500);\n\n/**\n * Checks if a streaming string matches a prefix, either fully or partially from the end.\n * For streaming content, partial matches are checked from shortest to longest since\n * the content grows at the end and we want to detect partial prefixes as they form.\n * @param content The string to check (potentially streaming)\n * @param prefix The prefix to look for\n * @param startIndex Optional starting index for the search\n * @returns\n *   - index >= 0: Position of full match\n *   - -1: No match found\n *   - -2: Partial match from the end\n *   - -3: String is only whitespace\n */\nexport function matchesContent(\n  content: string,\n  prefix: string,\n  startIndex = 0,\n  prefixCache: LRUCache<string, string[]> = globalPrefixCache\n): number {\n  // Check if string starts with a markdown block with optional language\n  if (/^```[a-zA-Z]*\\s*$/.test(content)) {\n    return -4;\n  }\n\n  // Check if string is only whitespace\n  if (/^[\\s`]*$/.test(content)) {\n    return -3;\n  }\n\n  // First check if the complete prefix exists anywhere after startIndex\n  const exactMatchIndex = content.indexOf(prefix, startIndex);\n\n  if (exactMatchIndex !== -1) {\n    return exactMatchIndex;\n  }\n\n  // Get or create cached prefixes\n  const prefixes =\n    prefixCache.get(prefix) ??\n    Array.from({ length: prefix.length }, (_, i) => prefix.slice(0, i + 1));\n\n  // Set in cache if it wasn't there\n  if (!prefixCache.get(prefix)) {\n    prefixCache.set(prefix, prefixes);\n  }\n\n  // Check for partial matches at the end (for streaming content)\n  // We want to find the longest partial prefix that the content ends with\n  let longestPartialMatch = -1;\n\n  // Start from the longest prefix and work backwards to find the longest match\n  for (let i = prefixes.length - 1; i >= 0; i--) {\n    const partialPrefix = prefixes[i] as string;\n\n    // Check if content ends with this partial prefix\n    if (content.endsWith(partialPrefix)) {\n      longestPartialMatch = i;\n      break; // Found the longest match, no need to continue\n    }\n  }\n\n  // Return -2 for partial match, -1 for no match\n  return longestPartialMatch >= 0 ? -2 : -1;\n}\n\nexport const formatTime = (ms: number): string => {\n  const seconds = Math.floor(ms / 1000);\n  if (seconds < 60) return `${seconds}s`;\n\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  if (minutes < 60) return `${minutes}m ${remainingSeconds}s`;\n\n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;\n};\n\nexport const calculateETA = (\n  current: number,\n  total: number,\n  elapsedMs: number\n): string => {\n  if (current === 0) return 'calculating...';\n\n  const msPerItem = elapsedMs / current;\n  const remainingItems = total - current;\n  const etaMs = msPerItem * remainingItems;\n\n  return formatTime(etaMs);\n};\n\ninterface ProgressConfigInfo {\n  maxRounds: number;\n  batchSize: number;\n  earlyStoppingPatience: number;\n  costMonitoring: boolean;\n  verboseMode: boolean;\n  debugMode: boolean;\n}\n\nexport const updateDetailedProgress = <T extends AxGenOut = AxGenOut>(\n  roundIndex: number,\n  current: number,\n  total: number,\n  elapsedTime: number,\n  example: Readonly<AxExample>,\n  stats: Readonly<AxOptimizationStats>,\n  configInfo: Readonly<ProgressConfigInfo>,\n  result?: T,\n  error?: Error\n): void => {\n  // Clear line and create a formatted output\n  process.stdout.write('\\r\\x1b[K');\n\n  const percentage = ((current / total) * 100).toFixed(1);\n  const formattedTime = formatTime(elapsedTime);\n  const eta = calculateETA(current, total, elapsedTime);\n\n  // Basic progress info (always shown) - more user-friendly\n  let output = `Training round ${roundIndex + 1}/${configInfo.maxRounds}: ${current}/${total} (${percentage}%) [${formattedTime}, ETA: ${eta}]`;\n\n  // Add success stats in a cleaner format\n  const successRate =\n    stats.totalCalls > 0 ? (stats.successfulDemos / stats.totalCalls) * 100 : 0;\n  output += ` | Success rate: ${successRate.toFixed(1)}% (${stats.successfulDemos}/${stats.totalCalls})`;\n\n  // Additional info for verbose mode\n  if (configInfo.verboseMode || configInfo.debugMode) {\n    if (configInfo.costMonitoring) {\n      output += `\\n  Tokens: ~${stats.estimatedTokenUsage.toLocaleString()} total`;\n    }\n\n    output += `\\n  Batch: ${Math.floor(current / configInfo.batchSize) + 1}/${Math.ceil(total / configInfo.batchSize)}`;\n\n    if (configInfo.earlyStoppingPatience > 0 && stats.earlyStopping) {\n      output += `\\n  Best round: ${stats.earlyStopping.bestScoreRound + 1}, Patience: ${configInfo.earlyStoppingPatience}`;\n    }\n  }\n\n  // Debug mode gets even more info\n  if (configInfo.debugMode) {\n    // Truncate example keys for display\n    const exampleKeys = Object.keys(example)\n      .map((k) => {\n        const valueStr = JSON.stringify(example[k]);\n        const truncated =\n          valueStr.length > 30 ? `${valueStr.substring(0, 30)}...` : valueStr;\n        return `${k}: ${truncated}`;\n      })\n      .join(', ');\n\n    output += `\\n  Example: {${exampleKeys}}`;\n\n    if (error) {\n      output += `\\n  ERROR: ${error.message}`;\n    } else if (result) {\n      // Truncate result for display\n      const resultStr = JSON.stringify(result);\n      const truncatedResult =\n        resultStr.length > 50 ? `${resultStr.substring(0, 50)}...` : resultStr;\n      output += `\\n  Result: ${truncatedResult}`;\n    }\n\n    // Add temperature info\n    output += `\\n  Temperature: ${(0.7 + 0.001 * current).toFixed(3)}`;\n  }\n\n  console.log(output);\n};\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { parseLLMFriendlyDate, parseLLMFriendlyDateTime } from './datetime.js';\nimport { ValidationError } from './errors.js';\nimport type { GenDeltaOut } from './program.js';\nimport type { AxField, AxSignature } from './sig.js';\nimport type { AxGenOut } from './types.js';\nimport { matchesContent, parseMarkdownList } from './util.js';\n\nexport const extractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  content: string,\n  strictMode = false\n) => {\n  const xstate = { extractedFields: [], streamedIndex: {}, s: -1 };\n  streamingExtractValues(sig, values, xstate, content, { strictMode });\n  streamingExtractFinalValue(sig, values, xstate, content);\n\n  // Filter out internal fields\n  for (const field of sig.getOutputFields()) {\n    if (field.isInternal) {\n      delete values[field.name];\n    }\n  }\n};\n\nexport interface extractionState {\n  prevFields?: { field: AxField; s: number; e: number }[];\n  currField?: AxField;\n  currFieldIndex?: number;\n  inAssumedField?: boolean;\n  extractedFields: AxField[];\n  streamedIndex: Record<string, number>;\n  s: number;\n  inBlock?: boolean;\n}\n\n// Helper function to check for missing required fields\nconst checkMissingRequiredFields = (\n  _xstate: Readonly<extractionState>,\n  values: Record<string, unknown>,\n  outputFields: Readonly<AxField[]>\n) => {\n  const missingFields: AxField[] = [];\n\n  for (const field of outputFields) {\n    if (field && !field.isOptional && values[field.name] === undefined) {\n      missingFields.push(field);\n    }\n  }\n\n  if (missingFields.length > 0) {\n    throw new ValidationError({\n      message: `Required ${missingFields.length === 1 ? 'field' : 'fields'} not found`,\n      fields: missingFields,\n    });\n  }\n};\n\nexport interface StreamingExtractValuesOptions {\n  strictMode?: boolean;\n  skipEarlyFail?: boolean;\n}\n\nexport const streamingExtractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  content: string,\n  { strictMode, skipEarlyFail }: StreamingExtractValuesOptions = {}\n) => {\n  const fields = sig.getOutputFields();\n  let expectedField: AxField | undefined;\n\n  for (const [index, field] of fields.entries()) {\n    // If the field is the current field and it's not assumed, skip it\n    if (index === xstate.currFieldIndex && !xstate.inAssumedField) {\n      continue;\n    }\n\n    // If field is already in values and it's not the current field and it's not assumed, skip it\n    if (\n      field.name in values &&\n      !(index === xstate.currFieldIndex && xstate.inAssumedField)\n    ) {\n      continue;\n    }\n\n    const isFirst = xstate.extractedFields.length === 0;\n    const prefix = `${(isFirst ? '' : '\\n') + field.title}:`;\n\n    let e = matchesContent(content, prefix, xstate.s);\n    let prefixLen = prefix.length;\n\n    switch (e) {\n      case -1:\n        if (skipEarlyFail) {\n          continue;\n        }\n\n        // If there is only one field then we assume the content is streaming to the first field\n        // Note: optimization for single field responses\n        if (\n          !strictMode &&\n          fields.length === 1 &&\n          xstate.currField === undefined\n        ) {\n          xstate.inAssumedField = true;\n          expectedField = field;\n          prefixLen = 0;\n          e = 0;\n          break;\n        }\n\n        // if multiple fields, we need to validate the field name of the first required field\n        if (xstate.currField === undefined && !field.isOptional) {\n          throw new ValidationError({\n            message: 'Expected (Required) field not found',\n            fields: [field],\n          });\n        }\n\n        expectedField = field.isOptional ? undefined : field;\n        continue; // Field is not found, continue to the next field\n      case -2:\n        return true; // Partial match at end, skip and gather more content\n      case -3:\n        return true; // String is only whitespace, skip and gather more content\n      case -4:\n        xstate.inBlock = true;\n        return true; // String is only backticks, skip and gather more content\n    }\n    // We found a field!!!\n\n    // If the field we found is not the expected field, throw an error\n    if (expectedField && expectedField.name !== field.name) {\n      throw new ValidationError({\n        message: 'Expected (Required) field not found',\n        fields: [expectedField],\n      });\n    }\n\n    if (xstate.currField !== undefined && xstate.inAssumedField) {\n      xstate.inAssumedField = false;\n      xstate.streamedIndex[xstate.currField.name] = 0;\n      xstate.currField = undefined;\n    }\n\n    // Lets wrap up the last field which is still the current field\n    if (xstate.currField) {\n      const val = content.substring(xstate.s, e).trim();\n      const parsedValue = validateAndParseFieldValue(xstate.currField, val);\n      if (parsedValue !== undefined) {\n        values[xstate.currField.name] = parsedValue;\n      }\n      if (xstate.prevFields) {\n        xstate.prevFields?.push({ field: xstate.currField, s: xstate.s, e });\n      } else {\n        xstate.prevFields = [{ field: xstate.currField, s: xstate.s, e }];\n      }\n    }\n\n    // Lets update the state for the new current field\n\n    xstate.s = e + prefixLen;\n    xstate.currField = field;\n    xstate.currFieldIndex = index;\n\n    if (!xstate.extractedFields.includes(field)) {\n      xstate.extractedFields.push(field);\n    }\n\n    if (xstate.streamedIndex[field.name] === undefined) {\n      xstate.streamedIndex[field.name] = 0;\n    }\n  }\n};\n\nexport const streamingExtractFinalValue = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  content: string\n) => {\n  if (xstate.currField) {\n    const val = content.substring(xstate.s).trim();\n\n    const parsedValue = validateAndParseFieldValue(xstate.currField, val);\n    if (parsedValue !== undefined) {\n      values[xstate.currField.name] = parsedValue;\n    }\n  }\n  // Check all previous required fields before processing current field\n  checkMissingRequiredFields(xstate, values, sig.getOutputFields());\n};\n\nconst convertValueToType = (\n  field: Readonly<AxField>,\n  val: string,\n  required = false\n) => {\n  switch (field.type?.name) {\n    case 'code':\n      return extractBlock(val);\n\n    case 'string':\n      return val;\n\n    case 'number': {\n      const v = Number(val);\n      if (Number.isNaN(v)) {\n        if (field.isOptional && !required) {\n          return;\n        }\n        throw new Error('Invalid number');\n      }\n      return v;\n    }\n\n    case 'boolean': {\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      const v = val.toLowerCase();\n      if (v === 'true') {\n        return true;\n      }\n      if (v === 'false') {\n        return false;\n      }\n      if (field.isOptional && !required) {\n        return;\n      }\n      throw new Error('Invalid boolean');\n    }\n    case 'date':\n      return parseLLMFriendlyDate(field, val, required);\n\n    case 'datetime':\n      return parseLLMFriendlyDateTime(field, val, required);\n\n    case 'class': {\n      const className = val;\n      if (field.type.options && !field.type.options.includes(className)) {\n        if (field.isOptional) {\n          return;\n        }\n        throw new Error(\n          `Invalid class '${val}', expected one of the following: ${field.type.options.join(', ')}`\n        );\n      }\n      return className as string;\n    }\n\n    default:\n      return val as string; // Unknown type\n  }\n};\n\nexport function* yieldDelta<OUT extends AxGenOut>(\n  content: string,\n  field: Readonly<AxField>,\n  s: number,\n  e: number,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  index: number\n): GenDeltaOut<OUT> {\n  const { name: fieldName, isInternal } = field;\n  const { isArray: fieldIsArray, name: fieldTypeName } = field.type ?? {};\n\n  if (\n    isInternal ||\n    fieldIsArray ||\n    (fieldTypeName && fieldTypeName !== 'string' && fieldTypeName !== 'code')\n  ) {\n    return;\n  }\n\n  const pos = xstate.streamedIndex[fieldName] ?? 0;\n  const isFirstChunk = pos === 0;\n\n  const d1 = content.substring(s + pos, e);\n  if (d1.length === 0) {\n    return;\n  }\n\n  // Remove trailing whitespace, tabs, and newlines\n  let d2 = d1.replace(/\\s+$/, '');\n\n  // If this field is a \"code\" type, remove trailing backticks\n  if (xstate.currField?.type?.name === 'code') {\n    d2 = d2.replace(/\\s*```\\s*$/, '');\n  }\n\n  // Only trim start for the first chunk\n  let d3 = isFirstChunk ? d2.trimStart() : d2;\n\n  if (xstate.currField?.type?.name === 'code') {\n    // Remove any leading triple-backtick fences (with optional language specifier)\n    d3 = d3.replace(/^[ ]*```[a-zA-Z0-9]*\\n\\s*/, '');\n  }\n\n  if (d3.length > 0) {\n    yield { index, delta: { [fieldName]: d3 } as unknown as Partial<OUT> };\n    xstate.streamedIndex[fieldName] = pos + d2.length;\n  }\n}\n\nexport function* streamValues<OUT extends AxGenOut>(\n  sig: Readonly<AxSignature>,\n  content: string,\n  values: Readonly<Record<string, OUT>>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  index: number\n): GenDeltaOut<OUT> {\n  for (const prevField of xstate.prevFields ?? []) {\n    const { field, s, e } = prevField;\n    yield* yieldDelta<OUT>(content, field, s, e, xstate, index);\n  }\n  xstate.prevFields = undefined;\n\n  if (!xstate.currField || xstate.currField.isInternal) {\n    return;\n  }\n\n  yield* yieldDelta<OUT>(\n    content,\n    xstate.currField,\n    xstate.s,\n    content.length,\n    xstate,\n    index\n  );\n\n  const outputFields = sig.getOutputFields();\n\n  for (const key of Object.keys(values)) {\n    const field = outputFields.find((f) => f.name === key);\n    if (!field || field.isInternal) {\n      continue;\n    }\n\n    const value = values[key];\n\n    if (Array.isArray(value)) {\n      const s = xstate.streamedIndex?.[key] ?? 0;\n      const v = value.slice(s);\n      if (v && v.length > 0) {\n        yield { index, delta: { [key]: v } as unknown as Partial<OUT> };\n        xstate.streamedIndex[key] = s + v.length;\n      }\n      continue;\n    }\n\n    if (!xstate.streamedIndex[key]) {\n      yield { index, delta: { [key]: value } as unknown as Partial<OUT> };\n      xstate.streamedIndex[key] = 1;\n    }\n  }\n}\n\nfunction validateAndParseFieldValue(\n  field: Readonly<AxField>,\n  fieldValue: string | undefined\n): unknown {\n  if (\n    !fieldValue ||\n    fieldValue === '' ||\n    /^(null|undefined)\\s*$/i.test(fieldValue)\n  ) {\n    if (field.isOptional) {\n      return;\n    }\n    throw new ValidationError({\n      message: 'Required field is missing',\n      fields: [field],\n      value: fieldValue,\n    });\n  }\n\n  let value: unknown | undefined;\n\n  if (field.type?.name === 'json') {\n    try {\n      const text = extractBlock(fieldValue);\n      value = JSON.parse(text);\n      return value;\n    } catch (e) {\n      throw new ValidationError({\n        message: `Invalid JSON: ${(e as Error).message}`,\n        fields: [field],\n        value: fieldValue,\n      });\n    }\n  }\n\n  if (field.type?.isArray) {\n    try {\n      try {\n        value = JSON.parse(fieldValue);\n      } catch {\n        // If JSON parsing fails, try markdown parsing\n        value = parseMarkdownList(fieldValue);\n      }\n      if (!Array.isArray(value)) {\n        throw new Error('Expected an array');\n      }\n    } catch (e) {\n      throw new ValidationError({\n        message: `Invalid Array: ${(e as Error).message}`,\n        fields: [field],\n        value: fieldValue,\n      });\n    }\n  }\n\n  try {\n    if (Array.isArray(value)) {\n      for (const [index, item] of value.entries()) {\n        if (item !== undefined) {\n          const v = typeof item === 'string' ? item.trim() : item;\n          value[index] = convertValueToType(field, v, true);\n        }\n      }\n    } else {\n      value = convertValueToType(field, fieldValue);\n    }\n  } catch (e) {\n    throw new ValidationError({\n      message: (e as Error).message,\n      fields: [field],\n      value: fieldValue,\n    });\n  }\n\n  if (typeof value === 'string' && value === '') {\n    return undefined;\n  }\n\n  return value;\n}\n\nexport const extractBlock = (input: string): string => {\n  const markdownBlockPattern = /```([A-Za-z]*)\\n([\\s\\S]*?)\\n```/g;\n  const match = markdownBlockPattern.exec(input);\n  if (!match) {\n    return input;\n  }\n  if (match.length === 3) {\n    return match[2] as string;\n  }\n  if (match.length === 2) {\n    return match[1] as string;\n  }\n  return input;\n};\n", "import type { AxAIMemory } from '../mem/types.js';\n\nimport type { extractionState } from './extract.js';\nimport type { AxField } from './sig.js';\nimport type { AxFieldValue, AxGenOut } from './types.js';\n\nexport type AxFieldProcessorProcess = (\n  value: AxFieldValue,\n  context?: Readonly<{\n    values?: AxGenOut;\n    sessionId?: string;\n    done?: boolean;\n  }>\n) => unknown | Promise<unknown>;\n\nexport type AxStreamingFieldProcessorProcess = (\n  value: string,\n  context?: Readonly<{\n    values?: AxGenOut;\n    sessionId?: string;\n    done?: boolean;\n  }>\n) => unknown | Promise<unknown>;\nexport interface AxFieldProcessor {\n  field: Readonly<AxField>;\n\n  /**\n   * Process the field value and return a new value (or undefined if no update is needed).\n   * The returned value may be merged back into memory.\n   * @param value - The current field value.\n   * @param context - Additional context (e.g. memory and session id).\n   */\n  process: AxFieldProcessorProcess | AxStreamingFieldProcessorProcess;\n}\n\n/**\n * For synchronous responses: iterates over registered field processors,\n * passing in the current values. If a processor returns a new value,\n * that value is merged into memory with a special role ('processor').\n */\nexport async function processFieldProcessors(\n  fieldProcessors: AxFieldProcessor[],\n  values: AxGenOut,\n  mem: AxAIMemory,\n  sessionId?: string\n) {\n  for (const processor of fieldProcessors) {\n    if (values[processor.field.name] === undefined) {\n      continue;\n    }\n\n    const processFn = processor.process as AxFieldProcessorProcess;\n    const result = await processFn(values[processor.field.name], {\n      sessionId,\n      values,\n      done: true,\n    });\n    addToMemory(processor.field, mem, result, sessionId);\n  }\n}\n\n/**\n * For streaming responses: processes each streaming field processor\n * and yields delta updates if they return new values.\n */\nexport async function processStreamingFieldProcessors(\n  fieldProcessors: AxFieldProcessor[],\n  content: string,\n  xstate: Readonly<extractionState>,\n  mem: AxAIMemory,\n  values: AxGenOut,\n  sessionId: string | undefined,\n  done = false\n): Promise<void> {\n  for (const processor of fieldProcessors) {\n    if (xstate.currField?.name !== processor.field.name) {\n      continue;\n    }\n\n    let value = content.substring(xstate.s);\n\n    if (xstate.currField?.type?.name === 'code') {\n      // remove markdown block\n      value = value.replace(/^[ ]*```[a-zA-Z0-9]*\\n\\s*/, '');\n      value = value.replace(/\\s*```\\s*$/, '');\n    }\n    const processFn = processor.process as AxStreamingFieldProcessorProcess;\n    const result = await processFn(value, {\n      sessionId,\n      values,\n      done,\n    });\n\n    addToMemory(xstate.currField, mem, result, sessionId);\n  }\n}\n\nconst addToMemory = (\n  field: Readonly<AxField>,\n  mem: AxAIMemory,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  result: any | any[],\n  sessionId?: string\n) => {\n  if (\n    result === undefined ||\n    (typeof result === 'string' &&\n      (result === '' || /^(null|undefined)\\s*$/i.test(result)))\n  ) {\n    return;\n  }\n\n  const resultText = JSON.stringify(\n    result,\n    (_key, value) => (typeof value === 'bigint' ? Number(value) : value),\n    2\n  );\n\n  const text = getFieldProcessingMessage(field, resultText);\n  mem.addRequest(\n    [{ role: 'user', content: [{ type: 'text', text }] }],\n    sessionId\n  );\n  mem.addTag('processor', sessionId);\n};\n\nfunction getFieldProcessingMessage(\n  field: Readonly<AxField>,\n  resultText: string\n) {\n  const isCodeField = field.type?.name === 'code';\n  const fieldTitle = field.title;\n\n  if (isCodeField) {\n    return `Code in the field \"${fieldTitle}\" was executed. The code execution produced the following output: ${resultText}`;\n  }\n  return `The field \"${fieldTitle}\" was processed. The field contents were transformed into the following output: ${resultText}`;\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport type { AxChatResponse, AxModelUsage } from '../ai/types.js';\nimport { mergeFunctionCalls } from '../ai/util.js';\nimport type { AxAIMemory } from '../mem/types.js';\n\nimport {\n  type AxAssertion,\n  type AxStreamingAssertion,\n  assertAssertions,\n  assertStreamingAssertions,\n} from './asserts.js';\nimport {\n  extractValues,\n  streamingExtractFinalValue,\n  streamingExtractValues,\n  streamValues,\n} from './extract.js';\nimport {\n  type AxFieldProcessor,\n  processFieldProcessors,\n  processStreamingFieldProcessors,\n} from './fieldProcessor.js';\nimport { parseFunctionCalls, processFunctions } from './functions.js';\nimport type { AxResponseHandlerArgs, InternalAxGenState } from './generate.js';\nimport type { AsyncGenDeltaOut, DeltaOut } from './program.js';\nimport type { AxSignature } from './sig.js';\nimport type { AxGenOut } from './types.js';\n\ntype ProcessStreamingResponseArgs = Readonly<\n  AxResponseHandlerArgs<ReadableStream<AxChatResponse>>\n> & {\n  states: InternalAxGenState[];\n  usage: AxModelUsage[];\n  asserts: AxAssertion[];\n  streamingAsserts: AxStreamingAssertion[];\n  fieldProcessors: AxFieldProcessor[];\n  streamingFieldProcessors: AxFieldProcessor[];\n  thoughtFieldName: string;\n  signature: AxSignature;\n  excludeContentFromTrace: boolean;\n  functionResultFormatter?: (result: unknown) => string;\n};\n\nexport async function* processStreamingResponse<OUT extends AxGenOut>({\n  res,\n  usage,\n  states,\n  ...args\n}: ProcessStreamingResponseArgs): AsyncGenDeltaOut<OUT> {\n  const skipEarlyFail =\n    (args.ai.getFeatures().functionCot ?? false) &&\n    args.functions !== undefined &&\n    args.functions.length > 0;\n\n  // Handle ReadableStream async iteration for browser compatibility\n  const reader = res.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n      const v = value;\n      if (v.modelUsage) {\n        usage.push(v.modelUsage);\n      }\n\n      for (const result of v.results) {\n        if (\n          (!result.content || result.content === '') &&\n          (!result.thought || result.thought === '') &&\n          (!result.functionCalls || result.functionCalls.length === 0)\n        ) {\n          continue;\n        }\n\n        const state = states.find((s) => s.index === result.index);\n        if (!state) {\n          throw new Error(`No state found for result (index: ${result.index})`);\n        }\n\n        yield* ProcessStreamingResponse<OUT>({\n          ...args,\n          result,\n          skipEarlyFail,\n          state,\n        });\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n\n  // Finalize the streams\n  for (const state of states) {\n    yield* finalizeStreamingResponse<OUT>({\n      ...args,\n      state,\n    });\n  }\n}\n\ntype ProcessStreamingResponseArgs2 = Readonly<\n  Omit<\n    ProcessStreamingResponseArgs,\n    | 'res'\n    | 'states'\n    | 'usage'\n    | 'excludeContentFromTrace'\n    | 'ai'\n    | 'model'\n    | 'traceId'\n    | 'functions'\n    | 'span'\n    | 'fieldProcessors'\n  > & {\n    result: AxChatResponse['results'][number];\n    skipEarlyFail: boolean;\n    state: InternalAxGenState;\n  }\n>;\n\nasync function* ProcessStreamingResponse<OUT extends AxGenOut>({\n  result,\n  mem,\n  sessionId,\n  strictMode,\n  skipEarlyFail,\n  state,\n  signature,\n  streamingFieldProcessors,\n  thoughtFieldName,\n  streamingAsserts,\n  asserts,\n}: ProcessStreamingResponseArgs2): AsyncGenDeltaOut<OUT> {\n  if (result.functionCalls && result.functionCalls.length > 0) {\n    mergeFunctionCalls(state.functionCalls, result.functionCalls);\n    mem.updateResult(\n      {\n        name: result.name,\n        content: result.content,\n        functionCalls: state.functionCalls,\n        delta: result.functionCalls?.[0]?.function?.params as string,\n        index: result.index,\n      },\n      sessionId\n    );\n  } else if (result.content && result.content.length > 0) {\n    if (result.thought && result.thought.length > 0) {\n      yield {\n        index: result.index,\n        delta: { [thoughtFieldName]: result.thought } as Partial<OUT>,\n      };\n    }\n\n    state.content += result.content;\n    mem.updateResult(\n      {\n        name: result.name,\n        content: state.content,\n        delta: result.content,\n        index: result.index,\n      },\n      sessionId\n    );\n\n    const skip = streamingExtractValues(\n      signature,\n      state.values,\n      state.xstate,\n      state.content,\n      { strictMode, skipEarlyFail }\n    );\n\n    if (skip) {\n      return;\n    }\n\n    if (streamingAsserts.length !== 0) {\n      await assertStreamingAssertions(\n        streamingAsserts,\n        state.xstate,\n        state.content\n      );\n    }\n\n    if (streamingFieldProcessors.length !== 0) {\n      await processStreamingFieldProcessors(\n        streamingFieldProcessors,\n        state.content,\n        state.xstate,\n        mem,\n        state.values,\n        sessionId\n      );\n    }\n\n    yield* streamValues<OUT>(\n      signature,\n      state.content,\n      state.values as Record<string, OUT>,\n      state.xstate,\n      result.index\n    );\n\n    await assertAssertions(asserts, state.values);\n  } else if (result.thought && result.thought.length > 0) {\n    state.values[thoughtFieldName] =\n      (state.values[thoughtFieldName] ?? '') + result.thought;\n\n    yield {\n      index: result.index,\n      delta: { [thoughtFieldName]: result.thought } as Partial<OUT>,\n    };\n  }\n\n  if (result.finishReason === 'length') {\n    throw new Error(\n      `Max tokens reached before completion\\nContent: ${state.content}`\n    );\n  }\n}\n\ntype FinalizeStreamingResponseArgs = Readonly<\n  Omit<ProcessStreamingResponseArgs, 'res' | 'states' | 'usage'> & {\n    state: InternalAxGenState;\n  }\n>;\n\nexport async function* finalizeStreamingResponse<OUT extends AxGenOut>({\n  state,\n  signature,\n  ai,\n  model,\n  functions,\n  mem,\n  sessionId,\n  traceId,\n  span,\n  excludeContentFromTrace,\n  streamingAsserts,\n  asserts,\n  fieldProcessors,\n  streamingFieldProcessors,\n  functionResultFormatter,\n}: FinalizeStreamingResponseArgs) {\n  const funcs = parseFunctionCalls(\n    ai,\n    state.functionCalls,\n    state.values,\n    model\n  );\n  if (funcs) {\n    if (!functions) {\n      throw new Error('Functions are not defined');\n    }\n    const fx = await processFunctions({\n      ai,\n      functionList: functions,\n      functionCalls: funcs,\n      mem,\n      sessionId,\n      traceId,\n      span,\n      index: state.index,\n      excludeContentFromTrace,\n      functionResultFormatter,\n    });\n    state.functionsExecuted = new Set([...state.functionsExecuted, ...fx]);\n  } else {\n    streamingExtractFinalValue(\n      signature,\n      state.values,\n      state.xstate,\n      state.content\n    );\n\n    await assertStreamingAssertions(\n      streamingAsserts,\n      state.xstate,\n      state.content,\n      true\n    );\n    await assertAssertions(asserts, state.values);\n\n    if (fieldProcessors.length) {\n      await processFieldProcessors(\n        fieldProcessors,\n        state.values,\n        mem,\n        sessionId\n      );\n    }\n\n    if (streamingFieldProcessors.length !== 0) {\n      await processStreamingFieldProcessors(\n        streamingFieldProcessors,\n        state.content,\n        state.xstate,\n        mem,\n        state.values,\n        sessionId,\n        true\n      );\n    }\n\n    yield* streamValues<OUT>(\n      signature,\n      state.content,\n      state.values as Record<string, OUT>,\n      state.xstate,\n      state.index\n    );\n  }\n}\n\nexport async function* processResponse<OUT extends AxGenOut>({\n  ai,\n  res,\n  mem,\n  sessionId,\n  traceId,\n  functions,\n  span,\n  strictMode,\n  states,\n  usage,\n  excludeContentFromTrace,\n  asserts,\n  fieldProcessors,\n  thoughtFieldName,\n  signature,\n  functionResultFormatter,\n}: Readonly<AxResponseHandlerArgs<AxChatResponse>> & {\n  states: InternalAxGenState[];\n  usage: AxModelUsage[];\n  excludeContentFromTrace: boolean;\n  asserts: AxAssertion[];\n  fieldProcessors: AxFieldProcessor[];\n  thoughtFieldName: string;\n  signature: AxSignature;\n  functionResultFormatter?: (result: unknown) => string;\n}): AsyncGenDeltaOut<OUT> {\n  const results = res.results ?? [];\n\n  mem.addResponse(results, sessionId);\n\n  for (const result of results) {\n    const state = states[result.index];\n\n    if (!state) {\n      throw new Error(`No state found for result (index: ${result.index})`);\n    }\n\n    if (res.modelUsage) {\n      usage.push(res.modelUsage);\n    }\n\n    if (result.functionCalls?.length) {\n      const funcs = parseFunctionCalls(ai, result.functionCalls, state.values);\n      if (funcs) {\n        if (!functions) {\n          throw new Error('Functions are not defined');\n        }\n\n        const fx = await processFunctions({\n          ai,\n          functionList: functions,\n          functionCalls: funcs,\n          mem,\n          sessionId,\n          traceId,\n          span,\n          excludeContentFromTrace,\n          index: result.index,\n          functionResultFormatter,\n        });\n\n        state.functionsExecuted = new Set([...state.functionsExecuted, ...fx]);\n      }\n    } else if (result.content) {\n      if (result.thought && result.thought.length > 0) {\n        state.values[thoughtFieldName] = result.thought;\n      }\n\n      extractValues(signature, state.values, result.content, strictMode);\n      await assertAssertions(asserts, state.values);\n\n      if (fieldProcessors.length) {\n        await processFieldProcessors(\n          fieldProcessors,\n          state.values,\n          mem,\n          sessionId\n        );\n      }\n    }\n\n    if (result.finishReason === 'length') {\n      throw new Error(\n        `Max tokens reached before completion\\nContent: ${result.content}`\n      );\n    }\n  }\n\n  const values = states.map((s) => s.values);\n\n  // Strip out values whose signature fields have isInternal: true\n  for (const v of values) {\n    for (const field of signature.getOutputFields()) {\n      if (field.isInternal) {\n        delete v[field.name];\n      }\n    }\n  }\n\n  const outputFields = signature.getOutputFields();\n  const deltas: DeltaOut<OUT>[] = values.map((v, index) => {\n    const delta: Record<string, unknown> = {};\n    for (const field of outputFields) {\n      if (field.isInternal) {\n        continue;\n      }\n      delta[field.name] = v[field.name];\n    }\n    // Include thought field if it exists in the values\n    if (v[thoughtFieldName] !== undefined) {\n      delta[thoughtFieldName] = v[thoughtFieldName];\n    }\n    return { index, delta: delta as Partial<OUT> };\n  });\n\n  for (const delta of deltas) {\n    yield delta;\n  }\n}\n\nexport function shouldContinueSteps(\n  mem: AxAIMemory,\n  stopFunction: string | undefined,\n  states: InternalAxGenState[],\n  sessionId?: string\n) {\n  const lastMemItem = mem.getLast(sessionId);\n\n  if (!lastMemItem) {\n    return true;\n  }\n\n  for (const [index, state] of states.entries()) {\n    const stopFunctionExecuted =\n      stopFunction && state.functionsExecuted.has(stopFunction);\n\n    const chat = lastMemItem.chat[index];\n\n    if (!chat) {\n      throw new Error(`No chat message found for result (index: ${index})`);\n    }\n\n    const isFunction = lastMemItem.role === 'function';\n    const isProcessor = lastMemItem.tags\n      ? lastMemItem.tags.some((tag) => tag === 'processor')\n      : false;\n\n    // If any state has stop function executed, return false immediately\n    if (isFunction && stopFunction && stopFunctionExecuted) {\n      return false;\n    }\n\n    // If this state doesn't meet continuation criteria, return false\n    if (!(isFunction || isProcessor)) {\n      return false;\n    }\n  }\n\n  // All states meet continuation criteria\n  return true;\n}\n", "import type { AxTunable, AxUsable } from './program.js';\nimport type { AxGenIn, AxGenOut } from './types.js';\n\ntype AxInstanceRegistryItem<\n  T extends AxTunable<IN, OUT>,\n  IN extends AxGenIn,\n  OUT extends AxGenOut,\n> = T & AxUsable;\n\nexport class AxInstanceRegistry<\n  T extends AxTunable<IN, OUT>,\n  IN extends AxGenIn,\n  OUT extends AxGenOut,\n> {\n  private reg: Set<AxInstanceRegistryItem<T, IN, OUT>>; // To track keys for iteration\n\n  constructor() {\n    this.reg = new Set();\n  }\n\n  register(instance: AxInstanceRegistryItem<T, IN, OUT>): void {\n    this.reg.add(instance);\n  }\n\n  *[Symbol.iterator]() {\n    const items = Array.from(this.reg);\n    for (let i = 0; i < items.length; i++) {\n      yield items[i];\n    }\n  }\n}\n", "// Updated type definitions\n\nexport type TypeNotClass =\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'json'\n  | 'image'\n  | 'audio'\n  | 'datetime'\n  | 'date'\n  | 'code';\nexport type Type = TypeNotClass | 'class';\nexport type ParsedIdentifier = string;\nexport type ParsedString = string;\n\nexport type ParsedSignature = {\n  desc?: string;\n  inputs: InputParsedField[];\n  outputs: OutputParsedField[];\n};\n\nexport type InputParsedField = {\n  name: ParsedIdentifier;\n  desc?: string;\n  type?: { name: TypeNotClass; isArray: boolean };\n  isOptional?: boolean;\n};\n\nexport type OutputParsedField = {\n  name: ParsedIdentifier;\n  desc?: string;\n  type?:\n    | { name: TypeNotClass; isArray: boolean; options?: string[] }\n    | { name: 'class'; isArray: boolean; options: string[] };\n  isOptional?: boolean;\n  isInternal?: boolean;\n};\n\nimport { axGlobals } from './globals.js';\n\nclass SignatureValidationError extends Error {\n  constructor(\n    message: string,\n    public readonly position: number,\n    public readonly context: string,\n    public readonly suggestion?: string\n  ) {\n    super(message);\n    this.name = 'SignatureValidationError';\n  }\n}\n\nclass SignatureParser {\n  private input: string;\n  private position: number;\n  private currentFieldName: string | null = null;\n  private currentSection: 'description' | 'inputs' | 'outputs' = 'description';\n\n  constructor(input: string) {\n    this.input = input.trim();\n    this.position = 0;\n\n    if (!this.input) {\n      throw new SignatureValidationError(\n        'Empty signature provided',\n        0,\n        '',\n        'A signature must contain at least input and output fields separated by \"->\". Example: \"userQuery:string -> aiResponse:string\"'\n      );\n    }\n  }\n\n  parse(): ParsedSignature {\n    try {\n      this.skipWhitespace();\n      const optionalDesc = this.parseParsedString();\n      this.skipWhitespace();\n\n      this.currentSection = 'inputs';\n      // Use the specialized input field parser\n      const inputs = this.parseFieldList(\n        this.parseInputField.bind(this),\n        'input'\n      );\n      this.skipWhitespace();\n\n      if (this.position >= this.input.length) {\n        throw new SignatureValidationError(\n          'Incomplete signature: Missing output section',\n          this.position,\n          this.getErrorContext(),\n          'Add \"->\" followed by output fields. Example: \"-> responseText:string\"'\n        );\n      }\n\n      this.expectArrow();\n      this.skipWhitespace();\n\n      if (this.position >= this.input.length) {\n        throw new SignatureValidationError(\n          'Incomplete signature: No output fields specified after \"->\"',\n          this.position,\n          this.getErrorContext(),\n          'Add at least one output field. Example: \"-> responseText:string\"'\n        );\n      }\n\n      this.currentSection = 'outputs';\n      // Use the specialized output field parser\n      const outputs = this.parseFieldList(\n        this.parseOutputField.bind(this),\n        'output'\n      );\n\n      // Check for any remaining content that shouldn't be there\n      this.skipWhitespace();\n      if (this.position < this.input.length) {\n        const remaining = this.input.slice(this.position);\n        throw new SignatureValidationError(\n          `Unexpected content after signature: \"${remaining}\"`,\n          this.position,\n          this.getErrorContext(),\n          'Remove any extra content after the output fields'\n        );\n      }\n\n      // Validate the parsed signature\n      this.validateParsedSignature({\n        desc: optionalDesc?.trim(),\n        inputs,\n        outputs,\n      });\n\n      return {\n        desc: optionalDesc?.trim(),\n        inputs,\n        outputs,\n      };\n    } catch (error) {\n      if (error instanceof SignatureValidationError) {\n        throw error;\n      }\n\n      // Wrap other errors with better context\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      throw new SignatureValidationError(\n        errorMessage,\n        this.position,\n        this.getErrorContext()\n      );\n    }\n  }\n\n  private validateParsedSignature(signature: Readonly<ParsedSignature>): void {\n    // Check for duplicate field names within inputs\n    const inputNames = new Set<string>();\n    for (const field of signature.inputs) {\n      if (inputNames.has(field.name)) {\n        throw new SignatureValidationError(\n          `Duplicate input field name: \"${field.name}\"`,\n          0,\n          '',\n          'Each field name must be unique within the signature'\n        );\n      }\n      inputNames.add(field.name);\n    }\n\n    // Check for duplicate field names within outputs\n    const outputNames = new Set<string>();\n    for (const field of signature.outputs) {\n      if (outputNames.has(field.name)) {\n        throw new SignatureValidationError(\n          `Duplicate output field name: \"${field.name}\"`,\n          0,\n          '',\n          'Each field name must be unique within the signature'\n        );\n      }\n      outputNames.add(field.name);\n    }\n\n    // Check for field names that appear in both inputs and outputs\n    for (const outputField of signature.outputs) {\n      if (inputNames.has(outputField.name)) {\n        throw new SignatureValidationError(\n          `Field name \"${outputField.name}\" appears in both inputs and outputs`,\n          0,\n          '',\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    // Validate that we have at least one input and one output\n    if (signature.inputs.length === 0) {\n      throw new SignatureValidationError(\n        'Signature must have at least one input field',\n        0,\n        '',\n        'Add an input field before \"->\". Example: \"userInput:string -> ...\"'\n      );\n    }\n\n    if (signature.outputs.length === 0) {\n      throw new SignatureValidationError(\n        'Signature must have at least one output field',\n        0,\n        '',\n        'Add an output field after \"->\". Example: \"... -> responseText:string\"'\n      );\n    }\n  }\n\n  private getErrorContext(): string {\n    const start = Math.max(0, this.position - 25);\n    const end = Math.min(this.input.length, this.position + 25);\n    const before = this.input.slice(start, this.position);\n    const after = this.input.slice(this.position, end);\n    const pointer = `${' '.repeat(before.length)}^`;\n\n    const lines = [\n      `Position ${this.position} in signature:`,\n      `\"${before}${after}\"`,\n      ` ${pointer}`,\n    ];\n\n    return lines.join('\\n');\n  }\n\n  private parseFieldList<T extends InputParsedField | OutputParsedField>(\n    parseFieldFn: () => T,\n    section: 'input' | 'output'\n  ): T[] {\n    const fields: T[] = [];\n    this.skipWhitespace();\n\n    if (this.position >= this.input.length) {\n      throw new SignatureValidationError(\n        `Empty ${section} section: Expected at least one field`,\n        this.position,\n        this.getErrorContext(),\n        `Add a ${section} field. Example: ${section === 'input' ? 'userInput:string' : 'responseText:string'}`\n      );\n    }\n\n    // Parse first field\n    try {\n      fields.push(parseFieldFn());\n    } catch (error) {\n      if (error instanceof SignatureValidationError) {\n        throw error;\n      }\n      throw new SignatureValidationError(\n        `Invalid first ${section} field: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        this.position,\n        this.getErrorContext()\n      );\n    }\n\n    this.skipWhitespace();\n\n    // Parse remaining fields\n    while (this.position < this.input.length) {\n      if (\n        this.input[this.position] === '-' &&\n        this.position + 1 < this.input.length &&\n        this.input[this.position + 1] === '>'\n      ) {\n        break;\n      }\n\n      if (this.match(',')) {\n        this.skipWhitespace();\n        if (this.position >= this.input.length) {\n          throw new SignatureValidationError(\n            `Unexpected end of input after comma in ${section} section`,\n            this.position,\n            this.getErrorContext(),\n            `Add another ${section} field after the comma`\n          );\n        }\n        try {\n          fields.push(parseFieldFn());\n        } catch (error) {\n          if (error instanceof SignatureValidationError) {\n            throw error;\n          }\n          throw new SignatureValidationError(\n            `Invalid ${section} field after comma: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            this.position,\n            this.getErrorContext()\n          );\n        }\n        this.skipWhitespace();\n      } else {\n        break;\n      }\n    }\n\n    return fields;\n  }\n\n  // -------------------------------\n  // Parse input fields (no \"class\" type and no internal flag)\n  // -------------------------------\n  private parseInputField(): InputParsedField {\n    this.skipWhitespace();\n    const name = this.parseParsedIdentifier();\n    this.currentFieldName = name;\n\n    // Validate field name for inputs\n    this.validateFieldName(name, 'input');\n\n    // Only the optional marker is allowed\n    let isOptional: boolean | undefined;\n    while (true) {\n      if (this.match('?')) {\n        isOptional = true;\n        continue;\n      }\n      if (this.match('!')) {\n        throw new SignatureValidationError(\n          `Input field \"${name}\" cannot use the internal marker \"!\"`,\n          this.position - 1,\n          this.getErrorContext(),\n          'Internal markers (!) are only allowed on output fields'\n        );\n      }\n      break;\n    }\n\n    let type: { name: TypeNotClass; isArray: boolean } | undefined;\n    this.skipWhitespace();\n    if (this.match(':')) {\n      this.skipWhitespace();\n      // Disallow the \"class\" type in input fields\n      if (/^class\\b/.test(this.input.slice(this.position))) {\n        throw new SignatureValidationError(\n          `Input field \"${name}\" cannot use the \"class\" type`,\n          this.position,\n          this.getErrorContext(),\n          'Class types are only allowed on output fields. Use \"string\" type for input classifications'\n        );\n      }\n      try {\n        const typeName = this.parseTypeNotClass();\n        const isArray = this.match('[]');\n        type = { name: typeName, isArray };\n\n        // Validate specific type constraints for input fields\n        if ((typeName === 'image' || typeName === 'audio') && isArray) {\n          throw new SignatureValidationError(\n            `Input field \"${name}\": Arrays of ${typeName} are not supported`,\n            this.position,\n            this.getErrorContext(),\n            `Use a single ${typeName} type instead: \"${typeName}\"`\n          );\n        }\n      } catch (error) {\n        if (error instanceof SignatureValidationError) {\n          throw error;\n        }\n        throw new SignatureValidationError(\n          `Input field \"${name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n          this.position,\n          this.getErrorContext()\n        );\n      }\n    }\n\n    this.skipWhitespace();\n    const desc = this.parseParsedString();\n\n    return {\n      name,\n      desc: desc?.trim(),\n      type,\n      isOptional,\n    };\n  }\n\n  // -------------------------------\n  // Parse output fields (supports both \"class\" type and the internal marker)\n  // -------------------------------\n  private parseOutputField(): OutputParsedField {\n    this.skipWhitespace();\n    const name = this.parseParsedIdentifier();\n    this.currentFieldName = name;\n\n    // Validate field name for outputs\n    this.validateFieldName(name, 'output');\n\n    let isOptional = false;\n    let isInternal = false;\n    while (true) {\n      if (this.match('?')) {\n        isOptional = true;\n        continue;\n      }\n      if (this.match('!')) {\n        isInternal = true;\n        continue;\n      }\n      break;\n    }\n\n    let type:\n      | { name: TypeNotClass; isArray: boolean; options?: string[] }\n      | { name: 'class'; isArray: boolean; options: string[] }\n      | undefined;\n    this.skipWhitespace();\n    if (this.match(':')) {\n      this.skipWhitespace();\n      if (this.match('class')) {\n        const isArray = this.match('[]');\n        this.skipWhitespace();\n        const classNamesString = this.parseParsedString();\n        if (!classNamesString) {\n          throw new SignatureValidationError(\n            `Output field \"${name}\": Missing class options after \"class\" type`,\n            this.position,\n            this.getErrorContext(),\n            'Add class names in quotes. Example: class \"positive, negative, neutral\"'\n          );\n        }\n        const options = classNamesString\n          .split(/[,|]/)\n          .map((s) => s.trim())\n          .filter((s) => s.length > 0);\n\n        if (options.length === 0) {\n          throw new SignatureValidationError(\n            `Output field \"${name}\": Empty class list provided`,\n            this.position,\n            this.getErrorContext(),\n            'Provide at least one class option. Example: \"positive, negative\"'\n          );\n        }\n\n        type = { name: 'class', isArray, options };\n      } else {\n        try {\n          const typeName = this.parseTypeNotClass();\n          const isArray = this.match('[]');\n          type = { name: typeName, isArray };\n\n          // Validate specific type constraints\n          if (typeName === 'image' && isArray) {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Arrays of images are not supported`,\n              this.position,\n              this.getErrorContext(),\n              'Use a single image type instead: \"image\"'\n            );\n          }\n\n          if (typeName === 'audio' && isArray) {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Arrays of audio are not supported`,\n              this.position,\n              this.getErrorContext(),\n              'Use a single audio type instead: \"audio\"'\n            );\n          }\n\n          if (typeName === 'image') {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Image type is not supported in output fields`,\n              this.position,\n              this.getErrorContext(),\n              'Image types can only be used in input fields'\n            );\n          }\n\n          if (typeName === 'audio') {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Audio type is not supported in output fields`,\n              this.position,\n              this.getErrorContext(),\n              'Audio types can only be used in input fields'\n            );\n          }\n        } catch (error) {\n          if (error instanceof SignatureValidationError) {\n            throw error;\n          }\n          throw new SignatureValidationError(\n            `Output field \"${name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n            this.position,\n            this.getErrorContext()\n          );\n        }\n      }\n    }\n\n    this.skipWhitespace();\n    const desc = this.parseParsedString();\n\n    return {\n      name,\n      desc: desc?.trim(),\n      type,\n      isOptional,\n      isInternal,\n    };\n  }\n\n  private validateFieldName(name: string, fieldType: 'input' | 'output'): void {\n    // Check for reserved/generic names that should be more descriptive\n    if (axGlobals.signatureStrict) {\n      const reservedNames = [\n        'text',\n        'object',\n        'image',\n        'string',\n        'number',\n        'boolean',\n        'json',\n        'array',\n        'datetime',\n        'date',\n        'time',\n        'type',\n        'class',\n        'input',\n        'output',\n        'data',\n        'value',\n        'result',\n        'response',\n        'request',\n        'item',\n        'element',\n      ];\n\n      if (reservedNames.includes(name.toLowerCase())) {\n        const suggestions =\n          fieldType === 'input'\n            ? ['userInput', 'questionText', 'documentContent', 'messageText']\n            : ['responseText', 'analysisResult', 'categoryType', 'summaryText'];\n\n        throw new SignatureValidationError(\n          `Field name \"${name}\" is too generic`,\n          this.position,\n          this.getErrorContext(),\n          `Use a more descriptive name. Examples: ${suggestions.join(', ')}`\n        );\n      }\n    }\n\n    // Check naming convention\n    const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;\n    const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/;\n\n    if (!camelCaseRegex.test(name) && !snakeCaseRegex.test(name)) {\n      throw new SignatureValidationError(\n        `Invalid field name \"${name}\"`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must be in camelCase (e.g., \"userInput\") or snake_case (e.g., \"user_input\")'\n      );\n    }\n\n    // Check for minimum length\n    if (name.length < 2) {\n      throw new SignatureValidationError(\n        `Field name \"${name}\" is too short`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must be at least 2 characters long'\n      );\n    }\n\n    // Check for maximum length\n    if (name.length > 50) {\n      throw new SignatureValidationError(\n        `Field name \"${name}\" is too long (${name.length} characters)`,\n        this.position,\n        this.getErrorContext(),\n        'Field names should be 50 characters or less'\n      );\n    }\n  }\n\n  private parseTypeNotClass(): TypeNotClass {\n    const types: TypeNotClass[] = [\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'image',\n      'audio',\n      'datetime',\n      'date',\n      'code',\n    ];\n\n    const foundType = types.find((type) => this.match(type));\n    if (!foundType) {\n      const currentWord =\n        this.input.slice(this.position).match(/^\\w+/)?.[0] || '';\n      const suggestion = this.suggestType(currentWord);\n\n      const baseMessage = `Invalid type \"${currentWord || 'empty'}\"`;\n      const suggestionPart = suggestion\n        ? `. Did you mean \"${suggestion}\"?`\n        : '';\n      const fullMessage = `${baseMessage}${suggestionPart}`;\n\n      throw new SignatureValidationError(\n        fullMessage,\n        this.position,\n        this.getErrorContext(),\n        `Expected one of: ${types.join(', ')}`\n      );\n    }\n    return foundType;\n  }\n\n  private suggestType(input: string): string | null {\n    const suggestions: Record<string, string> = {\n      str: 'string',\n      text: 'string',\n      int: 'number',\n      integer: 'number',\n      float: 'number',\n      double: 'number',\n      bool: 'boolean',\n      object: 'json',\n      dict: 'json',\n      timestamp: 'datetime',\n      time: 'datetime',\n      img: 'image',\n      picture: 'image',\n      sound: 'audio',\n      voice: 'audio',\n      classification: 'class',\n      category: 'class',\n    };\n\n    return suggestions[input.toLowerCase()] || null;\n  }\n\n  private parseParsedIdentifier(): ParsedIdentifier {\n    this.skipWhitespace();\n    const match = /^[a-zA-Z_][a-zA-Z_0-9]*/.exec(\n      this.input.slice(this.position)\n    );\n    if (match) {\n      this.position += match[0].length;\n      return match[0];\n    }\n\n    const invalidMatch = /^\\S+/.exec(this.input.slice(this.position));\n    const invalidId = invalidMatch ? invalidMatch[0] : '';\n\n    if (invalidId === '') {\n      throw new SignatureValidationError(\n        'Expected field name but found end of input',\n        this.position,\n        this.getErrorContext(),\n        'Add a field name. Field names must start with a letter or underscore'\n      );\n    }\n\n    if (/^\\d/.test(invalidId)) {\n      throw new SignatureValidationError(\n        `Invalid field name \"${invalidId}\" - cannot start with a number`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must start with a letter or underscore. Example: \"userInput\" or \"_internal\"'\n      );\n    }\n\n    throw new SignatureValidationError(\n      `Invalid field name \"${invalidId}\"`,\n      this.position,\n      this.getErrorContext(),\n      'Field names must start with a letter or underscore and contain only letters, numbers, or underscores'\n    );\n  }\n\n  private parseParsedString(): string | undefined {\n    const quoteChars = [\"'\", '\"'];\n    for (const quoteChar of quoteChars) {\n      if (this.match(quoteChar)) {\n        let content = '';\n        let escaped = false;\n        const startPos = this.position - 1;\n\n        while (this.position < this.input.length) {\n          const char = this.input[this.position];\n          this.position++;\n          if (escaped) {\n            content += char;\n            escaped = false;\n          } else if (char === '\\\\') {\n            escaped = true;\n          } else if (char === quoteChar) {\n            return content;\n          } else {\n            content += char;\n          }\n        }\n\n        const partialString = this.input.slice(\n          startPos,\n          Math.min(this.position, startPos + 20)\n        );\n        throw new SignatureValidationError(\n          `Unterminated string starting at position ${startPos}`,\n          startPos,\n          this.getErrorContext(),\n          `Add closing ${quoteChar} to complete the string: ${partialString}${quoteChar}`\n        );\n      }\n    }\n    return undefined;\n  }\n\n  private skipWhitespace() {\n    const match = /^[\\s\\t\\r\\n]+/.exec(this.input.slice(this.position));\n    if (match) {\n      this.position += match[0].length;\n    }\n  }\n\n  private match(strOrRegex: string | RegExp): boolean {\n    let match: RegExpExecArray | null;\n    if (typeof strOrRegex === 'string') {\n      if (this.input.startsWith(strOrRegex, this.position)) {\n        this.position += strOrRegex.length;\n        return true;\n      }\n    } else {\n      match = strOrRegex.exec(this.input.slice(this.position));\n      if (match) {\n        this.position += match[0].length;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private expectArrow() {\n    if (!this.match('->')) {\n      const found = this.input.slice(this.position, this.position + 10);\n      const suggestion = found.includes('>')\n        ? 'Use \"->\" (dash followed by greater-than)'\n        : found.includes('-')\n          ? 'Add \">\" after the dash'\n          : 'Add \"->\" to separate input and output fields';\n\n      throw new SignatureValidationError(\n        `Expected \"->\" but found \"${found}...\"`,\n        this.position,\n        this.getErrorContext(),\n        suggestion\n      );\n    }\n  }\n}\n\nexport function parseSignature(input: string): ParsedSignature {\n  const parser = new SignatureParser(input);\n  return parser.parse();\n}\n", "import { createHash } from '../util/crypto.js';\n\nimport type { AxFunctionJSONSchema } from '../ai/types.js';\n\nimport { axGlobals } from './globals.js';\nimport {\n  type InputParsedField,\n  type OutputParsedField,\n  type ParsedSignature,\n  parseSignature,\n} from './parser.js';\n\nexport interface AxField {\n  name: string;\n  title?: string;\n  description?: string;\n  type?: {\n    name:\n      | 'string'\n      | 'number'\n      | 'boolean'\n      | 'json'\n      | 'image'\n      | 'audio'\n      | 'date'\n      | 'datetime'\n      | 'class'\n      | 'code';\n    isArray?: boolean;\n    options?: string[];\n  };\n  isOptional?: boolean;\n  isInternal?: boolean;\n}\n\nexport type AxIField = Omit<AxField, 'title'> & { title: string };\n\nclass AxSignatureValidationError extends Error {\n  constructor(\n    message: string,\n    public readonly fieldName?: string,\n    public readonly suggestion?: string\n  ) {\n    super(message);\n    this.name = 'AxSignatureValidationError';\n  }\n}\n\nexport interface AxSignatureConfig {\n  description?: string;\n  inputs: readonly AxField[];\n  outputs: readonly AxField[];\n}\n\nexport class AxSignature {\n  private description?: string;\n  private inputFields: AxIField[];\n  private outputFields: AxIField[];\n\n  private sigHash: string;\n  private sigString: string;\n\n  // Validation caching - stores hash when validation last passed\n  private validatedAtHash?: string;\n\n  constructor(signature?: Readonly<AxSignature | string | AxSignatureConfig>) {\n    if (!signature) {\n      this.inputFields = [];\n      this.outputFields = [];\n      this.sigHash = '';\n      this.sigString = '';\n      return;\n    }\n\n    if (typeof signature === 'string') {\n      let sig: ParsedSignature;\n      try {\n        sig = parseSignature(signature);\n      } catch (e) {\n        if (e instanceof Error) {\n          // Preserve the suggestion if it's a SignatureValidationError\n          const suggestion =\n            'suggestion' in e &&\n            typeof (e as { suggestion: unknown }).suggestion === 'string'\n              ? (e as { suggestion: string }).suggestion\n              : 'Please check the signature format. Example: \"userInput:string -> responseText:string\"';\n          throw new AxSignatureValidationError(\n            `Invalid Signature: ${e.message}`,\n            undefined,\n            suggestion\n          );\n        }\n        throw new AxSignatureValidationError(\n          `Invalid Signature: ${signature}`,\n          undefined,\n          'Please check the signature format. Example: \"userInput:string -> responseText:string\"'\n        );\n      }\n      this.description = sig.desc;\n      this.inputFields = sig.inputs.map((v) => this.parseParsedField(v));\n      this.outputFields = sig.outputs.map((v) => this.parseParsedField(v));\n      [this.sigHash, this.sigString] = this.updateHash();\n    } else if (signature instanceof AxSignature) {\n      this.description = signature.getDescription();\n      this.inputFields = structuredClone(\n        signature.getInputFields()\n      ) as AxIField[];\n      this.outputFields = structuredClone(\n        signature.getOutputFields()\n      ) as AxIField[];\n      this.sigHash = signature.hash();\n      this.sigString = signature.toString();\n      // Copy validation state if the source signature was validated\n      if (signature.validatedAtHash === this.sigHash) {\n        this.validatedAtHash = this.sigHash;\n      }\n    } else if (typeof signature === 'object' && signature !== null) {\n      // Handle AxSignatureConfig object\n      if (!('inputs' in signature) || !('outputs' in signature)) {\n        throw new AxSignatureValidationError(\n          'Invalid signature object: missing inputs or outputs',\n          undefined,\n          'Signature object must have \"inputs\" and \"outputs\" arrays. Example: { inputs: [...], outputs: [...] }'\n        );\n      }\n\n      if (\n        !Array.isArray(signature.inputs) ||\n        !Array.isArray(signature.outputs)\n      ) {\n        throw new AxSignatureValidationError(\n          'Invalid signature object: inputs and outputs must be arrays',\n          undefined,\n          'Both \"inputs\" and \"outputs\" must be arrays of AxField objects'\n        );\n      }\n\n      try {\n        this.description = signature.description;\n        this.inputFields = signature.inputs.map((v) => this.parseField(v));\n        this.outputFields = signature.outputs.map((v) => this.parseField(v));\n        [this.sigHash, this.sigString] = this.updateHash();\n      } catch (error) {\n        if (error instanceof AxSignatureValidationError) {\n          throw error;\n        }\n        throw new AxSignatureValidationError(\n          `Failed to create signature from object: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          undefined,\n          'Check that all fields in inputs and outputs arrays are valid AxField objects'\n        );\n      }\n    } else {\n      throw new AxSignatureValidationError(\n        'Invalid signature argument type',\n        undefined,\n        'Signature must be a string, another AxSignature instance, or an object with inputs and outputs arrays'\n      );\n    }\n  }\n\n  private parseParsedField = (\n    field: Readonly<InputParsedField | OutputParsedField>\n  ): AxIField => {\n    if (!field.name || field.name.length === 0) {\n      throw new AxSignatureValidationError(\n        'Field name is required',\n        field.name,\n        'Every field must have a descriptive name. Example: \"userInput\", \"responseText\"'\n      );\n    }\n\n    const title = this.toTitle(field.name);\n    return {\n      name: field.name,\n      title,\n      description: 'desc' in field ? field.desc : undefined,\n      type: field.type ?? { name: 'string', isArray: false },\n      ...('isInternal' in field ? { isInternal: field.isInternal } : {}),\n      ...('isOptional' in field ? { isOptional: field.isOptional } : {}),\n    };\n  };\n\n  private parseField = (field: Readonly<AxField>): AxIField => {\n    const title =\n      !field.title || field.title.length === 0\n        ? this.toTitle(field.name)\n        : field.title;\n\n    if (field.type && (!field.type.name || field.type.name.length === 0)) {\n      throw new AxSignatureValidationError(\n        'Field type name is required',\n        field.name,\n        'Specify a valid type. Available types: string, number, boolean, json, image, audio, date, datetime, class, code'\n      );\n    }\n\n    return { ...field, title };\n  };\n\n  public setDescription = (desc: string) => {\n    if (typeof desc !== 'string') {\n      throw new AxSignatureValidationError(\n        'Description must be a string',\n        undefined,\n        'Provide a string description for the signature'\n      );\n    }\n    this.description = desc;\n    this.invalidateValidationCache();\n    this.updateHashLight();\n  };\n\n  public addInputField = (field: Readonly<AxField>) => {\n    try {\n      const parsedField = this.parseField(field);\n      validateField(parsedField, 'input');\n\n      // Check for duplicate input field names\n      for (const existingField of this.inputFields) {\n        if (existingField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Duplicate input field name: \"${parsedField.name}\"`,\n            parsedField.name,\n            'Each field name must be unique within the signature'\n          );\n        }\n      }\n\n      // Check if field name conflicts with existing output fields\n      for (const outputField of this.outputFields) {\n        if (outputField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n            parsedField.name,\n            'Use different names for input and output fields to avoid confusion'\n          );\n        }\n      }\n\n      this.inputFields.push(parsedField);\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to add input field \"${field.name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n        field.name\n      );\n    }\n  };\n\n  public addOutputField = (field: Readonly<AxField>) => {\n    try {\n      const parsedField = this.parseField(field);\n      validateField(parsedField, 'output');\n\n      // Check for duplicate output field names\n      for (const existingField of this.outputFields) {\n        if (existingField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Duplicate output field name: \"${parsedField.name}\"`,\n            parsedField.name,\n            'Each field name must be unique within the signature'\n          );\n        }\n      }\n\n      // Check if field name conflicts with existing input fields\n      for (const inputField of this.inputFields) {\n        if (inputField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n            parsedField.name,\n            'Use different names for input and output fields to avoid confusion'\n          );\n        }\n      }\n\n      this.outputFields.push(parsedField);\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to add output field \"${field.name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n        field.name\n      );\n    }\n  };\n\n  public setInputFields = (fields: readonly AxField[]) => {\n    if (!Array.isArray(fields)) {\n      throw new AxSignatureValidationError(\n        'Input fields must be an array',\n        undefined,\n        'Provide an array of field objects'\n      );\n    }\n\n    try {\n      const parsedFields = fields.map((v) => {\n        const parsed = this.parseField(v);\n        validateField(parsed, 'input');\n        return parsed;\n      });\n      this.inputFields = parsedFields;\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to set input fields: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  public setOutputFields = (fields: readonly AxField[]) => {\n    if (!Array.isArray(fields)) {\n      throw new AxSignatureValidationError(\n        'Output fields must be an array',\n        undefined,\n        'Provide an array of field objects'\n      );\n    }\n\n    try {\n      const parsedFields = fields.map((v) => {\n        const parsed = this.parseField(v);\n        validateField(parsed, 'output');\n        return parsed;\n      });\n      this.outputFields = parsedFields;\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to set output fields: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  public getInputFields = (): Readonly<AxIField[]> => this.inputFields;\n  public getOutputFields = (): Readonly<AxIField[]> => this.outputFields;\n  public getDescription = () => this.description;\n\n  private invalidateValidationCache = (): void => {\n    this.validatedAtHash = undefined;\n  };\n\n  private toTitle = (name: string) => {\n    let result = name.replace(/_/g, ' ');\n    result = result.replace(/([A-Z]|[0-9]+)/g, ' $1').trim();\n    return result.charAt(0).toUpperCase() + result.slice(1);\n  };\n\n  public toJSONSchema = (): AxFunctionJSONSchema => {\n    const properties: Record<string, unknown> = {};\n    const required: Array<string> = [];\n\n    for (const f of this.inputFields) {\n      const type = f.type ? f.type.name : 'string';\n      if (f.type?.isArray) {\n        properties[f.name] = {\n          description: f.description,\n          type: 'array' as const,\n          items: {\n            type: type,\n            description: f.description,\n          },\n        };\n      } else {\n        properties[f.name] = {\n          description: f.description,\n          type: type,\n        };\n      }\n\n      if (!f.isOptional) {\n        required.push(f.name);\n      }\n    }\n\n    const schema = {\n      type: 'object',\n      properties: properties,\n      required: required,\n    };\n\n    return schema as AxFunctionJSONSchema;\n  };\n\n  private updateHashLight = (): [string, string] => {\n    try {\n      // Light validation - only validate individual fields, not full signature consistency\n      this.getInputFields().forEach((field) => {\n        validateField(field, 'input');\n      });\n      this.getOutputFields().forEach((field) => {\n        validateField(field, 'output');\n      });\n\n      this.sigHash = createHash('sha256')\n        .update(JSON.stringify(this.inputFields))\n        .update(JSON.stringify(this.outputFields))\n        .digest('hex');\n\n      this.sigString = renderSignature(\n        this.description,\n        this.inputFields,\n        this.outputFields\n      );\n\n      return [this.sigHash, this.sigString];\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Signature validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  private updateHash = (): [string, string] => {\n    try {\n      this.getInputFields().forEach((field) => {\n        validateField(field, 'input');\n      });\n      this.getOutputFields().forEach((field) => {\n        validateField(field, 'output');\n      });\n\n      this.validateSignatureConsistency();\n\n      this.sigHash = createHash('sha256')\n        .update(this.description ?? '')\n        .update(JSON.stringify(this.inputFields))\n        .update(JSON.stringify(this.outputFields))\n        .digest('hex');\n\n      this.sigString = renderSignature(\n        this.description,\n        this.inputFields,\n        this.outputFields\n      );\n\n      return [this.sigHash, this.sigString];\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Signature validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  private validateSignatureConsistency(): void {\n    const inputNames = new Set<string>();\n    for (const field of this.inputFields) {\n      if (inputNames.has(field.name)) {\n        throw new AxSignatureValidationError(\n          `Duplicate input field name: \"${field.name}\"`,\n          field.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n      inputNames.add(field.name);\n    }\n\n    const outputNames = new Set<string>();\n    for (const field of this.outputFields) {\n      if (outputNames.has(field.name)) {\n        throw new AxSignatureValidationError(\n          `Duplicate output field name: \"${field.name}\"`,\n          field.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n      outputNames.add(field.name);\n    }\n\n    for (const outputField of this.outputFields) {\n      if (inputNames.has(outputField.name)) {\n        throw new AxSignatureValidationError(\n          `Field name \"${outputField.name}\" appears in both inputs and outputs`,\n          outputField.name,\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    if (this.inputFields.length === 0) {\n      throw new AxSignatureValidationError(\n        'Signature must have at least one input field',\n        undefined,\n        'Add an input field. Example: \"userInput:string -> ...\"'\n      );\n    }\n\n    if (this.outputFields.length === 0) {\n      throw new AxSignatureValidationError(\n        'Signature must have at least one output field',\n        undefined,\n        'Add an output field. Example: \"... -> responseText:string\"'\n      );\n    }\n  }\n\n  public validate = (): boolean => {\n    // Check if already validated at current hash\n    if (this.validatedAtHash === this.sigHash) {\n      return true;\n    }\n\n    try {\n      // Perform full validation\n      this.updateHash();\n\n      // Cache validation success\n      this.validatedAtHash = this.sigHash;\n\n      return true;\n    } catch (error) {\n      // Clear validation cache on failure\n      this.validatedAtHash = undefined;\n      throw error;\n    }\n  };\n\n  public hash = () => this.sigHash;\n\n  public toString = () => this.sigString;\n\n  public toJSON = () => {\n    return {\n      id: this.hash(),\n      description: this.description,\n      inputFields: this.inputFields,\n      outputFields: this.outputFields,\n    };\n  };\n}\n\nfunction renderField(field: Readonly<AxField>): string {\n  let result = field.name;\n  if (field.isOptional) {\n    result += '?';\n  }\n  if (field.isInternal) {\n    result += '!';\n  }\n  if (field.type) {\n    result += `:${field.type.name}`;\n    if (field.type.isArray) {\n      result += '[]';\n    }\n    if (field.type.name === 'class' && field.type.options) {\n      result += ` \"${field.type.options.join(' | ')}\"`;\n    }\n  }\n  if (field.description && field.type?.name !== 'class') {\n    result += ` \"${field.description}\"`;\n  }\n  return result;\n}\n\nfunction renderSignature(\n  description: string | undefined,\n  inputFields: readonly AxField[],\n  outputFields: readonly AxField[]\n): string {\n  const descriptionPart = description ? `\"${description}\" ` : '';\n\n  const inputFieldsRendered = inputFields.map(renderField).join(', ');\n\n  const outputFieldsRendered = outputFields.map(renderField).join(', ');\n\n  return `${descriptionPart}${inputFieldsRendered} -> ${outputFieldsRendered}`;\n}\n\nfunction isValidCase(inputString: string): boolean {\n  const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;\n  const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/;\n\n  return camelCaseRegex.test(inputString) || snakeCaseRegex.test(inputString);\n}\n\nfunction validateField(\n  field: Readonly<AxField>,\n  context: 'input' | 'output'\n): void {\n  if (!field.name || field.name.length === 0) {\n    throw new AxSignatureValidationError(\n      'Field name cannot be blank',\n      field.name,\n      'Every field must have a descriptive name'\n    );\n  }\n\n  if (!isValidCase(field.name)) {\n    throw new AxSignatureValidationError(\n      `Invalid field name '${field.name}' - must be camelCase or snake_case`,\n      field.name,\n      'Use camelCase (e.g., \"userInput\") or snake_case (e.g., \"user_input\")'\n    );\n  }\n\n  if (axGlobals.signatureStrict) {\n    const reservedNames = [\n      'text',\n      'object',\n      'image',\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'array',\n      'datetime',\n      'date',\n      'time',\n      'type',\n      'class',\n      'input',\n      'output',\n      'data',\n      'value',\n      'result',\n      'response',\n      'request',\n      'item',\n      'element',\n    ];\n\n    if (reservedNames.includes(field.name.toLowerCase())) {\n      const suggestions =\n        context === 'input'\n          ? [\n              'userInput',\n              'questionText',\n              'documentContent',\n              'messageText',\n              'queryString',\n            ]\n          : [\n              'responseText',\n              'analysisResult',\n              'categoryType',\n              'summaryText',\n              'outputData',\n            ];\n\n      throw new AxSignatureValidationError(\n        `Field name '${field.name}' is too generic`,\n        field.name,\n        `Use a more descriptive name. Examples for ${context} fields: ${suggestions.join(', ')}`\n      );\n    }\n  }\n\n  if (field.name.length < 2) {\n    throw new AxSignatureValidationError(\n      `Field name '${field.name}' is too short`,\n      field.name,\n      'Field names must be at least 2 characters long'\n    );\n  }\n\n  if (field.name.length > 50) {\n    throw new AxSignatureValidationError(\n      `Field name '${field.name}' is too long (${field.name.length} characters)`,\n      field.name,\n      'Field names should be 50 characters or less'\n    );\n  }\n\n  if (field.type) {\n    validateFieldType(field, context);\n  }\n}\n\nfunction validateFieldType(\n  field: Readonly<AxField>,\n  context: 'input' | 'output'\n): void {\n  if (!field.type) return;\n\n  const { type } = field;\n\n  if (type.name === 'image' || type.name === 'audio') {\n    if (context === 'output') {\n      throw new AxSignatureValidationError(\n        `${type.name} type is not supported in output fields`,\n        field.name,\n        `${type.name} types can only be used in input fields`\n      );\n    }\n\n    if (type.isArray) {\n      throw new AxSignatureValidationError(\n        `Arrays of ${type.name} are not supported`,\n        field.name,\n        `Use a single ${type.name} type instead`\n      );\n    }\n  }\n\n  if (type.name === 'class') {\n    if (context === 'input') {\n      throw new AxSignatureValidationError(\n        'Class type is not supported in input fields',\n        field.name,\n        'Class types are only allowed on output fields. Use \"string\" type for input classifications'\n      );\n    }\n\n    if (!type.options || type.options.length === 0) {\n      throw new AxSignatureValidationError(\n        'Class type requires options',\n        field.name,\n        'Provide class options. Example: class \"positive, negative, neutral\"'\n      );\n    }\n\n    for (const option of type.options) {\n      if (!option || option.trim().length === 0) {\n        throw new AxSignatureValidationError(\n          'Empty class option found',\n          field.name,\n          'All class options must be non-empty strings'\n        );\n      }\n\n      const trimmedOption = option.trim();\n      if (trimmedOption.includes(',') || trimmedOption.includes('|')) {\n        throw new AxSignatureValidationError(\n          `Invalid class option \"${trimmedOption}\"`,\n          field.name,\n          'Class options cannot contain commas (,) or pipes (|) as they are used to separate options'\n        );\n      }\n    }\n\n    const uniqueOptions = new Set(\n      type.options.map((opt) => opt.trim().toLowerCase())\n    );\n    if (uniqueOptions.size !== type.options.length) {\n      throw new AxSignatureValidationError(\n        'Duplicate class options found',\n        field.name,\n        'Each class option must be unique (case-insensitive)'\n      );\n    }\n  }\n\n  if (type.name === 'code' && type.isArray) {\n    throw new AxSignatureValidationError(\n      'Arrays of code are not commonly supported',\n      field.name,\n      'Consider using a single code field or an array of strings instead'\n    );\n  }\n\n  if (field.isInternal && context === 'input') {\n    throw new AxSignatureValidationError(\n      'Internal marker (!) is not allowed on input fields',\n      field.name,\n      'Internal markers are only allowed on output fields'\n    );\n  }\n}\n", "import type { Tracer } from '@opentelemetry/api';\n\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxRateLimiterFunction,\n} from '../ai/types.js';\nimport type { AxAIMemory } from '../mem/types.js';\n\nimport type { AxAssertion, AxStreamingAssertion } from './asserts.js';\nimport type { AxInputFunctionType } from './functions.js';\nimport type { AxPromptTemplate } from './prompt.js';\nimport { AxInstanceRegistry } from './registry.js';\nimport { AxSignature } from './sig.js';\nimport type { AxFieldValue, AxGenIn, AxGenOut, AxMessage } from './types.js';\nimport { mergeProgramUsage, validateValue } from './util.js';\nexport type AxProgramTrace<IN extends AxGenIn, OUT extends AxGenOut> = {\n  trace: OUT & IN;\n  programId: string;\n};\n\nexport type AxProgramDemos<IN extends AxGenIn, OUT extends AxGenOut> = {\n  traces: (OUT & IN)[];\n  programId: string;\n};\n\nexport type AxProgramExamples<IN extends AxGenIn, OUT extends AxGenOut> =\n  | AxProgramDemos<IN, OUT>\n  | AxProgramDemos<IN, OUT>['traces'];\n\nexport type AxResultPickerFunctionFieldResults<OUT extends AxGenOut> = {\n  type: 'fields';\n  results: readonly { index: number; sample: Partial<OUT> }[];\n};\n\nexport type AxResultPickerFunctionFunctionResults = {\n  type: 'function';\n  results: readonly {\n    index: number;\n    functionName: string;\n    functionId: string;\n    args: string | object;\n    result: string;\n    isError?: boolean;\n  }[];\n};\n\nexport type AxResultPickerFunction<OUT extends AxGenOut> = (\n  data:\n    | AxResultPickerFunctionFieldResults<OUT>\n    | AxResultPickerFunctionFunctionResults\n) => number | Promise<number>;\n\nexport type AxProgramForwardOptions = {\n  // Execution control\n  maxRetries?: number;\n  maxSteps?: number;\n  mem?: AxAIMemory;\n\n  // AI service and model configuration\n  ai?: AxAIService;\n  modelConfig?: AxModelConfig;\n  model?: string;\n\n  // Session and tracing\n  sessionId?: string;\n  traceId?: string | undefined;\n  tracer?: Tracer;\n  rateLimiter?: AxRateLimiterFunction;\n\n  // Streaming and output\n  stream?: boolean;\n  sampleCount?: number;\n  resultPicker?: AxResultPickerFunction<AxGenOut>;\n\n  // Functions and calls\n  functions?: AxInputFunctionType;\n  functionCall?: AxChatRequest['functionCall'];\n  stopFunction?: string;\n  functionResultFormatter?: (result: unknown) => string;\n\n  // Behavior control\n  fastFail?: boolean;\n  debug?: boolean;\n  debugHideSystemPrompt?: boolean;\n\n  // Thinking model controls\n  thinkingTokenBudget?:\n    | 'minimal'\n    | 'low'\n    | 'medium'\n    | 'high'\n    | 'highest'\n    | 'none';\n  showThoughts?: boolean;\n\n  // Tracing and logging\n  traceLabel?: string;\n  abortSignal?: AbortSignal;\n  logger?: AxLoggerFunction;\n\n  // AxGen-specific options (previously in AxGenOptions)\n  description?: string;\n  thoughtFieldName?: string;\n  promptTemplate?: typeof AxPromptTemplate;\n  asserts?: AxAssertion[];\n  streamingAsserts?: AxStreamingAssertion[];\n  excludeContentFromTrace?: boolean;\n\n  // Field prefix is required for single output field programs\n  strictMode?: boolean;\n};\n\nexport type AxProgramStreamingForwardOptions = Omit<\n  AxProgramForwardOptions,\n  'stream'\n>;\n\nexport type AxGenDeltaOut<OUT extends AxGenOut> = {\n  version: number;\n  index: number;\n  delta: Partial<OUT>;\n};\n\nexport type AxGenStreamingOut<OUT extends AxGenOut> = AsyncGenerator<\n  AxGenDeltaOut<OUT>,\n  void,\n  unknown\n>;\n\nexport type DeltaOut<OUT extends AxGenOut> = Omit<\n  AxGenDeltaOut<OUT>,\n  'version'\n>;\n\nexport type AsyncGenDeltaOut<OUT extends AxGenOut> = AsyncGenerator<\n  DeltaOut<OUT>,\n  void,\n  unknown\n>;\n\nexport type GenDeltaOut<OUT extends AxGenOut> = Generator<\n  DeltaOut<OUT>,\n  void,\n  unknown\n>;\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport type AxSetExamplesOptions = {\n  // No options needed - all fields can be missing in examples\n};\n\nexport interface AxTunable<IN extends AxGenIn, OUT extends AxGenOut> {\n  setExamples: (\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) => void;\n  setId: (id: string) => void;\n  setParentId: (parentId: string) => void;\n  getTraces: () => AxProgramTrace<IN, OUT>[];\n  setDemos: (demos: readonly AxProgramDemos<IN, OUT>[]) => void;\n}\n\nexport interface AxUsable {\n  getUsage: () => AxProgramUsage[];\n  resetUsage: () => void;\n}\n\nexport type AxProgramUsage = AxChatResponse['modelUsage'] & {\n  ai: string;\n  model: string;\n};\n\nexport interface AxProgramOptions {\n  description?: string;\n  traceLabel?: string;\n}\n\nexport class AxProgram<IN extends AxGenIn, OUT extends AxGenOut>\n  implements AxTunable<IN, OUT>, AxUsable\n{\n  protected signature: AxSignature;\n  protected sigHash: string;\n\n  protected examples?: OUT[];\n  protected examplesOptions?: AxSetExamplesOptions;\n  protected demos?: OUT[];\n  protected trace?: OUT;\n  protected usage: AxProgramUsage[] = [];\n  protected traceLabel?: string;\n\n  private key: { id: string; custom?: boolean };\n  private children: AxInstanceRegistry<Readonly<AxTunable<IN, OUT>>, IN, OUT>;\n\n  constructor(\n    signature: NonNullable<ConstructorParameters<typeof AxSignature>[0]>,\n    options?: Readonly<AxProgramOptions>\n  ) {\n    this.signature = new AxSignature(signature);\n\n    if (options?.description) {\n      this.signature.setDescription(options.description);\n    }\n\n    if (options?.traceLabel) {\n      this.traceLabel = options.traceLabel;\n    }\n\n    // Validate full signature consistency for use in generation\n    this.signature.validate();\n\n    this.sigHash = this.signature?.hash();\n    this.children = new AxInstanceRegistry();\n    this.key = { id: this.signature.hash() };\n  }\n\n  public getSignature() {\n    return this.signature;\n  }\n\n  public register(prog: Readonly<AxTunable<IN, OUT> & AxUsable>) {\n    if (this.key) {\n      prog.setParentId(this.key.id);\n    }\n    this.children.register(prog);\n  }\n\n  public async forward(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _ai: Readonly<AxAIService>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _values: IN | AxMessage<IN>[],\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxProgramForwardOptions>\n  ): Promise<OUT> {\n    throw new Error('forward() not implemented');\n  }\n\n  // biome-ignore lint/correctness/useYield: just a placeholder\n  public async *streamingForward(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _ai: Readonly<AxAIService>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _values: IN | AxMessage<IN>[],\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxProgramStreamingForwardOptions>\n  ): AxGenStreamingOut<OUT> {\n    throw new Error('streamingForward() not implemented');\n  }\n\n  public setId(id: string) {\n    this.key = { id, custom: true };\n    for (const child of Array.from(this.children)) {\n      child?.setParentId(id);\n    }\n  }\n\n  public setParentId(parentId: string) {\n    if (!this.key.custom) {\n      this.key.id = [parentId, this.key.id].join('/');\n    }\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    this._setExamples(examples, options);\n\n    if (!('programId' in examples)) {\n      return;\n    }\n\n    for (const child of Array.from(this.children)) {\n      child?.setExamples(examples, options);\n    }\n  }\n\n  private _setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    let traces: Record<string, AxFieldValue>[] = [];\n\n    if ('programId' in examples && examples.programId === this.key.id) {\n      traces = examples.traces;\n    }\n\n    if (Array.isArray(examples)) {\n      traces = examples;\n    }\n\n    if (traces) {\n      this.examplesOptions = options;\n      const sig = this.signature;\n      const fields = [...sig.getInputFields(), ...sig.getOutputFields()];\n\n      this.examples = traces.map((e) => {\n        const res: Record<string, AxFieldValue> = {};\n        for (const f of fields) {\n          const value = e[f.name];\n          if (value !== undefined) {\n            // Only validate the type of fields that are actually set\n            // Allow any field to be missing regardless of whether it's required\n            validateValue(f, value);\n            res[f.name] = value;\n          }\n        }\n        return res;\n      }) as OUT[];\n    }\n  }\n\n  public getTraces(): AxProgramTrace<IN, OUT>[] {\n    let traces: AxProgramTrace<IN, OUT>[] = [];\n\n    if (this.trace) {\n      traces.push({ trace: this.trace as OUT & IN, programId: this.key.id });\n    }\n\n    for (const child of Array.from(this.children)) {\n      const Traces = child?.getTraces();\n      traces = [...traces, ...(Traces ?? [])];\n    }\n    return traces;\n  }\n\n  public getUsage(): AxProgramUsage[] {\n    let usage: AxProgramUsage[] = [...(this.usage ?? [])];\n\n    for (const child of Array.from(this.children)) {\n      const cu = child?.getUsage();\n      usage = [...usage, ...(cu ?? [])];\n    }\n    return mergeProgramUsage(usage);\n  }\n\n  public resetUsage() {\n    this.usage = [];\n    for (const child of Array.from(this.children)) {\n      child?.resetUsage();\n    }\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]) {\n    // Check if this program has children and if its programId is not found in demos\n    const hasChildren = Array.from(this.children).length > 0;\n    const hasMatchingDemo = demos.some(\n      (demo) => demo.programId === this.key.id\n    );\n\n    if (hasChildren && !hasMatchingDemo) {\n      throw new Error(\n        `Program with id '${this.key.id}' has children but no matching programId found in demos`\n      );\n    }\n\n    // biome-ignore lint/complexity/useFlatMap: it can't\n    this.demos = demos\n      .filter((v) => v.programId === this.key.id)\n      .map((v) => v.traces)\n      .flat();\n\n    for (const child of Array.from(this.children)) {\n      child?.setDemos(demos);\n    }\n  }\n}\n", "import type { AxChatRequest } from '../ai/types.js';\n\nimport { formatDateWithTimezone } from './datetime.js';\nimport type { AxInputFunctionType } from './functions.js';\nimport type { AxField, AxIField, AxSignature } from './sig.js';\nimport type { AxFieldValue, AxGenIn, AxMessage } from './types.js';\nimport { validateValue } from './util.js';\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\n// Define options type for AxPromptTemplate constructor\nexport interface AxPromptTemplateOptions {\n  functions?: Readonly<AxInputFunctionType>;\n  thoughtFieldName?: string;\n}\ntype AxChatRequestChatPrompt = Writeable<AxChatRequest['chatPrompt'][0]>;\n\ntype ChatRequestUserMessage = Exclude<\n  Extract<AxChatRequestChatPrompt, { role: 'user' }>['content'],\n  string\n>;\n\nconst functionCallInstructions = `\n## Function Call Instructions\n- Complete the task, using the functions defined earlier in this prompt. \n- Output fields should only be generated after all functions have been called.\n- Use the function results to generate the output fields.`;\n\nconst formattingRules = `\n## Strict Output Formatting Rules\n- Output must strictly follow the defined plain-text \\`field name: value\\` field format.\n- Output field, values must strictly adhere to the specified output field formatting rules.\n- No formatting rules should override these **Strict Output Formatting Rules**\n- Do not add any text before or after the output fields, just the field name and value.\n- Do not use code blocks.`;\n\nexport type AxFieldTemplateFn = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n) => ChatRequestUserMessage;\n\nexport class AxPromptTemplate {\n  private sig: Readonly<AxSignature>;\n  private fieldTemplates?: Record<string, AxFieldTemplateFn>;\n  private task: { type: 'text'; text: string };\n  private readonly thoughtFieldName: string;\n  private readonly functions?: Readonly<AxInputFunctionType>;\n\n  constructor(\n    sig: Readonly<AxSignature>,\n    options?: Readonly<AxPromptTemplateOptions>,\n    fieldTemplates?: Record<string, AxFieldTemplateFn>\n  ) {\n    this.sig = sig;\n    this.fieldTemplates = fieldTemplates;\n    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought';\n    this.functions = options?.functions;\n\n    const task = [];\n\n    const inArgs = renderDescFields(this.sig.getInputFields());\n    const outArgs = renderDescFields(this.sig.getOutputFields());\n    task.push(\n      `You will be provided with the following fields: ${inArgs}. Your task is to generate new fields: ${outArgs}.`\n    );\n\n    // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here\n    const funcs = this.functions\n      ?.map((f) => ('toFunction' in f ? f.toFunction() : f))\n      ?.flat();\n\n    const funcList = funcs\n      ?.map((fn) => `- \\`${fn.name}\\`: ${formatDescription(fn.description)}`)\n      .join('\\n');\n\n    if (funcList && funcList.length > 0) {\n      task.push(`## Available Functions\\n${funcList}`);\n    }\n\n    const inputFields = renderInputFields(this.sig.getInputFields());\n    task.push(`## Input Fields\\n${inputFields}`);\n\n    const outputFields = renderOutputFields(this.sig.getOutputFields());\n    task.push(`## Output Fields\\n${outputFields}`);\n\n    if (funcList && funcList.length > 0) {\n      task.push(functionCallInstructions.trim());\n    }\n\n    task.push(formattingRules.trim());\n\n    const desc = this.sig.getDescription();\n    if (desc) {\n      const text = formatDescription(desc);\n      task.push(text);\n    }\n\n    this.task = {\n      type: 'text' as const,\n      text: task.join('\\n\\n'),\n    };\n  }\n\n  private renderSingleValueUserContent = <T extends AxGenIn>(\n    values: T,\n    renderedExamples: ChatRequestUserMessage,\n    renderedDemos: ChatRequestUserMessage,\n    examplesInSystemPrompt: boolean\n  ): string | ChatRequestUserMessage => {\n    const completion = this.renderInputFields(values);\n    const promptList: ChatRequestUserMessage = examplesInSystemPrompt\n      ? completion\n      : [...renderedExamples, ...renderedDemos, ...completion];\n\n    const prompt = promptList.filter((v) => v !== undefined);\n\n    return prompt.every((v) => v.type === 'text')\n      ? prompt.map((v) => v.text).join('\\n')\n      : prompt.reduce(combineConsecutiveStrings('\\n'), []);\n  };\n\n  public render = <T extends AxGenIn>(\n    values: T | ReadonlyArray<AxMessage<T>>, // Allow T (AxGenIn) or array of AxMessages\n    {\n      examples,\n      demos,\n    }: Readonly<{\n      skipSystemPrompt?: boolean;\n      examples?: Record<string, AxFieldValue>[]; // Keep as is, examples are specific structures\n      demos?: Record<string, AxFieldValue>[]; // Keep as is\n    }>\n  ): Extract<\n    AxChatRequest['chatPrompt'][number],\n    { role: 'user' | 'system' | 'assistant' }\n  >[] => {\n    const renderedExamples = examples\n      ? [\n          { type: 'text' as const, text: '\\n\\n## Examples\\n' },\n          ...this.renderExamples(examples),\n        ]\n      : [];\n\n    const renderedDemos = demos ? this.renderDemos(demos) : [];\n\n    // Check if demos and examples are all text type\n    const allTextExamples = renderedExamples.every((v) => v.type === 'text');\n    const allTextDemos = renderedDemos.every((v) => v.type === 'text');\n    const examplesInSystemPrompt = allTextExamples && allTextDemos;\n\n    let systemContent = this.task.text;\n\n    if (examplesInSystemPrompt) {\n      const combinedItems = [\n        { type: 'text' as const, text: systemContent },\n        ...renderedExamples,\n        ...renderedDemos,\n      ];\n      combinedItems.reduce(combineConsecutiveStrings(''), []);\n\n      if (combinedItems?.[0]) {\n        systemContent = combinedItems[0].text;\n      }\n    }\n\n    const systemPrompt = {\n      role: 'system' as const,\n      content: systemContent,\n    };\n\n    if (Array.isArray(values)) {\n      const messages: Extract<\n        AxChatRequest['chatPrompt'][number],\n        { role: 'user' } | { role: 'assistant' }\n      >[] = [];\n\n      const history = values as ReadonlyArray<AxMessage<T>>;\n\n      let firstItem = true;\n      for (const message of history) {\n        let content: string | ChatRequestUserMessage;\n\n        if (firstItem) {\n          content = this.renderSingleValueUserContent(\n            message.values,\n            renderedExamples,\n            renderedDemos,\n            examplesInSystemPrompt\n          );\n          firstItem = false;\n        } else {\n          content = this.renderSingleValueUserContent(\n            message.values,\n            [],\n            [],\n            false\n          );\n        }\n\n        if (message.role === 'user') {\n          messages.push({ role: 'user', content });\n          continue;\n        }\n\n        if (message.role !== 'assistant') {\n          throw new Error('Invalid message role');\n        }\n\n        if (typeof content !== 'string') {\n          throw new Error(\n            'Assistant message cannot contain non-text content like images, files,etc'\n          );\n        }\n\n        messages.push({ role: 'assistant', content });\n      }\n\n      return [systemPrompt, ...messages];\n    }\n\n    // values is T (AxGenIn) - existing logic path\n    const userContent = this.renderSingleValueUserContent(\n      values as T,\n      renderedExamples,\n      renderedDemos,\n      examplesInSystemPrompt\n    );\n\n    return [systemPrompt, { role: 'user' as const, content: userContent }];\n  };\n\n  public renderExtraFields = (extraFields: readonly AxIField[]) => {\n    const prompt: ChatRequestUserMessage = [];\n\n    if (!extraFields || extraFields.length === 0) {\n      return prompt;\n    }\n\n    const groupedFields = extraFields.reduce(\n      (acc, field) => {\n        const title = field.title;\n        if (!acc[title]) {\n          acc[title] = [];\n        }\n        acc[title].push(field);\n        return acc;\n      },\n      {} as Record<string, AxIField[]>\n    );\n\n    const formattedGroupedFields = Object.entries(groupedFields)\n      .map(([title, fields]) => {\n        if (fields.length === 1) {\n          const field = fields[0]!;\n          return {\n            title,\n            name: field.name,\n            description: field.description,\n          };\n        }\n        if (fields.length > 1) {\n          const valuesList = fields\n            .map((field) => `- ${field.description}`)\n            .join('\\n');\n          return {\n            title,\n            name: fields[0]!.name,\n            description: valuesList,\n          };\n        }\n      })\n      .filter(Boolean) as AxIField[];\n\n    formattedGroupedFields.forEach((field) => {\n      const fn = this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;\n      prompt.push(...fn(field, field.description));\n    });\n\n    return prompt;\n  };\n\n  private renderExamples = (data: Readonly<Record<string, AxFieldValue>[]>) => {\n    const list: ChatRequestUserMessage = [];\n    const exampleContext = {\n      isExample: true,\n    };\n\n    for (const [index, item] of data.entries()) {\n      const renderedInputItem = this.sig\n        .getInputFields()\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...exampleContext,\n            isInputField: true,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedOutputItem = this.sig\n        .getOutputFields()\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...exampleContext,\n            isInputField: false,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedItem = [...renderedInputItem, ...renderedOutputItem];\n\n      if (\n        index > 0 &&\n        renderedItem.length > 0 &&\n        renderedItem[0]?.type === 'text'\n      ) {\n        list.push({ type: 'text' as const, text: '---\\n\\n' });\n      }\n\n      renderedItem.forEach((v) => {\n        if ('text' in v) {\n          v.text = `${v.text}\\n`;\n        }\n        list.push(v);\n      });\n    }\n\n    return list;\n  };\n\n  private renderDemos = (data: Readonly<Record<string, AxFieldValue>[]>) => {\n    const list: ChatRequestUserMessage = [];\n    const inputFields = this.sig.getInputFields();\n    const outputFields = this.sig.getOutputFields();\n    const demoContext = {\n      isExample: true,\n    };\n\n    for (const item of data) {\n      const inputRenderedItems = inputFields\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...demoContext,\n            isInputField: true,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const outputRenderedItems = outputFields\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...demoContext,\n            isInputField: false,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedItem = [...inputRenderedItems, ...outputRenderedItems];\n\n      renderedItem.slice(0, -1).forEach((v) => {\n        if ('text' in v) {\n          v.text = `${v.text}\\n`;\n        }\n        list.push(v);\n      });\n    }\n\n    return list;\n  };\n\n  private renderInputFields = <T extends AxGenIn>(values: T) => {\n    const renderedItems = this.sig\n      .getInputFields()\n      .map((field) => this.renderInField(field, values, undefined))\n      .filter((v) => v !== undefined)\n      .flat();\n\n    renderedItems\n      .filter((v) => v.type === 'text')\n      .forEach((v) => {\n        v.text = `${v.text}\\n`;\n      });\n\n    return renderedItems;\n  };\n\n  private renderInField = (\n    field: Readonly<AxField>,\n    values: Readonly<Record<string, AxFieldValue>>,\n    context?: {\n      isExample?: boolean;\n      strictExamples?: boolean;\n      optionalOutputFields?: string[];\n      isInputField?: boolean;\n    }\n  ) => {\n    const value = values[field.name];\n\n    if (isEmptyValue(field, value, context)) {\n      return;\n    }\n\n    if (field.type) {\n      validateValue(field, value!);\n    }\n\n    const processedValue = processValue(field, value!);\n\n    const textFieldFn: AxFieldTemplateFn =\n      this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;\n\n    return textFieldFn(field, processedValue);\n  };\n\n  private defaultRenderInField = (\n    field: Readonly<AxField>,\n    value: Readonly<AxFieldValue>\n  ): ChatRequestUserMessage => {\n    if (field.type?.name === 'image') {\n      const validateImage = (\n        value: Readonly<AxFieldValue>\n      ): { mimeType: string; data: string } => {\n        if (!value) {\n          throw new Error('Image field value is required.');\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Image field value must be an object.');\n        }\n        if (!('mimeType' in value)) {\n          throw new Error('Image field must have mimeType');\n        }\n        if (!('data' in value)) {\n          throw new Error('Image field must have data');\n        }\n        return value as { mimeType: string; data: string };\n      };\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Image field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            // Cast to unknown[] before map\n            const validated = validateImage(v as AxFieldValue);\n            return {\n              type: 'image',\n              mimeType: validated.mimeType,\n              image: validated.data,\n            };\n          })\n        );\n      } else {\n        const validated = validateImage(value);\n        result.push({\n          type: 'image',\n          mimeType: validated.mimeType,\n          image: validated.data,\n        });\n      }\n      return result;\n    }\n\n    if (field.type?.name === 'audio') {\n      const validateAudio = (\n        value: Readonly<AxFieldValue>\n      ): { format?: 'wav'; data: string } => {\n        if (!value) {\n          throw new Error('Audio field value is required.');\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Audio field value must be an object.');\n        }\n        if (!('data' in value)) {\n          throw new Error('Audio field must have data');\n        }\n        return value as { format?: 'wav'; data: string };\n      };\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Audio field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            // Cast to unknown[] before map\n            const validated = validateAudio(v as AxFieldValue);\n            return {\n              type: 'audio',\n              format: validated.format ?? 'wav',\n              data: validated.data,\n            };\n          })\n        );\n      } else {\n        const validated = validateAudio(value);\n        result.push({\n          type: 'audio',\n          format: validated.format ?? 'wav',\n          data: validated.data,\n        });\n      }\n      return result;\n    }\n\n    const text = [field.title, ': '];\n\n    if (Array.isArray(value)) {\n      text.push('\\n');\n      text.push(value.map((v) => `- ${v}`).join('\\n'));\n    } else {\n      text.push(value as string);\n    }\n    return [{ type: 'text', text: text.join('') }];\n  };\n}\n\nconst renderDescFields = (list: readonly AxField[]) =>\n  list.map((v) => `\\`${v.title}\\``).join(', ');\n\nconst renderInputFields = (fields: readonly AxField[]) => {\n  const rows = fields.map((field) => {\n    const name = field.title;\n    const type = field.type?.name ? toFieldType(field.type) : 'string';\n\n    const requiredMsg = field.isOptional\n      ? `This optional ${type} field may be omitted`\n      : `A ${type} field`;\n\n    const description = field.description\n      ? ` ${formatDescription(field.description)}`\n      : '';\n\n    return `${name}: (${requiredMsg})${description}`.trim();\n  });\n\n  return rows.join('\\n');\n};\n\nconst renderOutputFields = (fields: readonly AxField[]) => {\n  const rows = fields.map((field) => {\n    const name = field.title;\n    const type = field.type?.name ? toFieldType(field.type) : 'string';\n\n    const requiredMsg = field.isOptional\n      ? `Only include this ${type} field if its value is available`\n      : `This ${type} field must be included`;\n\n    let description = '';\n\n    if (field.description && field.description.length > 0) {\n      const value =\n        field.type?.name === 'class'\n          ? field.description\n          : formatDescription(field.description);\n      description = ` ${value}`;\n    }\n\n    if (field.type?.options && field.type.options.length > 0) {\n      if (description.length > 0) {\n        description += '. ';\n      }\n      description += `Allowed values: ${field.type.options.join(', ')}`;\n    }\n\n    return `${name}: (${requiredMsg})${description}`.trim();\n  });\n\n  return rows.join('\\n');\n};\n\nconst processValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): AxFieldValue => {\n  if (field.type?.name === 'date' && value instanceof Date) {\n    const v = value.toISOString();\n    return v.slice(0, v.indexOf('T'));\n  }\n  if (field.type?.name === 'datetime' && value instanceof Date) {\n    return formatDateWithTimezone(value);\n  }\n  if (field.type?.name === 'image' && typeof value === 'object') {\n    return value;\n  }\n  if (field.type?.name === 'audio' && typeof value === 'object') {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  return JSON.stringify(value, null, 2);\n};\n\nexport const toFieldType = (type: Readonly<AxField['type']>) => {\n  const baseType = (() => {\n    switch (type?.name) {\n      case 'string':\n        return 'string';\n      case 'number':\n        return 'number';\n      case 'boolean':\n        return 'boolean (true or false)';\n      case 'date':\n        return 'date (\"YYYY-MM-DD\" format)';\n      case 'datetime':\n        return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n      case 'json':\n        return 'JSON object';\n      case 'class':\n        return 'classification class';\n      case 'code':\n        return 'code';\n      default:\n        return 'string';\n    }\n  })();\n\n  return type?.isArray ? `json array of ${baseType} items` : baseType;\n};\n\nfunction combineConsecutiveStrings(separator: string) {\n  return (acc: ChatRequestUserMessage, current: ChatRequestUserMessage[0]) => {\n    if (current.type === 'text') {\n      const previous = acc.length > 0 ? acc[acc.length - 1] : null;\n      if (previous && previous.type === 'text') {\n        previous.text += separator + current.text;\n      } else {\n        acc.push(current);\n      }\n    } else {\n      acc.push(current);\n    }\n    return acc;\n  };\n}\n\nconst isEmptyValue = (\n  field: Readonly<AxField>,\n  value?: Readonly<AxFieldValue>,\n  context?: {\n    isExample?: boolean;\n    isInputField?: boolean;\n  }\n) => {\n  if (typeof value === 'boolean') {\n    return false;\n  }\n\n  if (\n    !value ||\n    ((Array.isArray(value) || typeof value === 'string') && value.length === 0)\n  ) {\n    // Handle examples case - all fields can be missing in examples\n    if (context?.isExample) {\n      return true;\n    }\n\n    // Handle non-examples case (regular field validation)\n    if (field.isOptional || field.isInternal) {\n      return true;\n    }\n\n    const fieldType = context?.isInputField !== false ? 'input' : 'output';\n    throw new Error(\n      `Value for ${fieldType} field '${field.name}' is required.`\n    );\n  }\n  return false;\n};\n\nfunction formatDescription(str: string) {\n  const value = str.trim();\n  return value.length > 0\n    ? `${value.charAt(0).toUpperCase()}${value.slice(1)}${value.endsWith('.') ? '' : '.'}`\n    : '';\n}\n", "import type { AxAIMemory } from '../mem/types.js';\n\nimport type {\n  AxGenDeltaOut,\n  AxResultPickerFunction,\n  AxResultPickerFunctionFunctionResults,\n} from './program.js';\nimport type { AxGenOut } from './types.js';\n\nexport interface AxSamplePickerOptions<OUT extends AxGenOut> {\n  resultPicker?: AxResultPickerFunction<OUT>;\n}\n\n/**\n * Checks if there are function calls in memory\n */\nfunction checkForFunctionCalls(mem: AxAIMemory, sessionId?: string): boolean {\n  const history = mem.history(0, sessionId);\n\n  // Check for both function calls and function results\n  const hasFunctionResults = history.some((msg) => msg.role === 'function');\n  const hasFunctionCalls = history.some(\n    (msg) =>\n      msg.role === 'assistant' &&\n      'functionCalls' in msg &&\n      Array.isArray(msg.functionCalls) &&\n      msg.functionCalls.length > 0\n  );\n\n  return hasFunctionCalls && hasFunctionResults;\n}\n\n/**\n * Extracts function execution results from memory\n */\nfunction extractFunctionResults(\n  mem: AxAIMemory,\n  sessionId?: string\n): AxResultPickerFunctionFunctionResults['results'] {\n  const history = mem.history(0, sessionId);\n  const results: {\n    index: number;\n    functionName: string;\n    functionId: string;\n    args: string | object;\n    result: string;\n    isError?: boolean;\n  }[] = [];\n\n  // Find assistant messages with function calls\n  const assistantMessages = history.filter(\n    (msg) =>\n      msg.role === 'assistant' &&\n      'functionCalls' in msg &&\n      Array.isArray(msg.functionCalls) &&\n      msg.functionCalls.length > 0\n  );\n\n  // Find function result messages\n  const functionMessages = history.filter((msg) => msg.role === 'function');\n\n  // Match function calls with their results\n  for (const assistantMsg of assistantMessages) {\n    if ('functionCalls' in assistantMsg && assistantMsg.functionCalls) {\n      for (const funcCall of assistantMsg.functionCalls) {\n        // Find the corresponding function result\n        const funcResult = functionMessages.find(\n          (msg) => 'functionId' in msg && msg.functionId === funcCall.id\n        );\n\n        if (\n          funcResult &&\n          'result' in funcResult &&\n          'functionId' in funcResult\n        ) {\n          results.push({\n            index: results.length, // Use sequential index for function results\n            functionName: funcCall.function.name,\n            functionId: funcCall.id,\n            args: funcCall.function.params || '',\n            result: String(funcResult.result),\n            isError:\n              'isError' in funcResult ? Boolean(funcResult.isError) : false,\n          });\n        }\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Selects a result from multiple samples using the provided result picker function.\n * If no result picker is provided or only one result exists, returns the first result.\n */\nexport async function selectFromSamples<OUT extends AxGenOut>(\n  buffer: AxGenDeltaOut<OUT>[],\n  options?: AxSamplePickerOptions<OUT>,\n  mem?: AxAIMemory,\n  sessionId?: string\n): Promise<number> {\n  // If no result picker or only one result, use index 0\n  if (!options?.resultPicker || buffer.length <= 1) {\n    return 0;\n  }\n\n  const resultPicker = options.resultPicker;\n\n  // Check if there are function calls in memory to determine data type\n  const hasFunctionCalls = mem ? checkForFunctionCalls(mem, sessionId) : false;\n\n  if (hasFunctionCalls && mem) {\n    // Extract function execution data from memory\n    const functionResults = extractFunctionResults(mem, sessionId);\n    const selectedIndex = await resultPicker({\n      type: 'function',\n      results: functionResults,\n    });\n\n    // Validate the selected index\n    if (selectedIndex < 0 || selectedIndex >= functionResults.length) {\n      throw new Error(\n        `Result picker returned invalid index: ${selectedIndex}. Must be between 0 and ${functionResults.length - 1}`\n      );\n    }\n\n    return selectedIndex;\n  }\n  // Use field results\n  const fieldResults = buffer.map((b, index) => ({\n    index,\n    sample: b.delta,\n  }));\n\n  const selectedIndex = await resultPicker({\n    type: 'fields',\n    results: fieldResults,\n  });\n\n  // Validate the selected index\n  if (selectedIndex < 0 || selectedIndex >= buffer.length) {\n    throw new Error(\n      `Result picker returned invalid index: ${selectedIndex}. Must be between 0 and ${buffer.length - 1}`\n    );\n  }\n\n  return selectedIndex;\n}\n\n/**\n * Selects a result index from memory using the provided result picker function.\n * If no result picker is provided or only one result exists, returns 0.\n * If the last memory is not from an assistant role, returns 0.\n */\nexport async function selectFromSamplesInMemory<OUT extends AxGenOut>(\n  mem: AxAIMemory,\n  sessionId?: string,\n  options?: AxSamplePickerOptions<OUT>\n): Promise<number> {\n  const lastMemory = mem?.getLast(sessionId);\n\n  // If no memory or not from assistant role, return 0\n  if (!lastMemory || lastMemory.role !== 'assistant') {\n    return 0;\n  }\n\n  // If only one chat sample, return 0\n  if (lastMemory.chat.length <= 1) {\n    return 0;\n  }\n\n  // Convert memory chat to buffer format for selectFromSamples\n  const buffer = lastMemory.chat.map((chat) => ({\n    version: 0,\n    index: chat.index,\n    delta: chat.value as OUT,\n  }));\n\n  const selectedIndex = await selectFromSamples(\n    buffer,\n    options,\n    mem,\n    sessionId\n  );\n  return selectedIndex;\n}\n", "import type { AxAIService } from '../ai/types.js';\nimport type { AxAIMemory } from '../mem/types.js';\n\nimport type { AxPromptTemplate } from './prompt.js';\nimport type { AxIField } from './sig.js';\n\nexport function handleValidationError(\n  mem: AxAIMemory,\n  errorFields: AxIField[],\n  ai: Readonly<AxAIService>,\n  promptTemplate: Readonly<AxPromptTemplate>,\n  sessionId?: string\n) {\n  mem.addRequest(\n    [\n      {\n        role: 'user' as const,\n        content: promptTemplate.renderExtraFields(errorFields),\n      },\n    ],\n    sessionId\n  );\n  mem.addTag('error', sessionId);\n\n  if (ai.getOptions().debug) {\n    const errors = errorFields\n      .map((field) => `- ${field.title}: ${field.description}`)\n      .join('\\n');\n\n    const logger = ai.getLogger();\n    logger(` Error Correction:\\n${errors}`, {\n      tags: ['error'],\n    });\n  }\n}\n", "const trimNonAlphaNum = (str: string) => {\n  return str.replace(/^\\W+|\\W+$/g, '');\n};\n\nconst splitIntoTwo = (\n  str: string,\n  separator: Readonly<RegExp | string>\n): string[] => {\n  const index = str.search(separator);\n  if (index === -1) {\n    return [str]; // No separator found, return the original string as the only part\n  }\n  const matchResult = str.match(separator);\n  if (!matchResult) {\n    throw new Error('Match failed unexpectedly.');\n  }\n  const firstPart = str.substring(0, index);\n  const secondPart = str.substring(index + matchResult[0].length);\n  return [firstPart, secondPart];\n};\n\nconst dedup = (seq: readonly string[]): string[] => {\n  const seen = new Set<string>();\n  const result: string[] = [];\n\n  for (const x of seq) {\n    if (!seen.has(x)) {\n      seen.add(x);\n      result.push(x);\n    }\n  }\n\n  return result;\n};\n\nconst extractIdAndText = (input: string): { id: number; text: string } => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/);\n  if (!match || match.length < 3) {\n    throw new Error(\n      'line must start with a number, a dot and then text. e.g. \"1. hello\"'\n    );\n  }\n\n  const id = Number.parseInt(match[1] as string, 10);\n  const text = (match[2] as string).trim();\n  return { id, text };\n};\n\nconst extractIndexPrefixedText = (input: string): string => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/);\n  // Check if match is not null and if the second capturing group is present\n  if (match && match[2] !== undefined) {\n    return match[2].trim();\n  }\n  return input;\n};\n\nconst batchArray = <T>(arr: readonly T[], size: number): T[][] => {\n  const chunkedArr: T[][] = [];\n  for (let i = 0; i < arr.length; i += size) {\n    chunkedArr.push(arr.slice(i, i + size));\n  }\n  return chunkedArr;\n};\n\nexport const AxStringUtil = {\n  trimNonAlphaNum,\n  splitIntoTwo,\n  dedup,\n  extractIdAndText,\n  extractIndexPrefixedText,\n  batchArray,\n};\n", "import type { AxAIService } from '../ai/types.js';\nimport { AxGen } from '../dsp/generate.js';\nimport type { AxProgramForwardOptions } from '../dsp/program.js';\nimport { AxStringUtil } from '../dsp/strutil.js';\n\nimport type { AxRerankerIn, AxRerankerOut } from './manager.js';\n\nexport class AxDefaultResultReranker extends AxGen<\n  AxRerankerIn,\n  AxRerankerOut\n> {\n  constructor(options?: Readonly<AxProgramForwardOptions>) {\n    const signature = `\"You are a re-ranker assistant tasked with evaluating a set of content items in relation to a specific question. Your role involves critically analyzing each content item to determine its relevance to the question and re-ranking them accordingly. This process includes assigning a relevance score from 0 to 10 to each content item based on how well it answers the question, its coverage of the topic, and the reliability of its information. This re-ranked list should start with the content item that is most relevant to the question and end with the least relevant. Output only the list.\"\n    query: string, items: string[] -> rankedItems: string[] \"list of id, 5-words Rationale, relevance score\"`;\n\n    super(signature, options);\n  }\n\n  public override forward = async (\n    ai: Readonly<AxAIService>,\n    input: Readonly<AxRerankerIn>,\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<AxRerankerOut> => {\n    const { rankedItems } = await super.forward(ai, input, options);\n\n    const sortedIndexes: number[] = rankedItems.map((item) => {\n      const { id: index } = AxStringUtil.extractIdAndText(item);\n      return index;\n    });\n\n    // Ensure all elements are strings and filter out null or undefined\n    const sortedItems = input.items\n      .map((_, index) => {\n        const originalIndex = sortedIndexes[index];\n        return originalIndex !== undefined\n          ? input.items[originalIndex]\n          : undefined;\n      })\n      .filter((item): item is string => item !== undefined);\n\n    return { rankedItems: sortedItems };\n  };\n}\n", "// Dynamic import for Node.js-specific functionality to maintain browser compatibility\n\nexport interface AxApacheTikaArgs {\n  url?: string | URL;\n  fetch?: typeof fetch;\n}\n\nexport interface AxApacheTikaConvertOptions {\n  format?: 'text' | 'html';\n}\n\nexport class AxApacheTika {\n  private tikaUrl: URL;\n  private fetch?: typeof fetch;\n\n  constructor(args?: Readonly<AxApacheTikaArgs>) {\n    const Args = args ?? { url: 'http://localhost:9998/' };\n    this.tikaUrl = new URL('/tika', Args.url);\n    this.fetch = Args.fetch;\n  }\n\n  private async _convert(\n    fileData: ReadableStream | Blob,\n    options?: Readonly<AxApacheTikaConvertOptions>\n  ): Promise<string> {\n    if (!fileData) {\n      throw new Error('Failed to read file data');\n    }\n\n    const acceptValue = options?.format === 'html' ? 'text/html' : 'text/plain';\n\n    try {\n      const fetchOptions: RequestInit = {\n        body: fileData as any,\n        headers: { Accept: acceptValue },\n        method: 'PUT',\n      };\n\n      // Add duplex option only in Node.js environments\n      if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        (fetchOptions as any).duplex = 'half';\n      }\n\n      const res = await (this.fetch ?? fetch)(this.tikaUrl, fetchOptions);\n\n      if (!res.ok) {\n        throw new Error(`Failed to upload file: ${res.statusText}`);\n      }\n\n      const text = await res.text();\n      return text;\n    } catch (error) {\n      throw new Error(`Error converting file: ${error}`);\n    }\n  }\n\n  public async convert(\n    files: Readonly<Blob[] | ReadableStream[]>,\n    options?: Readonly<{ batchSize?: number; format?: 'html' | 'text' }>\n  ): Promise<string[]> {\n    const results: string[] = [];\n    const bs = options?.batchSize ?? 10;\n\n    for (let i = 0; i < files.length; i += bs) {\n      const batch = files.slice(i, i + bs);\n      const uploadPromises = batch.map((files) =>\n        this._convert(files, { format: options?.format })\n      );\n      const batchResults = await Promise.all(uploadPromises);\n      results.push(...batchResults);\n    }\n\n    return results;\n  }\n}\nexport default AxApacheTika;\n", "import type { AxAIService } from '../ai/types.js';\nimport { AxDBMemory, type AxDBState } from '../db/memory.js';\nimport { ColorLog } from '../util/log.js';\n\nconst colorLog = new ColorLog();\n\nexport interface AxSimpleClassifierForwardOptions {\n  cutoff?: number;\n  abortSignal?: AbortSignal;\n}\n\nexport class AxSimpleClassifierClass {\n  private readonly name: string;\n  private readonly context: readonly string[];\n\n  constructor(name: string, context: readonly string[]) {\n    this.name = name;\n    this.context = context;\n  }\n\n  public getName(): string {\n    return this.name;\n  }\n\n  public getContext(): readonly string[] {\n    return this.context;\n  }\n}\n\nexport class AxSimpleClassifier {\n  private readonly ai: AxAIService;\n\n  private db: AxDBMemory;\n  private debug?: boolean;\n\n  public constructor(ai: AxAIService) {\n    this.db = new AxDBMemory();\n    this.ai = ai;\n  }\n\n  public getState(): AxDBState | undefined {\n    return this.db.getDB();\n  }\n\n  public setState(state: AxDBState) {\n    this.db.setDB(state);\n  }\n\n  public setClasses = async (\n    classes: readonly AxSimpleClassifierClass[],\n    options?: Readonly<{ abortSignal?: AbortSignal }>\n  ): Promise<void> => {\n    for (const c of classes) {\n      const ret = await this.ai.embed(\n        { texts: c.getContext() },\n        {\n          abortSignal: options?.abortSignal,\n        }\n      );\n      await this.db.upsert({\n        id: c.getName(),\n        table: 'classes',\n        values: ret.embeddings[0],\n      });\n    }\n  };\n\n  public async forward(\n    text: string,\n    options?: Readonly<AxSimpleClassifierForwardOptions>\n  ): Promise<string> {\n    const { embeddings } = await this.ai.embed(\n      { texts: [text] },\n      {\n        abortSignal: options?.abortSignal,\n      }\n    );\n\n    const matches = await this.db.query({\n      table: 'classes',\n      values: embeddings[0],\n    });\n\n    let m = matches.matches;\n    if (typeof options?.cutoff === 'number') {\n      const { cutoff } = options;\n      m = m.filter((m) => m.score <= cutoff);\n    }\n\n    if (this.debug) {\n      console.log(\n        `${colorLog.whiteBright(`query: ${text}`)}\\n${colorLog.greenBright(\n          JSON.stringify(m.map((m) => `${m.id}, ${m.score}`))\n        )}`\n      );\n    }\n\n    const matchedClass = m.at(0);\n    if (!matchedClass) {\n      return '';\n    }\n\n    return matchedClass.id;\n  }\n\n  public setOptions(options: Readonly<{ debug?: boolean }>): void {\n    if (typeof options.debug === 'boolean') {\n      this.debug = options.debug;\n    }\n  }\n}\n", "export const stopwords = new Set([\n  '0o',\n  '0s',\n  '3a',\n  '3b',\n  '3d',\n  '6b',\n  '6o',\n  'a',\n  'a1',\n  'a2',\n  'a3',\n  'a4',\n  'ab',\n  'able',\n  'about',\n  'above',\n  'abst',\n  'ac',\n  'accordance',\n  'according',\n  'accordingly',\n  'across',\n  'act',\n  'actually',\n  'ad',\n  'added',\n  'adj',\n  'ae',\n  'af',\n  'affected',\n  'affecting',\n  'affects',\n  'after',\n  'afterwards',\n  'ag',\n  'again',\n  'against',\n  'ah',\n  'ain',\n  \"ain't\",\n  'aj',\n  'al',\n  'all',\n  'allow',\n  'allows',\n  'almost',\n  'alone',\n  'along',\n  'already',\n  'also',\n  'although',\n  'always',\n  'am',\n  'among',\n  'amongst',\n  'amoungst',\n  'amount',\n  'an',\n  'and',\n  'announce',\n  'another',\n  'any',\n  'anybody',\n  'anyhow',\n  'anymore',\n  'anyone',\n  'anything',\n  'anyway',\n  'anyways',\n  'anywhere',\n  'ao',\n  'ap',\n  'apart',\n  'apparently',\n  'appear',\n  'appreciate',\n  'appropriate',\n  'approximately',\n  'ar',\n  'are',\n  'aren',\n  'arent',\n  \"aren't\",\n  'arise',\n  'around',\n  'as',\n  \"a's\",\n  'aside',\n  'ask',\n  'asking',\n  'associated',\n  'at',\n  'au',\n  'auth',\n  'av',\n  'available',\n  'aw',\n  'away',\n  'awfully',\n  'ax',\n  'ay',\n  'az',\n  'b',\n  'b1',\n  'b2',\n  'b3',\n  'ba',\n  'back',\n  'bc',\n  'bd',\n  'be',\n  'became',\n  'because',\n  'become',\n  'becomes',\n  'becoming',\n  'been',\n  'before',\n  'beforehand',\n  'begin',\n  'beginning',\n  'beginnings',\n  'begins',\n  'behind',\n  'being',\n  'believe',\n  'below',\n  'beside',\n  'besides',\n  'best',\n  'better',\n  'between',\n  'beyond',\n  'bi',\n  'bill',\n  'biol',\n  'bj',\n  'bk',\n  'bl',\n  'bn',\n  'both',\n  'bottom',\n  'bp',\n  'br',\n  'brief',\n  'briefly',\n  'bs',\n  'bt',\n  'bu',\n  'but',\n  'bx',\n  'by',\n  'c',\n  'c1',\n  'c2',\n  'c3',\n  'ca',\n  'call',\n  'came',\n  'can',\n  'cannot',\n  'cant',\n  \"can't\",\n  'cause',\n  'causes',\n  'cc',\n  'cd',\n  'ce',\n  'certain',\n  'certainly',\n  'cf',\n  'cg',\n  'ch',\n  'changes',\n  'ci',\n  'cit',\n  'cj',\n  'cl',\n  'clearly',\n  'cm',\n  \"c'mon\",\n  'cn',\n  'co',\n  'com',\n  'come',\n  'comes',\n  'con',\n  'concerning',\n  'consequently',\n  'consider',\n  'considering',\n  'contain',\n  'containing',\n  'contains',\n  'corresponding',\n  'could',\n  'couldn',\n  'couldnt',\n  \"couldn't\",\n  'course',\n  'cp',\n  'cq',\n  'cr',\n  'cry',\n  'cs',\n  \"c's\",\n  'ct',\n  'cu',\n  'currently',\n  'cv',\n  'cx',\n  'cy',\n  'cz',\n  'd',\n  'd2',\n  'da',\n  'date',\n  'dc',\n  'dd',\n  'de',\n  'definitely',\n  'describe',\n  'described',\n  'despite',\n  'detail',\n  'df',\n  'di',\n  'did',\n  'didn',\n  \"didn't\",\n  'different',\n  'dj',\n  'dk',\n  'dl',\n  'do',\n  'does',\n  'doesn',\n  \"doesn't\",\n  'doing',\n  'don',\n  'done',\n  \"don't\",\n  'down',\n  'downwards',\n  'dp',\n  'dr',\n  'ds',\n  'dt',\n  'du',\n  'due',\n  'during',\n  'dx',\n  'dy',\n  'e',\n  'e2',\n  'e3',\n  'ea',\n  'each',\n  'ec',\n  'ed',\n  'edu',\n  'ee',\n  'ef',\n  'effect',\n  'eg',\n  'ei',\n  'eight',\n  'eighty',\n  'either',\n  'ej',\n  'el',\n  'eleven',\n  'else',\n  'elsewhere',\n  'em',\n  'empty',\n  'en',\n  'end',\n  'ending',\n  'enough',\n  'entirely',\n  'eo',\n  'ep',\n  'eq',\n  'er',\n  'es',\n  'especially',\n  'est',\n  'et',\n  'et-al',\n  'etc',\n  'eu',\n  'ev',\n  'even',\n  'ever',\n  'every',\n  'everybody',\n  'everyone',\n  'everything',\n  'everywhere',\n  'ex',\n  'exactly',\n  'example',\n  'except',\n  'ey',\n  'f',\n  'f2',\n  'fa',\n  'far',\n  'fc',\n  'few',\n  'ff',\n  'fi',\n  'fifteen',\n  'fifth',\n  'fify',\n  'fill',\n  'find',\n  'fire',\n  'first',\n  'five',\n  'fix',\n  'fj',\n  'fl',\n  'fn',\n  'fo',\n  'followed',\n  'following',\n  'follows',\n  'for',\n  'former',\n  'formerly',\n  'forth',\n  'forty',\n  'found',\n  'four',\n  'fr',\n  'from',\n  'front',\n  'ft',\n  'fu',\n  'full',\n  'further',\n  'furthermore',\n  'fy',\n  'g',\n  'ga',\n  'gave',\n  'ge',\n  'get',\n  'gets',\n  'getting',\n  'gi',\n  'give',\n  'given',\n  'gives',\n  'giving',\n  'gj',\n  'gl',\n  'go',\n  'goes',\n  'going',\n  'gone',\n  'got',\n  'gotten',\n  'gr',\n  'greetings',\n  'gs',\n  'gy',\n  'h',\n  'h2',\n  'h3',\n  'had',\n  'hadn',\n  \"hadn't\",\n  'happens',\n  'hardly',\n  'has',\n  'hasn',\n  'hasnt',\n  \"hasn't\",\n  'have',\n  'haven',\n  \"haven't\",\n  'having',\n  'he',\n  'hed',\n  \"he'd\",\n  \"he'll\",\n  'hello',\n  'help',\n  'hence',\n  'her',\n  'here',\n  'hereafter',\n  'hereby',\n  'herein',\n  'heres',\n  \"here's\",\n  'hereupon',\n  'hers',\n  'herself',\n  'hes',\n  \"he's\",\n  'hh',\n  'hi',\n  'hid',\n  'him',\n  'himself',\n  'his',\n  'hither',\n  'hj',\n  'ho',\n  'home',\n  'hopefully',\n  'how',\n  'howbeit',\n  'however',\n  \"how's\",\n  'hr',\n  'hs',\n  'http',\n  'hu',\n  'hundred',\n  'hy',\n  'i',\n  'i2',\n  'i3',\n  'i4',\n  'i6',\n  'i7',\n  'i8',\n  'ia',\n  'ib',\n  'ibid',\n  'ic',\n  'id',\n  \"i'd\",\n  'ie',\n  'if',\n  'ig',\n  'ignored',\n  'ih',\n  'ii',\n  'ij',\n  'il',\n  \"i'll\",\n  'im',\n  \"i'm\",\n  'immediate',\n  'immediately',\n  'importance',\n  'important',\n  'in',\n  'inasmuch',\n  'inc',\n  'indeed',\n  'index',\n  'indicate',\n  'indicated',\n  'indicates',\n  'information',\n  'inner',\n  'insofar',\n  'instead',\n  'interest',\n  'into',\n  'invention',\n  'inward',\n  'io',\n  'ip',\n  'iq',\n  'ir',\n  'is',\n  'isn',\n  \"isn't\",\n  'it',\n  'itd',\n  \"it'd\",\n  \"it'll\",\n  'its',\n  \"it's\",\n  'itself',\n  'iv',\n  \"i've\",\n  'ix',\n  'iy',\n  'iz',\n  'j',\n  'jj',\n  'jr',\n  'js',\n  'jt',\n  'ju',\n  'just',\n  'k',\n  'ke',\n  'keep',\n  'keeps',\n  'kept',\n  'kg',\n  'kj',\n  'km',\n  'know',\n  'known',\n  'knows',\n  'ko',\n  'l',\n  'l2',\n  'la',\n  'largely',\n  'last',\n  'lately',\n  'later',\n  'latter',\n  'latterly',\n  'lb',\n  'lc',\n  'le',\n  'least',\n  'les',\n  'less',\n  'lest',\n  'let',\n  'lets',\n  \"let's\",\n  'lf',\n  'like',\n  'liked',\n  'likely',\n  'line',\n  'little',\n  'lj',\n  'll',\n  'll',\n  'ln',\n  'lo',\n  'look',\n  'looking',\n  'looks',\n  'los',\n  'lr',\n  'ls',\n  'lt',\n  'ltd',\n  'm',\n  'm2',\n  'ma',\n  'made',\n  'mainly',\n  'make',\n  'makes',\n  'many',\n  'may',\n  'maybe',\n  'me',\n  'mean',\n  'means',\n  'meantime',\n  'meanwhile',\n  'merely',\n  'mg',\n  'might',\n  'mightn',\n  \"mightn't\",\n  'mill',\n  'million',\n  'mine',\n  'miss',\n  'ml',\n  'mn',\n  'mo',\n  'more',\n  'moreover',\n  'most',\n  'mostly',\n  'move',\n  'mr',\n  'mrs',\n  'ms',\n  'mt',\n  'mu',\n  'much',\n  'mug',\n  'must',\n  'mustn',\n  \"mustn't\",\n  'my',\n  'myself',\n  'model',\n  'n',\n  'n2',\n  'na',\n  'name',\n  'namely',\n  'nay',\n  'nc',\n  'nd',\n  'ne',\n  'near',\n  'nearly',\n  'necessarily',\n  'necessary',\n  'need',\n  'needn',\n  \"needn't\",\n  'needs',\n  'neither',\n  'never',\n  'nevertheless',\n  'new',\n  'next',\n  'ng',\n  'ni',\n  'nine',\n  'ninety',\n  'nj',\n  'nl',\n  'nn',\n  'no',\n  'nobody',\n  'non',\n  'none',\n  'nonetheless',\n  'noone',\n  'nor',\n  'normally',\n  'nos',\n  'not',\n  'noted',\n  'nothing',\n  'novel',\n  'now',\n  'nowhere',\n  'nr',\n  'ns',\n  'nt',\n  'ny',\n  'o',\n  'oa',\n  'ob',\n  'obtain',\n  'obtained',\n  'obviously',\n  'oc',\n  'od',\n  'of',\n  'off',\n  'often',\n  'og',\n  'oh',\n  'oi',\n  'oj',\n  'ok',\n  'okay',\n  'ol',\n  'old',\n  'om',\n  'omitted',\n  'on',\n  'once',\n  'one',\n  'ones',\n  'only',\n  'onto',\n  'oo',\n  'op',\n  'oq',\n  'or',\n  'ord',\n  'os',\n  'ot',\n  'other',\n  'others',\n  'otherwise',\n  'ou',\n  'ought',\n  'our',\n  'ours',\n  'ourselves',\n  'out',\n  'outside',\n  'over',\n  'overall',\n  'ow',\n  'owing',\n  'own',\n  'ox',\n  'oz',\n  'p',\n  'p1',\n  'p2',\n  'p3',\n  'page',\n  'pagecount',\n  'pages',\n  'par',\n  'part',\n  'particular',\n  'particularly',\n  'pas',\n  'past',\n  'pc',\n  'pd',\n  'pe',\n  'per',\n  'perhaps',\n  'pf',\n  'ph',\n  'pi',\n  'pj',\n  'pk',\n  'pl',\n  'placed',\n  'please',\n  'plus',\n  'pm',\n  'pn',\n  'po',\n  'poorly',\n  'possible',\n  'possibly',\n  'potentially',\n  'pp',\n  'pq',\n  'pr',\n  'predominantly',\n  'present',\n  'presumably',\n  'previously',\n  'primarily',\n  'probably',\n  'promptly',\n  'proud',\n  'provides',\n  'ps',\n  'pt',\n  'pu',\n  'put',\n  'py',\n  'q',\n  'qj',\n  'qu',\n  'que',\n  'quickly',\n  'quite',\n  'qv',\n  'r',\n  'r2',\n  'ra',\n  'ran',\n  'rather',\n  'rc',\n  'rd',\n  're',\n  'readily',\n  'really',\n  'reasonably',\n  'recent',\n  'recently',\n  'ref',\n  'refs',\n  'regarding',\n  'regardless',\n  'regards',\n  'related',\n  'relatively',\n  'research',\n  'research-articl',\n  'respectively',\n  'resulted',\n  'resulting',\n  'results',\n  'rf',\n  'rh',\n  'ri',\n  'right',\n  'rj',\n  'rl',\n  'rm',\n  'rn',\n  'ro',\n  'rq',\n  'rr',\n  'rs',\n  'rt',\n  'ru',\n  'run',\n  'rv',\n  'ry',\n  's',\n  's2',\n  'sa',\n  'said',\n  'same',\n  'saw',\n  'say',\n  'saying',\n  'says',\n  'sc',\n  'sd',\n  'se',\n  'sec',\n  'second',\n  'secondly',\n  'section',\n  'see',\n  'seeing',\n  'seem',\n  'seemed',\n  'seeming',\n  'seems',\n  'seen',\n  'self',\n  'selves',\n  'sensible',\n  'sent',\n  'serious',\n  'seriously',\n  'seven',\n  'several',\n  'sf',\n  'shall',\n  'shan',\n  \"shan't\",\n  'she',\n  'shed',\n  \"she'd\",\n  \"she'll\",\n  'shes',\n  \"she's\",\n  'should',\n  'shouldn',\n  \"shouldn't\",\n  \"should've\",\n  'show',\n  'showed',\n  'shown',\n  'showns',\n  'shows',\n  'si',\n  'side',\n  'significant',\n  'significantly',\n  'similar',\n  'similarly',\n  'since',\n  'sincere',\n  'six',\n  'sixty',\n  'sj',\n  'sl',\n  'slightly',\n  'sm',\n  'sn',\n  'so',\n  'some',\n  'somebody',\n  'somehow',\n  'someone',\n  'somethan',\n  'something',\n  'sometime',\n  'sometimes',\n  'somewhat',\n  'somewhere',\n  'soon',\n  'sorry',\n  'sp',\n  'specifically',\n  'specified',\n  'specify',\n  'specifying',\n  'sq',\n  'sr',\n  'ss',\n  'st',\n  'still',\n  'stop',\n  'strongly',\n  'sub',\n  'substantially',\n  'successfully',\n  'such',\n  'sufficiently',\n  'suggest',\n  'sup',\n  'sure',\n  'sy',\n  'system',\n  'sz',\n  't',\n  't1',\n  't2',\n  't3',\n  'take',\n  'taken',\n  'taking',\n  'tb',\n  'tc',\n  'td',\n  'te',\n  'tell',\n  'ten',\n  'tends',\n  'tf',\n  'th',\n  'than',\n  'thank',\n  'thanks',\n  'thanx',\n  'that',\n  \"that'll\",\n  'thats',\n  \"that's\",\n  \"that've\",\n  'the',\n  'their',\n  'theirs',\n  'them',\n  'themselves',\n  'then',\n  'thence',\n  'there',\n  'thereafter',\n  'thereby',\n  'thered',\n  'therefore',\n  'therein',\n  \"there'll\",\n  'thereof',\n  'therere',\n  'theres',\n  \"there's\",\n  'thereto',\n  'thereupon',\n  \"there've\",\n  'these',\n  'they',\n  'theyd',\n  \"they'd\",\n  \"they'll\",\n  'theyre',\n  \"they're\",\n  \"they've\",\n  'thickv',\n  'thin',\n  'think',\n  'third',\n  'this',\n  'thorough',\n  'thoroughly',\n  'those',\n  'thou',\n  'though',\n  'thoughh',\n  'thousand',\n  'three',\n  'throug',\n  'through',\n  'throughout',\n  'thru',\n  'thus',\n  'ti',\n  'til',\n  'tip',\n  'tj',\n  'tl',\n  'tm',\n  'tn',\n  'to',\n  'together',\n  'too',\n  'took',\n  'top',\n  'toward',\n  'towards',\n  'tp',\n  'tq',\n  'tr',\n  'tried',\n  'tries',\n  'truly',\n  'try',\n  'trying',\n  'ts',\n  \"t's\",\n  'tt',\n  'tv',\n  'twelve',\n  'twenty',\n  'twice',\n  'two',\n  'tx',\n  'u',\n  'u201d',\n  'ue',\n  'ui',\n  'uj',\n  'uk',\n  'um',\n  'un',\n  'under',\n  'unfortunately',\n  'unless',\n  'unlike',\n  'unlikely',\n  'until',\n  'unto',\n  'uo',\n  'up',\n  'upon',\n  'ups',\n  'ur',\n  'us',\n  'use',\n  'used',\n  'useful',\n  'usefully',\n  'usefulness',\n  'uses',\n  'using',\n  'usually',\n  'ut',\n  'v',\n  'va',\n  'value',\n  'various',\n  'vd',\n  've',\n  've',\n  'very',\n  'via',\n  'viz',\n  'vj',\n  'vo',\n  'vol',\n  'vols',\n  'volumtype',\n  'vq',\n  'vs',\n  'vt',\n  'vu',\n  'w',\n  'wa',\n  'want',\n  'wants',\n  'was',\n  'wasn',\n  'wasnt',\n  \"wasn't\",\n  'way',\n  'we',\n  'wed',\n  \"we'd\",\n  'welcome',\n  'well',\n  \"we'll\",\n  'well-b',\n  'went',\n  'were',\n  \"we're\",\n  'weren',\n  'werent',\n  \"weren't\",\n  \"we've\",\n  'what',\n  'whatever',\n  \"what'll\",\n  'whats',\n  \"what's\",\n  'when',\n  'whence',\n  'whenever',\n  \"when's\",\n  'where',\n  'whereafter',\n  'whereas',\n  'whereby',\n  'wherein',\n  'wheres',\n  \"where's\",\n  'whereupon',\n  'wherever',\n  'whether',\n  'which',\n  'while',\n  'whim',\n  'whither',\n  'who',\n  'whod',\n  'whoever',\n  'whole',\n  \"who'll\",\n  'whom',\n  'whomever',\n  'whos',\n  \"who's\",\n  'whose',\n  'why',\n  \"why's\",\n  'wi',\n  'widely',\n  'will',\n  'willing',\n  'wish',\n  'with',\n  'within',\n  'without',\n  'wo',\n  'won',\n  'wonder',\n  'wont',\n  \"won't\",\n  'words',\n  'world',\n  'would',\n  'wouldn',\n  'wouldnt',\n  \"wouldn't\",\n  'www',\n  'x',\n  'x1',\n  'x2',\n  'x3',\n  'xf',\n  'xi',\n  'xj',\n  'xk',\n  'xl',\n  'xn',\n  'xo',\n  'xs',\n  'xt',\n  'xv',\n  'xx',\n  'y',\n  'y2',\n  'yes',\n  'yet',\n  'yj',\n  'yl',\n  'you',\n  'youd',\n  \"you'd\",\n  \"you'll\",\n  'your',\n  'youre',\n  \"you're\",\n  'yours',\n  'yourself',\n  'yourselves',\n  \"you've\",\n  'yr',\n  'ys',\n  'yt',\n  'z',\n  'zero',\n  'zi',\n  'zz',\n  'task',\n]);\n", "import { stopwords } from './stopwords.js';\n\n/**\n * Filters out tokens based on a set of exclusion tokens.\n *\n * @param tokens The array of tokens to filter.\n * @param exclusions A set containing tokens to exclude.\n * @returns An array of filtered tokens.\n */\nfunction filterTokens(\n  tokens: readonly string[],\n  exclusions: ReadonlySet<string>\n): string[] {\n  return tokens.filter((token) => !exclusions.has(token));\n}\n\n/**\n * Counts the occurrences of each token in an array of tokens.\n *\n * This function supports the preprocessing step for NLP tasks like text similarity\n * and classification by transforming text into a bag-of-words model, facilitating\n * the comparison of different texts based on their content.\n *\n * @param tokens An array of string tokens.\n * @returns A Counter object mapping each token to its count.\n */\nfunction countTokens(tokens: readonly string[]): Record<string, number> {\n  const counter: Record<string, number> = {};\n  for (const token of tokens) {\n    counter[token] = (counter[token] || 0) + 1;\n  }\n  return counter;\n}\n\n/**\n * Normalizes text by lowercasing, removing punctuation, and squashing multiple spaces.\n *\n * This normalization is crucial in NLP for reducing the complexity of the text data,\n * minimizing the variance between words that should be considered the same for analysis\n * purposes (e.g., \"Dog!\" and \"dog\" are treated as the same word).\n *\n * @param s A string to be normalized.\n * @returns A normalized string.\n */\nfunction normalizeText(s: string): string {\n  let normalized = s.normalize('NFD');\n  normalized = normalized.replace(/\\b(a|an|the)\\b/g, ' ');\n  normalized = normalized.split(/\\s+/).join(' ');\n  normalized = normalized.replace(/[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]/g, '');\n  return normalized.toLowerCase();\n}\n\n/**\n * Calculates the Exact Match (EM) score between a prediction and ground truth.\n *\n * The EM score is a strict metric used in machine learning to assess if the predicted\n * answer matches the ground truth exactly, commonly used in tasks like question answering.\n *\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @returns A number (1.0 for exact match, 0.0 otherwise).\n */\nfunction emScore(prediction: string, groundTruth: string): number {\n  return normalizeText(prediction) === normalizeText(groundTruth) ? 1.0 : 0.0;\n}\n\n/**\n * Calculates the F1 score between a prediction and ground truth.\n *\n * The F1 score is a harmonic mean of precision and recall, widely used in NLP to measure\n * a model's accuracy in considering both false positives and false negatives, offering a\n * balance for evaluating classification models.\n *\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @returns The F1 score as a number.\n */\nfunction f1Score(prediction: string, groundTruth: string): number {\n  const predictionTokens = normalizeText(prediction).split(' ');\n  const groundTruthTokens = normalizeText(groundTruth).split(' ');\n\n  // Calculate the intersection of common tokens between prediction and ground truth\n  const predictionCounts = countTokens(predictionTokens);\n  const groundTruthCounts = countTokens(groundTruthTokens);\n\n  let numSame = 0;\n  for (const token in predictionCounts) {\n    const v1 = predictionCounts[token] ?? 0;\n    const v2 = groundTruthCounts[token] ?? 0;\n    numSame += Math.min(v1, v2);\n  }\n  if (numSame === 0) {\n    return 0;\n  }\n\n  const precision = numSame / predictionTokens.length;\n  const recall = numSame / groundTruthTokens.length;\n  return (2 * precision * recall) / (precision + recall);\n}\n\n/**\n * Calculates a novel F1 score, taking into account a history of interaction and excluding stopwords.\n *\n * This metric extends the F1 score by considering contextual relevance and filtering out common words\n * that might skew the assessment of the prediction's quality, especially in conversational models or\n * when historical context is relevant.\n *\n * @param history The historical context or preceding interactions.\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @param returnRecall Optionally return the recall score instead of F1.\n * @returns The novel F1 or recall score as a number.\n */\nfunction novelF1ScoreOptimized(\n  history: string,\n  prediction: string,\n  groundTruth: string,\n  returnRecall = false\n): number {\n  // Normalize and split the input texts into tokens\n  const historyTokens = normalizeText(history).split(' ');\n  let predictionTokens = normalizeText(prediction).split(' ');\n  let groundTruthTokens = normalizeText(groundTruth).split(' ');\n\n  // Combine stopwords and history tokens for exclusion\n  const exclusions = new Set([...stopwords, ...historyTokens]);\n\n  // Filter prediction and ground truth tokens against the exclusions\n  predictionTokens = filterTokens(predictionTokens, exclusions);\n  groundTruthTokens = filterTokens(groundTruthTokens, exclusions);\n\n  // Proceed with calculating common tokens, precision, recall, and F1 score as previously outlined\n\n  // Placeholder for the calculation logic\n  const numSame = 0; // This should be calculated as before\n  const precision = numSame / predictionTokens.length;\n  const recall = numSame / groundTruthTokens.length;\n  const f1 = (2 * precision * recall) / (precision + recall);\n\n  return returnRecall ? recall : f1;\n}\n\nexport const AxEvalUtil = {\n  emScore,\n  f1Score,\n  novelF1ScoreOptimized,\n};\n", "import type { AxAIService } from '../ai/types.js';\n\nimport type { AxExample, AxMetricFn } from './optimizer.js';\nimport type { AxProgram } from './program.js';\nimport type { AxGenIn, AxGenOut } from './types.js';\nimport { updateProgressBar } from './util.js';\n\nexport type AxEvaluateArgs<IN extends AxGenIn, OUT extends AxGenOut> = {\n  ai: AxAIService;\n  program: Readonly<AxProgram<IN, OUT>>;\n  examples: Readonly<AxExample[]>;\n};\n\nexport class AxTestPrompt<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> {\n  private ai: AxAIService;\n  private program: Readonly<AxProgram<IN, OUT>>;\n  private examples: Readonly<AxExample[]>;\n\n  constructor({\n    ai,\n    program,\n    examples = [],\n  }: Readonly<AxEvaluateArgs<IN, OUT>>) {\n    if (examples.length === 0) {\n      throw new Error('No examples found');\n    }\n    this.ai = ai;\n    this.program = program;\n    this.examples = examples;\n  }\n\n  public async run(metricFn: AxMetricFn) {\n    const st = Date.now();\n    const total = this.examples.length;\n    let sumOfScores = 0;\n\n    for (let i = 0; i < total; i++) {\n      const ex = this.examples[i];\n      if (!ex) {\n        throw new Error('Invalid example');\n      }\n\n      const res = await this.program.forward(this.ai, ex as IN);\n      const score = await metricFn({ prediction: res, example: ex });\n      sumOfScores += score;\n\n      const et = Date.now() - st;\n      // Assuming updateProgressBar's 3rd argument is a count/value that represents progress.\n      // If it specifically needs a 'success count', this might need adjustment.\n      // For now, using sumOfScores, but it might represent total score, not #successes.\n      // If AxMetricFn is always 0 or 1, sumOfScores is equivalent to successCount.\n      updateProgressBar(i, total, sumOfScores, et, 'Testing Prompt', 30);\n    }\n\n    const averageScore = total > 0 ? sumOfScores / total : 0;\n    console.log(\n      '\\nPerformance: ',\n      sumOfScores,\n      '/',\n      total,\n      'Average Score: ',\n      averageScore,\n      '\\n'\n    );\n  }\n}\n", "import type { AxFieldValue } from './types.js';\n\nexport type AxDataRow = { row: Record<string, AxFieldValue> };\n\nexport class AxHFDataLoader {\n  private rows: AxDataRow[] = [];\n  private baseUrl: string;\n\n  private dataset: string;\n  private split: string;\n  private config: string;\n  private options?: Readonly<{ offset?: number; length?: number }>;\n\n  constructor({\n    dataset,\n    split,\n    config,\n    options,\n  }: Readonly<{\n    dataset: string;\n    split: string;\n    config: string;\n    options?: Readonly<{ offset?: number; length?: number }>;\n  }>) {\n    this.baseUrl = 'https://datasets-server.huggingface.co/rows';\n    this.dataset = dataset;\n    this.split = split;\n    this.config = config;\n    this.options = options;\n  }\n\n  private async fetchDataFromAPI(url: string): Promise<AxDataRow[]> {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Error fetching data: ${response.statusText}`);\n      }\n      const data = (await response.json()) as { rows: AxDataRow[] };\n      if (!data?.rows) {\n        throw new Error('Invalid data format');\n      }\n      return data.rows;\n    } catch (error) {\n      console.error('Error fetching data from API:', error);\n      throw error;\n    }\n  }\n\n  // https://datasets-server.huggingface.co/rows?dataset=hotpot_qa&config=distractor&split=train&offset=0&length=100\n\n  public async loadData() {\n    const offset = this.options?.offset ?? 0;\n    const length = this.options?.length ?? 100;\n    const ds = encodeURIComponent(this.dataset);\n\n    const url = `${this.baseUrl}?dataset=${ds}&config=${this.config}&split=${this.split}&offset=${offset}&length=${length}`;\n\n    console.log('Downloading data from API.');\n    this.rows = (await this.fetchDataFromAPI(url)) as AxDataRow[];\n    return this.rows;\n  }\n\n  public setData(rows: AxDataRow[]) {\n    this.rows = rows;\n  }\n\n  public getData() {\n    return this.rows;\n  }\n\n  public async getRows<T>({\n    count,\n    fields,\n    renameMap,\n  }: Readonly<{\n    count: number;\n    fields: readonly string[];\n    renameMap?: Record<string, string>;\n  }>): Promise<T[]> {\n    if (this.rows.length === 0) {\n      throw new Error('No data loaded, call loadData or setData first.');\n    }\n    const dataRows = this.rows.slice(0, count);\n\n    return dataRows\n      .map((item) => {\n        const result: Record<string, AxFieldValue> = {};\n\n        fields.forEach((field) => {\n          const keys = field.split('.');\n          // Initial value should match the type of the rows, and be indexable by string\n          let value: AxFieldValue | unknown = item.row;\n          for (const key of keys) {\n            // Use type assertion to tell TypeScript that value will always be an object that can be indexed with string keys\n            if (Object.hasOwn(value as Record<string, unknown>, key)) {\n              value = (value as Record<string, unknown>)[key];\n            }\n          }\n          if (!value) {\n            return;\n          }\n          const resultFieldName =\n            renameMap && field in renameMap ? renameMap[field] : field;\n          if (!resultFieldName) {\n            throw new Error(`Invalid field name: ${field}`);\n          }\n          result[resultFieldName] = value as AxFieldValue;\n        });\n\n        return result;\n      })\n      .filter((v) => Object.keys(v).length !== 0) as T[];\n  }\n}\n", "import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\nimport type { AxAIService, AxLoggerFunction } from '../ai/types.js';\n\nimport { axGlobals } from './globals.js';\nimport { axDefaultOptimizerLogger } from './loggers.js';\nimport type { AxProgram, AxProgramDemos } from './program.js';\nimport type { AxFieldValue, AxGenIn, AxGenOut } from './types.js';\n\n// Logger utilities are now exported from ./loggers.js\n\n// Common types used by optimizers\nexport type AxExample = Record<string, AxFieldValue>;\n\nexport type AxMetricFn = <T extends AxGenOut = AxGenOut>(\n  arg0: Readonly<{ prediction: T; example: AxExample }>\n) => number | Promise<number>;\n\nexport type AxMetricFnArgs = Parameters<AxMetricFn>[0];\n\n// Multi-objective metric function for Pareto optimization\nexport type AxMultiMetricFn = <T extends AxGenOut = AxGenOut>(\n  arg0: Readonly<{ prediction: T; example: AxExample }>\n) => Record<string, number>;\n\n// Progress tracking interface for real-time updates\nexport interface AxOptimizationProgress {\n  round: number;\n  totalRounds: number;\n  currentScore: number;\n  bestScore: number;\n  tokensUsed: number;\n  timeElapsed: number;\n  successfulExamples: number;\n  totalExamples: number;\n  currentConfiguration?: Record<string, unknown>;\n  convergenceInfo?: {\n    improvement: number;\n    stagnationRounds: number;\n    isConverging: boolean;\n  };\n}\n\n// Cost tracking interface for monitoring resource usage\nexport interface AxCostTracker {\n  trackTokens(count: number, model: string): void;\n  getCurrentCost(): number;\n  getTokenUsage(): Record<string, number>;\n  getTotalTokens(): number;\n  isLimitReached(): boolean;\n  reset(): void;\n}\n\n// Checkpoint interface for saving/loading optimization state\nexport interface AxOptimizationCheckpoint {\n  version: string;\n  timestamp: number;\n  optimizerType: string;\n  optimizerConfig: Record<string, unknown>;\n\n  // Current optimization state\n  currentRound: number;\n  totalRounds: number;\n  bestScore: number;\n  bestConfiguration?: Record<string, unknown>;\n\n  // Historical data\n  scoreHistory: number[];\n  configurationHistory: Record<string, unknown>[];\n\n  // Resource usage\n  stats: AxOptimizationStats;\n\n  // Optimizer-specific state\n  optimizerState: Record<string, unknown>;\n\n  // Examples and validation data\n  examples: readonly AxExample[];\n  validationSet?: readonly AxExample[];\n}\n\n// Simple checkpoint functions - users implement these as needed\nexport type AxCheckpointSaveFn = (\n  checkpoint: Readonly<AxOptimizationCheckpoint>\n) => Promise<string>;\nexport type AxCheckpointLoadFn = (\n  checkpointId: string\n) => Promise<AxOptimizationCheckpoint | null>;\n\n// Cost tracker configuration options\nexport interface AxCostTrackerOptions {\n  // Cost-based limits\n  costPerModel?: Record<string, number>;\n  maxCost?: number;\n\n  // Token-based limits\n  maxTokens?: number;\n}\n\n// Enhanced optimizer arguments - no longer includes program\nexport type AxOptimizerArgs = {\n  studentAI: AxAIService;\n  teacherAI?: AxAIService; // For generating high-quality examples/corrections\n  examples: readonly AxExample[];\n\n  // Evaluation strategy\n  validationSet?: readonly AxExample[];\n\n  // Quality thresholds\n  minSuccessRate?: number;\n  targetScore?: number;\n\n  // Monitoring & callbacks\n  onProgress?: (progress: Readonly<AxOptimizationProgress>) => void;\n  onEarlyStop?: (reason: string, stats: Readonly<AxOptimizationStats>) => void;\n  costTracker?: AxCostTracker;\n\n  // Checkpointing\n  checkpointSave?: AxCheckpointSaveFn;\n  checkpointLoad?: AxCheckpointLoadFn;\n  checkpointInterval?: number; // Save checkpoint every N rounds\n  resumeFromCheckpoint?: string; // Checkpoint ID to resume from\n\n  // Logging\n  logger?: AxLoggerFunction;\n  verbose?: boolean;\n\n  // Reproducibility\n  seed?: number;\n};\n\n// Enhanced optimization statistics\nexport interface AxOptimizationStats {\n  totalCalls: number;\n  successfulDemos: number;\n  estimatedTokenUsage: number;\n  earlyStopped: boolean;\n  earlyStopping?: {\n    bestScoreRound: number;\n    patienceExhausted: boolean;\n    reason: string;\n  };\n\n  // Resource usage tracking\n  resourceUsage: {\n    totalTokens: number;\n    totalTime: number;\n    avgLatencyPerEval: number;\n    peakMemoryUsage?: number;\n    costByModel: Record<string, number>;\n  };\n\n  // Quality metrics\n  convergenceInfo: {\n    converged: boolean;\n    finalImprovement: number;\n    stagnationRounds: number;\n    convergenceThreshold: number;\n  };\n\n  // Evaluation breakdown\n  evaluationBreakdown?: {\n    trainingScore: number;\n    validationScore: number;\n    crossValidationScores?: number[];\n    standardDeviation?: number;\n  };\n}\n\n// Optimizer metrics configuration interface\nexport interface AxOptimizerMetricsConfig {\n  enabled: boolean;\n  enabledCategories: (\n    | 'optimization'\n    | 'convergence'\n    | 'resource_usage'\n    | 'teacher_student'\n    | 'checkpointing'\n    | 'pareto'\n  )[];\n  maxLabelLength: number;\n  samplingRate: number;\n}\n\n// Default optimizer metrics configuration\nexport const axDefaultOptimizerMetricsConfig: AxOptimizerMetricsConfig = {\n  enabled: true,\n  enabledCategories: [\n    'optimization',\n    'convergence',\n    'resource_usage',\n    'teacher_student',\n    'checkpointing',\n    'pareto',\n  ],\n  maxLabelLength: 100,\n  samplingRate: 1.0,\n};\n\n// Optimizer metrics instruments interface\nexport interface AxOptimizerMetricsInstruments {\n  // Optimization flow metrics\n  optimizationLatencyHistogram?: Histogram;\n  optimizationRequestsCounter?: Counter;\n  optimizationErrorsCounter?: Counter;\n\n  // Convergence metrics\n  convergenceRoundsHistogram?: Histogram;\n  convergenceScoreGauge?: Gauge;\n  convergenceImprovementGauge?: Gauge;\n  stagnationRoundsGauge?: Gauge;\n  earlyStoppingCounter?: Counter;\n\n  // Resource usage metrics\n  tokenUsageCounter?: Counter;\n  costUsageCounter?: Counter;\n  memoryUsageGauge?: Gauge;\n  optimizationDurationHistogram?: Histogram;\n\n  // Teacher-student metrics\n  teacherStudentUsageCounter?: Counter;\n  teacherStudentLatencyHistogram?: Histogram;\n  teacherStudentScoreImprovementGauge?: Gauge;\n\n  // Checkpointing metrics\n  checkpointSaveCounter?: Counter;\n  checkpointLoadCounter?: Counter;\n  checkpointSaveLatencyHistogram?: Histogram;\n  checkpointLoadLatencyHistogram?: Histogram;\n\n  // Pareto optimization metrics\n  paretoOptimizationsCounter?: Counter;\n  paretoFrontSizeHistogram?: Histogram;\n  paretoHypervolumeGauge?: Gauge;\n  paretoSolutionsGeneratedHistogram?: Histogram;\n\n  // Program complexity metrics\n  programInputFieldsGauge?: Gauge;\n  programOutputFieldsGauge?: Gauge;\n  examplesCountGauge?: Gauge;\n  validationSetSizeGauge?: Gauge;\n\n  // Performance metrics\n  evaluationLatencyHistogram?: Histogram;\n  demoGenerationLatencyHistogram?: Histogram;\n  metricComputationLatencyHistogram?: Histogram;\n\n  // Configuration metrics\n  optimizerTypeGauge?: Gauge;\n  targetScoreGauge?: Gauge;\n  maxRoundsGauge?: Gauge;\n}\n\n// Singleton instance for optimizer metrics instruments\nlet globalOptimizerMetricsInstruments:\n  | AxOptimizerMetricsInstruments\n  | undefined;\n\n// Function to get or create optimizer metrics instruments (singleton pattern)\nexport const getOrCreateOptimizerMetricsInstruments = (\n  meter?: Meter\n): AxOptimizerMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalOptimizerMetricsInstruments) {\n    return globalOptimizerMetricsInstruments;\n  }\n\n  if (meter) {\n    globalOptimizerMetricsInstruments =\n      createOptimizerMetricsInstruments(meter);\n    return globalOptimizerMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the optimizer metrics singleton (useful for testing)\nexport const resetOptimizerMetricsInstruments = (): void => {\n  globalOptimizerMetricsInstruments = undefined;\n};\n\n// Global optimizer metrics configuration\nlet currentOptimizerMetricsConfig: AxOptimizerMetricsConfig =\n  axDefaultOptimizerMetricsConfig;\n\n// Function to update optimizer metrics configuration\nexport const axUpdateOptimizerMetricsConfig = (\n  config: Readonly<Partial<AxOptimizerMetricsConfig>>\n): void => {\n  currentOptimizerMetricsConfig = {\n    ...currentOptimizerMetricsConfig,\n    ...config,\n  };\n};\n\n// Function to get current optimizer metrics configuration\nexport const axGetOptimizerMetricsConfig = (): AxOptimizerMetricsConfig => {\n  return { ...currentOptimizerMetricsConfig };\n};\n\nexport const createOptimizerMetricsInstruments = (\n  meter: Meter\n): AxOptimizerMetricsInstruments => {\n  return {\n    // Optimization flow metrics\n    optimizationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_optimization_duration_ms',\n      {\n        description: 'End-to-end duration of optimization runs',\n        unit: 'ms',\n      }\n    ),\n\n    optimizationRequestsCounter: meter.createCounter(\n      'ax_optimizer_optimization_requests_total',\n      {\n        description: 'Total number of optimization requests',\n      }\n    ),\n\n    optimizationErrorsCounter: meter.createCounter(\n      'ax_optimizer_optimization_errors_total',\n      {\n        description: 'Total number of failed optimizations',\n      }\n    ),\n\n    // Convergence metrics\n    convergenceRoundsHistogram: meter.createHistogram(\n      'ax_optimizer_convergence_rounds',\n      {\n        description: 'Number of rounds until convergence',\n      }\n    ),\n\n    convergenceScoreGauge: meter.createGauge('ax_optimizer_convergence_score', {\n      description: 'Current best score during optimization',\n    }),\n\n    convergenceImprovementGauge: meter.createGauge(\n      'ax_optimizer_convergence_improvement',\n      {\n        description: 'Improvement in score from baseline',\n      }\n    ),\n\n    stagnationRoundsGauge: meter.createGauge('ax_optimizer_stagnation_rounds', {\n      description: 'Number of rounds without improvement',\n    }),\n\n    earlyStoppingCounter: meter.createCounter(\n      'ax_optimizer_early_stopping_total',\n      {\n        description: 'Total number of early stopping events',\n      }\n    ),\n\n    // Resource usage metrics\n    tokenUsageCounter: meter.createCounter('ax_optimizer_token_usage_total', {\n      description: 'Total tokens used during optimization',\n    }),\n\n    costUsageCounter: meter.createCounter('ax_optimizer_cost_usage_total', {\n      description: 'Total cost incurred during optimization',\n      unit: '$',\n    }),\n\n    memoryUsageGauge: meter.createGauge('ax_optimizer_memory_usage_bytes', {\n      description: 'Peak memory usage during optimization',\n      unit: 'By',\n    }),\n\n    optimizationDurationHistogram: meter.createHistogram(\n      'ax_optimizer_duration_ms',\n      {\n        description: 'Duration of optimization runs',\n        unit: 'ms',\n      }\n    ),\n\n    // Teacher-student metrics\n    teacherStudentUsageCounter: meter.createCounter(\n      'ax_optimizer_teacher_student_usage_total',\n      {\n        description: 'Total number of teacher-student interactions',\n      }\n    ),\n\n    teacherStudentLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_teacher_student_latency_ms',\n      {\n        description: 'Latency of teacher-student interactions',\n        unit: 'ms',\n      }\n    ),\n\n    teacherStudentScoreImprovementGauge: meter.createGauge(\n      'ax_optimizer_teacher_student_score_improvement',\n      {\n        description: 'Score improvement from teacher-student interactions',\n      }\n    ),\n\n    // Checkpointing metrics\n    checkpointSaveCounter: meter.createCounter(\n      'ax_optimizer_checkpoint_save_total',\n      {\n        description: 'Total number of checkpoint saves',\n      }\n    ),\n\n    checkpointLoadCounter: meter.createCounter(\n      'ax_optimizer_checkpoint_load_total',\n      {\n        description: 'Total number of checkpoint loads',\n      }\n    ),\n\n    checkpointSaveLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_checkpoint_save_latency_ms',\n      {\n        description: 'Latency of checkpoint save operations',\n        unit: 'ms',\n      }\n    ),\n\n    checkpointLoadLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_checkpoint_load_latency_ms',\n      {\n        description: 'Latency of checkpoint load operations',\n        unit: 'ms',\n      }\n    ),\n\n    // Pareto optimization metrics\n    paretoOptimizationsCounter: meter.createCounter(\n      'ax_optimizer_pareto_optimizations_total',\n      {\n        description: 'Total number of Pareto optimizations',\n      }\n    ),\n\n    paretoFrontSizeHistogram: meter.createHistogram(\n      'ax_optimizer_pareto_front_size',\n      {\n        description: 'Size of Pareto frontier',\n      }\n    ),\n\n    paretoHypervolumeGauge: meter.createGauge(\n      'ax_optimizer_pareto_hypervolume',\n      {\n        description: 'Hypervolume of Pareto frontier',\n      }\n    ),\n\n    paretoSolutionsGeneratedHistogram: meter.createHistogram(\n      'ax_optimizer_pareto_solutions_generated',\n      {\n        description: 'Number of solutions generated for Pareto optimization',\n      }\n    ),\n\n    // Program complexity metrics\n    programInputFieldsGauge: meter.createGauge(\n      'ax_optimizer_program_input_fields',\n      {\n        description: 'Number of input fields in optimized program',\n      }\n    ),\n\n    programOutputFieldsGauge: meter.createGauge(\n      'ax_optimizer_program_output_fields',\n      {\n        description: 'Number of output fields in optimized program',\n      }\n    ),\n\n    examplesCountGauge: meter.createGauge('ax_optimizer_examples_count', {\n      description: 'Number of training examples used',\n    }),\n\n    validationSetSizeGauge: meter.createGauge(\n      'ax_optimizer_validation_set_size',\n      {\n        description: 'Size of validation set used',\n      }\n    ),\n\n    // Performance metrics\n    evaluationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_evaluation_latency_ms',\n      {\n        description: 'Latency of program evaluations',\n        unit: 'ms',\n      }\n    ),\n\n    demoGenerationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_demo_generation_latency_ms',\n      {\n        description: 'Latency of demo generation',\n        unit: 'ms',\n      }\n    ),\n\n    metricComputationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_metric_computation_latency_ms',\n      {\n        description: 'Latency of metric computation',\n        unit: 'ms',\n      }\n    ),\n\n    // Configuration metrics\n    optimizerTypeGauge: meter.createGauge('ax_optimizer_type', {\n      description: 'Type of optimizer being used',\n    }),\n\n    targetScoreGauge: meter.createGauge('ax_optimizer_target_score', {\n      description: 'Target score for optimization',\n    }),\n\n    maxRoundsGauge: meter.createGauge('ax_optimizer_max_rounds', {\n      description: 'Maximum rounds for optimization',\n    }),\n  };\n};\n\n// Utility function to sanitize optimizer metric labels\nconst sanitizeOptimizerLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length based on configuration\n      const maxLength = currentOptimizerMetricsConfig.maxLabelLength;\n      sanitized[key] =\n        stringValue.length > maxLength\n          ? stringValue.substring(0, maxLength)\n          : stringValue;\n    }\n  }\n  return sanitized;\n};\n\n// Recording functions for optimization flow metrics\nexport const recordOptimizationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  duration: number,\n  success: boolean,\n  optimizerType: string,\n  programSignature?: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      success: success.toString(),\n      optimizer_type: optimizerType,\n      ...(programSignature ? { program_signature: programSignature } : {}),\n    });\n\n    if (instruments.optimizationLatencyHistogram) {\n      instruments.optimizationLatencyHistogram.record(duration, labels);\n    }\n\n    if (instruments.optimizationRequestsCounter) {\n      instruments.optimizationRequestsCounter.add(1, labels);\n    }\n\n    if (!success && instruments.optimizationErrorsCounter) {\n      instruments.optimizationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimization metric:', error);\n  }\n};\n\n// Recording functions for convergence metrics\nexport const recordConvergenceMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  rounds: number,\n  currentScore: number,\n  improvement: number,\n  stagnationRounds: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.convergenceRoundsHistogram) {\n      instruments.convergenceRoundsHistogram.record(rounds, labels);\n    }\n\n    if (instruments.convergenceScoreGauge) {\n      instruments.convergenceScoreGauge.record(currentScore, labels);\n    }\n\n    if (instruments.convergenceImprovementGauge) {\n      instruments.convergenceImprovementGauge.record(improvement, labels);\n    }\n\n    if (instruments.stagnationRoundsGauge) {\n      instruments.stagnationRoundsGauge.record(stagnationRounds, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record convergence metric:', error);\n  }\n};\n\nexport const recordEarlyStoppingMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  reason: string,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      reason,\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.earlyStoppingCounter) {\n      instruments.earlyStoppingCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record early stopping metric:', error);\n  }\n};\n\n// Recording functions for resource usage metrics\nexport const recordResourceUsageMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  tokensUsed: number,\n  costIncurred: number,\n  optimizerType: string,\n  memoryUsage?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.tokenUsageCounter) {\n      instruments.tokenUsageCounter.add(tokensUsed, labels);\n    }\n\n    if (instruments.costUsageCounter) {\n      instruments.costUsageCounter.add(costIncurred, labels);\n    }\n\n    if (memoryUsage !== undefined && instruments.memoryUsageGauge) {\n      instruments.memoryUsageGauge.record(memoryUsage, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record resource usage metric:', error);\n  }\n};\n\nexport const recordOptimizationDurationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  duration: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.optimizationDurationHistogram) {\n      instruments.optimizationDurationHistogram.record(duration, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimization duration metric:', error);\n  }\n};\n\n// Recording functions for teacher-student metrics\nexport const recordTeacherStudentMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  latency: number,\n  scoreImprovement: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.teacherStudentUsageCounter) {\n      instruments.teacherStudentUsageCounter.add(1, labels);\n    }\n\n    if (instruments.teacherStudentLatencyHistogram) {\n      instruments.teacherStudentLatencyHistogram.record(latency, labels);\n    }\n\n    if (instruments.teacherStudentScoreImprovementGauge) {\n      instruments.teacherStudentScoreImprovementGauge.record(\n        scoreImprovement,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record teacher-student metric:', error);\n  }\n};\n\n// Recording functions for checkpointing metrics\nexport const recordCheckpointMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  operation: 'save' | 'load',\n  latency: number,\n  success: boolean,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      operation,\n      success: success.toString(),\n      optimizer_type: optimizerType,\n    });\n\n    if (operation === 'save') {\n      if (instruments.checkpointSaveCounter) {\n        instruments.checkpointSaveCounter.add(1, labels);\n      }\n      if (instruments.checkpointSaveLatencyHistogram) {\n        instruments.checkpointSaveLatencyHistogram.record(latency, labels);\n      }\n    } else {\n      if (instruments.checkpointLoadCounter) {\n        instruments.checkpointLoadCounter.add(1, labels);\n      }\n      if (instruments.checkpointLoadLatencyHistogram) {\n        instruments.checkpointLoadLatencyHistogram.record(latency, labels);\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to record checkpoint metric:', error);\n  }\n};\n\n// Recording functions for Pareto optimization metrics\nexport const recordParetoMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  frontSize: number,\n  solutionsGenerated: number,\n  optimizerType: string,\n  hypervolume?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.paretoOptimizationsCounter) {\n      instruments.paretoOptimizationsCounter.add(1, labels);\n    }\n\n    if (instruments.paretoFrontSizeHistogram) {\n      instruments.paretoFrontSizeHistogram.record(frontSize, labels);\n    }\n\n    if (hypervolume !== undefined && instruments.paretoHypervolumeGauge) {\n      instruments.paretoHypervolumeGauge.record(hypervolume, labels);\n    }\n\n    if (instruments.paretoSolutionsGeneratedHistogram) {\n      instruments.paretoSolutionsGeneratedHistogram.record(\n        solutionsGenerated,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record Pareto metric:', error);\n  }\n};\n\n// Recording functions for program complexity metrics\nexport const recordProgramComplexityMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  inputFields: number,\n  outputFields: number,\n  examplesCount: number,\n  validationSetSize: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.programInputFieldsGauge) {\n      instruments.programInputFieldsGauge.record(inputFields, labels);\n    }\n\n    if (instruments.programOutputFieldsGauge) {\n      instruments.programOutputFieldsGauge.record(outputFields, labels);\n    }\n\n    if (instruments.examplesCountGauge) {\n      instruments.examplesCountGauge.record(examplesCount, labels);\n    }\n\n    if (instruments.validationSetSizeGauge) {\n      instruments.validationSetSizeGauge.record(validationSetSize, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record program complexity metric:', error);\n  }\n};\n\n// Recording functions for performance metrics\nexport const recordOptimizerPerformanceMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  metricType: 'evaluation' | 'demo_generation' | 'metric_computation',\n  duration: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      metric_type: metricType,\n      optimizer_type: optimizerType,\n    });\n\n    switch (metricType) {\n      case 'evaluation':\n        if (instruments.evaluationLatencyHistogram) {\n          instruments.evaluationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'demo_generation':\n        if (instruments.demoGenerationLatencyHistogram) {\n          instruments.demoGenerationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'metric_computation':\n        if (instruments.metricComputationLatencyHistogram) {\n          instruments.metricComputationLatencyHistogram.record(\n            duration,\n            labels\n          );\n        }\n        break;\n    }\n  } catch (error) {\n    console.warn('Failed to record optimizer performance metric:', error);\n  }\n};\n\n// Recording functions for configuration metrics\nexport const recordOptimizerConfigurationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  optimizerType: string,\n  targetScore?: number,\n  maxRounds?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.optimizerTypeGauge) {\n      instruments.optimizerTypeGauge.record(1, labels);\n    }\n\n    if (targetScore !== undefined && instruments.targetScoreGauge) {\n      instruments.targetScoreGauge.record(targetScore, labels);\n    }\n\n    if (maxRounds !== undefined && instruments.maxRoundsGauge) {\n      instruments.maxRoundsGauge.record(maxRounds, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimizer configuration metric:', error);\n  }\n};\n\n// Simplified result - no program since it's passed to compile\nexport interface AxOptimizerResult<OUT extends AxGenOut> {\n  demos?: AxProgramDemos<AxGenIn, OUT>[];\n  stats: AxOptimizationStats;\n  bestScore: number;\n  finalConfiguration?: Record<string, unknown>;\n\n  // Optimization history for analysis\n  scoreHistory?: number[];\n  configurationHistory?: Record<string, unknown>[];\n}\n\n// Pareto optimization result for multi-objective optimization\nexport interface AxParetoResult<OUT extends AxGenOut = AxGenOut>\n  extends AxOptimizerResult<OUT> {\n  paretoFront: ReadonlyArray<{\n    demos: readonly AxProgramDemos<AxGenIn, OUT>[];\n    scores: Readonly<Record<string, number>>;\n    configuration: Readonly<Record<string, unknown>>;\n    dominatedSolutions: number;\n  }>;\n\n  // Multi-objective specific stats\n  hypervolume?: number;\n  paretoFrontSize: number;\n  convergenceMetrics?: Record<string, number>;\n}\n\n// Compile options that can override constructor arguments\nexport interface AxCompileOptions {\n  // Method-specific options\n  maxIterations?: number;\n  earlyStoppingPatience?: number;\n  verbose?: boolean;\n\n  // Override args for this specific run\n  overrideValidationSet?: readonly AxExample[];\n  overrideTargetScore?: number;\n  overrideCostTracker?: AxCostTracker;\n  overrideTeacherAI?: AxAIService;\n\n  // Progress monitoring overrides\n  overrideOnProgress?: (progress: Readonly<AxOptimizationProgress>) => void;\n  overrideOnEarlyStop?: (\n    reason: string,\n    stats: Readonly<AxOptimizationStats>\n  ) => void;\n\n  // Checkpointing overrides\n  overrideCheckpointSave?: AxCheckpointSaveFn;\n  overrideCheckpointLoad?: AxCheckpointLoadFn;\n  overrideCheckpointInterval?: number;\n  saveCheckpointOnComplete?: boolean;\n}\n\n// Enhanced base optimizer interface\nexport interface AxOptimizer<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> {\n  /**\n   * Optimize a program using the provided metric function\n   * @param program The program to optimize (moved from constructor)\n   * @param metricFn Evaluation metric function to assess program performance\n   * @param options Optional configuration options that can override constructor settings\n   * @returns Optimization result containing demos, stats, and configuration\n   */\n  compile(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizerResult<OUT>>;\n\n  /**\n   * Optimize a program with real-time streaming updates\n   * @param program The program to optimize\n   * @param metricFn Evaluation metric function\n   * @param options Optional configuration options\n   * @returns Async iterator yielding optimization progress\n   */\n  compileStream?(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): AsyncIterableIterator<AxOptimizationProgress>;\n\n  /**\n   * Multi-objective optimization using Pareto frontier\n   * @param program The program to optimize\n   * @param metricFn Multi-objective metric function\n   * @param options Optional configuration options\n   * @returns Pareto optimization result\n   */\n  compilePareto?(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>>;\n\n  /**\n   * Get current optimization statistics\n   * @returns Current optimization statistics\n   */\n  getStats(): AxOptimizationStats;\n\n  /**\n   * Cancel ongoing optimization gracefully\n   * @returns Promise that resolves when cancellation is complete\n   */\n  cancel?(): Promise<void>;\n\n  /**\n   * Reset optimizer state for reuse with different programs\n   */\n  reset?(): void;\n\n  /**\n   * Get optimizer-specific configuration\n   * @returns Current optimizer configuration\n   */\n  getConfiguration?(): Record<string, unknown>;\n\n  /**\n   * Update optimizer configuration\n   * @param config New configuration to merge with existing\n   */\n  updateConfiguration?(config: Readonly<Record<string, unknown>>): void;\n\n  /**\n   * Validate that the optimizer can handle the given program\n   * @param program Program to validate\n   * @returns Validation result with any issues found\n   */\n  validateProgram?(program: Readonly<AxProgram<IN, OUT>>): {\n    isValid: boolean;\n    issues: string[];\n    suggestions: string[];\n  };\n}\n\n// Specific optimizer options interfaces\n\nexport interface AxBootstrapOptimizerOptions {\n  maxRounds?: number;\n  maxExamples?: number;\n  maxDemos?: number;\n  batchSize?: number;\n  earlyStoppingPatience?: number;\n  teacherAI?: AxAIService;\n  costMonitoring?: boolean;\n  maxTokensPerGeneration?: number;\n  verboseMode?: boolean;\n  debugMode?: boolean;\n\n  // Enhanced options\n  adaptiveBatching?: boolean;\n  dynamicTemperature?: boolean;\n  qualityThreshold?: number;\n  diversityWeight?: number;\n}\n\nexport interface AxMiPROOptimizerOptions {\n  numCandidates?: number;\n  initTemperature?: number;\n  maxBootstrappedDemos?: number;\n  maxLabeledDemos?: number;\n  numTrials?: number;\n  minibatch?: boolean;\n  minibatchSize?: number;\n  minibatchFullEvalSteps?: number;\n  programAwareProposer?: boolean;\n  dataAwareProposer?: boolean;\n  viewDataBatchSize?: number;\n  tipAwareProposer?: boolean;\n  fewshotAwareProposer?: boolean;\n  verbose?: boolean;\n  earlyStoppingTrials?: number;\n  minImprovementThreshold?: number;\n\n  // Enhanced options\n  bayesianOptimization?: boolean;\n  acquisitionFunction?:\n    | 'expected_improvement'\n    | 'upper_confidence_bound'\n    | 'probability_improvement';\n  explorationWeight?: number;\n\n  // New option: number of samples to generate per forward call for self-consistency\n  sampleCount?: number;\n}\n\n// Legacy compile options (for backward compatibility)\nexport interface AxBootstrapCompileOptions extends AxCompileOptions {\n  validationExamples?: readonly AxExample[];\n  maxDemos?: number;\n  teacherProgram?: Readonly<AxProgram<AxGenIn, AxGenOut>>;\n}\n\nexport interface AxMiPROCompileOptions extends AxCompileOptions {\n  validationExamples?: readonly AxExample[];\n  teacher?: Readonly<AxProgram<AxGenIn, AxGenOut>>;\n  auto?: 'light' | 'medium' | 'heavy';\n\n  // Enhanced MiPRO options\n  instructionCandidates?: string[];\n  customProposer?: (\n    context: Readonly<{\n      programSummary: string;\n      dataSummary: string;\n      previousInstructions: string[];\n    }>\n  ) => Promise<string[]>;\n}\n\n// Default cost tracker implementation\nexport class AxDefaultCostTracker implements AxCostTracker {\n  private tokenUsage: Record<string, number> = {};\n  private totalTokens = 0;\n\n  // Configuration options\n  private readonly costPerModel: Record<string, number>;\n  private readonly maxCost?: number;\n  private readonly maxTokens?: number;\n\n  constructor(options?: AxCostTrackerOptions) {\n    this.costPerModel = options?.costPerModel ?? {};\n    this.maxCost = options?.maxCost;\n    this.maxTokens = options?.maxTokens;\n  }\n\n  trackTokens(count: number, model: string): void {\n    this.tokenUsage[model] = (this.tokenUsage[model] || 0) + count;\n    this.totalTokens += count;\n  }\n\n  getCurrentCost(): number {\n    // Calculate cost on-demand\n    let totalCost = 0;\n    for (const [model, tokens] of Object.entries(this.tokenUsage)) {\n      const costPer1K = this.costPerModel[model] || 0.001; // Default fallback\n      totalCost += (tokens / 1000) * costPer1K;\n    }\n    return totalCost;\n  }\n\n  getTokenUsage(): Record<string, number> {\n    return { ...this.tokenUsage };\n  }\n\n  getTotalTokens(): number {\n    return this.totalTokens;\n  }\n\n  isLimitReached(): boolean {\n    // Check token limit if configured\n    if (this.maxTokens !== undefined && this.totalTokens >= this.maxTokens) {\n      return true;\n    }\n\n    // Check cost limit if configured (calculate cost on-demand)\n    if (this.maxCost !== undefined) {\n      const currentCost = this.getCurrentCost();\n      if (currentCost >= this.maxCost) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reset(): void {\n    this.tokenUsage = {};\n    this.totalTokens = 0;\n  }\n}\n\n/**\n * Abstract base class for optimizers that provides common functionality\n * and standardized handling of AxOptimizerArgs\n */\nexport abstract class AxBaseOptimizer<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> implements AxOptimizer<IN, OUT>\n{\n  // Common AxOptimizerArgs fields\n  protected readonly studentAI: AxAIService;\n  protected readonly teacherAI?: AxAIService;\n  protected readonly examples: readonly AxExample[];\n  protected readonly validationSet?: readonly AxExample[];\n  protected readonly targetScore?: number;\n  protected readonly minSuccessRate?: number;\n  protected readonly onProgress?: (\n    progress: Readonly<AxOptimizationProgress>\n  ) => void;\n  protected readonly onEarlyStop?: (\n    reason: string,\n    stats: Readonly<AxOptimizationStats>\n  ) => void;\n  protected readonly costTracker?: AxCostTracker;\n  protected readonly seed?: number;\n\n  // Checkpointing fields\n  protected readonly checkpointSave?: AxCheckpointSaveFn;\n  protected readonly checkpointLoad?: AxCheckpointLoadFn;\n  protected readonly checkpointInterval?: number;\n  protected readonly resumeFromCheckpoint?: string;\n\n  // Logging fields\n  protected readonly logger?: AxLoggerFunction;\n  protected readonly verbose?: boolean;\n\n  // Checkpoint state\n  private currentRound = 0;\n  private scoreHistory: number[] = [];\n  private configurationHistory: Record<string, unknown>[] = [];\n\n  // Common optimization statistics\n  protected stats: AxOptimizationStats;\n\n  // Metrics instruments\n  protected readonly metricsInstruments?: AxOptimizerMetricsInstruments;\n\n  constructor(args: Readonly<AxOptimizerArgs>) {\n    if (args.examples.length === 0) {\n      throw new Error('No examples found');\n    }\n\n    // Set common fields from AxOptimizerArgs\n    this.studentAI = args.studentAI;\n    this.teacherAI = args.teacherAI;\n    this.examples = args.examples;\n    this.validationSet = args.validationSet;\n    this.targetScore = args.targetScore;\n    this.minSuccessRate = args.minSuccessRate;\n    this.onProgress = args.onProgress;\n    this.onEarlyStop = args.onEarlyStop;\n    this.seed = args.seed;\n\n    // Set up checkpointing\n    this.checkpointSave = args.checkpointSave;\n    this.checkpointLoad = args.checkpointLoad;\n    this.checkpointInterval = args.checkpointInterval ?? 10; // Default: checkpoint every 10 rounds\n    this.resumeFromCheckpoint = args.resumeFromCheckpoint;\n\n    // Set up logging\n    this.logger = args.logger;\n    this.verbose = args.verbose;\n\n    // Set up cost tracker with default if not provided\n    const costTracker = new AxDefaultCostTracker({\n      maxTokens: 1000000,\n    });\n    this.costTracker = args.costTracker ?? costTracker;\n\n    // Initialize metrics instruments\n    this.metricsInstruments = getOrCreateOptimizerMetricsInstruments(\n      axGlobals.meter\n    );\n\n    // Initialize common stats structure\n    this.stats = this.initializeStats();\n  }\n\n  /**\n   * Initialize the optimization statistics structure\n   */\n  protected initializeStats(): AxOptimizationStats {\n    return {\n      totalCalls: 0,\n      successfulDemos: 0,\n      estimatedTokenUsage: 0,\n      earlyStopped: false,\n      resourceUsage: {\n        totalTokens: 0,\n        totalTime: 0,\n        avgLatencyPerEval: 0,\n        costByModel: {},\n      },\n      convergenceInfo: {\n        converged: false,\n        finalImprovement: 0,\n        stagnationRounds: 0,\n        convergenceThreshold: 0.01,\n      },\n    };\n  }\n\n  /**\n   * Set up reproducible random seed if provided\n   */\n  protected setupRandomSeed(): void {\n    if (this.seed !== undefined) {\n      // Note: For full reproducibility, we'd need a proper PRNG\n      Math.random = (() => {\n        let seed = this.seed!;\n        return () => {\n          seed = (seed * 9301 + 49297) % 233280;\n          return seed / 233280;\n        };\n      })();\n    }\n  }\n\n  /**\n   * Check if optimization should stop early due to cost limits\n   */\n  protected checkCostLimits(): boolean {\n    return this.costTracker?.isLimitReached() ?? false;\n  }\n\n  /**\n   * Check if target score has been reached\n   */\n  protected checkTargetScore(currentScore: number): boolean {\n    return this.targetScore !== undefined && currentScore >= this.targetScore;\n  }\n\n  /**\n   * Update resource usage statistics\n   */\n  protected updateResourceUsage(startTime: number, tokensUsed = 0): void {\n    this.stats.resourceUsage.totalTime = Date.now() - startTime;\n    this.stats.resourceUsage.totalTokens += tokensUsed;\n\n    if (this.stats.totalCalls > 0) {\n      this.stats.resourceUsage.avgLatencyPerEval =\n        this.stats.resourceUsage.totalTime / this.stats.totalCalls;\n    }\n  }\n\n  /**\n   * Trigger early stopping with appropriate callbacks\n   */\n  protected triggerEarlyStopping(reason: string, bestScoreRound: number): void {\n    this.stats.earlyStopped = true;\n    this.stats.earlyStopping = {\n      bestScoreRound,\n      patienceExhausted: reason.includes('improvement'),\n      reason,\n    };\n\n    // Record early stopping metrics (use a default optimizer type)\n    this.recordEarlyStoppingMetrics(reason, 'unknown');\n\n    if (this.onEarlyStop) {\n      this.onEarlyStop(reason, this.stats);\n    }\n  }\n\n  /**\n   * Get the validation set, with fallback to a split of examples\n   */\n  protected getValidationSet(options?: AxCompileOptions): readonly AxExample[] {\n    return (\n      options?.overrideValidationSet ||\n      this.validationSet ||\n      this.examples.slice(0, Math.floor(this.examples.length * 0.2))\n    );\n  }\n\n  /**\n   * Get the AI service to use for a specific task, preferring teacher when available\n   * @param preferTeacher Whether to prefer teacher AI over student AI\n   * @param options Optional compile options that may override teacher AI\n   * @returns The appropriate AI service to use\n   */\n  protected getAIService(\n    preferTeacher = false,\n    options?: AxCompileOptions\n  ): AxAIService {\n    // Check for override teacher AI first\n    if (preferTeacher && options?.overrideTeacherAI) {\n      return options.overrideTeacherAI;\n    }\n\n    // Then check for configured teacher AI\n    if (preferTeacher && this.teacherAI) {\n      return this.teacherAI;\n    }\n\n    return this.studentAI;\n  }\n\n  /**\n   * Check if teacher AI is available (including overrides)\n   * @param options Optional compile options that may override teacher AI\n   * @returns True if teacher AI is configured or overridden\n   */\n  protected hasTeacherAI(options?: AxCompileOptions): boolean {\n    return (\n      options?.overrideTeacherAI !== undefined || this.teacherAI !== undefined\n    );\n  }\n\n  /**\n   * Get teacher AI if available, otherwise return student AI\n   * @param options Optional compile options that may override teacher AI\n   * @returns Teacher AI if available, otherwise student AI\n   */\n  protected getTeacherOrStudentAI(options?: AxCompileOptions): AxAIService {\n    return options?.overrideTeacherAI || this.teacherAI || this.studentAI;\n  }\n\n  /**\n   * Execute a task with teacher AI if available, otherwise use student AI\n   * @param task Function that takes an AI service and returns a promise\n   * @param preferTeacher Whether to prefer teacher AI (default: true)\n   * @param options Optional compile options that may override teacher AI\n   * @returns Result of the task execution\n   */\n  protected async executeWithTeacher<T>(\n    task: (ai: AxAIService) => Promise<T>,\n    preferTeacher = true,\n    options?: AxCompileOptions\n  ): Promise<T> {\n    const ai = this.getAIService(preferTeacher, options);\n    return await task(ai);\n  }\n\n  /**\n   * Abstract method that must be implemented by concrete optimizers\n   */\n  public abstract compile(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizerResult<OUT>>;\n\n  /**\n   * Get current optimization statistics\n   */\n  public getStats(): AxOptimizationStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Reset optimizer state for reuse with different programs\n   */\n  public reset(): void {\n    this.stats = this.initializeStats();\n    this.costTracker?.reset();\n    this.currentRound = 0;\n    this.scoreHistory = [];\n    this.configurationHistory = [];\n  }\n\n  /**\n   * Basic program validation that can be extended by concrete optimizers\n   */\n  public validateProgram(program: Readonly<AxProgram<IN, OUT>>): {\n    isValid: boolean;\n    issues: string[];\n    suggestions: string[];\n  } {\n    const issues: string[] = [];\n    const suggestions: string[] = [];\n\n    // Check if program has required methods for optimization\n    if (!('forward' in program) || typeof program.forward !== 'function') {\n      issues.push('Program must have a forward method');\n    }\n\n    // Check if we have enough examples\n    if (this.examples.length < 2) {\n      issues.push('Need at least 2 examples for optimization');\n      suggestions.push('Provide more training examples');\n    }\n\n    // Check if validation set is reasonable\n    const valSetSize = this.getValidationSet().length;\n    if (valSetSize < 1) {\n      issues.push('Validation set is empty');\n      suggestions.push('Provide examples or a validation set');\n    }\n\n    return {\n      isValid: issues.length === 0,\n      issues,\n      suggestions,\n    };\n  }\n\n  /**\n   * Multi-objective optimization using Pareto frontier\n   * Default implementation that leverages the single-objective compile method\n   * @param program The program to optimize\n   * @param metricFn Multi-objective metric function that returns multiple scores\n   * @param options Optional configuration options\n   * @returns Pareto optimization result with frontier of non-dominated solutions\n   */\n  public async compilePareto(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>> {\n    const startTime = Date.now();\n\n    if (options?.verbose) {\n      this.getLogger(options)?.(\n        'Starting Pareto optimization using base implementation',\n        { tags: ['discovery'] }\n      );\n      this.getLogger(options)?.(\n        'This will run multiple single-objective optimizations',\n        { tags: ['discovery'] }\n      );\n    }\n\n    // Strategy 1: Generate different weighted combinations of objectives\n    const solutions = await this.generateWeightedSolutions(\n      program,\n      metricFn,\n      options\n    );\n\n    // Strategy 2: Generate constraint-based solutions (optimize one objective while constraining others)\n    const constraintSolutions = await this.generateConstraintSolutions(\n      program,\n      metricFn,\n      options\n    );\n\n    // Combine all solutions\n    const allSolutions = [...solutions, ...constraintSolutions];\n\n    if (options?.verbose) {\n      this.getLogger(options)?.(\n        `Generated ${allSolutions.length} candidate solutions`,\n        { tags: ['discovery'] }\n      );\n    }\n\n    // Find Pareto frontier\n    const paretoFront = this.findParetoFrontier(allSolutions);\n\n    // Calculate hypervolume if possible\n    const hypervolume = this.calculateHypervolume(paretoFront);\n\n    if (options?.verbose) {\n      this.getLogger(options)?.(\n        `Found ${paretoFront.length} non-dominated solutions`,\n        { tags: ['discovery'] }\n      );\n      this.getLogger(options)?.(\n        `Hypervolume: ${hypervolume?.toFixed(4) || 'N/A'}`,\n        { tags: ['discovery'] }\n      );\n    }\n\n    // Update stats\n    this.updateResourceUsage(startTime);\n    this.stats.convergenceInfo.converged = true;\n\n    // Record Pareto optimization metrics\n    this.recordParetoMetrics(\n      paretoFront.length,\n      allSolutions.length,\n      'base_optimizer',\n      hypervolume\n    );\n\n    // Calculate best score as the maximum across all objectives and solutions\n    const bestScore =\n      paretoFront.length > 0\n        ? Math.max(\n            ...paretoFront.map((sol) => Math.max(...Object.values(sol.scores)))\n          )\n        : 0;\n\n    return {\n      demos: paretoFront.length > 0 ? [...paretoFront[0]!.demos] : undefined,\n      stats: this.stats,\n      bestScore,\n      paretoFront,\n      hypervolume,\n      paretoFrontSize: paretoFront.length,\n      finalConfiguration: {\n        paretoFrontSize: paretoFront.length,\n        hypervolume,\n        strategy: 'weighted_combinations_and_constraints',\n        numSolutions: allSolutions.length,\n      },\n    };\n  }\n\n  /**\n   * Generate solutions using different weighted combinations of objectives\n   */\n  private async generateWeightedSolutions(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<\n    Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<AxGenIn, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  > {\n    const solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<AxGenIn, OUT>[];\n      configuration: Record<string, unknown>;\n    }> = [];\n\n    // First, determine the objectives by running the metric on a sample\n    const sampleExample = this.examples[0]!;\n    const samplePrediction = await program.forward(\n      this.studentAI,\n      sampleExample as IN\n    );\n    const sampleScores = await metricFn({\n      prediction: samplePrediction,\n      example: sampleExample,\n    });\n    const objectives = Object.keys(sampleScores);\n\n    if (options?.verbose) {\n      this.getLogger(options)?.(\n        `Detected objectives: ${objectives.join(', ')}`,\n        { tags: ['discovery'] }\n      );\n    }\n\n    // Generate different weight combinations\n    const weightCombinations = this.generateWeightCombinations(objectives);\n\n    for (let i = 0; i < weightCombinations.length; i++) {\n      const weights = weightCombinations[i]!;\n\n      if (options?.verbose) {\n        this.getLogger(options)?.(\n          `Optimizing with weights: ${JSON.stringify(weights)}`,\n          { tags: ['discovery'] }\n        );\n      }\n\n      // Create a weighted single-objective metric\n      const weightedMetric: AxMetricFn = async ({ prediction, example }) => {\n        const scores = await metricFn({ prediction, example });\n        let weightedScore = 0;\n        for (const [objective, score] of Object.entries(scores)) {\n          weightedScore += score * (weights[objective] || 0);\n        }\n        return weightedScore;\n      };\n\n      try {\n        // Use the concrete optimizer's compile method\n        const result = await this.compile(program, weightedMetric, {\n          ...options,\n          verbose: false, // Suppress inner optimization logs\n        });\n\n        // Evaluate the result with the multi-objective metric\n        const scores = await this.evaluateWithMultiObjective(\n          program,\n          result,\n          metricFn\n        );\n\n        solutions.push({\n          scores,\n          demos: result.demos,\n          configuration: {\n            ...result.finalConfiguration,\n            weights,\n            strategy: 'weighted_combination',\n          },\n        });\n      } catch (error) {\n        if (options?.verbose) {\n          this.getLogger(options)?.(\n            `Failed optimization with weights ${JSON.stringify(weights)}: ${error}`,\n            { tags: ['warning'] }\n          );\n        }\n      }\n    }\n\n    return solutions;\n  }\n\n  /**\n   * Generate solutions using constraint-based optimization\n   */\n  private async generateConstraintSolutions(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<\n    Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<AxGenIn, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  > {\n    const solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<AxGenIn, OUT>[];\n      configuration: Record<string, unknown>;\n    }> = [];\n\n    // Get objectives from a sample evaluation\n    const sampleExample = this.examples[0]!;\n    const samplePrediction = await program.forward(\n      this.studentAI,\n      sampleExample as IN\n    );\n    const sampleScores = await metricFn({\n      prediction: samplePrediction,\n      example: sampleExample,\n    });\n    const objectives = Object.keys(sampleScores);\n\n    // For each objective, optimize it while constraining others\n    for (const primaryObjective of objectives) {\n      if (options?.verbose) {\n        this.getLogger(options)?.(\n          `Optimizing ${primaryObjective} with constraints on other objectives`,\n          { tags: ['discovery'] }\n        );\n      }\n\n      // Create a constraint-based metric\n      const constraintMetric: AxMetricFn = async ({ prediction, example }) => {\n        const scores = await metricFn({ prediction, example });\n\n        // Primary objective score\n        const primaryScore = scores[primaryObjective] || 0;\n\n        // Penalty for violating constraints on other objectives\n        let penalty = 0;\n        for (const [objective, score] of Object.entries(scores)) {\n          if (objective !== primaryObjective) {\n            // Simple constraint: other objectives should be at least 0.3\n            // This is a heuristic - in practice you'd set domain-specific thresholds\n            if (score < 0.3) {\n              penalty += (0.3 - score) * 2; // Penalty factor\n            }\n          }\n        }\n\n        return primaryScore - penalty;\n      };\n\n      try {\n        const result = await this.compile(program, constraintMetric, {\n          ...options,\n          verbose: false,\n        });\n\n        const scores = await this.evaluateWithMultiObjective(\n          program,\n          result,\n          metricFn\n        );\n\n        solutions.push({\n          scores,\n          demos: result.demos,\n          configuration: {\n            ...result.finalConfiguration,\n            primaryObjective,\n            strategy: 'constraint_based',\n          },\n        });\n      } catch (error) {\n        if (options?.verbose) {\n          this.getLogger(options)?.(\n            `Failed constraint optimization for ${primaryObjective}: ${error}`,\n            { tags: ['warning'] }\n          );\n        }\n      }\n    }\n\n    return solutions;\n  }\n\n  /**\n   * Generate different weight combinations for objectives\n   */\n  private generateWeightCombinations(\n    objectives: string[]\n  ): Record<string, number>[] {\n    const combinations: Record<string, number>[] = [];\n\n    // Single-objective focus (one objective gets weight 1, others get 0)\n    for (const objective of objectives) {\n      const weights: Record<string, number> = {};\n      for (const obj of objectives) {\n        weights[obj] = obj === objective ? 1 : 0;\n      }\n      combinations.push(weights);\n    }\n\n    // Equal weights\n    const equalWeights: Record<string, number> = {};\n    for (const objective of objectives) {\n      equalWeights[objective] = 1 / objectives.length;\n    }\n    combinations.push(equalWeights);\n\n    // If we have 2 objectives, generate more granular combinations\n    if (objectives.length === 2) {\n      const [obj1, obj2] = objectives;\n      for (let w1 = 0.1; w1 <= 0.9; w1 += 0.2) {\n        const w2 = 1 - w1;\n        combinations.push({ [obj1!]: w1, [obj2!]: w2 });\n      }\n    }\n\n    // If we have 3 objectives, generate some key combinations\n    if (objectives.length === 3) {\n      const [obj1, obj2, obj3] = objectives;\n      combinations.push(\n        { [obj1!]: 0.5, [obj2!]: 0.3, [obj3!]: 0.2 },\n        { [obj1!]: 0.3, [obj2!]: 0.5, [obj3!]: 0.2 },\n        { [obj1!]: 0.2, [obj2!]: 0.3, [obj3!]: 0.5 }\n      );\n    }\n\n    return combinations;\n  }\n\n  /**\n   * Evaluate a single-objective result with multi-objective metrics\n   */\n  private async evaluateWithMultiObjective(\n    program: Readonly<AxProgram<IN, OUT>>,\n    result: Readonly<AxOptimizerResult<OUT>>,\n    metricFn: AxMultiMetricFn\n  ): Promise<Record<string, number>> {\n    const valSet = this.getValidationSet();\n    const allScores: Record<string, number[]> = {};\n\n    // Apply the optimized configuration to the program\n    const testProgram = { ...program };\n    if (result.demos && 'setDemos' in testProgram) {\n      (\n        testProgram as unknown as { setDemos: (demos: unknown) => void }\n      ).setDemos(result.demos);\n    }\n\n    // Evaluate on validation set\n    const evalSet = valSet.slice(0, Math.min(5, valSet.length));\n\n    for (const example of evalSet) {\n      try {\n        const prediction = await testProgram.forward(\n          this.studentAI,\n          example as IN\n        );\n        const scores = await metricFn({ prediction, example });\n\n        // Collect scores for each objective\n        for (const [objective, score] of Object.entries(scores)) {\n          if (!allScores[objective]) {\n            allScores[objective] = [];\n          }\n          allScores[objective]!.push(score);\n        }\n      } catch {}\n    }\n\n    // Calculate average scores for each objective\n    const avgScores: Record<string, number> = {};\n    for (const [objective, scores] of Object.entries(allScores)) {\n      avgScores[objective] =\n        scores.length > 0\n          ? scores.reduce((sum, score) => sum + score, 0) / scores.length\n          : 0;\n    }\n\n    return avgScores;\n  }\n\n  /**\n   * Find the Pareto frontier from a set of solutions\n   */\n  private findParetoFrontier(\n    solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<AxGenIn, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  ): Array<{\n    demos: readonly AxProgramDemos<AxGenIn, OUT>[];\n    scores: Readonly<Record<string, number>>;\n    configuration: Readonly<Record<string, unknown>>;\n    dominatedSolutions: number;\n  }> {\n    const paretoFront: Array<{\n      demos: readonly AxProgramDemos<AxGenIn, OUT>[];\n      scores: Readonly<Record<string, number>>;\n      configuration: Readonly<Record<string, unknown>>;\n      dominatedSolutions: number;\n    }> = [];\n\n    // For each solution, check if it's dominated by any other solution\n    for (let i = 0; i < solutions.length; i++) {\n      const solutionA = solutions[i]!;\n      let isDominated = false;\n      let dominatedCount = 0;\n\n      for (let j = 0; j < solutions.length; j++) {\n        if (i === j) continue;\n\n        const solutionB = solutions[j]!;\n\n        // Check if B dominates A\n        if (this.dominates(solutionB.scores, solutionA.scores)) {\n          isDominated = true;\n          break;\n        }\n\n        // Count how many solutions A dominates\n        if (this.dominates(solutionA.scores, solutionB.scores)) {\n          dominatedCount++;\n        }\n      }\n\n      // If A is not dominated by any solution, it's on the Pareto frontier\n      if (!isDominated) {\n        paretoFront.push({\n          demos: solutionA.demos || [],\n          scores: solutionA.scores,\n          configuration: solutionA.configuration,\n          dominatedSolutions: dominatedCount,\n        });\n      }\n    }\n\n    return paretoFront;\n  }\n\n  /**\n   * Check if solution A dominates solution B\n   * A dominates B if A is better or equal in all objectives and strictly better in at least one\n   */\n  private dominates(\n    scoresA: Record<string, number>,\n    scoresB: Record<string, number>\n  ): boolean {\n    const objectives = Object.keys(scoresA);\n\n    // Check if A is at least as good as B in all objectives\n    let atLeastAsGood = true;\n    let strictlyBetter = false;\n\n    for (const objective of objectives) {\n      const scoreA = scoresA[objective] || 0;\n      const scoreB = scoresB[objective] || 0;\n\n      if (scoreA < scoreB) {\n        atLeastAsGood = false;\n        break;\n      }\n\n      if (scoreA > scoreB) {\n        strictlyBetter = true;\n      }\n    }\n\n    return atLeastAsGood && strictlyBetter;\n  }\n\n  /**\n   * Calculate hypervolume of the Pareto frontier\n   * Simplified implementation using reference point at origin\n   */\n  private calculateHypervolume(\n    paretoFront: Array<{\n      scores: Readonly<Record<string, number>>;\n    }>\n  ): number | undefined {\n    if (paretoFront.length === 0) return undefined;\n\n    // For simplicity, calculate 2D hypervolume if we have exactly 2 objectives\n    const firstSolution = paretoFront[0]!;\n    const objectives = Object.keys(firstSolution.scores);\n\n    if (objectives.length === 2) {\n      const [obj1, obj2] = objectives;\n      let hypervolume = 0;\n\n      // Sort solutions by first objective (descending)\n      const sortedSolutions = [...paretoFront].sort(\n        (a, b) => (b.scores[obj1!] || 0) - (a.scores[obj1!] || 0)\n      );\n\n      let prevScore2 = 0;\n      for (const solution of sortedSolutions) {\n        const score1 = solution.scores[obj1!] || 0;\n        const score2 = solution.scores[obj2!] || 0;\n\n        // Calculate area contribution\n        hypervolume += score1 * (score2 - prevScore2);\n        prevScore2 = Math.max(prevScore2, score2);\n      }\n\n      return hypervolume;\n    }\n\n    // For higher dimensions, return undefined (would need more complex algorithm)\n    return undefined;\n  }\n\n  /**\n   * Save current optimization state to checkpoint\n   */\n  protected async saveCheckpoint(\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<string | undefined> {\n    const saveFn = options?.overrideCheckpointSave || this.checkpointSave;\n    if (!saveFn) return undefined;\n\n    const startTime = Date.now();\n    let success = false;\n    let checkpointId: string | undefined;\n\n    try {\n      const checkpoint: AxOptimizationCheckpoint = {\n        version: '1.0.0',\n        timestamp: Date.now(),\n        optimizerType,\n        optimizerConfig,\n        currentRound: this.currentRound,\n        totalRounds:\n          this.stats.resourceUsage.totalTime > 0 ? this.currentRound : 0,\n        bestScore,\n        bestConfiguration,\n        scoreHistory: [...this.scoreHistory],\n        configurationHistory: [...this.configurationHistory],\n        stats: { ...this.stats },\n        optimizerState,\n        examples: this.examples,\n        validationSet: this.validationSet,\n      };\n\n      checkpointId = await saveFn(checkpoint);\n      success = true;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const latency = Date.now() - startTime;\n      this.recordCheckpointMetrics('save', latency, success, optimizerType);\n    }\n\n    return checkpointId;\n  }\n\n  /**\n   * Load optimization state from checkpoint\n   */\n  protected async loadCheckpoint(\n    checkpointId: string,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizationCheckpoint | null> {\n    const loadFn = options?.overrideCheckpointLoad || this.checkpointLoad;\n    if (!loadFn) return null;\n\n    const startTime = Date.now();\n    let success = false;\n    let checkpoint: AxOptimizationCheckpoint | null = null;\n\n    try {\n      checkpoint = await loadFn(checkpointId);\n      success = checkpoint !== null;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const latency = Date.now() - startTime;\n      // Use a default optimizer type since we don't know it at load time\n      this.recordCheckpointMetrics('load', latency, success, 'unknown');\n    }\n\n    return checkpoint;\n  }\n\n  /**\n   * Restore optimizer state from checkpoint\n   */\n  protected restoreFromCheckpoint(\n    checkpoint: Readonly<AxOptimizationCheckpoint>\n  ): void {\n    this.currentRound = checkpoint.currentRound;\n    this.scoreHistory = [...checkpoint.scoreHistory];\n    this.configurationHistory = [...checkpoint.configurationHistory];\n    this.stats = { ...checkpoint.stats };\n  }\n\n  /**\n   * Check if checkpoint should be saved\n   */\n  protected shouldSaveCheckpoint(\n    round: number,\n    options?: AxCompileOptions\n  ): boolean {\n    const interval =\n      options?.overrideCheckpointInterval || this.checkpointInterval;\n    return interval !== undefined && round % interval === 0;\n  }\n\n  /**\n   * Update optimization progress and handle checkpointing\n   */\n  protected async updateOptimizationProgress(\n    round: number,\n    score: number,\n    configuration: Record<string, unknown>,\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<void> {\n    this.currentRound = round;\n    this.scoreHistory.push(score);\n    this.configurationHistory.push(configuration);\n\n    // Save checkpoint if needed\n    if (this.shouldSaveCheckpoint(round, options)) {\n      await this.saveCheckpoint(\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        optimizerState,\n        options\n      );\n    }\n  }\n\n  /**\n   * Save final checkpoint on completion\n   */\n  protected async saveFinalCheckpoint(\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<void> {\n    if (options?.saveCheckpointOnComplete !== false) {\n      await this.saveCheckpoint(\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        { ...optimizerState, final: true },\n        options\n      );\n    }\n  }\n\n  /**\n   * Get the logger function with fallback hierarchy:\n   * 1. Explicit logger passed to optimizer\n   * 2. Logger from student AI service\n   * 3. Default optimizer logger\n   * 4. undefined if verbose is false\n   */\n  protected getLogger(\n    options?: AxCompileOptions\n  ): AxLoggerFunction | undefined {\n    // Check if logging should be disabled\n    const isVerbose = this.isLoggingEnabled(options);\n    if (!isVerbose) {\n      return undefined;\n    }\n\n    // Use explicit logger if provided\n    if (this.logger) {\n      return this.logger;\n    }\n\n    // Fall back to default optimizer logger\n    return axDefaultOptimizerLogger;\n  }\n\n  /**\n   * Check if logging is enabled based on verbose settings\n   */\n  protected isLoggingEnabled(options?: AxCompileOptions): boolean {\n    // Explicit verbose setting in options takes precedence\n    if (options?.verbose !== undefined) {\n      return options.verbose;\n    }\n\n    // Use optimizer's verbose setting\n    return this.verbose ?? true; // Default to true if not specified\n  }\n\n  /**\n   * Record optimization start metrics\n   */\n  protected recordOptimizationStart(\n    optimizerType: string,\n    programSignature?: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    // Record program complexity metrics\n    if (programSignature) {\n      // Extract field counts from signature (simplified)\n      const inputFields = (programSignature.match(/input:/g) || []).length;\n      const outputFields = (programSignature.match(/output:/g) || []).length;\n\n      recordProgramComplexityMetric(\n        this.metricsInstruments,\n        inputFields,\n        outputFields,\n        this.examples.length,\n        this.getValidationSet().length,\n        optimizerType\n      );\n    }\n\n    // Record configuration metrics\n    recordOptimizerConfigurationMetric(\n      this.metricsInstruments,\n      optimizerType,\n      this.targetScore,\n      undefined // maxRounds would be set by concrete optimizers\n    );\n  }\n\n  /**\n   * Record optimization completion metrics\n   */\n  protected recordOptimizationComplete(\n    duration: number,\n    success: boolean,\n    optimizerType: string,\n    programSignature?: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordOptimizationMetric(\n      this.metricsInstruments,\n      duration,\n      success,\n      optimizerType,\n      programSignature\n    );\n\n    recordOptimizationDurationMetric(\n      this.metricsInstruments,\n      duration,\n      optimizerType\n    );\n\n    // Record resource usage\n    const currentCost = this.costTracker?.getCurrentCost() ?? 0;\n    const totalTokens = this.costTracker?.getTotalTokens() ?? 0;\n    recordResourceUsageMetric(\n      this.metricsInstruments,\n      totalTokens,\n      currentCost,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record convergence metrics\n   */\n  protected recordConvergenceMetrics(\n    rounds: number,\n    currentScore: number,\n    improvement: number,\n    stagnationRounds: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordConvergenceMetric(\n      this.metricsInstruments,\n      rounds,\n      currentScore,\n      improvement,\n      stagnationRounds,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record early stopping metrics\n   */\n  protected recordEarlyStoppingMetrics(\n    reason: string,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordEarlyStoppingMetric(this.metricsInstruments, reason, optimizerType);\n  }\n\n  /**\n   * Record teacher-student interaction metrics\n   */\n  protected recordTeacherStudentMetrics(\n    latency: number,\n    scoreImprovement: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordTeacherStudentMetric(\n      this.metricsInstruments,\n      latency,\n      scoreImprovement,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record checkpoint metrics\n   */\n  protected recordCheckpointMetrics(\n    operation: 'save' | 'load',\n    latency: number,\n    success: boolean,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordCheckpointMetric(\n      this.metricsInstruments,\n      operation,\n      latency,\n      success,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record Pareto optimization metrics\n   */\n  protected recordParetoMetrics(\n    frontSize: number,\n    solutionsGenerated: number,\n    optimizerType: string,\n    hypervolume?: number\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordParetoMetric(\n      this.metricsInstruments,\n      frontSize,\n      solutionsGenerated,\n      optimizerType,\n      hypervolume\n    );\n  }\n\n  /**\n   * Record performance metrics\n   */\n  protected recordPerformanceMetrics(\n    metricType: 'evaluation' | 'demo_generation' | 'metric_computation',\n    duration: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordOptimizerPerformanceMetric(\n      this.metricsInstruments,\n      metricType,\n      duration,\n      optimizerType\n    );\n  }\n}\n", "import {\n  AxBaseOptimizer,\n  type AxBootstrapCompileOptions,\n  type AxBootstrapOptimizerOptions,\n  type AxMetricFn,\n  type AxOptimizerArgs,\n  type AxOptimizerResult,\n} from '../optimizer.js';\nimport type { AxProgram, AxProgramDemos, AxProgramTrace } from '../program.js';\nimport type { AxFieldValue, AxGenIn, AxGenOut } from '../types.js';\nimport { updateDetailedProgress, updateProgressBar } from '../util.js';\n\n// Define model config interface\ninterface ModelConfig {\n  temperature: number;\n  max_tokens?: number;\n  [key: string]: number | string | boolean | undefined;\n}\n\nexport class AxBootstrapFewShot<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> extends AxBaseOptimizer<IN, OUT> {\n  private maxRounds: number;\n  private maxDemos: number;\n  private maxExamples: number;\n  private batchSize: number;\n  private earlyStoppingPatience: number;\n  private costMonitoring: boolean;\n  private maxTokensPerGeneration: number;\n  private verboseMode: boolean;\n  private debugMode: boolean;\n  private traces: AxProgramTrace<IN, OUT>[] = [];\n\n  constructor(\n    args: Readonly<AxOptimizerArgs & { options?: AxBootstrapOptimizerOptions }>\n  ) {\n    // Call parent constructor\n    super(args);\n\n    const options = args.options || {};\n\n    this.maxRounds = options.maxRounds ?? 3;\n    this.maxDemos = options.maxDemos ?? 4;\n    this.maxExamples = options.maxExamples ?? 16;\n    this.batchSize = options.batchSize ?? 1;\n    this.earlyStoppingPatience = options.earlyStoppingPatience ?? 0;\n    this.costMonitoring = options.costMonitoring ?? false;\n    this.maxTokensPerGeneration = options.maxTokensPerGeneration ?? 0;\n    this.verboseMode = options.verboseMode ?? true;\n    this.debugMode = options.debugMode ?? false;\n\n    // Note: teacherAI from options can be used via compile options overrideTeacherAI\n    // The base class provides methods to access teacher AI with fallbacks\n  }\n\n  private async compileRound(\n    program: Readonly<AxProgram<IN, OUT>>,\n    roundIndex: number,\n    metricFn: AxMetricFn,\n    options?: { maxRounds?: number; maxDemos?: number } | undefined\n  ) {\n    const st = Date.now();\n    const maxDemos = options?.maxDemos ?? this.maxDemos;\n    const aiOpt = {\n      modelConfig: {\n        temperature: 0.7,\n      } as ModelConfig,\n    };\n\n    // Apply token limit if specified\n    if (this.maxTokensPerGeneration > 0) {\n      aiOpt.modelConfig.max_tokens = this.maxTokensPerGeneration;\n    }\n\n    const examples = randomSample(this.examples, this.maxExamples);\n    const previousSuccessCount = this.traces.length;\n\n    // Process examples in batches if batch size > 1\n    for (let i = 0; i < examples.length; i += this.batchSize) {\n      if (i > 0) {\n        aiOpt.modelConfig.temperature = 0.7 + 0.001 * i;\n      }\n\n      const batch = examples.slice(i, i + this.batchSize);\n\n      // Process batch sequentially for now (could be parallelized if AI service supports it)\n      for (const ex of batch) {\n        if (!ex) {\n          continue;\n        }\n\n        // Use remaining examples as demonstration examples (excluding current one)\n        const exList = examples.filter((e) => e !== ex);\n        program.setExamples(exList as unknown as readonly (OUT & IN)[]);\n\n        // Use teacher AI if provided, otherwise use student AI\n        const aiService = this.getTeacherOrStudentAI();\n\n        this.stats.totalCalls++;\n        let res: OUT;\n        let error: Error | undefined;\n\n        try {\n          res = await program.forward(aiService, ex as IN, aiOpt);\n\n          // Estimate token usage if cost monitoring is enabled\n          if (this.costMonitoring) {\n            // Very rough estimate - replace with actual token counting from your AI service\n            this.stats.estimatedTokenUsage +=\n              JSON.stringify(ex).length / 4 + JSON.stringify(res).length / 4;\n          }\n\n          const score = await metricFn({ prediction: res, example: ex });\n          const success = score >= 0.5; // Assuming a threshold of 0.5 for success\n          if (success) {\n            this.traces = [...this.traces, ...program.getTraces()];\n            this.stats.successfulDemos++;\n          }\n        } catch (err) {\n          error = err as Error;\n          res = {} as OUT;\n        }\n\n        const current =\n          i + examples.length * roundIndex + (batch.indexOf(ex) + 1);\n        const total = examples.length * this.maxRounds;\n        const et = Date.now() - st;\n\n        // Use enhanced progress reporting if verbose or debug mode is enabled\n        if (this.verboseMode || this.debugMode) {\n          // Create a configuration object to pass to updateDetailedProgress\n          const configInfo = {\n            maxRounds: this.maxRounds,\n            batchSize: this.batchSize,\n            earlyStoppingPatience: this.earlyStoppingPatience,\n            costMonitoring: this.costMonitoring,\n            verboseMode: this.verboseMode,\n            debugMode: this.debugMode,\n          };\n\n          updateDetailedProgress(\n            roundIndex,\n            current,\n            total,\n            et,\n            ex,\n            this.stats,\n            configInfo,\n            res,\n            error\n          );\n        } else {\n          // Use the standard progress bar for normal mode\n          updateProgressBar(\n            current,\n            total,\n            this.traces.length,\n            et,\n            'Tuning Prompt',\n            30\n          );\n        }\n\n        if (this.traces.length >= maxDemos) {\n          return;\n        }\n      }\n    }\n\n    // Check if we should early stop based on no improvement\n    if (this.earlyStoppingPatience > 0) {\n      const newSuccessCount = this.traces.length;\n      const improvement = newSuccessCount - previousSuccessCount;\n\n      if (!this.stats.earlyStopping) {\n        this.stats.earlyStopping = {\n          bestScoreRound: improvement > 0 ? roundIndex : 0,\n          patienceExhausted: false,\n          reason: 'No improvement detected',\n        };\n      } else if (improvement > 0) {\n        this.stats.earlyStopping.bestScoreRound = roundIndex;\n      } else if (\n        roundIndex - this.stats.earlyStopping.bestScoreRound >=\n        this.earlyStoppingPatience\n      ) {\n        this.stats.earlyStopping.patienceExhausted = true;\n        this.stats.earlyStopped = true;\n        this.stats.earlyStopping.reason = `No improvement for ${this.earlyStoppingPatience} rounds`;\n\n        if (this.verboseMode || this.debugMode) {\n          this.getLogger()?.(\n            `Early stopping after ${roundIndex + 1} rounds (no improvement for ${this.earlyStoppingPatience} rounds)`,\n            { tags: ['optimizer', 'warning'] }\n          );\n        }\n\n        return;\n      }\n    }\n  }\n\n  public async compile(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxBootstrapCompileOptions\n  ): Promise<AxOptimizerResult<OUT>> {\n    const maxRounds = options?.maxIterations ?? this.maxRounds;\n    this.traces = [];\n\n    // Reset stats using parent method\n    this.reset();\n\n    if (this.verboseMode || this.debugMode) {\n      this.getLogger()?.(\n        `Starting BootstrapFewshot optimization with ${maxRounds} rounds`,\n        { tags: ['optimizer', 'start'] }\n      );\n      this.getLogger()?.(\n        `Using ${this.examples.length} examples, max ${this.maxDemos} demos`,\n        { tags: ['optimizer', 'config'] }\n      );\n    }\n\n    for (let i = 0; i < maxRounds; i++) {\n      await this.compileRound(program, i, metricFn, options);\n\n      // Break early if early stopping was triggered\n      if (this.stats.earlyStopped) {\n        break;\n      }\n    }\n\n    if (this.traces.length === 0) {\n      throw new Error(\n        'No demonstrations found. Either provide more examples or improve the existing ones.'\n      );\n    }\n\n    const demos: AxProgramDemos<IN, OUT>[] = groupTracesByKeys(this.traces);\n\n    // Calculate best score from traces\n    let bestScore = 0;\n    if (this.traces.length > 0) {\n      // Simple approximation - in a real implementation you'd track scores properly\n      bestScore =\n        this.stats.successfulDemos / Math.max(1, this.stats.totalCalls);\n    }\n\n    if (this.verboseMode || this.debugMode) {\n      this.getLogger()?.(\n        `Bootstrap complete. Generated ${demos.length} demos with ${bestScore.toFixed(3)} success rate`,\n        { tags: ['optimizer', 'complete'] }\n      );\n    }\n\n    return {\n      demos,\n      stats: this.stats,\n      bestScore,\n      finalConfiguration: {\n        maxRounds: this.maxRounds,\n        maxDemos: this.maxDemos,\n        batchSize: this.batchSize,\n        successRate: bestScore,\n      },\n    };\n  }\n}\n\nfunction groupTracesByKeys<IN extends AxGenIn, OUT extends AxGenOut>(\n  programTraces: readonly AxProgramTrace<IN, OUT>[]\n): AxProgramDemos<IN, OUT>[] {\n  const groupedTraces = new Map<string, Record<string, AxFieldValue>[]>();\n\n  // Group all traces by their keys\n  for (const programTrace of programTraces) {\n    if (groupedTraces.has(programTrace.programId)) {\n      const traces = groupedTraces.get(programTrace.programId);\n      if (traces) {\n        traces.push(programTrace.trace);\n      }\n    } else {\n      groupedTraces.set(programTrace.programId, [programTrace.trace]);\n    }\n  }\n\n  // Convert the Map into an array of ProgramDemos\n  const programDemosArray: AxProgramDemos<IN, OUT>[] = [];\n  groupedTraces.forEach((traces, programId) => {\n    programDemosArray.push({\n      traces: traces as unknown as (OUT & IN)[],\n      programId,\n    });\n  });\n\n  return programDemosArray;\n}\n\nconst randomSample = <T>(array: readonly T[], n: number): T[] => {\n  // Clone the array to avoid modifying the original array\n  const clonedArray = [...array];\n  // Shuffle the cloned array\n  for (let i = clonedArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const caI = clonedArray[i];\n    const caJ = clonedArray[j];\n\n    if (!caI || !caJ) {\n      throw new Error('Invalid array elements');\n    }\n\n    [clonedArray[i], clonedArray[j]] = [caJ, caI];\n  }\n  // Return the first `n` items of the shuffled array\n  return clonedArray.slice(0, n);\n};\n", "import type { AxAIService } from '../../ai/types.js';\nimport { AxGen } from '../generate.js';\nimport {\n  AxBaseOptimizer,\n  type AxCompileOptions,\n  type AxExample,\n  type AxMetricFn,\n  type AxMiPROCompileOptions,\n  type AxMiPROOptimizerOptions,\n  type AxOptimizerArgs,\n  type AxOptimizerResult,\n} from '../optimizer.js';\nimport type {\n  AxProgram,\n  AxProgramDemos,\n  AxResultPickerFunction,\n} from '../program.js';\nimport type { AxGenIn, AxGenOut } from '../types.js';\nimport { updateProgressBar } from '../util.js';\n\nimport { AxBootstrapFewShot } from './bootstrapFewshot.js';\n\ninterface ConfigType extends Record<string, unknown> {\n  instruction: string;\n  bootstrappedDemos: number;\n  labeledExamples: number;\n}\n\n// Extended result interface to include the optimized AxGen\nexport interface AxMiPROResult<IN extends AxGenIn, OUT extends AxGenOut>\n  extends AxOptimizerResult<OUT> {\n  optimizedGen?: AxGen<IN, OUT>;\n}\n\nexport class AxMiPRO<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> extends AxBaseOptimizer<IN, OUT> {\n  // MiPRO-specific options\n  private maxBootstrappedDemos: number;\n  private maxLabeledDemos: number;\n  private numCandidates: number;\n  private initTemperature: number;\n  private numTrials: number;\n  private minibatch: boolean;\n  private minibatchSize: number;\n  private minibatchFullEvalSteps: number;\n  private programAwareProposer: boolean;\n  private dataAwareProposer: boolean;\n  private viewDataBatchSize: number;\n  private tipAwareProposer: boolean;\n  private fewshotAwareProposer: boolean;\n  private earlyStoppingTrials: number;\n  private minImprovementThreshold: number;\n  private bayesianOptimization: boolean;\n  private acquisitionFunction:\n    | 'expected_improvement'\n    | 'upper_confidence_bound'\n    | 'probability_improvement';\n  private explorationWeight: number;\n\n  // Self-consistency / multiple sampling\n  private sampleCount: number;\n\n  // Surrogate model state for Bayesian optimization\n  private miproConfigHistory: { config: ConfigType; score: number }[] = [];\n  private surrogateModel: Map<string, { mean: number; variance: number }> =\n    new Map();\n\n  constructor(\n    args: Readonly<AxOptimizerArgs & { options?: AxMiPROOptimizerOptions }>\n  ) {\n    // Call parent constructor with base args\n    super(args);\n\n    const options = args.options || {};\n\n    // MiPRO-specific options with proper defaults\n    this.numCandidates = options.numCandidates ?? 5;\n    this.initTemperature = options.initTemperature ?? 0.7;\n    this.maxBootstrappedDemos = options.maxBootstrappedDemos ?? 3;\n    this.maxLabeledDemos = options.maxLabeledDemos ?? 4;\n    this.numTrials = options.numTrials ?? 30;\n    this.minibatch = options.minibatch ?? true;\n    this.minibatchSize = options.minibatchSize ?? 25;\n    this.minibatchFullEvalSteps = options.minibatchFullEvalSteps ?? 10;\n    this.programAwareProposer = options.programAwareProposer ?? true;\n    this.dataAwareProposer = options.dataAwareProposer ?? true;\n    this.viewDataBatchSize = options.viewDataBatchSize ?? 10;\n    this.tipAwareProposer = options.tipAwareProposer ?? true;\n    this.fewshotAwareProposer = options.fewshotAwareProposer ?? true;\n    this.earlyStoppingTrials = options.earlyStoppingTrials ?? 5;\n    this.minImprovementThreshold = options.minImprovementThreshold ?? 0.01;\n    this.bayesianOptimization = options.bayesianOptimization ?? false;\n    this.acquisitionFunction =\n      options.acquisitionFunction ?? 'expected_improvement';\n    this.explorationWeight = options.explorationWeight ?? 0.1;\n\n    // Self-consistency options\n    this.sampleCount = options.sampleCount ?? 1;\n\n    // Update convergence threshold in stats\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  /**\n   * Configures the optimizer for light, medium, or heavy optimization\n   * @param level The optimization level: \"light\", \"medium\", or \"heavy\"\n   */\n  public configureAuto(level: 'light' | 'medium' | 'heavy'): void {\n    switch (level) {\n      case 'light':\n        this.numCandidates = 3;\n        this.numTrials = 10;\n        this.minibatch = true;\n        this.minibatchSize = 20;\n        break;\n      case 'medium':\n        this.numCandidates = 5;\n        this.numTrials = 20;\n        this.minibatch = true;\n        this.minibatchSize = 25;\n        break;\n      case 'heavy':\n        this.numCandidates = 7;\n        this.numTrials = 30;\n        this.minibatch = true;\n        this.minibatchSize = 30;\n        break;\n    }\n  }\n\n  /**\n   * Generates creative tips for instruction generation\n   */\n  private generateTips(): string[] {\n    return [\n      'Be very specific and detailed in your instructions.',\n      'Focus on step-by-step reasoning in your instructions.',\n      'Provide clear constraints and guidelines in your instructions.',\n      'Keep your instructions concise and to the point.',\n      'Emphasize accuracy and precision in your instructions.',\n      'Include examples of good outputs in your instructions.',\n      'Focus on handling edge cases in your instructions.',\n      'Explicitly outline the reasoning process in your instructions.',\n    ];\n  }\n\n  /**\n   * Generates program summary for context-aware instruction generation\n   */\n  private async generateProgramSummary(\n    program: Readonly<AxProgram<IN, OUT>>,\n    ai: Readonly<AxAIService>\n  ): Promise<string> {\n    // Extract program structure information\n    const signature = program.getSignature();\n\n    // Create program summary prompt based on paper's Appendix C.5\n    const summaryPrompt = `\nAnalyze this language model program and provide a concise summary of its purpose and structure.\n\nProgram Signature: ${signature}\n\nProvide a 2-3 sentence summary focusing on:\n1. The main task or purpose of this program\n2. The input-output relationship\n3. Any special constraints or requirements\n\nSummary:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [{ role: 'user', content: summaryPrompt }],\n      });\n      if ('results' in response) {\n        return (\n          response.results[0]?.content?.trim() ||\n          'General language model program'\n        );\n      }\n      return 'General language model program';\n    } catch {\n      return 'General language model program';\n    }\n  }\n\n  /**\n   * Generates dataset summary for context-aware instruction generation\n   */\n  private async generateDatasetSummary(\n    examples: readonly AxExample[],\n    ai: Readonly<AxAIService>\n  ): Promise<string> {\n    if (examples.length === 0) return 'No examples available';\n\n    // Sample a few examples for analysis (based on paper's approach)\n    const sampleSize = Math.min(this.viewDataBatchSize, examples.length);\n    const sampledExamples = examples.slice(0, sampleSize);\n\n    // Create dataset summary prompt based on paper's Appendix C.3\n    const exampleTexts = sampledExamples\n      .map((ex, i) => `Example ${i + 1}: ${JSON.stringify(ex)}`)\n      .join('\\n');\n\n    const summaryPrompt = `\nAnalyze this dataset and provide a concise summary of its characteristics.\n\nSample Examples:\n${exampleTexts}\n\nProvide a 2-3 sentence summary focusing on:\n1. The type of data and domain\n2. Common patterns or structures in the examples\n3. Key challenges or requirements for processing this data\n\nDataset Summary:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [{ role: 'user', content: summaryPrompt }],\n      });\n      if ('results' in response) {\n        return response.results[0]?.content?.trim() || 'General dataset';\n      }\n      return 'General dataset';\n    } catch {\n      return 'General dataset';\n    }\n  }\n\n  /**\n   * Enhanced instruction generation using AI with program and data awareness\n   */\n  private async generateInstruction({\n    tip,\n    candidateIndex,\n    ai,\n    programSummary,\n    datasetSummary,\n    previousInstructions = [],\n  }: Readonly<{\n    tip: string | undefined;\n    candidateIndex: number;\n    ai: Readonly<AxAIService>;\n    programSummary?: string;\n    datasetSummary?: string;\n    previousInstructions?: string[];\n  }>): Promise<string> {\n    // Build context-aware instruction generation prompt based on paper\n    let contextInfo = '';\n\n    if (this.programAwareProposer && programSummary) {\n      contextInfo += `\\nProgram Context: ${programSummary}`;\n    }\n\n    if (this.dataAwareProposer && datasetSummary) {\n      contextInfo += `\\nDataset Context: ${datasetSummary}`;\n    }\n\n    if (this.fewshotAwareProposer && previousInstructions.length > 0) {\n      contextInfo += `\\nPrevious Instructions (avoid repeating): ${previousInstructions.slice(-3).join('; ')}`;\n    }\n\n    // Core instruction generation prompt inspired by paper's Appendix C.1\n    const instructionPrompt = `\nGenerate a high-quality instruction for a language model program.\n\n${contextInfo}\n\n${tip ? `Tip: ${tip}` : ''}\n\nRequirements:\n1. Be specific and actionable\n2. Focus on accuracy and clarity\n3. Consider the program's purpose and data characteristics\n4. Make the instruction distinct from previous ones\n5. Keep it concise but comprehensive\n\nGenerate a single, well-crafted instruction:\nInstruction:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [\n          {\n            role: 'user',\n            content: instructionPrompt,\n          },\n        ],\n      });\n\n      if ('results' in response) {\n        const instruction = response.results[0]?.content?.trim();\n        if (instruction && instruction.length > 10) {\n          return instruction;\n        }\n      }\n    } catch (error) {\n      if (this.isLoggingEnabled()) {\n        this.getLogger()?.(`Failed to generate AI instruction: ${error}`, {\n          tags: ['optimizer', 'warning'],\n        });\n      }\n    }\n\n    // Fallback to enhanced templates if AI generation fails\n    const enhancedTemplates = [\n      'Analyze the input systematically and provide a precise, well-reasoned response.',\n      'Think through this step-by-step, considering all relevant factors before responding.',\n      'Examine the input carefully and generate an accurate, detailed answer.',\n      'Process the information methodically and deliver a clear, comprehensive response.',\n      'Consider the context thoroughly and provide a thoughtful, accurate answer.',\n    ];\n\n    let instruction =\n      enhancedTemplates[candidateIndex % enhancedTemplates.length] ||\n      enhancedTemplates[0]!;\n\n    if (tip) {\n      instruction = `${instruction} ${tip}`;\n    }\n\n    return instruction;\n  }\n\n  /**\n   * Generates instruction candidates using enhanced AI-powered generation\n   * @param options Optional compile options that may override teacher AI\n   * @returns Array of generated instruction candidates\n   */\n  private async proposeInstructionCandidates(\n    program: Readonly<AxProgram<IN, OUT>>,\n    options?: AxCompileOptions\n  ): Promise<string[]> {\n    const instructions: string[] = [];\n    const aiToUse = this.getTeacherOrStudentAI(options);\n\n    // Generate contextual information if enabled\n    let programSummary: string | undefined;\n    let datasetSummary: string | undefined;\n\n    if (this.programAwareProposer) {\n      programSummary = await this.generateProgramSummary(program, aiToUse);\n      if (this.isLoggingEnabled(options)) {\n        this.getLogger(options)?.(`Program summary: ${programSummary}`, {\n          tags: ['optimizer', 'config'],\n        });\n      }\n    }\n\n    if (this.dataAwareProposer) {\n      datasetSummary = await this.generateDatasetSummary(\n        this.examples,\n        aiToUse\n      );\n      if (this.isLoggingEnabled(options)) {\n        this.getLogger(options)?.(`Dataset summary: ${datasetSummary}`, {\n          tags: ['optimizer', 'config'],\n        });\n      }\n    }\n\n    // Generate creative tips for tip-aware proposing\n    const tips = this.tipAwareProposer ? this.generateTips() : [];\n\n    // Generate instructions for each candidate\n    for (let i = 0; i < this.numCandidates; i++) {\n      const tipIndex = tips.length > 0 ? i % tips.length : -1;\n      const tipToUse = tipIndex >= 0 ? tips[tipIndex] : undefined;\n\n      const instruction = await this.generateInstruction({\n        tip: tipToUse,\n        candidateIndex: i,\n        ai: aiToUse,\n        programSummary,\n        datasetSummary,\n        previousInstructions: instructions, // Pass previous instructions for diversity\n      });\n\n      instructions.push(instruction);\n    }\n\n    return instructions;\n  }\n\n  /**\n   * Bootstraps few-shot examples for the program\n   */\n  private async bootstrapFewShotExamples(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMetricFn\n  ): Promise<AxProgramDemos<IN, OUT>[]> {\n    if (this.isLoggingEnabled()) {\n      this.getLogger()?.('Bootstrapping few-shot examples...', {\n        tags: ['optimizer', 'phase'],\n      });\n    }\n\n    // Initialize the bootstrapper for this program\n    const bootstrapper = new AxBootstrapFewShot<IN, OUT>({\n      studentAI: this.studentAI,\n      examples: this.examples,\n      options: {\n        maxDemos: this.maxBootstrappedDemos,\n        maxRounds: 3,\n        verboseMode: this.isLoggingEnabled(),\n      },\n    });\n\n    const result = await bootstrapper.compile(program, metricFn, {\n      maxDemos: this.maxBootstrappedDemos,\n    });\n\n    return (result.demos || []) as AxProgramDemos<IN, OUT>[];\n  }\n\n  /**\n   * Selects labeled examples directly from the training set\n   */\n  private selectLabeledExamples(): AxExample[] {\n    const selectedExamples: AxExample[] = [];\n\n    // Random sampling from the training set\n    const indices = new Set<number>();\n    while (\n      indices.size < this.maxLabeledDemos &&\n      indices.size < this.examples.length\n    ) {\n      const idx = Math.floor(Math.random() * this.examples.length);\n      if (!indices.has(idx)) {\n        indices.add(idx);\n        const example = this.examples[idx];\n        if (example) {\n          selectedExamples.push(example);\n        }\n      }\n    }\n\n    return selectedExamples;\n  }\n\n  /**\n   * Runs optimization to find the best combination of few-shot examples and instructions\n   */\n  private async runOptimization(\n    program: Readonly<AxProgram<IN, OUT>>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[],\n    instructions: readonly string[],\n    validationExamples: readonly AxExample[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<{ bestConfig: ConfigType; bestScore: number }> {\n    let bestConfig: ConfigType = {\n      instruction: instructions[0] || '',\n      bootstrappedDemos: Math.min(1, bootstrappedDemos.length),\n      labeledExamples: Math.min(1, labeledExamples.length),\n    };\n    let bestScore = 0;\n    let stagnationRounds = 0;\n    const scoreHistory: number[] = [];\n\n    // Check for checkpoint resume\n    let startRound = 0;\n    if (this.resumeFromCheckpoint) {\n      const checkpoint = await this.loadCheckpoint(\n        this.resumeFromCheckpoint,\n        options\n      );\n      if (checkpoint && checkpoint.optimizerType === 'MiPRO') {\n        if (this.isLoggingEnabled(options)) {\n          this.getLogger(options)?.(\n            `Resuming from checkpoint at round ${checkpoint.currentRound}`,\n            { tags: ['optimizer', 'checkpoint'] }\n          );\n        }\n\n        this.restoreFromCheckpoint(checkpoint);\n        startRound = checkpoint.currentRound;\n        bestScore = checkpoint.bestScore;\n        bestConfig = (checkpoint.bestConfiguration as ConfigType) || bestConfig;\n        stagnationRounds =\n          checkpoint.stats.convergenceInfo?.stagnationRounds || 0;\n      }\n    }\n\n    // Optimization loop with early stopping and checkpointing\n    if (this.isLoggingEnabled(options)) {\n      this.getLogger(options)?.(\n        `Running optimization trials (${this.numTrials} total)`,\n        { tags: ['optimizer', 'phase'] }\n      );\n    }\n\n    for (let i = startRound; i < this.numTrials; i++) {\n      let config: ConfigType;\n\n      if (this.bayesianOptimization && this.miproConfigHistory.length > 2) {\n        // Use Bayesian optimization with acquisition function\n        config = await this.selectConfigurationViaBayesianOptimization(\n          instructions,\n          bootstrappedDemos,\n          labeledExamples\n        );\n      } else {\n        // Random or round-robin selection (exploration phase)\n        config = {\n          instruction:\n            instructions[i % instructions.length] || instructions[0] || '',\n          bootstrappedDemos: Math.min(\n            Math.floor(Math.random() * (bootstrappedDemos.length + 1)),\n            this.maxBootstrappedDemos\n          ),\n          labeledExamples: Math.min(\n            Math.floor(Math.random() * (labeledExamples.length + 1)),\n            this.maxLabeledDemos\n          ),\n        };\n      }\n\n      const score = await this.evaluateConfig(\n        program,\n        config,\n        bootstrappedDemos,\n        labeledExamples,\n        validationExamples,\n        metricFn,\n        i + 1 // Pass current trial number for adaptive evaluation\n      );\n\n      // Update surrogate model with observed score\n      this.updateSurrogateModel(config, score);\n\n      scoreHistory.push(score);\n\n      // Check for improvement\n      const improvement = score - bestScore;\n      if (improvement > this.minImprovementThreshold) {\n        bestScore = score;\n        bestConfig = config;\n        stagnationRounds = 0;\n\n        if (this.isLoggingEnabled(options)) {\n          this.getLogger(options)?.(\n            `Trial ${i + 1}/${this.numTrials}: New best score ${bestScore.toFixed(3)}`,\n            { tags: ['optimizer', 'progress'] }\n          );\n        }\n      } else {\n        stagnationRounds++;\n      }\n\n      // Update optimization progress with checkpointing\n      await this.updateOptimizationProgress(\n        i + 1,\n        score,\n        config,\n        'MiPRO',\n        this.getConfiguration(),\n        bestScore,\n        bestConfig,\n        {\n          stagnationRounds,\n          bootstrappedDemos: bootstrappedDemos.length,\n          labeledExamples: labeledExamples.length,\n          instructions: instructions.length,\n        },\n        options\n      );\n\n      // Progress callback\n      if (this.onProgress) {\n        this.onProgress({\n          round: i + 1,\n          totalRounds: this.numTrials,\n          currentScore: score,\n          bestScore,\n          tokensUsed: this.stats.resourceUsage.totalTokens,\n          timeElapsed: Date.now(),\n          successfulExamples: this.stats.successfulDemos,\n          totalExamples: this.examples.length,\n          currentConfiguration: config,\n          convergenceInfo: {\n            improvement,\n            stagnationRounds,\n            isConverging: stagnationRounds < this.earlyStoppingTrials,\n          },\n        });\n      }\n\n      // Update progress bar\n      updateProgressBar(\n        i + 1,\n        this.numTrials,\n        Math.round(bestScore * 100),\n        0,\n        'Running MIPROv2 optimization',\n        30\n      );\n\n      // Cost tracking check (handles token/time/cost budgets)\n      if (this.checkCostLimits()) {\n        this.triggerEarlyStopping('Cost limit reached', i + 1);\n        break;\n      }\n\n      // Early stopping check\n      if (stagnationRounds >= this.earlyStoppingTrials) {\n        this.triggerEarlyStopping(\n          `No improvement for ${this.earlyStoppingTrials} trials`,\n          i - stagnationRounds + 1\n        );\n        break;\n      }\n\n      // Target score check\n      if (this.checkTargetScore(bestScore)) {\n        this.triggerEarlyStopping(\n          `Target score ${this.targetScore} reached`,\n          i + 1\n        );\n        break;\n      }\n    }\n\n    // Update convergence info\n    this.stats.convergenceInfo.stagnationRounds = stagnationRounds;\n    this.stats.convergenceInfo.finalImprovement =\n      scoreHistory.length > 1 ? bestScore - scoreHistory[0]! : 0;\n    this.stats.convergenceInfo.converged =\n      stagnationRounds < this.earlyStoppingTrials;\n\n    return { bestConfig, bestScore };\n  }\n\n  private async evaluateConfig(\n    program: Readonly<AxProgram<IN, OUT>>,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[],\n    validationExamples: readonly AxExample[],\n    metricFn: AxMetricFn,\n    currentTrial = 0\n  ): Promise<number> {\n    // Create a copy of the program and apply the configuration\n    const testProgram = { ...program };\n    this.applyConfigToProgram(\n      testProgram,\n      config,\n      bootstrappedDemos,\n      labeledExamples\n    );\n\n    let totalScore = 0;\n    let count = 0;\n\n    // Adaptive minibatch size based on paper's approach\n    let evalSize: number;\n    if (this.minibatch) {\n      // Start with smaller batches and increase for more promising configurations\n      const baseSize = Math.min(this.minibatchSize, validationExamples.length);\n\n      // Use full evaluation for top configurations in later trials\n      const isFullEvalTrial = currentTrial % this.minibatchFullEvalSteps === 0;\n      if (isFullEvalTrial || currentTrial > this.numTrials * 0.8) {\n        evalSize = Math.min(validationExamples.length, baseSize * 2);\n      } else {\n        // Stochastic minibatch evaluation\n        evalSize = Math.max(3, Math.min(baseSize, validationExamples.length));\n      }\n    } else {\n      evalSize = validationExamples.length;\n    }\n\n    // Randomly sample evaluation examples for stochastic evaluation\n    const evalIndices = this.shuffleArray([\n      ...Array(validationExamples.length).keys(),\n    ]).slice(0, evalSize);\n    const evalSet = evalIndices.map((i) => validationExamples[i]!);\n\n    for (const example of evalSet) {\n      try {\n        const prediction = await testProgram.forward(\n          this.studentAI,\n          example as IN,\n          this.sampleCount > 1\n            ? {\n                sampleCount: this.sampleCount,\n                resultPicker:\n                  axMajorityVotePicker<OUT>() as AxResultPickerFunction<AxGenOut>,\n              }\n            : undefined\n        );\n        const score = await metricFn({ prediction, example });\n        totalScore += score;\n        count++;\n        this.stats.totalCalls++;\n      } catch {}\n    }\n\n    return count > 0 ? totalScore / count : 0;\n  }\n\n  /**\n   * Fisher-Yates shuffle for stochastic evaluation\n   */\n  private shuffleArray<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j]!, shuffled[i]!];\n    }\n    return shuffled;\n  }\n\n  private applyConfigToProgram(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    program: any,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): void {\n    // Set instruction if the program supports it\n    if (program.setInstruction) {\n      program.setInstruction(config.instruction);\n    }\n\n    // Set demos if needed\n    if (config.bootstrappedDemos > 0 && program.setDemos) {\n      program.setDemos(bootstrappedDemos.slice(0, config.bootstrappedDemos));\n    }\n\n    // Set examples if needed\n    if (config.labeledExamples > 0 && program.setExamples) {\n      program.setExamples(labeledExamples.slice(0, config.labeledExamples));\n    }\n  }\n\n  /**\n   * The main compile method to run MIPROv2 optimization\n   */\n  public async compile(\n    program: Readonly<AxProgram<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxMiPROResult<IN, OUT>> {\n    const startTime = Date.now();\n\n    // Initialize random seed if provided\n    this.setupRandomSeed();\n\n    // Configure auto settings if provided (cast to access MiPRO-specific options)\n    const miproOptions = options as AxMiPROCompileOptions;\n    if (miproOptions?.auto) {\n      this.configureAuto(miproOptions.auto);\n    }\n\n    // Use validation set from parent class method\n    const validationExamples =\n      this.getValidationSet(options) ||\n      (miproOptions?.validationExamples ??\n        this.examples.slice(0, Math.floor(this.examples.length * 0.2)));\n\n    if (this.isLoggingEnabled(options)) {\n      this.getLogger(options)?.(\n        `Starting MIPROv2 optimization with ${this.numTrials} trials`,\n        { tags: ['optimizer', 'start'] }\n      );\n      this.getLogger(options)?.(\n        `Using ${this.examples.length} examples for training and ${validationExamples.length} for validation`,\n        { tags: ['optimizer', 'config'] }\n      );\n      if (this.teacherAI) {\n        this.getLogger(options)?.(\n          'Using separate teacher model for instruction generation',\n          { tags: ['optimizer', 'config'] }\n        );\n      }\n    }\n\n    // Step 1: Bootstrap few-shot examples\n    let bootstrappedDemos: AxProgramDemos<IN, OUT>[] = [];\n    if (this.maxBootstrappedDemos > 0) {\n      bootstrappedDemos = await this.bootstrapFewShotExamples(\n        program,\n        metricFn\n      );\n\n      if (this.isLoggingEnabled(options)) {\n        this.getLogger(options)?.(\n          `Generated ${bootstrappedDemos.length} bootstrapped demonstrations`,\n          { tags: ['optimizer', 'result'] }\n        );\n      }\n    }\n\n    // Step 2: Select labeled examples from training set\n    let labeledExamples: AxExample[] = [];\n    if (this.maxLabeledDemos > 0) {\n      labeledExamples = this.selectLabeledExamples();\n\n      if (this.isLoggingEnabled(options)) {\n        this.getLogger(options)?.(\n          `Selected ${labeledExamples.length} labeled examples from training set`,\n          { tags: ['optimizer', 'result'] }\n        );\n      }\n    }\n\n    // Step 3: Generate instruction candidates\n    const instructions = await this.proposeInstructionCandidates(\n      program,\n      options\n    );\n\n    if (this.isLoggingEnabled(options)) {\n      this.getLogger(options)?.(\n        `Generated ${instructions.length} instruction candidates`,\n        { tags: ['optimizer', 'result'] }\n      );\n      if (this.hasTeacherAI(options)) {\n        this.getLogger(options)?.(\n          'Using teacher AI for instruction generation',\n          { tags: ['optimizer', 'config'] }\n        );\n      }\n    }\n\n    // Step 4: Run optimization to find the best configuration\n    const { bestConfig, bestScore } = await this.runOptimization(\n      program,\n      bootstrappedDemos,\n      labeledExamples,\n      instructions,\n      validationExamples,\n      metricFn,\n      options\n    );\n\n    if (this.isLoggingEnabled(options)) {\n      this.getLogger(options)?.(\n        `Optimization complete. Best score: ${bestScore}`,\n        { tags: ['optimizer', 'complete'] }\n      );\n      this.getLogger(options)?.(\n        `Best configuration: ${JSON.stringify(bestConfig)}`,\n        { tags: ['optimizer', 'result'] }\n      );\n    }\n\n    // Check if target score was reached\n    if (this.checkTargetScore(bestScore)) {\n      this.triggerEarlyStopping(\n        `Target score ${this.targetScore} reached with score ${bestScore}`,\n        this.numTrials\n      );\n    }\n\n    // Create a new AxGen instance with the optimized configuration\n    let signature: any;\n    if (\n      'getSignature' in program &&\n      typeof program.getSignature === 'function'\n    ) {\n      signature = program.getSignature();\n    } else {\n      // Fallback: create a basic signature\n      signature = 'input -> output';\n    }\n\n    const optimizedGen = new AxGen<IN, OUT>(signature);\n\n    // Apply the best configuration to the new AxGen\n    this.applyConfigToAxGen(\n      optimizedGen,\n      bestConfig,\n      bootstrappedDemos,\n      labeledExamples\n    );\n\n    // Update stats using parent class method\n    this.updateResourceUsage(startTime);\n    this.stats.convergenceInfo.converged = true;\n    this.stats.convergenceInfo.finalImprovement = bestScore;\n\n    // Save final checkpoint\n    await this.saveFinalCheckpoint(\n      'MiPRO',\n      this.getConfiguration(),\n      bestScore,\n      bestConfig,\n      {\n        bootstrappedDemos: bootstrappedDemos.length,\n        labeledExamples: labeledExamples.length,\n        instructions: instructions.length,\n        optimizedGen: !!optimizedGen,\n      },\n      options\n    );\n\n    return {\n      demos: bootstrappedDemos,\n      stats: this.stats,\n      bestScore,\n      optimizedGen,\n      finalConfiguration: {\n        instruction: bestConfig.instruction,\n        bootstrappedDemos: bestConfig.bootstrappedDemos,\n        labeledExamples: bestConfig.labeledExamples,\n        numCandidates: this.numCandidates,\n        numTrials: this.numTrials,\n        sampleCount: this.sampleCount,\n      },\n    };\n  }\n\n  /**\n   * Applies a configuration to an AxGen instance\n   */\n  private applyConfigToAxGen(\n    axgen: Readonly<AxGen<IN, OUT>>,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): void {\n    // Set instruction if the AxGen supports it\n    if (\n      'setInstruction' in axgen &&\n      typeof axgen.setInstruction === 'function'\n    ) {\n      axgen.setInstruction(config.instruction);\n    }\n\n    // Set demos if needed\n    if (config.bootstrappedDemos > 0) {\n      axgen.setDemos(bootstrappedDemos.slice(0, config.bootstrappedDemos));\n    }\n\n    // Set examples if needed\n    if (config.labeledExamples > 0) {\n      axgen.setExamples(\n        labeledExamples.slice(\n          0,\n          config.labeledExamples\n        ) as unknown as readonly (OUT & IN)[]\n      );\n    }\n  }\n\n  /**\n   * Get optimizer-specific configuration\n   * @returns Current optimizer configuration\n   */\n  public getConfiguration(): Record<string, unknown> {\n    return {\n      numCandidates: this.numCandidates,\n      initTemperature: this.initTemperature,\n      maxBootstrappedDemos: this.maxBootstrappedDemos,\n      maxLabeledDemos: this.maxLabeledDemos,\n      numTrials: this.numTrials,\n      minibatch: this.minibatch,\n      minibatchSize: this.minibatchSize,\n      minibatchFullEvalSteps: this.minibatchFullEvalSteps,\n      programAwareProposer: this.programAwareProposer,\n      dataAwareProposer: this.dataAwareProposer,\n      tipAwareProposer: this.tipAwareProposer,\n      fewshotAwareProposer: this.fewshotAwareProposer,\n      earlyStoppingTrials: this.earlyStoppingTrials,\n      minImprovementThreshold: this.minImprovementThreshold,\n      bayesianOptimization: this.bayesianOptimization,\n      acquisitionFunction: this.acquisitionFunction,\n      explorationWeight: this.explorationWeight,\n      sampleCount: this.sampleCount,\n    };\n  }\n\n  /**\n   * Update optimizer configuration\n   * @param config New configuration to merge with existing\n   */\n  public updateConfiguration(config: Readonly<Record<string, unknown>>): void {\n    if (config.numCandidates !== undefined) {\n      this.numCandidates = config.numCandidates as number;\n    }\n    if (config.initTemperature !== undefined) {\n      this.initTemperature = config.initTemperature as number;\n    }\n    if (config.maxBootstrappedDemos !== undefined) {\n      this.maxBootstrappedDemos = config.maxBootstrappedDemos as number;\n    }\n    if (config.maxLabeledDemos !== undefined) {\n      this.maxLabeledDemos = config.maxLabeledDemos as number;\n    }\n    if (config.numTrials !== undefined) {\n      this.numTrials = config.numTrials as number;\n    }\n    if (config.minibatch !== undefined) {\n      this.minibatch = config.minibatch as boolean;\n    }\n    if (config.minibatchSize !== undefined) {\n      this.minibatchSize = config.minibatchSize as number;\n    }\n    if (config.earlyStoppingTrials !== undefined) {\n      this.earlyStoppingTrials = config.earlyStoppingTrials as number;\n    }\n    if (config.minImprovementThreshold !== undefined) {\n      this.minImprovementThreshold = config.minImprovementThreshold as number;\n    }\n    if (config.sampleCount !== undefined) {\n      this.sampleCount = config.sampleCount as number;\n    }\n    // Note: verbose is now handled by the base class and cannot be updated here\n  }\n\n  /**\n   * Reset optimizer state for reuse with different programs\n   */\n  public override reset(): void {\n    super.reset();\n    // Reset surrogate model state\n    this.miproConfigHistory = [];\n    this.surrogateModel.clear();\n    // Update convergence threshold after reset\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  /**\n   * Validate that the optimizer can handle the given program\n   * @param program Program to validate\n   * @returns Validation result with any issues found\n   */\n  public override validateProgram(program: Readonly<AxProgram<IN, OUT>>): {\n    isValid: boolean;\n    issues: string[];\n    suggestions: string[];\n  } {\n    // Start with base validation\n    const result = super.validateProgram(program);\n\n    // Add MiPRO-specific validation\n    if (\n      this.examples.length <\n      this.maxBootstrappedDemos + this.maxLabeledDemos\n    ) {\n      result.issues.push(\n        `Not enough examples: need at least ${\n          this.maxBootstrappedDemos + this.maxLabeledDemos\n        }, got ${this.examples.length}`\n      );\n      result.suggestions.push(\n        'Reduce maxBootstrappedDemos or maxLabeledDemos, or provide more examples'\n      );\n    }\n\n    // Check if validation set is reasonable for MiPRO\n    const validationSetSize = this.getValidationSet().length;\n    if (validationSetSize < 5) {\n      result.issues.push(\n        'Validation set too small for reliable MiPRO optimization'\n      );\n      result.suggestions.push(\n        'Provide more examples or a larger validation set'\n      );\n    }\n\n    return {\n      isValid: result.issues.length === 0,\n      issues: result.issues,\n      suggestions: result.suggestions,\n    };\n  }\n\n  /**\n   * Encodes a configuration into a string key for surrogate model lookup\n   */\n  private encodeConfiguration(config: Readonly<ConfigType>): string {\n    return `${config.instruction.length}_${config.bootstrappedDemos}_${config.labeledExamples}`;\n  }\n\n  /**\n   * Updates the surrogate model with a new configuration-score pair\n   */\n  private updateSurrogateModel(\n    config: Readonly<ConfigType>,\n    score: number\n  ): void {\n    this.miproConfigHistory.push({ config: { ...config }, score });\n\n    // Simple Gaussian Process approximation for the surrogate model\n    const key = this.encodeConfiguration(config);\n\n    // Find similar configurations (same instruction length and demo counts)\n    const similarConfigs = this.miproConfigHistory.filter(\n      (entry) => this.encodeConfiguration(entry.config) === key\n    );\n\n    if (similarConfigs.length > 0) {\n      const scores = similarConfigs.map((entry) => entry.score);\n      const mean = scores.reduce((sum, s) => sum + s, 0) / scores.length;\n      const variance =\n        scores.length > 1\n          ? scores.reduce((sum, s) => sum + (s - mean) ** 2, 0) /\n            (scores.length - 1)\n          : 0.1; // Default variance for single observation\n\n      this.surrogateModel.set(key, { mean, variance });\n    }\n  }\n\n  /**\n   * Predicts performance using the surrogate model\n   */\n  private predictPerformance(config: Readonly<ConfigType>): {\n    mean: number;\n    variance: number;\n  } {\n    const key = this.encodeConfiguration(config);\n\n    if (this.surrogateModel.has(key)) {\n      return this.surrogateModel.get(key)!;\n    }\n\n    // For unseen configurations, use prior knowledge\n    if (this.miproConfigHistory.length > 0) {\n      // Find most similar configurations based on demo counts\n      const similarities = this.miproConfigHistory.map((entry) => {\n        const diff =\n          Math.abs(entry.config.bootstrappedDemos - config.bootstrappedDemos) +\n          Math.abs(entry.config.labeledExamples - config.labeledExamples);\n        return { score: entry.score, similarity: 1 / (1 + diff) };\n      });\n\n      // Weighted average based on similarity\n      const totalWeight = similarities.reduce(\n        (sum, s) => sum + s.similarity,\n        0\n      );\n      const weightedMean =\n        similarities.reduce((sum, s) => sum + s.score * s.similarity, 0) /\n        totalWeight;\n\n      return { mean: weightedMean, variance: 0.2 }; // Higher variance for unseen configs\n    }\n\n    // Default prior for completely unknown configurations\n    return { mean: 0.5, variance: 0.3 };\n  }\n\n  /**\n   * Calculates acquisition function value for Bayesian optimization\n   */\n  private calculateAcquisitionValue(config: Readonly<ConfigType>): number {\n    const prediction = this.predictPerformance(config);\n    const { mean, variance } = prediction;\n    const std = Math.sqrt(variance);\n\n    // Current best score\n    const bestScore =\n      this.miproConfigHistory.length > 0\n        ? Math.max(...this.miproConfigHistory.map((entry) => entry.score))\n        : 0;\n\n    switch (this.acquisitionFunction) {\n      case 'expected_improvement': {\n        const improvement = mean - bestScore;\n        if (std === 0) return Math.max(0, improvement);\n\n        const z = improvement / std;\n        const phi = 0.5 * (1 + this.erf(z / Math.sqrt(2))); // CDF of standard normal\n        const pdfValue = Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI); // PDF of standard normal\n\n        return improvement * phi + std * pdfValue;\n      }\n\n      case 'upper_confidence_bound': {\n        return mean + this.explorationWeight * std;\n      }\n\n      case 'probability_improvement': {\n        const improvement = mean - bestScore;\n        if (std === 0) return improvement > 0 ? 1 : 0;\n\n        const z = improvement / std;\n        return 0.5 * (1 + this.erf(z / Math.sqrt(2)));\n      }\n\n      default:\n        return mean;\n    }\n  }\n\n  /**\n   * Error function approximation for acquisition function calculations\n   */\n  private erf(x: number): number {\n    // Abramowitz and Stegun approximation\n    const a1 = 0.254829592;\n    const a2 = -0.284496736;\n    const a3 = 1.421413741;\n    const a4 = -1.453152027;\n    const a5 = 1.061405429;\n    const p = 0.3275911;\n\n    const sign = x >= 0 ? 1 : -1;\n    const absX = Math.abs(x);\n\n    const t = 1.0 / (1.0 + p * absX);\n    const y =\n      1.0 -\n      ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) *\n        t *\n        Math.exp(-absX * absX);\n\n    return sign * y;\n  }\n\n  /**\n   * Selects the next configuration to evaluate using Bayesian optimization\n   */\n  private async selectConfigurationViaBayesianOptimization(\n    instructions: readonly string[],\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): Promise<ConfigType> {\n    const candidates: Array<{ config: ConfigType; acquisitionValue: number }> =\n      [];\n\n    // Generate candidate configurations\n    const numCandidates = Math.min(20, instructions.length * 3); // Reasonable number of candidates\n\n    for (let i = 0; i < numCandidates; i++) {\n      const config: ConfigType = {\n        instruction:\n          instructions[i % instructions.length] || instructions[0] || '',\n        bootstrappedDemos: Math.min(\n          Math.floor(Math.random() * (bootstrappedDemos.length + 1)),\n          this.maxBootstrappedDemos\n        ),\n        labeledExamples: Math.min(\n          Math.floor(Math.random() * (labeledExamples.length + 1)),\n          this.maxLabeledDemos\n        ),\n      };\n\n      const acquisitionValue = this.calculateAcquisitionValue(config);\n      candidates.push({ config, acquisitionValue });\n    }\n\n    // Sort by acquisition value (higher is better)\n    candidates.sort((a, b) => b.acquisitionValue - a.acquisitionValue);\n\n    // Return the most promising configuration\n    return candidates[0]!.config;\n  }\n}\n\n// ---------------------------------------\n// Helper: Majority-vote result picker for self-consistency\n// ---------------------------------------\nconst axMajorityVotePicker = <\n  OUT extends AxGenOut,\n>(): AxResultPickerFunction<OUT> => {\n  // Return a picker function capturing no external state\n  return async (data) => {\n    // If we have field results, do majority vote on stringified payload\n    if (data.type === 'fields') {\n      const counts: Record<string, { count: number; index: number }> = {};\n      for (const { index, sample } of data.results) {\n        const key = JSON.stringify(sample);\n        if (!counts[key]) {\n          counts[key] = { count: 0, index };\n        }\n        counts[key]!.count += 1;\n      }\n\n      // Select the sample with highest count (ties -> first seen)\n      let bestKey: string | undefined;\n      let bestCount = -1;\n      for (const [k, v] of Object.entries(counts)) {\n        if (v.count > bestCount) {\n          bestCount = v.count;\n          bestKey = k;\n        }\n      }\n      return counts[bestKey!]?.index ?? 0;\n    }\n\n    // For function results, fall back to first sample (could be improved)\n    return data.results[0]?.index ?? 0;\n  };\n};\n", "/* eslint-disable @typescript-eslint/no-unused-vars */\n// Added to allow the standard tagged template rest parameters usage.\n\nimport { AxGen, type AxGenerateResult } from './generate.js';\nimport { AxSignature } from './sig.js';\nimport type { AxGenIn, AxGenOut } from './types.js';\n\n// Type for template interpolation values\nexport type AxSignatureTemplateValue =\n  | string\n  | AxFieldType\n  | AxFieldDescriptor\n  | AxSignature;\n\nexport interface AxFieldType {\n  readonly type:\n    | 'string'\n    | 'number'\n    | 'boolean'\n    | 'json'\n    | 'image'\n    | 'audio'\n    | 'date'\n    | 'datetime'\n    | 'class'\n    | 'code';\n  readonly isArray?: boolean;\n  readonly options?: readonly string[];\n  readonly description?: string;\n  readonly isOptional?: boolean;\n  readonly isInternal?: boolean;\n}\n\nexport interface AxFieldDescriptor {\n  readonly name: string;\n  readonly type?: AxFieldType;\n  readonly description?: string;\n  readonly isOptional?: boolean;\n  readonly isInternal?: boolean;\n}\n\n// Main tagged template function for creating signatures\nexport function s(\n  strings: TemplateStringsArray,\n  // eslint-disable-next-line functional/functional-parameters\n  ...values: readonly AxSignatureTemplateValue[]\n): AxSignature {\n  let result = '';\n\n  for (let i = 0; i < strings.length; i++) {\n    // Add the literal part first\n    result += strings[i] ?? '';\n\n    // Then process the value (if any)\n    if (i < values.length) {\n      const val = values[i];\n\n      // When the value is a field type with optional/internal flags we need to add\n      // the markers (?) / (!) on the FIELD NAME (the part just written in result).\n      if (isAxFieldType(val)) {\n        // Detect the last field name before the ':' we just wrote in the literal.\n        // Look for pattern like \"fieldName:\" at the end of result\n        const fieldNameMatch = result.match(/(\\w+)\\s*:\\s*$/);\n        if (fieldNameMatch && (val.isOptional || val.isInternal)) {\n          const fieldName = fieldNameMatch[1];\n          let modifiedFieldName = fieldName;\n\n          // Add markers in the correct order: fieldName?! (optional first, then internal)\n          if (val.isOptional) modifiedFieldName += '?';\n          if (val.isInternal) modifiedFieldName += '!';\n\n          // Replace the field name in the result\n          result = result.replace(/(\\w+)(\\s*:\\s*)$/, `${modifiedFieldName}$2`);\n        }\n\n        // Now append the converted type string (without optional/internal markers)\n\n        const { isOptional: _o, isInternal: _i, ...typeNoFlags } = val;\n        result += convertFieldTypeToString(typeNoFlags);\n      } else if (isAxFieldDescriptor(val)) {\n        result += convertFieldDescriptorToString(val);\n      } else if (typeof val === 'string' || val instanceof AxSignature) {\n        result += convertValueToSignatureString(val);\n      } else {\n        throw new Error('Unsupported template interpolation value');\n      }\n    }\n  }\n\n  return new AxSignature(result);\n}\n\n// Tagged template function that returns AxGen instances\nexport function ax<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenerateResult<AxGenOut> = AxGenerateResult<AxGenOut>,\n>(\n  strings: TemplateStringsArray,\n  // eslint-disable-next-line functional/functional-parameters\n  ...values: readonly AxSignatureTemplateValue[]\n): AxGen<IN, OUT> {\n  let result = '';\n\n  for (let i = 0; i < strings.length; i++) {\n    // Add the literal part first\n    result += strings[i] ?? '';\n\n    // Then process the value (if any)\n    if (i < values.length) {\n      const val = values[i];\n\n      // When the value is a field type with optional/internal flags we need to add\n      // the markers (?) / (!) on the FIELD NAME (the part just written in result).\n      if (isAxFieldType(val)) {\n        // Detect the last field name before the ':' we just wrote in the literal.\n        // Look for pattern like \"fieldName:\" at the end of result\n        const fieldNameMatch = result.match(/(\\w+)\\s*:\\s*$/);\n        if (fieldNameMatch && (val.isOptional || val.isInternal)) {\n          const fieldName = fieldNameMatch[1];\n          let modifiedFieldName = fieldName;\n\n          // Add markers in the correct order: fieldName?! (optional first, then internal)\n          if (val.isOptional) modifiedFieldName += '?';\n          if (val.isInternal) modifiedFieldName += '!';\n\n          // Replace the field name in the result\n          result = result.replace(/(\\w+)(\\s*:\\s*)$/, `${modifiedFieldName}$2`);\n        }\n\n        // Now append the converted type string (without optional/internal markers)\n\n        const { isOptional: _o, isInternal: _i, ...typeNoFlags } = val;\n        result += convertFieldTypeToString(typeNoFlags);\n      } else if (isAxFieldDescriptor(val)) {\n        result += convertFieldDescriptorToString(val);\n      } else if (typeof val === 'string' || val instanceof AxSignature) {\n        result += convertValueToSignatureString(val);\n      } else {\n        throw new Error('Unsupported template interpolation value');\n      }\n    }\n  }\n\n  return new AxGen<IN, OUT>(result);\n}\n\nfunction convertValueToSignatureString(\n  value: AxSignatureTemplateValue\n): string {\n  if (typeof value === 'string') {\n    return value;\n  }\n\n  if (isAxFieldType(value)) {\n    return convertFieldTypeToString(value);\n  }\n\n  if (isAxFieldDescriptor(value)) {\n    return convertFieldDescriptorToString(value);\n  }\n\n  if (value instanceof AxSignature) {\n    // Extract the signature string without description\n    const sigString = value.toString();\n    const arrowIndex = sigString.indexOf(' -> ');\n    if (arrowIndex !== -1) {\n      return sigString.substring(arrowIndex + 4); // Return just the output part\n    }\n    return sigString;\n  }\n\n  throw new Error(`Unsupported template value type: ${typeof value}`);\n}\n\nfunction convertFieldTypeToString(fieldType: Readonly<AxFieldType>): string {\n  let result = fieldType.type;\n\n  // Add array notation\n  if (fieldType.isArray) {\n    result += '[]';\n  }\n\n  // Add options only for class types\n  if (\n    fieldType.options &&\n    fieldType.options.length > 0 &&\n    fieldType.type === 'class'\n  ) {\n    result += ` \"${fieldType.options.join(', ')}\"`;\n  }\n\n  // Add description\n  if (fieldType.description) {\n    result += ` \"${fieldType.description}\"`;\n  }\n\n  return result;\n}\n\nfunction convertFieldDescriptorToString(\n  descriptor: Readonly<AxFieldDescriptor>\n): string {\n  let result = descriptor.name;\n\n  if (descriptor.isOptional) {\n    result += '?';\n  }\n\n  if (descriptor.isInternal) {\n    result += '!';\n  }\n\n  if (descriptor.type) {\n    result += `:${convertFieldTypeToString(descriptor.type)}`;\n  }\n\n  if (descriptor.description && !descriptor.type?.description) {\n    result += ` \"${descriptor.description}\"`;\n  }\n\n  return result;\n}\n\nfunction isAxFieldType(value: unknown): value is AxFieldType {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    value !== undefined &&\n    'type' in value &&\n    typeof (value as Record<string, unknown>).type === 'string'\n  );\n}\n\nfunction isAxFieldDescriptor(value: unknown): value is AxFieldDescriptor {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    value !== undefined &&\n    'name' in value &&\n    typeof (value as Record<string, unknown>).name === 'string'\n  );\n}\n\n// Helper functions for type-safe field creation\nexport const f = {\n  string: (desc?: string): AxFieldType => ({\n    type: 'string',\n    description: desc,\n  }),\n\n  number: (desc?: string): AxFieldType => ({\n    type: 'number',\n    description: desc,\n  }),\n\n  boolean: (desc?: string): AxFieldType => ({\n    type: 'boolean',\n    description: desc,\n  }),\n\n  date: (desc?: string): AxFieldType => ({\n    type: 'date',\n    description: desc,\n  }),\n\n  datetime: (desc?: string): AxFieldType => ({\n    type: 'datetime',\n    description: desc,\n  }),\n\n  json: (desc?: string): AxFieldType => ({\n    type: 'json',\n    description: desc,\n  }),\n\n  image: (desc?: string): AxFieldType => ({\n    type: 'image',\n    description: desc,\n  }),\n\n  audio: (desc?: string): AxFieldType => ({\n    type: 'audio',\n    description: desc,\n  }),\n\n  class: (options: readonly string[], desc?: string): AxFieldType => ({\n    type: 'class',\n    options,\n    description: desc,\n  }),\n\n  code: (language: string, desc?: string): AxFieldType => ({\n    type: 'code',\n    options: [language],\n    description: desc,\n  }),\n\n  array: <T extends AxFieldType>(\n    baseType: T\n  ): T & { readonly isArray: true } => ({\n    ...baseType,\n    isArray: true,\n  }),\n\n  optional: <T extends AxFieldType>(\n    baseType: T\n  ): T & { readonly isOptional: true } => ({\n    ...baseType,\n    isOptional: true,\n  }),\n\n  internal: <T extends AxFieldType>(\n    baseType: T\n  ): T & { readonly isInternal: true } => ({\n    ...baseType,\n    isInternal: true,\n  }),\n};\n\n// Utility function to create field descriptors\nexport function createField(\n  name: string,\n  type?: AxFieldType,\n  options?: Readonly<{\n    description?: string;\n    isOptional?: boolean;\n    isInternal?: boolean;\n  }>\n): AxFieldDescriptor {\n  return {\n    name,\n    type,\n    description: options?.description,\n    isOptional: options?.isOptional,\n    isInternal: options?.isInternal,\n  };\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any, functional/prefer-immutable-types */\nimport type { AxAIService } from '../ai/types.js';\nimport { AxGen } from '../dsp/generate.js';\nimport { AxProgram, type AxProgramForwardOptions } from '../dsp/program.js';\nimport { AxSignature } from '../dsp/sig.js';\nimport type { AxFieldValue, AxGenIn, AxGenOut } from '../dsp/types.js';\n\n// Type for state object that flows through the pipeline\ntype AxFlowState = Record<string, unknown>;\n\n// Type for node definitions in the flow\ninterface AxFlowNodeDefinition {\n  inputs: Record<string, unknown>;\n  outputs: Record<string, unknown>;\n}\n\n// Type for flow step functions\ntype AxFlowStepFunction = (\n  state: AxFlowState,\n  context: Readonly<{\n    mainAi: AxAIService;\n    mainOptions?: AxProgramForwardOptions;\n  }>\n) => Promise<AxFlowState> | AxFlowState;\n\n// Type for dynamic context overrides\ninterface AxFlowDynamicContext {\n  ai?: AxAIService;\n  options?: AxProgramForwardOptions;\n}\n\n// =============================================================================\n// ADVANCED TYPE SYSTEM FOR TYPE-SAFE CHAINING\n// =============================================================================\n\n// Helper type to extract input type from an AxGen instance\ntype GetGenIn<T extends AxGen<AxGenIn, AxGenOut>> = T extends AxGen<\n  infer IN,\n  AxGenOut\n>\n  ? IN\n  : never;\n\n// Helper type to extract output type from an AxGen instance\ntype GetGenOut<T extends AxGen<AxGenIn, AxGenOut>> = T extends AxGen<\n  AxGenIn,\n  infer OUT\n>\n  ? OUT\n  : never;\n\n// Helper type to create an AxGen type from a signature string\n// This is a simplified version - in practice, you'd need more sophisticated parsing\ntype InferAxGen<TSig extends string> = TSig extends string\n  ? AxGen<AxGenIn, AxGenOut>\n  : never;\n\n// Helper type to create result key name from node name\ntype NodeResultKey<TNodeName extends string> = `${TNodeName}Result`;\n\n// Helper type to add node result to state\ntype AddNodeResult<\n  TState extends AxFlowState,\n  TNodeName extends string,\n  TNodeOut extends AxGenOut,\n> = TState & { [K in NodeResultKey<TNodeName>]: TNodeOut };\n\n// =============================================================================\n// TYPED SUB-CONTEXT INTERFACES\n// =============================================================================\n\n// Type for parallel branch functions with typed context\n// NOTE: The `any` here is necessary because we need to support AxGen with any input/output types\ntype AxFlowTypedParallelBranch<\n  TNodes extends Record<string, AxGen<any, any>>,\n  TState extends AxFlowState,\n> = (\n  subFlow: AxFlowTypedSubContext<TNodes, TState>\n) => AxFlowTypedSubContext<TNodes, AxFlowState>;\n\n// Type for typed sub-flow context used in parallel execution\n// NOTE: The `any` here is necessary for the same reason as above\ninterface AxFlowTypedSubContext<\n  TNodes extends Record<string, AxGen<any, any>>,\n  TState extends AxFlowState,\n> {\n  execute<TNodeName extends keyof TNodes & string>(\n    nodeName: TNodeName,\n    mapping: (state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext\n  ): AxFlowTypedSubContext<\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  >;\n\n  map<TNewState extends AxFlowState>(\n    transform: (state: TState) => TNewState\n  ): AxFlowTypedSubContext<TNodes, TNewState>;\n\n  executeSteps(\n    initialState: TState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions;\n    }>\n  ): Promise<AxFlowState>;\n}\n\n// Legacy untyped interfaces for backward compatibility\ntype AxFlowParallelBranch = (subFlow: AxFlowSubContext) => AxFlowSubContext;\n\ninterface AxFlowSubContext {\n  execute(\n    nodeName: string,\n    mapping: (state: AxFlowState) => Record<string, AxFieldValue>,\n    dynamicContext?: AxFlowDynamicContext\n  ): this;\n  map(transform: (state: AxFlowState) => AxFlowState): this;\n  executeSteps(\n    initialState: AxFlowState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions;\n    }>\n  ): Promise<AxFlowState>;\n}\n\n// Type for branch context\ninterface AxFlowBranchContext {\n  predicate: (state: AxFlowState) => unknown;\n  branches: Map<unknown, AxFlowStepFunction[]>;\n  currentBranchValue?: unknown;\n}\n\n// =============================================================================\n// AUTOMATIC DEPENDENCY ANALYSIS AND PARALLELIZATION\n// =============================================================================\n\n// Type for execution step metadata\ninterface AxFlowExecutionStep {\n  type: 'execute' | 'map' | 'other';\n  nodeName?: string;\n  dependencies: string[];\n  produces: string[];\n  stepFunction: AxFlowStepFunction;\n  stepIndex: number;\n}\n\n// Type for parallel execution groups\ninterface AxFlowParallelGroup {\n  level: number;\n  steps: AxFlowExecutionStep[];\n}\n\n// Configuration for automatic parallelization\ninterface AxFlowAutoParallelConfig {\n  enabled: boolean;\n}\n\n/**\n * Analyzes mapping functions to extract state dependencies\n */\nclass AxFlowDependencyAnalyzer {\n  /**\n   * Analyzes a mapping function to determine which state fields it depends on\n   */\n  analyzeMappingDependencies(\n    mapping: (state: any) => any,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _nodeName: string\n  ): string[] {\n    const dependencies: string[] = [];\n\n    // Method 1: Static analysis of function source\n    const source = mapping.toString();\n    const stateAccessMatches = Array.from(source.matchAll(/state\\.(\\w+)/g));\n    for (const match of stateAccessMatches) {\n      if (match[1] && !dependencies.includes(match[1])) {\n        dependencies.push(match[1]);\n      }\n    }\n\n    // Method 2: Proxy-based tracking (fallback for complex cases)\n    if (dependencies.length === 0) {\n      try {\n        const tracker = this.createDependencyTracker(dependencies);\n        mapping(tracker);\n      } catch {\n        // Expected - we're just tracking access patterns\n      }\n    }\n\n    return dependencies;\n  }\n\n  private createDependencyTracker(dependencies: string[]): any {\n    return new Proxy(\n      {},\n      {\n        get(_target, prop) {\n          if (typeof prop === 'string' && !dependencies.includes(prop)) {\n            dependencies.push(prop);\n          }\n          // Return another proxy for nested access\n          return new Proxy(\n            {},\n            {\n              get: () => undefined,\n            }\n          );\n        },\n      }\n    );\n  }\n}\n\n/**\n * Builds and manages the execution plan with automatic parallelization\n */\nclass AxFlowExecutionPlanner {\n  private steps: AxFlowExecutionStep[] = [];\n  private parallelGroups: AxFlowParallelGroup[] = [];\n  private readonly analyzer = new AxFlowDependencyAnalyzer();\n  private initialFields: Set<string> = new Set();\n\n  /**\n   * Adds an execution step to the plan\n   */\n  addExecutionStep(\n    stepFunction: AxFlowStepFunction,\n    nodeName?: string,\n    mapping?: (state: any) => any\n  ): void {\n    let dependencies: string[] = [];\n    let produces: string[] = [];\n    let type: 'execute' | 'map' | 'other' = 'other';\n\n    if (nodeName && mapping) {\n      type = 'execute';\n      dependencies = this.analyzer.analyzeMappingDependencies(\n        mapping,\n        nodeName\n      );\n      produces = [`${nodeName}Result`];\n    } else if (stepFunction.toString().includes('transform(')) {\n      type = 'map';\n      // Map steps are harder to analyze statically, assume they depend on all previous steps\n      dependencies = this.getAllProducedFields();\n    }\n\n    const step: AxFlowExecutionStep = {\n      type,\n      nodeName,\n      dependencies,\n      produces,\n      stepFunction,\n      stepIndex: this.steps.length,\n    };\n\n    this.steps.push(step);\n    // Don't rebuild parallel groups during construction - only after initial fields are set\n    // this.rebuildParallelGroups()\n  }\n\n  /**\n   * Sets the initial fields and rebuilds parallel groups\n   */\n  setInitialFields(fields: string[]): void {\n    this.initialFields = new Set(fields);\n    this.rebuildParallelGroups();\n  }\n\n  /**\n   * Rebuilds the parallel execution groups based on dependencies\n   */\n  private rebuildParallelGroups(): void {\n    this.parallelGroups = [];\n    const processedSteps = new Set<number>();\n    const availableFields = new Set<string>(this.initialFields);\n    let currentLevel = 0;\n\n    while (processedSteps.size < this.steps.length) {\n      const currentLevelSteps: AxFlowExecutionStep[] = [];\n\n      // Find all steps that can run at this level\n      for (const step of this.steps) {\n        if (processedSteps.has(step.stepIndex)) continue;\n\n        // Check if all dependencies are available\n        const canRun =\n          step.dependencies.length === 0 ||\n          step.dependencies.every((dep) => availableFields.has(dep));\n\n        if (canRun) {\n          currentLevelSteps.push(step);\n          processedSteps.add(step.stepIndex);\n        }\n      }\n\n      if (currentLevelSteps.length > 0) {\n        // Add all produced fields from this level to available fields\n        for (const step of currentLevelSteps) {\n          step.produces.forEach((field) => availableFields.add(field));\n        }\n\n        this.parallelGroups.push({\n          level: currentLevel,\n          steps: currentLevelSteps,\n        });\n        currentLevel++;\n      } else {\n        // No progress made - break to avoid infinite loop\n        break;\n      }\n    }\n  }\n\n  /**\n   * Gets all fields produced by previous steps\n   */\n  private getAllProducedFields(): string[] {\n    const fields: string[] = [];\n    for (const step of this.steps) {\n      fields.push(...step.produces);\n    }\n    return fields;\n  }\n\n  /**\n   * Creates optimized execution function\n   */\n  createOptimizedExecution(): AxFlowStepFunction[] {\n    const optimizedSteps: AxFlowStepFunction[] = [];\n\n    for (const group of this.parallelGroups) {\n      if (group.steps.length === 1) {\n        // Single step - execute directly\n        const step = group.steps[0];\n        if (step) {\n          optimizedSteps.push(step.stepFunction);\n        }\n      } else if (group.steps.length > 1) {\n        // Multiple steps - execute in parallel\n        const parallelStep: AxFlowStepFunction = async (state, context) => {\n          const promises = group.steps.map((step) =>\n            step.stepFunction(state, context)\n          );\n\n          const results = await Promise.all(promises);\n\n          // Merge all results\n          let mergedState = state;\n          for (const result of results) {\n            mergedState = { ...mergedState, ...result };\n          }\n\n          return mergedState;\n        };\n\n        optimizedSteps.push(parallelStep);\n      }\n    }\n\n    return optimizedSteps;\n  }\n\n  /**\n   * Gets execution plan info for debugging\n   */\n  getExecutionPlan(): {\n    totalSteps: number;\n    parallelGroups: number;\n    maxParallelism: number;\n    steps: AxFlowExecutionStep[];\n    groups: AxFlowParallelGroup[];\n  } {\n    return {\n      totalSteps: this.steps.length,\n      parallelGroups: this.parallelGroups.length,\n      maxParallelism: Math.max(\n        ...this.parallelGroups.map((g) => g.steps.length),\n        0\n      ),\n      steps: this.steps,\n      groups: this.parallelGroups,\n    };\n  }\n}\n\n/**\n * AxFlow - A fluent, chainable API for building and orchestrating complex, stateful AI programs.\n *\n * Now with advanced type-safe chaining where each method call evolves the type information,\n * providing compile-time type safety and superior IntelliSense.\n *\n * @example\n * ```typescript\n * const flow = new AxFlow<{ topic: string }, { finalAnswer: string }>()\n *   .node('summarizer', 'text:string -> summary:string')\n *   .node('critic', 'summary:string -> critique:string')\n *   .execute('summarizer', state => ({ text: `About ${state.topic}` })) // state is { topic: string }\n *   .execute('critic', state => ({ summary: state.summarizerResult.summary })) // state evolves!\n *   .map(state => ({ finalAnswer: state.criticResult.critique })) // fully typed!\n *\n * const result = await flow.forward(ai, { topic: \"AI safety\" })\n * ```\n */\nexport class AxFlow<\n  IN extends AxGenIn,\n  OUT extends AxGenOut,\n  // NOTE: The `any` here is necessary because TNodes must accommodate AxGen instances with various input/output types\n  TNodes extends Record<string, AxGen<any, any>> = Record<string, never>, // Node registry for type tracking\n  TState extends AxFlowState = IN, // Current evolving state type\n> extends AxProgram<IN, OUT> {\n  private readonly nodes: Map<string, AxFlowNodeDefinition> = new Map();\n  private readonly flowDefinition: AxFlowStepFunction[] = [];\n  private readonly nodeGenerators: Map<\n    string,\n    AxGen<AxGenIn, AxGenOut> | AxProgram<AxGenIn, AxGenOut>\n  > = new Map();\n  private readonly loopStack: number[] = [];\n  private readonly stepLabels: Map<string, number> = new Map();\n  private branchContext: AxFlowBranchContext | null = null;\n\n  // Automatic parallelization components\n  private readonly autoParallelConfig: AxFlowAutoParallelConfig;\n  private readonly executionPlanner = new AxFlowExecutionPlanner();\n\n  constructor(\n    signature: NonNullable<\n      ConstructorParameters<typeof AxSignature>[0]\n    > = 'userInput:string -> flowOutput:string',\n    options?: {\n      autoParallel?: boolean;\n    }\n  ) {\n    super(signature);\n    this.autoParallelConfig = {\n      enabled: options?.autoParallel !== false, // Default to true\n    };\n  }\n\n  /**\n   * Declares a reusable computational node using a signature string.\n   * Returns a new AxFlow type that tracks this node in the TNodes registry.\n   *\n   * @param name - The name of the node\n   * @param signature - Signature string in the same format as AxSignature\n   * @param options - Optional program forward options (same as AxGen)\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```typescript\n   * flow.node('summarizer', 'text:string -> summary:string')\n   * flow.node('analyzer', 'text:string -> analysis:string, confidence:number', { debug: true })\n   * ```\n   */\n  public node<TName extends string, TSig extends string>(\n    name: TName,\n    signature: TSig,\n    options?: Readonly<AxProgramForwardOptions>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: InferAxGen<TSig> }, // Add new node to registry\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using an AxSignature instance.\n   * This allows using pre-configured signatures in the flow.\n   *\n   * @param name - The name of the node\n   * @param signature - AxSignature instance to use for this node\n   * @param options - Optional program forward options (same as AxGen)\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```typescript\n   * const sig = new AxSignature('text:string -> summary:string')\n   * flow.node('summarizer', sig, { temperature: 0.1 })\n   * ```\n   */\n  public node<TName extends string>(\n    name: TName,\n    signature: AxSignature,\n    options?: Readonly<AxProgramForwardOptions>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> }, // Add new node to registry\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using an existing AxGen instance.\n   * This allows reusing pre-configured generators in the flow.\n   *\n   * @param name - The name of the node\n   * @param axgenInstance - Existing AxGen instance to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```typescript\n   * const summarizer = new AxGen('text:string -> summary:string', { temperature: 0.1 })\n   * flow.node('summarizer', summarizer)\n   * ```\n   */\n  public node<TName extends string, TGen extends AxGen<any, any>>(\n    name: TName,\n    axgenInstance: TGen\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: TGen }, // Add new node to registry with exact type\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using a class that extends AxProgram.\n   * This allows using custom program classes in the flow.\n   *\n   * @param name - The name of the node\n   * @param programClass - Class that extends AxProgram to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```typescript\n   * class CustomProgram extends AxProgram<{ input: string }, { output: string }> {\n   *   async forward(ai, values) { return { output: values.input.toUpperCase() } }\n   * }\n   * flow.node('custom', CustomProgram)\n   * ```\n   */\n  public node<\n    TName extends string,\n    TProgram extends new () => AxProgram<any, any>,\n  >(\n    name: TName,\n    programClass: TProgram\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: InstanceType<TProgram> }, // Add new node to registry with exact type\n    TState // State unchanged\n  >;\n\n  // Implementation\n  public node<TName extends string>(\n    name: TName,\n    signatureOrAxGenOrClass:\n      | string\n      | AxSignature\n      | AxGen<any, any>\n      | (new () => AxProgram<any, any>),\n    options?: Readonly<AxProgramForwardOptions>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: any }, // Using any here as the implementation handles all cases\n    TState\n  > {\n    if (signatureOrAxGenOrClass instanceof AxGen) {\n      // Using existing AxGen instance\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Store the existing AxGen instance\n      this.nodeGenerators.set(\n        name,\n        signatureOrAxGenOrClass as AxGen<AxGenIn, AxGenOut>\n      );\n    } else if (signatureOrAxGenOrClass instanceof AxSignature) {\n      // Using AxSignature instance\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Create and store the AxGen instance for this node using the signature\n      this.nodeGenerators.set(\n        name,\n        new AxGen(signatureOrAxGenOrClass, options)\n      );\n    } else if (\n      typeof signatureOrAxGenOrClass === 'function' &&\n      signatureOrAxGenOrClass.prototype instanceof AxProgram\n    ) {\n      // Using a class that extends AxProgram\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Create an instance of the program class and store it directly\n      const programInstance = new signatureOrAxGenOrClass();\n      this.nodeGenerators.set(name, programInstance);\n    } else if (typeof signatureOrAxGenOrClass === 'string') {\n      // Using signature string (original behavior)\n      const signature = signatureOrAxGenOrClass;\n\n      // Validate that signature is provided\n      if (!signature) {\n        throw new Error(\n          `Invalid signature for node '${name}': signature cannot be empty`\n        );\n      }\n\n      // Store node definition (simplified since we're using standard signatures)\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Create and store the AxGen instance for this node with the same arguments as AxGen\n      this.nodeGenerators.set(name, new AxGen(signature, options));\n    } else {\n      throw new Error(\n        `Invalid second argument for node '${name}': expected string, AxSignature, AxGen instance, or class extending AxProgram`\n      );\n    }\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    // The runtime value is the same object, but TypeScript can't track the evolving generic types\n    return this as any;\n  }\n\n  /**\n   * Short alias for node() - supports signature strings, AxSignature instances, AxGen instances, and program classes\n   */\n  public n<TName extends string, TSig extends string>(\n    name: TName,\n    signature: TSig,\n    options?: Readonly<AxProgramForwardOptions>\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: InferAxGen<TSig> }, TState>;\n\n  public n<TName extends string>(\n    name: TName,\n    signature: AxSignature,\n    options?: Readonly<AxProgramForwardOptions>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> },\n    TState\n  >;\n\n  public n<TName extends string, TGen extends AxGen<any, any>>(\n    name: TName,\n    axgenInstance: TGen\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: TGen }, TState>;\n\n  public n<\n    TName extends string,\n    TProgram extends new () => AxProgram<any, any>,\n  >(\n    name: TName,\n    programClass: TProgram\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: InstanceType<TProgram> }, TState>;\n\n  public n<TName extends string>(\n    name: TName,\n    signatureOrAxGenOrClass:\n      | string\n      | AxSignature\n      | AxGen<any, any>\n      | (new () => AxProgram<any, any>),\n    options?: Readonly<AxProgramForwardOptions>\n  ): any {\n    return this.node(name, signatureOrAxGenOrClass as any, options);\n  }\n\n  /**\n   * Applies a synchronous transformation to the state object.\n   * Returns a new AxFlow type with the evolved state.\n   *\n   * @param transform - Function that takes the current state and returns a new state\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```typescript\n   * flow.map(state => ({ ...state, processedText: state.text.toLowerCase() }))\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transform: (state: TState) => TNewState\n  ): AxFlow<IN, OUT, TNodes, TNewState> {\n    const step = (state: AxFlowState) => {\n      return transform(state as TState);\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      // We're inside a branch - add to current branch\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      // Normal execution - add to main flow\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(step);\n      }\n    }\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as unknown as AxFlow<IN, OUT, TNodes, TNewState>;\n  }\n\n  /**\n   * Short alias for map()\n   */\n  public m<TNewState extends AxFlowState>(\n    transform: (state: TState) => TNewState\n  ): AxFlow<IN, OUT, TNodes, TNewState> {\n    return this.map(transform);\n  }\n\n  /**\n   * Labels a step for later reference (useful for feedback loops).\n   *\n   * @param label - The label to assign to the current step position\n   * @returns this (for chaining, no type change)\n   *\n   * @example\n   * ```typescript\n   * flow.label('retry-point')\n   *   .execute('queryGen', ...)\n   * ```\n   */\n  public label(label: string): this {\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      throw new Error('Cannot create labels inside branch blocks');\n    }\n    this.stepLabels.set(label, this.flowDefinition.length);\n    return this;\n  }\n\n  /**\n   * Short alias for label()\n   */\n  public l(label: string): this {\n    return this.label(label);\n  }\n\n  /**\n   * Executes a previously defined node with full type safety.\n   * The node name must exist in TNodes, and the mapping function is typed based on the node's signature.\n   *\n   * @param nodeName - The name of the node to execute (must exist in TNodes)\n   * @param mapping - Typed function that takes the current state and returns the input for the node\n   * @param dynamicContext - Optional object to override the AI service or options for this specific step\n   * @returns New AxFlow instance with TState augmented with the node's result\n   *\n   * @example\n   * ```typescript\n   * flow.execute('summarizer', state => ({ text: state.originalText }), { ai: cheapAI })\n   * ```\n   */\n  public execute<TNodeName extends keyof TNodes & string>(\n    nodeName: TNodeName,\n    mapping: (state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    if (!this.nodes.has(nodeName)) {\n      throw new Error(\n        `Node '${nodeName}' not found. Make sure to define it with .node() first.`\n      );\n    }\n\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    const step = async (\n      state: AxFlowState,\n      context: Readonly<{\n        mainAi: AxAIService;\n        mainOptions?: AxProgramForwardOptions;\n      }>\n    ) => {\n      // Determine AI service and options using fallback logic\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n\n      // Map the state to node inputs (with type safety)\n      const nodeInputs = mapping(state as TState);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      const result = await nodeProgram.forward(ai, nodeInputs, {\n        ...options,\n        traceLabel,\n      });\n\n      // Merge result back into state under a key like `${nodeName}Result`\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      // We're inside a branch - add to current branch\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      // Normal execution - add to main flow\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(step, nodeName, mapping);\n      }\n    }\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as AxFlow<\n      IN,\n      OUT,\n      TNodes,\n      AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n    >;\n  }\n\n  /**\n   * Short alias for execute()\n   */\n  public e<TNodeName extends keyof TNodes & string>(\n    nodeName: TNodeName,\n    mapping: (state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    return this.execute(nodeName, mapping, dynamicContext);\n  }\n\n  /**\n   * Starts a conditional branch based on a predicate function.\n   *\n   * @param predicate - Function that takes state and returns a value to branch on\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.branch(state => state.qualityResult.needsMoreInfo)\n   *   .when(true)\n   *     .execute('queryGen', ...)\n   *   .when(false)\n   *     .execute('answer', ...)\n   *   .merge()\n   * ```\n   */\n  public branch(predicate: (state: TState) => unknown): this {\n    if (this.branchContext) {\n      throw new Error('Nested branches are not supported');\n    }\n\n    this.branchContext = {\n      predicate: (state: AxFlowState) => predicate(state as TState),\n      branches: new Map(),\n      currentBranchValue: undefined,\n    };\n\n    return this;\n  }\n\n  /**\n   * Short alias for branch()\n   */\n  public b(predicate: (state: TState) => unknown): this {\n    return this.branch(predicate);\n  }\n\n  /**\n   * Defines a branch case for the current branch context.\n   *\n   * @param value - The value to match against the branch predicate result\n   * @returns this (for chaining)\n   */\n  public when(value: unknown): this {\n    if (!this.branchContext) {\n      throw new Error('when() called without matching branch()');\n    }\n\n    this.branchContext.currentBranchValue = value;\n    this.branchContext.branches.set(value, []);\n\n    return this;\n  }\n\n  /**\n   * Short alias for when()\n   */\n  public w(value: unknown): this {\n    return this.when(value);\n  }\n\n  /**\n   * Ends the current branch and merges all branch paths back into the main flow.\n   * Optionally specify the explicit merged state type for better type safety.\n   *\n   * @param explicitMergedType - Optional type hint for the merged state (defaults to current TState)\n   * @returns AxFlow instance with the merged state type\n   *\n   * @example\n   * ```typescript\n   * // Default behavior - preserves current TState\n   * flow.branch(state => state.type)\n   *   .when('simple').execute('simpleProcessor', ...)\n   *   .when('complex').execute('complexProcessor', ...)\n   *   .merge()\n   *\n   * // Explicit type - specify exact merged state shape\n   * flow.branch(state => state.type)\n   *   .when('simple').map(state => ({ result: state.simpleResult, method: 'simple' }))\n   *   .when('complex').map(state => ({ result: state.complexResult, method: 'complex' }))\n   *   .merge<{ result: string; method: string }>()\n   * ```\n   */\n  public merge<TMergedState extends AxFlowState = TState>(): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    TMergedState\n  > {\n    if (!this.branchContext) {\n      throw new Error('merge() called without matching branch()');\n    }\n\n    const branchContext = this.branchContext;\n    this.branchContext = null;\n\n    // Add the branch execution step to main flow\n    this.flowDefinition.push(async (state, context) => {\n      const branchValue = branchContext.predicate(state);\n      const branchSteps = branchContext.branches.get(branchValue);\n\n      if (!branchSteps) {\n        // No matching branch - return state unchanged\n        return state;\n      }\n\n      // Execute all steps in the matched branch\n      let currentState = state;\n      for (const step of branchSteps) {\n        currentState = await step(currentState, context);\n      }\n\n      return currentState;\n    });\n\n    // Cast `this` to preserve runtime object while updating compile-time type information.\n    return this as unknown as AxFlow<IN, OUT, TNodes, TMergedState>;\n  }\n\n  /**\n   * Short alias for merge()\n   */\n  public mg<TMergedState extends AxFlowState = TState>(): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    TMergedState\n  > {\n    return this.merge<TMergedState>();\n  }\n\n  /**\n   * Executes multiple operations in parallel and merges their results.\n   * Both typed and legacy untyped branches are supported.\n   *\n   * @param branches - Array of functions that define parallel operations\n   * @returns Object with merge method for combining results\n   *\n   * @example\n   * ```typescript\n   * flow.parallel([\n   *   subFlow => subFlow.execute('retrieve1', state => ({ query: state.query1 })),\n   *   subFlow => subFlow.execute('retrieve2', state => ({ query: state.query2 })),\n   *   subFlow => subFlow.execute('retrieve3', state => ({ query: state.query3 }))\n   * ]).merge('documents', (docs1, docs2, docs3) => [...docs1, ...docs2, ...docs3])\n   * ```\n   */\n  public parallel(\n    branches: (\n      | AxFlowParallelBranch\n      | AxFlowTypedParallelBranch<TNodes, TState>\n    )[]\n  ): {\n    merge<T, TResultKey extends string>(\n      resultKey: TResultKey,\n      mergeFunction: (...results: unknown[]) => T\n    ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }>;\n  } {\n    const parallelStep = async (\n      state: AxFlowState,\n      context: Readonly<{\n        mainAi: AxAIService;\n        mainOptions?: AxProgramForwardOptions;\n      }>\n    ) => {\n      // Execute all branches in parallel\n      const promises = branches.map(async (branchFn) => {\n        // Create a sub-context for this branch\n        const subContext = new AxFlowSubContextImpl(this.nodeGenerators);\n        // NOTE: Type assertion needed here because we support both typed and untyped branch functions\n        const populatedSubContext = branchFn(\n          subContext as AxFlowSubContext & AxFlowTypedSubContext<TNodes, TState>\n        );\n\n        // Execute the sub-context steps\n        return await populatedSubContext.executeSteps(state, context);\n      });\n\n      const results = await Promise.all(promises);\n\n      // Store results for merging\n      return {\n        ...state,\n        _parallelResults: results,\n      };\n    };\n\n    this.flowDefinition.push(parallelStep);\n\n    return {\n      merge: <T, TResultKey extends string>(\n        resultKey: TResultKey,\n        mergeFunction: (...results: unknown[]) => T\n      ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }> => {\n        this.flowDefinition.push((state) => {\n          const results = state._parallelResults;\n          if (!Array.isArray(results)) {\n            throw new Error('No parallel results found for merge');\n          }\n\n          const mergedValue = mergeFunction(...results);\n          const newState = { ...state };\n          newState._parallelResults = undefined;\n          newState[resultKey] = mergedValue;\n\n          return newState;\n        });\n\n        // NOTE: This type assertion is necessary for the type-level programming pattern\n        return this as AxFlow<\n          IN,\n          OUT,\n          TNodes,\n          TState & { [K in TResultKey]: T }\n        >;\n      },\n    };\n  }\n\n  /**\n   * Short alias for parallel()\n   */\n  public p(\n    branches: (\n      | AxFlowParallelBranch\n      | AxFlowTypedParallelBranch<TNodes, TState>\n    )[]\n  ): {\n    merge<T, TResultKey extends string>(\n      resultKey: TResultKey,\n      mergeFunction: (...results: unknown[]) => T\n    ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }>;\n  } {\n    return this.parallel(branches);\n  }\n\n  /**\n   * Creates a feedback loop that jumps back to a labeled step if a condition is met.\n   *\n   * @param condition - Function that returns true to trigger the feedback loop\n   * @param targetLabel - The label to jump back to\n   * @param maxIterations - Maximum number of iterations to prevent infinite loops (default: 10)\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.label('retry-point')\n   *   .execute('answer', ...)\n   *   .execute('qualityCheck', ...)\n   *   .feedback(state => state.qualityCheckResult.confidence < 0.7, 'retry-point')\n   * ```\n   */\n  public feedback(\n    condition: (state: TState) => boolean,\n    targetLabel: string,\n    maxIterations = 10\n  ): this {\n    if (!this.stepLabels.has(targetLabel)) {\n      throw new Error(\n        `Label '${targetLabel}' not found. Make sure to define it with .label() before the feedback point.`\n      );\n    }\n\n    const targetIndex = this.stepLabels.get(targetLabel)!;\n\n    // Capture the current flow definition length before adding the feedback step\n    // This prevents the feedback step from executing itself recursively\n    const feedbackStepIndex = this.flowDefinition.length;\n\n    this.flowDefinition.push(async (state, context) => {\n      let currentState = state;\n      let iterations = 1; // Start at 1 since we've already executed once before reaching feedback\n\n      // Add iteration tracking to state if not present\n      const iterationKey = `_feedback_${targetLabel}_iterations`;\n      if (typeof currentState[iterationKey] !== 'number') {\n        currentState = { ...currentState, [iterationKey]: 1 }; // Initial execution counts as iteration 1\n      }\n\n      // Check if we should loop back (iterations < maxIterations since initial execution counts as 1)\n      while (condition(currentState as TState) && iterations < maxIterations) {\n        iterations++;\n        currentState = { ...currentState, [iterationKey]: iterations };\n\n        // Execute steps from target index to just before the feedback step\n        // Use feedbackStepIndex to avoid including the feedback step itself\n        for (let i = targetIndex; i < feedbackStepIndex; i++) {\n          const step = this.flowDefinition[i];\n          if (step) {\n            currentState = await step(currentState, context);\n          }\n        }\n      }\n\n      return currentState;\n    });\n\n    return this;\n  }\n\n  /**\n   * Short alias for feedback()\n   */\n  public fb(\n    condition: (state: TState) => boolean,\n    targetLabel: string,\n    maxIterations = 10\n  ): this {\n    return this.feedback(condition, targetLabel, maxIterations);\n  }\n\n  /**\n   * Marks the beginning of a loop block.\n   *\n   * @param condition - Function that takes the current state and returns a boolean\n   * @param maxIterations - Maximum number of iterations to prevent infinite loops (default: 100)\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.while(state => state.iterations < 3, 10)\n   *   .map(state => ({ ...state, iterations: (state.iterations || 0) + 1 }))\n   *   .endWhile()\n   * ```\n   */\n  public while(\n    condition: (state: TState) => boolean,\n    maxIterations = 100\n  ): this {\n    // Store the condition and mark the start of the loop\n    const loopStartIndex = this.flowDefinition.length;\n    this.loopStack.push(loopStartIndex);\n\n    // Add a placeholder step that will be replaced in endWhile()\n    // We store the condition and maxIterations in the placeholder for later use\n    interface LoopPlaceholder extends AxFlowStepFunction {\n      _condition: (state: TState) => boolean;\n      _maxIterations: number;\n      _isLoopStart: boolean;\n    }\n\n    const placeholderStep: LoopPlaceholder = Object.assign(\n      (state: AxFlowState) => state,\n      {\n        _condition: condition,\n        _maxIterations: maxIterations,\n        _isLoopStart: true,\n      }\n    );\n\n    this.flowDefinition.push(placeholderStep);\n\n    return this;\n  }\n\n  /**\n   * Short alias for while()\n   */\n  public wh(condition: (state: TState) => boolean, maxIterations = 100): this {\n    return this.while(condition, maxIterations);\n  }\n\n  /**\n   * Marks the end of a loop block.\n   *\n   * @returns this (for chaining)\n   */\n  public endWhile(): this {\n    if (this.loopStack.length === 0) {\n      throw new Error('endWhile() called without matching while()');\n    }\n\n    const loopStartIndex = this.loopStack.pop()!;\n\n    // Get the condition from the placeholder step\n    const placeholderStep = this.flowDefinition[loopStartIndex];\n    if (!placeholderStep || !('_isLoopStart' in placeholderStep)) {\n      throw new Error('Loop start step not found or invalid');\n    }\n\n    const condition = (\n      placeholderStep as unknown as {\n        _condition: (state: TState) => boolean;\n        _maxIterations: number;\n      }\n    )._condition;\n\n    const maxIterations = (\n      placeholderStep as unknown as {\n        _condition: (state: TState) => boolean;\n        _maxIterations: number;\n      }\n    )._maxIterations;\n\n    // Extract the loop body steps (everything between while and endWhile)\n    const loopBodySteps = this.flowDefinition.splice(loopStartIndex + 1);\n\n    // Replace the placeholder with the actual loop implementation\n    this.flowDefinition[loopStartIndex] = async (state, context) => {\n      let currentState = state;\n      let iterations = 0;\n\n      // Execute the loop while condition is true and within iteration limit\n      while (condition(currentState as TState) && iterations < maxIterations) {\n        iterations++;\n\n        // Execute all steps in the loop body\n        for (const step of loopBodySteps) {\n          currentState = await step(currentState, context);\n        }\n      }\n\n      // Check if we exceeded the maximum iterations\n      if (iterations >= maxIterations && condition(currentState as TState)) {\n        throw new Error(\n          `While loop exceeded maximum iterations (${maxIterations}). Consider increasing maxIterations or ensuring the loop condition eventually becomes false.`\n        );\n      }\n\n      return currentState;\n    };\n\n    return this;\n  }\n\n  /**\n   * Short alias for endWhile()\n   */\n  public end(): this {\n    return this.endWhile();\n  }\n\n  /**\n   * Executes the flow with the given AI service and input values.\n   *\n   * @param ai - The AI service to use as the default for all steps\n   * @param values - The input values for the flow\n   * @param options - Optional forward options to use as defaults (includes autoParallel override)\n   * @returns Promise that resolves to the final output\n   */\n  public override async forward(\n    ai: Readonly<AxAIService>,\n    values: IN,\n    options?: Readonly<AxProgramForwardOptions & { autoParallel?: boolean }>\n  ): Promise<OUT> {\n    // Initialize state with input values\n    let state: AxFlowState = { ...values };\n\n    // Create context object\n    const context = {\n      mainAi: ai,\n      mainOptions: options,\n    } as const;\n\n    // Determine if auto-parallel should be used\n    const useAutoParallel =\n      options?.autoParallel !== false && this.autoParallelConfig.enabled;\n\n    if (useAutoParallel) {\n      // Set initial fields for dependency analysis\n      this.executionPlanner.setInitialFields(Object.keys(values));\n\n      // Use optimized execution with automatic parallelization\n      const optimizedSteps = this.executionPlanner.createOptimizedExecution();\n      for (const step of optimizedSteps) {\n        state = await step(state, context);\n      }\n    } else {\n      // Use original sequential execution\n      for (const step of this.flowDefinition) {\n        state = await step(state, context);\n      }\n    }\n\n    // Return the final state cast to OUT type\n    return state as unknown as OUT;\n  }\n\n  /**\n   * Gets execution plan information for debugging automatic parallelization\n   *\n   * @returns Object with execution plan details\n   */\n  public getExecutionPlan(): {\n    totalSteps: number;\n    parallelGroups: number;\n    maxParallelism: number;\n    autoParallelEnabled: boolean;\n    steps?: AxFlowExecutionStep[];\n    groups?: AxFlowParallelGroup[];\n  } {\n    const planInfo = this.executionPlanner.getExecutionPlan();\n    return {\n      totalSteps: planInfo.totalSteps,\n      parallelGroups: planInfo.parallelGroups,\n      maxParallelism: planInfo.maxParallelism,\n      autoParallelEnabled: this.autoParallelConfig.enabled,\n      steps: planInfo.steps,\n      groups: planInfo.groups,\n    };\n  }\n}\n\n/**\n * Implementation of the sub-context for parallel execution\n */\nclass AxFlowSubContextImpl implements AxFlowSubContext {\n  private readonly steps: AxFlowStepFunction[] = [];\n\n  constructor(\n    private readonly nodeGenerators: Map<\n      string,\n      AxGen<AxGenIn, AxGenOut> | AxProgram<AxGenIn, AxGenOut>\n    >\n  ) {}\n\n  execute(\n    nodeName: string,\n    mapping: (state: AxFlowState) => Record<string, AxFieldValue>,\n    dynamicContext?: AxFlowDynamicContext\n  ): this {\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    this.steps.push(async (state, context) => {\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n      const nodeInputs = mapping(state);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      const result = await nodeProgram.forward(ai, nodeInputs, {\n        ...options,\n        traceLabel,\n      });\n\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    });\n\n    return this;\n  }\n\n  map(transform: (state: AxFlowState) => AxFlowState): this {\n    this.steps.push((state) => transform(state));\n    return this;\n  }\n\n  async executeSteps(\n    initialState: AxFlowState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions;\n    }>\n  ): Promise<AxFlowState> {\n    let currentState = initialState;\n\n    for (const step of this.steps) {\n      currentState = await step(currentState, context);\n    }\n\n    return currentState;\n  }\n}\n\n/**\n * Typed implementation of the sub-context for parallel execution with full type safety\n */\n// This class is used by the type system but not directly instantiated in this file\n// NOTE: The `any` here is necessary for the same reason as in the interfaces above\nexport class AxFlowTypedSubContextImpl<\n  TNodes extends Record<string, AxGen<any, any>>,\n  TState extends AxFlowState,\n> implements AxFlowTypedSubContext<TNodes, TState>\n{\n  private readonly steps: AxFlowStepFunction[] = [];\n\n  constructor(\n    private readonly nodeGenerators: Map<\n      string,\n      AxGen<AxGenIn, AxGenOut> | AxProgram<AxGenIn, AxGenOut>\n    >\n  ) {}\n\n  execute<TNodeName extends keyof TNodes & string>(\n    nodeName: TNodeName,\n    mapping: (state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext\n  ): AxFlowTypedSubContext<\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    this.steps.push(async (state, context) => {\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n      const nodeInputs = mapping(state as TState);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      const result = await nodeProgram.forward(ai, nodeInputs, {\n        ...options,\n        traceLabel,\n      });\n\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    });\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as AxFlowTypedSubContext<\n      TNodes,\n      AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n    >;\n  }\n\n  map<TNewState extends AxFlowState>(\n    transform: (state: TState) => TNewState\n  ): AxFlowTypedSubContext<TNodes, TNewState> {\n    this.steps.push((state) => transform(state as TState));\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as unknown as AxFlowTypedSubContext<TNodes, TNewState>;\n  }\n\n  async executeSteps(\n    initialState: TState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions;\n    }>\n  ): Promise<AxFlowState> {\n    let currentState: AxFlowState = initialState;\n\n    for (const step of this.steps) {\n      currentState = await step(currentState, context);\n    }\n\n    return currentState;\n  }\n}\n", "import type { AxFunction } from '../ai/types.js';\n\nexport interface AxDockerContainer {\n  Id: string;\n  Names: string[];\n  Image: string;\n  ImageID: string;\n  Command: string;\n  Created: number;\n  State: {\n    Status: string;\n    Running: boolean;\n    Paused: boolean;\n    Restarting: boolean;\n    OOMKilled: boolean;\n    Dead: boolean;\n    Pid: number;\n    ExitCode: number;\n    Error: string;\n    StartedAt: Date;\n    FinishedAt: Date;\n  };\n  Status: string;\n  Ports: Array<{\n    IP: string;\n    PrivatePort: number;\n    PublicPort: number;\n    Type: string;\n  }>;\n  Labels: { [key: string]: string };\n  SizeRw: number;\n  SizeRootFs: number;\n  HostConfig: {\n    NetworkMode: string;\n  };\n  NetworkSettings: {\n    Networks: {\n      [key: string]: {\n        IPAddress: string;\n        IPPrefixLen: number;\n        Gateway: string;\n        MacAddress: string;\n      };\n    };\n  };\n  Mounts: Array<{\n    Type: string;\n    Source: string;\n    Destination: string;\n    Mode: string;\n    RW: boolean;\n    Propagation: string;\n  }>;\n}\n\nexport class AxDockerSession {\n  private readonly apiUrl: string;\n  private containerId: string | null = null;\n\n  constructor(apiUrl = 'http://localhost:2375') {\n    this.apiUrl = apiUrl;\n  }\n\n  async pullImage(imageName: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/images/create?fromImage=${encodeURIComponent(imageName)}`,\n      {\n        method: 'POST',\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to pull image: ${response.statusText}`);\n    }\n\n    // Wait for the pull to complete\n    await response.text();\n  }\n\n  async createContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string;\n    volumes?: Array<{ hostPath: string; containerPath: string }>;\n    doNotPullImage?: boolean;\n    tag?: string;\n  }>) {\n    const binds = volumes.map((v) => `${v.hostPath}:${v.containerPath}`);\n\n    if (!doNotPullImage) {\n      await this.pullImage(imageName);\n    }\n\n    const containerConfig = {\n      Image: imageName,\n      Tty: true,\n      OpenStdin: false,\n      AttachStdin: false,\n      AttachStdout: false,\n      AttachStderr: false,\n      HostConfig: { Binds: binds },\n      Labels: {} as Record<string, string>,\n    };\n\n    if (tag) {\n      containerConfig.Labels['com.example.tag'] = tag;\n    }\n\n    const response = await this.fetchDockerAPI('/containers/create', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(containerConfig),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to create container: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as { Id: string };\n    this.containerId = data.Id;\n\n    return data;\n  }\n\n  async findOrCreateContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string;\n    volumes?: Array<{ hostPath: string; containerPath: string }>;\n    doNotPullImage?: boolean;\n    tag: string;\n  }>): Promise<{ Id: string; isNew: boolean }> {\n    // First, try to find existing containers with the given tag\n    const existingContainers = await this.listContainers(true);\n    const matchingContainers = existingContainers.filter(\n      (container) =>\n        container.Labels && container.Labels['com.example.tag'] === tag\n    );\n\n    if (matchingContainers && matchingContainers.length > 0) {\n      // Randomly select a container from the matching ones\n      const randomIndex = Math.floor(Math.random() * matchingContainers.length);\n      const selectedContainer = matchingContainers[randomIndex];\n\n      if (selectedContainer) {\n        // Connect to the selected container\n        await this.connectToContainer(selectedContainer.Id);\n        return { Id: selectedContainer.Id, isNew: false };\n      }\n    }\n\n    // If no container with the tag exists, create a new one\n    const newContainer = await this.createContainer({\n      imageName,\n      volumes,\n      doNotPullImage,\n      tag,\n    });\n\n    return { Id: newContainer.Id, isNew: true };\n  }\n\n  async startContainer(): Promise<void> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/start`,\n      {\n        method: 'POST',\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to start container: ${response.statusText}`);\n    }\n  }\n\n  async connectToContainer(containerId: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to connect to container: ${response.statusText}`);\n    }\n\n    this.containerId = containerId;\n  }\n\n  async stopContainers({\n    tag,\n    remove,\n    timeout = 10,\n  }: Readonly<{ tag?: string; remove?: boolean; timeout?: number }>): Promise<\n    Array<{ Id: string; Action: 'stopped' | 'removed' }>\n  > {\n    const results: Array<{ Id: string; Action: 'stopped' | 'removed' }> = [];\n\n    // List all containers\n    const containers = await this.listContainers(true);\n\n    // Filter containers by tag if provided\n    const targetContainers = tag\n      ? containers.filter(\n          (container) => container.Labels['com.example.tag'] === tag\n        )\n      : containers;\n\n    for (const container of targetContainers) {\n      // Stop the container if it's running\n      if (container.State.Status === 'running') {\n        const stopResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}/stop?t=${timeout}`,\n          { method: 'POST' }\n        );\n\n        if (!stopResponse.ok) {\n          console.warn(\n            `Failed to stop container ${container.Id}: ${stopResponse.statusText}`\n          );\n          continue;\n        }\n\n        results.push({ Id: container.Id, Action: 'stopped' });\n      }\n\n      // Remove the container if the remove flag is set\n      if (remove) {\n        const removeResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}`,\n          { method: 'DELETE' }\n        );\n\n        if (!removeResponse.ok) {\n          console.warn(\n            `Failed to remove container ${container.Id}: ${removeResponse.statusText}`\n          );\n          continue;\n        }\n\n        results.push({ Id: container.Id, Action: 'removed' });\n      }\n    }\n\n    return results;\n  }\n\n  async listContainers(all = false): Promise<AxDockerContainer[]> {\n    const response = await this.fetchDockerAPI(`/containers/json?all=${all}`, {\n      method: 'GET',\n    });\n    return response.json() as Promise<AxDockerContainer[]>;\n  }\n\n  async getContainerLogs(): Promise<string> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/logs?stdout=true&stderr=true`,\n      { method: 'GET' }\n    );\n    return response.text();\n  }\n\n  async executeCommand(command: string) {\n    console.log('Executing command:', command);\n\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n\n    // Check container state\n    const containerInfo = await this.getContainerInfo(this.containerId);\n\n    if (containerInfo.State.Status !== 'running') {\n      await this.startContainer();\n\n      // Wait for the container to be in the \"running\" state\n      await this.waitForContainerToBeRunning(this.containerId);\n    }\n\n    // Create exec instance\n    const createResponse = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/exec`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Cmd: ['sh', '-c', command],\n          AttachStdout: true,\n          AttachStderr: true,\n        }),\n      }\n    );\n\n    if (!createResponse.ok) {\n      throw new Error(\n        `Failed to create exec instance: ${createResponse.statusText}`\n      );\n    }\n\n    const execData = (await createResponse.json()) as { Id: string };\n\n    // Start exec instance\n    const startResponse = await this.fetchDockerAPI(\n      `/exec/${execData.Id}/start`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Detach: false,\n          Tty: false,\n        }),\n      }\n    );\n\n    if (!startResponse.ok) {\n      throw new Error(\n        `Failed to start exec instance: ${startResponse.statusText}`\n      );\n    }\n\n    // Return the output\n    return await startResponse.text();\n  }\n\n  // Add these new methods to the class:\n\n  private async getContainerInfo(\n    containerId: string\n  ): Promise<AxDockerContainer> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    );\n    if (!response.ok) {\n      throw new Error(`Failed to get container info: ${response.statusText}`);\n    }\n    return response.json() as Promise<AxDockerContainer>;\n  }\n\n  private async waitForContainerToBeRunning(\n    containerId: string,\n    timeout = 30000\n  ): Promise<void> {\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeout) {\n      const containerInfo = await this.getContainerInfo(containerId);\n      if (containerInfo.State.Status === 'running') {\n        return;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before checking again\n    }\n    throw new Error('Timeout waiting for container to start');\n  }\n\n  private async fetchDockerAPI(\n    endpoint: string,\n    options?: Readonly<RequestInit>\n  ): Promise<Response> {\n    const url = new URL(endpoint, this.apiUrl).toString();\n    return await fetch(url, options);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: 'commandExecution',\n      description:\n        'Use this function to execute shell commands, scripts, and programs. This function enables interaction with the file system, running system utilities, and performing tasks that require a shell interface.',\n      parameters: {\n        type: 'object',\n        properties: {\n          command: {\n            type: 'string',\n            description:\n              'Shell command to execute. eg. `ls -l` or `echo \"Hello, World!\"`.',\n          },\n        },\n        required: ['command'],\n      },\n\n      func: async ({ command }: Readonly<{ command: string }>) =>\n        await this.executeCommand(command),\n    };\n  }\n}\n", "import type {\n  AxAIService,\n  AxAIServiceActionOptions,\n  AxFunction,\n} from '../ai/types.js';\n\nexport class AxEmbeddingAdapter {\n  private aiService: AxAIService;\n  private info: {\n    name: string;\n    description: string;\n    argumentDescription: string;\n  };\n  private func: (\n    args: readonly number[],\n    extra?: Readonly<AxAIServiceActionOptions>\n  ) => Promise<unknown>;\n\n  constructor({\n    ai,\n    info,\n    func,\n  }: Readonly<{\n    ai: AxAIService;\n    info: Readonly<{\n      name: string;\n      description: string;\n      argumentDescription: string;\n    }>;\n    func: (\n      args: readonly number[],\n      extra?: Readonly<AxAIServiceActionOptions>\n    ) => Promise<unknown>;\n  }>) {\n    this.aiService = ai;\n    this.info = info;\n    this.func = func;\n  }\n\n  private async embedAdapter(\n    text: string,\n    extra?: Readonly<AxAIServiceActionOptions>\n  ): Promise<unknown> {\n    const embedRes = await this.aiService.embed(\n      { texts: [text] },\n      {\n        sessionId: extra?.sessionId,\n        abortSignal: extra?.abortSignal,\n      }\n    );\n    const embeds = embedRes.embeddings.at(0);\n\n    if (!embeds) {\n      throw new Error('Failed to embed text');\n    }\n\n    return this.func.length === 2\n      ? this.func(embeds, extra)\n      : this.func(embeds);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: this.info.name,\n      description: this.info.description,\n      parameters: {\n        type: 'object',\n        properties: {\n          text: {\n            type: 'string',\n            description: this.info.argumentDescription,\n          },\n        },\n        required: ['text'],\n      },\n      func: ({ text }: Readonly<{ text: string }>, options) =>\n        this.embedAdapter(text, options),\n    };\n  }\n}\n", "import type { AxFunction, AxLoggerFunction } from '../ai/types.js';\nimport { randomUUID } from '../util/crypto.js';\n\nimport type { AxMCPTransport } from './transport.js';\nimport type {\n  JSONRPCNotification,\n  JSONRPCRequest,\n  MCPInitializeParams,\n  MCPInitializeResult,\n  MCPToolsListResult,\n} from './types.js';\n\n/**\n * Configuration for overriding function properties\n */\ninterface FunctionOverride {\n  /** Original function name to override */\n  name: string;\n  /** Updates to apply to the function */\n  updates: {\n    /** Alternative name for the function */\n    name?: string;\n    /** Alternative description for the function */\n    description?: string;\n  };\n}\n\n/**\n * Options for the MCP client\n */\ninterface AxMCPClientOptions {\n  /** Enable debug logging */\n  debug?: boolean;\n  /** Logger function for debug output */\n  logger?: AxLoggerFunction;\n  /**\n   * List of function overrides\n   * Use this to provide alternative names and descriptions for functions\n   * while preserving their original functionality\n   *\n   * Example:\n   * ```\n   * functionOverrides: [\n   *   {\n   *     name: \"original-function-name\",\n   *     updates: {\n   *       name: \"new-function-name\",\n   *       description: \"New function description\"\n   *     }\n   *   }\n   * ]\n   * ```\n   */\n  functionOverrides?: FunctionOverride[];\n}\n\nexport class AxMCPClient {\n  private functions: AxFunction[] = [];\n  private activeRequests: Map<string, { reject: (reason: unknown) => void }> =\n    new Map();\n  private capabilities: {\n    tools?: boolean;\n    resources?: boolean;\n    prompts?: boolean;\n  } = {};\n  private logger: AxLoggerFunction;\n\n  constructor(\n    private readonly transport: AxMCPTransport,\n    private readonly options: Readonly<AxMCPClientOptions> = {}\n  ) {\n    this.logger = options.logger ?? ((message: string) => console.log(message));\n  }\n\n  async init(): Promise<void> {\n    if ('connect' in this.transport) {\n      await this.transport.connect?.();\n    }\n\n    const { result: res } = await this.sendRequest<\n      MCPInitializeParams,\n      MCPInitializeResult\n    >('initialize', {\n      protocolVersion: '2024-11-05',\n      capabilities: {\n        roots: { listChanged: true },\n        sampling: {},\n      },\n      clientInfo: {\n        name: 'AxMCPClient',\n        version: '1.0.0',\n      },\n    });\n\n    const expectedProtocolVersion = '2024-11-05';\n    if (res.protocolVersion !== expectedProtocolVersion) {\n      throw new Error(\n        `Protocol version mismatch. Expected ${expectedProtocolVersion} but got ${res.protocolVersion}`\n      );\n    }\n\n    if (res.capabilities.tools) {\n      this.capabilities.tools = true;\n    }\n\n    if (res.capabilities.resources) {\n      this.capabilities.resources = true;\n    }\n\n    if (res.capabilities.prompts) {\n      this.capabilities.prompts = true;\n    }\n\n    await this.sendNotification('notifications/initialized');\n\n    await this.discoverFunctions();\n  }\n\n  private async discoverFunctions(): Promise<void> {\n    if (!this.capabilities.tools) {\n      throw new Error('Tools are not supported');\n    }\n\n    const { result: res } = await this.sendRequest<\n      undefined,\n      MCPToolsListResult\n    >('tools/list');\n\n    this.functions = res.tools.map((fn): AxFunction => {\n      // Check if there's an override for this function\n      const override = this.options.functionOverrides?.find(\n        (o) => o.name === fn.name\n      );\n\n      const parameters = fn.inputSchema.properties\n        ? {\n            properties: fn.inputSchema.properties,\n            required: fn.inputSchema.required ?? [],\n            type: fn.inputSchema.type,\n          }\n        : undefined;\n\n      return {\n        name: override?.updates.name ?? fn.name,\n        description: override?.updates.description ?? fn.description,\n        parameters,\n        func: async (args) => {\n          // Always use original name when calling the function\n          const { result } = await this.sendRequest<{\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments: unknown;\n          }>('tools/call', { name: fn.name, arguments: args });\n          return result;\n        },\n      };\n    });\n\n    if (this.options.debug) {\n      this.logger(`> Discovered ${this.functions.length} functions:`, {\n        tags: ['discovery'],\n      });\n      for (const fn of this.functions) {\n        this.logger(`  - ${fn.name}: ${fn.description}`, {\n          tags: ['discovery'],\n        });\n      }\n    }\n  }\n\n  async ping(timeout = 3000): Promise<void> {\n    const pingPromise = this.sendRequest('ping');\n    const timeoutPromise = new Promise((_, reject) =>\n      setTimeout(\n        () => reject(new Error('Ping response timeout exceeded')),\n        timeout\n      )\n    );\n    const response = (await Promise.race([pingPromise, timeoutPromise])) as {\n      result: unknown;\n    };\n    const { result } = response;\n    if (\n      typeof result !== 'object' ||\n      result === null ||\n      Object.keys(result).length !== 0\n    ) {\n      throw new Error(`Unexpected ping response: ${JSON.stringify(result)}`);\n    }\n  }\n\n  toFunction(): AxFunction[] {\n    return this.functions;\n  }\n\n  cancelRequest(id: string): void {\n    if (this.activeRequests.has(id)) {\n      this.sendNotification('notifications/cancelled', {\n        requestId: id,\n        reason: 'Client cancelled request',\n      });\n      const entry = this.activeRequests.get(id);\n      if (entry) {\n        entry.reject(new Error(`Request ${id} cancelled`));\n      }\n      this.activeRequests.delete(id);\n    }\n  }\n\n  private async sendRequest<T = unknown, R = unknown>(\n    method: string,\n    params: T = {} as T\n  ): Promise<{ id: string; result: R }> {\n    const requestId = randomUUID();\n    const request: JSONRPCRequest<T> = {\n      jsonrpc: '2.0',\n      id: requestId,\n      method,\n      params,\n    };\n\n    const responsePromise = new Promise<{ result: R }>((resolve, reject) => {\n      this.activeRequests.set(requestId, { reject });\n      this.transport\n        .send(request)\n        .then((res: unknown) => {\n          this.activeRequests.delete(requestId);\n          if (res !== null && typeof res === 'object' && 'error' in res) {\n            const errorObj = res as {\n              error: { code: number; message: string };\n            };\n            reject(\n              new Error(\n                `RPC Error ${errorObj.error.code}: ${errorObj.error.message}`\n              )\n            );\n          } else if (\n            res !== null &&\n            typeof res === 'object' &&\n            'result' in res\n          ) {\n            resolve({ result: (res as { result: R }).result });\n          } else {\n            reject(new Error('Invalid response no result or error'));\n          }\n        })\n        .catch((err: unknown) => {\n          this.activeRequests.delete(requestId);\n          reject(err);\n        });\n    });\n\n    const { result } = await responsePromise;\n    return { id: requestId, result };\n  }\n\n  private async sendNotification(\n    method: string,\n    params: Record<string, unknown> = {}\n  ): Promise<void> {\n    const notification: JSONRPCNotification = {\n      jsonrpc: '2.0',\n      method,\n      params,\n    };\n\n    if (this.options.debug) {\n      this.logger(\n        ` Sending notification: ${JSON.stringify(notification, null, 2)}`,\n        { tags: ['requestStart'] }\n      );\n    }\n\n    await this.transport.sendNotification(notification);\n  }\n}\n", "import type { AxMCPTransport } from './transport.js';\nimport type {\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from './types.js';\n\nexport class AxMCPHTTPSSETransport implements AxMCPTransport {\n  private endpoint: string | null = null;\n  private sseUrl: string;\n  private eventSource?: EventSource;\n\n  constructor(sseUrl: string) {\n    this.sseUrl = sseUrl;\n  }\n\n  async connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.eventSource = new EventSource(this.sseUrl);\n\n      this.eventSource.addEventListener('endpoint', (event: Event) => {\n        try {\n          const messageEvent = event as MessageEvent;\n          const data = JSON.parse(messageEvent.data);\n          if (!data.uri) {\n            throw new Error('Endpoint URI missing in SSE event data');\n          }\n          this.endpoint = data.uri;\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      this.eventSource.onerror = () => {\n        reject(new Error('Failed to establish SSE connection'));\n      };\n    });\n  }\n\n  async send(\n    message: JSONRPCRequest<unknown> | JSONRPCNotification\n  ): Promise<JSONRPCResponse<unknown>> {\n    if (!this.endpoint) {\n      throw new Error(\n        'HTTPTransport endpoint is not initialized. Call connect() first.'\n      );\n    }\n\n    const res = await fetch(this.endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(message),\n    });\n\n    if (!res.ok) {\n      throw new Error(`HTTP error ${res.status}: ${res.statusText}`);\n    }\n\n    return res.json() as Promise<JSONRPCResponse<unknown>>;\n  }\n\n  async sendNotification(\n    message: Readonly<JSONRPCNotification>\n  ): Promise<void> {\n    if (!this.endpoint) {\n      throw new Error(\n        'HTTPTransport endpoint is not initialized. Call connect() first.'\n      );\n    }\n    await fetch(this.endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(message),\n    });\n  }\n}\n\nexport interface AxMCPStreamableHTTPTransportOptions {\n  /**\n   * Custom headers to include with all HTTP requests\n   * Note: Content-Type, Accept, and Mcp-Session-Id are managed automatically\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * Authorization header value (convenience for common use case)\n   * If provided, will be added to the headers as 'Authorization'\n   */\n  authorization?: string;\n}\n\n/**\n * AxMCPStreambleHTTPTransport implements the 2025-03-26 Streamable HTTP transport specification\n * This transport uses a single HTTP endpoint that supports both POST and GET methods\n */\nexport class AxMCPStreambleHTTPTransport implements AxMCPTransport {\n  private mcpEndpoint: string;\n  private sessionId?: string;\n  private eventSource?: EventSource;\n  private pendingRequests = new Map<\n    string | number,\n    {\n      resolve: (value: JSONRPCResponse<unknown>) => void;\n      reject: (reason: unknown) => void;\n    }\n  >();\n  private messageHandler?: (\n    message: JSONRPCRequest<unknown> | JSONRPCNotification\n  ) => void;\n  private customHeaders: Record<string, string>;\n\n  constructor(\n    mcpEndpoint: string,\n    options?: AxMCPStreamableHTTPTransportOptions\n  ) {\n    this.mcpEndpoint = mcpEndpoint;\n    this.customHeaders = { ...options?.headers };\n\n    // Add authorization header if provided\n    if (options?.authorization) {\n      this.customHeaders.Authorization = options.authorization;\n    }\n  }\n\n  /**\n   * Update custom headers (useful for refreshing tokens)\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this.customHeaders = { ...headers };\n  }\n\n  /**\n   * Update authorization header (convenience method)\n   */\n  setAuthorization(authorization: string): void {\n    this.customHeaders.Authorization = authorization;\n  }\n\n  /**\n   * Get a copy of the current custom headers\n   */\n  getHeaders(): Record<string, string> {\n    return { ...this.customHeaders };\n  }\n\n  /**\n   * Build headers for HTTP requests, merging custom headers with required ones\n   */\n  private buildHeaders(\n    baseHeaders: Record<string, string>\n  ): Record<string, string> {\n    const headers = { ...this.customHeaders, ...baseHeaders };\n\n    if (this.sessionId) {\n      headers['Mcp-Session-Id'] = this.sessionId;\n    }\n\n    return headers;\n  }\n\n  /**\n   * Set a handler for incoming server messages (requests/notifications)\n   */\n  setMessageHandler(\n    handler: (message: JSONRPCRequest<unknown> | JSONRPCNotification) => void\n  ): void {\n    this.messageHandler = handler;\n  }\n\n  async connect(): Promise<void> {\n    // For Streamable HTTP, connection is implicit when making requests\n    // But we can optionally open a GET SSE stream for server-initiated messages\n    return Promise.resolve();\n  }\n\n  /**\n   * Opens an SSE stream to listen for server-initiated messages\n   */\n  async openListeningStream(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const headers = this.buildHeaders({\n        Accept: 'text/event-stream',\n      });\n\n      // Note: EventSource doesn't support custom headers in standard browsers\n      // For custom headers with SSE, you may need to use fetch with ReadableStream\n      // or use a library that supports custom headers\n      const url = new URL(this.mcpEndpoint);\n\n      // If we have custom headers, we need to use fetch instead of EventSource\n      if (Object.keys(this.customHeaders).length > 0) {\n        this.openListeningStreamWithFetch(headers).then(resolve).catch(reject);\n        return;\n      }\n\n      this.eventSource = new EventSource(url.toString());\n\n      this.eventSource.onopen = () => {\n        resolve();\n      };\n\n      this.eventSource.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          if (this.messageHandler) {\n            this.messageHandler(message);\n          }\n        } catch (error) {\n          console.error('Failed to parse SSE message:', error);\n        }\n      };\n\n      this.eventSource.onerror = () => {\n        reject(new Error('Failed to establish SSE connection'));\n      };\n    });\n  }\n\n  /**\n   * Opens an SSE stream using fetch API to support custom headers\n   */\n  private async openListeningStreamWithFetch(\n    headers: Record<string, string>\n  ): Promise<void> {\n    const response = await fetch(this.mcpEndpoint, {\n      method: 'GET',\n      headers,\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to open SSE stream: ${response.status} ${response.statusText}`\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('No response body available for SSE stream');\n    }\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    const processStream = async (): Promise<void> => {\n      try {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          reader.releaseLock();\n          return;\n        }\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6); // Remove 'data: ' prefix\n            if (data === '[DONE]') {\n              return;\n            }\n\n            try {\n              const message = JSON.parse(data);\n              if (this.messageHandler) {\n                this.messageHandler(message);\n              }\n            } catch (error) {\n              console.error('Failed to parse SSE data:', error);\n            }\n          }\n        }\n\n        // Continue reading\n        await processStream();\n      } catch (error) {\n        reader.releaseLock();\n        throw error;\n      }\n    };\n\n    await processStream();\n  }\n\n  async send(\n    message: Readonly<JSONRPCRequest<unknown>>\n  ): Promise<JSONRPCResponse<unknown>> {\n    const headers = this.buildHeaders({\n      'Content-Type': 'application/json',\n      Accept: 'application/json, text/event-stream',\n    });\n\n    const response = await fetch(this.mcpEndpoint, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(message),\n    });\n\n    if (!response.ok) {\n      if (response.status === 404 && this.sessionId) {\n        // Session expired, clear it\n        this.sessionId = undefined;\n        throw new Error('Session expired. Please reinitialize.');\n      }\n      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n    }\n\n    // Check if this is the initialization response with session ID\n    const sessionIdHeader = response.headers.get('Mcp-Session-Id');\n    if (sessionIdHeader) {\n      this.sessionId = sessionIdHeader;\n    }\n\n    const contentType = response.headers.get('Content-Type');\n\n    if (contentType?.includes('text/event-stream')) {\n      // Handle SSE response\n      return this.handleSSEResponse(response, message.id);\n    }\n    if (contentType?.includes('application/json')) {\n      // Handle JSON response\n      return response.json() as Promise<JSONRPCResponse<unknown>>;\n    }\n    throw new Error(`Unexpected content type: ${contentType}`);\n  }\n\n  private async handleSSEResponse(\n    response: Response,\n    requestId: string | number\n  ): Promise<JSONRPCResponse<unknown>> {\n    return new Promise((resolve, reject) => {\n      const reader = response.body?.getReader();\n      if (!reader) {\n        reject(new Error('No response body reader available'));\n        return;\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      const processChunk = async (): Promise<void> => {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            reader.releaseLock();\n            return;\n          }\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6); // Remove 'data: ' prefix\n              if (data === '[DONE]') {\n                return;\n              }\n\n              try {\n                const message = JSON.parse(data);\n\n                // Check if this is the response to our request\n                if ('id' in message && message.id === requestId) {\n                  resolve(message as JSONRPCResponse<unknown>);\n                  return;\n                }\n\n                // Handle other messages (server requests/notifications)\n                if (this.messageHandler) {\n                  this.messageHandler(message);\n                }\n              } catch (error) {\n                console.error('Failed to parse SSE data:', error);\n              }\n            }\n          }\n\n          // Continue reading\n          await processChunk();\n        } catch (error) {\n          reader.releaseLock();\n          reject(error);\n        }\n      };\n\n      processChunk().catch(reject);\n    });\n  }\n\n  async sendNotification(\n    message: Readonly<JSONRPCNotification>\n  ): Promise<void> {\n    const headers = this.buildHeaders({\n      'Content-Type': 'application/json',\n      Accept: 'application/json, text/event-stream',\n    });\n\n    const response = await fetch(this.mcpEndpoint, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(message),\n    });\n\n    if (!response.ok) {\n      if (response.status === 404 && this.sessionId) {\n        // Session expired, clear it\n        this.sessionId = undefined;\n        throw new Error('Session expired. Please reinitialize.');\n      }\n      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n    }\n\n    // For notifications, we expect 202 Accepted with no body\n    if (response.status !== 202) {\n      console.warn(`Unexpected status for notification: ${response.status}`);\n    }\n  }\n\n  /**\n   * Explicitly terminate the session (if supported by server)\n   */\n  async terminateSession(): Promise<void> {\n    if (!this.sessionId) {\n      return;\n    }\n\n    try {\n      const headers = this.buildHeaders({});\n\n      const response = await fetch(this.mcpEndpoint, {\n        method: 'DELETE',\n        headers,\n      });\n\n      if (response.status === 405) {\n        // Server doesn't support explicit session termination\n        console.info('Server does not support explicit session termination');\n      }\n    } catch (error) {\n      console.error('Failed to terminate session:', error);\n    } finally {\n      this.sessionId = undefined;\n    }\n  }\n\n  /**\n   * Close any open connections\n   */\n  close(): void {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = undefined;\n    }\n  }\n}\n", "import type {\n  AxAIModelList,\n  AxAIService,\n  AxFunction,\n  AxFunctionHandler,\n  AxFunctionJSONSchema,\n} from '../ai/types.js';\nimport type { AxInputFunctionType } from '../dsp/functions.js';\nimport { AxGen } from '../dsp/generate.js';\nimport type {\n  AxGenStreamingOut,\n  AxProgram,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramStreamingForwardOptions,\n  AxSetExamplesOptions,\n  AxTunable,\n  AxUsable,\n} from '../dsp/program.js';\nimport type { AxSignature } from '../dsp/sig.js';\nimport type { AxGenIn, AxGenOut, AxMessage } from '../dsp/types.js';\n\n/**\n * Interface for agents that can be used as child agents.\n * Provides methods to get the agent's function definition and features.\n */\nexport interface AxAgentic<IN extends AxGenIn, OUT extends AxGenOut>\n  extends AxTunable<IN, OUT>,\n    AxUsable {\n  getFunction(): AxFunction;\n  getFeatures(): AxAgentFeatures;\n}\n\nexport type AxAgentOptions = Omit<AxProgramForwardOptions, 'functions'> & {\n  disableSmartModelRouting?: boolean;\n  /** List of field names that should not be automatically passed from parent to child agents */\n  excludeFieldsFromPassthrough?: string[];\n  debug?: boolean;\n};\n\nexport interface AxAgentFeatures {\n  /** Whether this agent can use smart model routing (requires an AI service) */\n  canConfigureSmartModelRouting: boolean;\n  /** List of fields that this agent excludes from parent->child value passing */\n  excludeFieldsFromPassthrough: string[];\n}\n\n/**\n * Processes a child agent's function, applying model routing and input injection as needed.\n * Handles both the schema modifications and function wrapping.\n */\nfunction processChildAgentFunction<IN extends AxGenIn>(\n  childFunction: Readonly<AxFunction>,\n  parentValues: IN | AxMessage<IN>[],\n  parentInputKeys: string[],\n  modelList: AxAIModelList | undefined,\n  options: Readonly<{\n    debug: boolean;\n    disableSmartModelRouting: boolean;\n    excludeFieldsFromPassthrough: string[];\n    canConfigureSmartModelRouting: boolean;\n  }>\n): AxFunction {\n  const processedFunction = { ...childFunction };\n\n  // Process input field injection\n  if (processedFunction.parameters) {\n    const childKeys = processedFunction.parameters.properties\n      ? Object.keys(processedFunction.parameters.properties)\n      : [];\n\n    // Find common keys between parent and child, excluding 'model' and specified exclusions\n    const commonKeys = parentInputKeys\n      .filter((key) => childKeys.includes(key))\n      .filter((key) => key !== 'model');\n    const injectionKeys = commonKeys.filter(\n      (key) => !options.excludeFieldsFromPassthrough.includes(key)\n    );\n\n    if (injectionKeys.length > 0) {\n      // Remove injected fields from child schema\n      processedFunction.parameters = removePropertiesFromSchema(\n        processedFunction.parameters,\n        injectionKeys\n      );\n\n      // Wrap function to inject parent values\n      const originalFunc = processedFunction.func;\n      // add debug logging if enabled\n      processedFunction.func = async (childArgs, funcOptions) => {\n        // Extract values from parentValues - handle both IN and AxMessage<IN>[] cases\n        let valuesToInject: Partial<IN> = {};\n        if (Array.isArray(parentValues)) {\n          // If parentValues is an array of messages, find the most recent user message\n          const lastUserMessage = parentValues\n            .filter((msg) => msg.role === 'user')\n            .pop();\n          if (lastUserMessage) {\n            valuesToInject = pick(\n              lastUserMessage.values,\n              injectionKeys as (keyof IN)[]\n            );\n          }\n        } else {\n          // If parentValues is a single IN object\n          valuesToInject = pick(parentValues, injectionKeys as (keyof IN)[]);\n        }\n\n        const updatedChildArgs = {\n          ...childArgs,\n          ...valuesToInject,\n        };\n\n        if (options.debug && injectionKeys.length > 0) {\n          const ai = funcOptions?.ai;\n          if (ai) {\n            const logger = ai.getLogger();\n            logger(\n              `Function Params: ${JSON.stringify(updatedChildArgs, null, 2)}`,\n              { tags: ['functionArg'] }\n            );\n          }\n        }\n\n        return await originalFunc(updatedChildArgs, funcOptions);\n      };\n    }\n\n    return processedFunction;\n  }\n\n  // Apply smart model routing if enabled\n  if (\n    modelList &&\n    !options.disableSmartModelRouting &&\n    options.canConfigureSmartModelRouting\n  ) {\n    processedFunction.parameters = addModelParameter(\n      processedFunction.parameters,\n      modelList\n    );\n  }\n\n  return processedFunction;\n}\n\nconst descriptionError = new Error(\n  'Agent description must be at least 20 characters (explain in detail what the agent does)'\n);\n\nconst definitionError = new Error(\n  'Agent definition is the prompt you give to the LLM for the agent. It must be detailed and at least 100 characters'\n);\n\n/**\n * An AI agent that can process inputs using an AI service and coordinate with child agents.\n * Supports features like smart model routing and automatic input field passing to child agents.\n */\nexport class AxAgent<IN extends AxGenIn, OUT extends AxGenOut>\n  implements AxAgentic<IN, OUT>\n{\n  private ai?: AxAIService;\n  private program: AxProgram<IN, OUT>;\n  private functions?: AxInputFunctionType;\n  private agents?: AxAgentic<IN, OUT>[];\n  private disableSmartModelRouting?: boolean;\n  private excludeFieldsFromPassthrough: string[];\n  private debug?: boolean;\n\n  private name: string;\n  //   private subAgentList?: string\n  private func: AxFunction;\n\n  constructor(\n    {\n      ai,\n      name,\n      description,\n      definition,\n      signature,\n      agents,\n      functions,\n    }: Readonly<{\n      ai?: Readonly<AxAIService>;\n      name: string;\n      description: string;\n      definition?: string;\n      signature: NonNullable<ConstructorParameters<typeof AxSignature>[0]>;\n      agents?: AxAgentic<IN, OUT>[];\n      functions?: AxInputFunctionType;\n    }>,\n    options?: Readonly<AxAgentOptions>\n  ) {\n    const { disableSmartModelRouting, excludeFieldsFromPassthrough, debug } =\n      options ?? {};\n\n    this.ai = ai;\n    this.agents = agents;\n    this.functions = functions;\n    this.disableSmartModelRouting = disableSmartModelRouting;\n    this.excludeFieldsFromPassthrough = excludeFieldsFromPassthrough ?? [];\n    this.debug = debug;\n\n    if (!name || name.length < 5) {\n      throw new Error(\n        'Agent name must be at least 10 characters (more descriptive)'\n      );\n    }\n\n    if (!description || description.length < 20) {\n      throw descriptionError;\n    }\n\n    if (definition && definition.length < 100) {\n      throw definitionError;\n    }\n\n    this.program = new AxGen<IN, OUT>(signature, {\n      ...options,\n      description: definition ?? description,\n    });\n\n    for (const agent of agents ?? []) {\n      this.program.register(\n        agent as unknown as Readonly<AxTunable<IN, OUT> & AxUsable>\n      );\n    }\n\n    this.name = name;\n    // this.subAgentList = agents?.map((a) => a.getFunction().name).join(', ')\n\n    this.func = {\n      name: toCamelCase(this.name),\n      description,\n      parameters: this.program.getSignature().toJSONSchema(),\n      func: () => this.forward,\n    };\n\n    const mm = ai?.getModelList();\n    // Only add model parameter if smart routing is enabled and model list exists\n    if (mm && !this.disableSmartModelRouting) {\n      this.func.parameters = addModelParameter(this.func.parameters, mm);\n    }\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    this.program.setExamples(examples, options);\n  }\n\n  public setId(id: string) {\n    this.program.setId(id);\n  }\n\n  public setParentId(parentId: string) {\n    this.program.setParentId(parentId);\n  }\n\n  public getTraces() {\n    return this.program.getTraces();\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]) {\n    this.program.setDemos(demos);\n  }\n\n  public getUsage() {\n    return this.program.getUsage();\n  }\n\n  public resetUsage() {\n    this.program.resetUsage();\n  }\n\n  public getFunction(): AxFunction {\n    const boundFunc = this.forward.bind(this);\n\n    // Create a wrapper function that excludes the 'ai' parameter\n    const wrappedFunc: AxFunctionHandler = async (\n      valuesAndModel: IN & { model: string },\n      options?\n    ): Promise<string> => {\n      const { model, ...values } = valuesAndModel;\n\n      const ai = this.ai ?? options?.ai;\n      if (!ai) {\n        throw new Error('AI service is required to run the agent');\n      }\n      const debug = this.getDebug(ai, options);\n\n      if (debug) {\n        const logger = ai.getLogger();\n        logger(` Agent ${this.name} starting...`, {\n          tags: ['start'],\n        });\n      }\n\n      const ret = await boundFunc(ai, values as unknown as IN, {\n        ...options,\n        model,\n      });\n\n      if (debug) {\n        const logger = ai.getLogger();\n        logger(` Agent ${this.name} completed.`, { tags: ['end'] });\n      }\n\n      const sig = this.program.getSignature();\n      const outFields = sig.getOutputFields();\n      const result = Object.keys(ret)\n        .map((k) => {\n          const field = outFields.find((f) => f.name === k);\n          if (field) {\n            return `${field.title}: ${ret[k]}`;\n          }\n          return `${k}: ${ret[k]}`;\n        })\n        .join('\\n');\n\n      return result;\n    };\n\n    return {\n      ...this.func,\n      func: wrappedFunc,\n    };\n  }\n\n  public getFeatures(): AxAgentFeatures {\n    return {\n      canConfigureSmartModelRouting: this.ai === undefined,\n      excludeFieldsFromPassthrough: this.excludeFieldsFromPassthrough,\n    };\n  }\n\n  /**\n   * Initializes the agent's execution context, processing child agents and their functions.\n   */\n  private init(\n    parentAi: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options: Readonly<AxProgramForwardOptions> | undefined\n  ) {\n    const ai = this.ai ?? parentAi;\n    const mm = ai?.getModelList();\n\n    // Get parent's input schema and keys\n    const parentSchema = this.program.getSignature().getInputFields();\n    const parentKeys = parentSchema.map((p) => p.name);\n    const debug = this.getDebug(ai, options);\n\n    // Process each child agent's function\n    const agentFuncs = this.agents?.map((agent) => {\n      const f = agent.getFeatures();\n\n      const processOptions = {\n        debug,\n        disableSmartModelRouting: !!this.disableSmartModelRouting,\n        excludeFieldsFromPassthrough: f.excludeFieldsFromPassthrough,\n        canConfigureSmartModelRouting: f.canConfigureSmartModelRouting,\n      };\n\n      return processChildAgentFunction(\n        agent.getFunction(),\n        values,\n        parentKeys,\n        mm,\n        processOptions\n      );\n    });\n\n    // Combine all functions\n    const functions: AxInputFunctionType = [\n      ...(options?.functions ?? this.functions ?? []),\n      ...(agentFuncs ?? []),\n    ];\n\n    return { ai, functions, debug };\n  }\n\n  public async forward(\n    parentAi: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<OUT> {\n    const { ai, functions, debug } = this.init(parentAi, values, options);\n    return await this.program.forward(ai, values, {\n      ...options,\n      debug,\n      functions,\n    });\n  }\n\n  public async *streamingForward(\n    parentAi: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptions>\n  ): AxGenStreamingOut<OUT> {\n    const { ai, functions, debug } = this.init(parentAi, values, options);\n    return yield* this.program.streamingForward(ai, values, {\n      ...options,\n      debug,\n      functions,\n    });\n  }\n\n  /**\n   * Updates the agent's description.\n   * This updates both the stored description and the function's description.\n   *\n   * @param description - New description for the agent (must be at least 20 characters)\n   * @throws Error if description is too short\n   */\n  public setDescription(description: string): void {\n    if (!description || description.length < 20) {\n      throw descriptionError;\n    }\n\n    this.program.getSignature().setDescription(description);\n    this.func.description = description;\n  }\n\n  public setDefinition(definition: string): void {\n    if (!definition || definition.length < 100) {\n      throw definitionError;\n    }\n\n    this.program.getSignature().setDescription(definition);\n  }\n\n  private getDebug(\n    ai: AxAIService,\n    options?: Readonly<AxProgramForwardOptions>\n  ): boolean {\n    return options?.debug ?? this.debug ?? ai?.getOptions()?.debug ?? false;\n  }\n}\n\nfunction toCamelCase(inputString: string): string {\n  // Split the string by any non-alphanumeric character (including underscores, spaces, hyphens)\n  const words = inputString.split(/[^a-zA-Z0-9]/);\n\n  // Map through each word, capitalize the first letter of each word except the first word\n  const camelCaseString = words\n    .map((word, index) => {\n      // Lowercase the word to handle cases like uppercase letters in input\n      const lowerWord = word.toLowerCase();\n\n      // Capitalize the first letter of each word except the first one\n      if (index > 0 && lowerWord && lowerWord[0]) {\n        return lowerWord[0].toUpperCase() + lowerWord.slice(1);\n      }\n\n      return lowerWord;\n    })\n    .join('');\n\n  return camelCaseString;\n}\n\n/**\n * Adds a required model parameter to a JSON Schema definition based on provided model mappings.\n * The model parameter will be an enum with values from the model map keys.\n *\n * @param parameters - The original JSON Schema parameters definition (optional)\n * @param models - Array of model mappings containing keys, model names and descriptions\n * @returns Updated JSON Schema with added model parameter\n */\nexport function addModelParameter(\n  parameters: AxFunctionJSONSchema | undefined,\n  models: AxAIModelList\n): AxFunctionJSONSchema {\n  // If parameters is undefined, create a base schema\n  const baseSchema: AxFunctionJSONSchema = parameters\n    ? structuredClone(parameters)\n    : {\n        type: 'object',\n        properties: {},\n        required: [],\n      };\n\n  // Check if model parameter already exists\n  if (baseSchema.properties?.model) {\n    return baseSchema;\n  }\n\n  // Create the model property schema\n  const modelProperty: AxFunctionJSONSchema & {\n    enum: string[];\n    description: string;\n  } = {\n    type: 'string',\n    enum: models.map((m) => m.key),\n    description: `The AI model to use for this function call. Available options: ${models\n      .map((m) => `\\`${m.key}\\` ${m.description}`)\n      .join(', ')}`,\n  };\n\n  // Create new properties object with model parameter\n  const newProperties = {\n    ...(baseSchema.properties ?? {}),\n    model: modelProperty,\n  };\n\n  // Add model to required fields\n  const newRequired = [...(baseSchema.required ?? []), 'model'];\n\n  // Return updated schema\n  return {\n    ...baseSchema,\n    properties: newProperties,\n    required: newRequired,\n  };\n}\n\n// New helper: removePropertiesFromSchema\n//    Clones a JSON schema and removes properties and required fields matching the provided keys.\nfunction removePropertiesFromSchema(\n  schema: Readonly<AxFunctionJSONSchema>,\n  keys: string[]\n): AxFunctionJSONSchema {\n  const newSchema = structuredClone(schema);\n  if (newSchema.properties) {\n    for (const key of keys) {\n      delete newSchema.properties[key];\n    }\n  }\n  if (Array.isArray(newSchema.required)) {\n    const filteredRequired = newSchema.required.filter(\n      (r: string) => !keys.includes(r)\n    );\n    Object.defineProperty(newSchema, 'required', {\n      value: filteredRequired,\n      writable: true,\n      configurable: true,\n    });\n  }\n  return newSchema;\n}\n\n// New helper: pick\n//    Returns an object composed of the picked object properties.\nfunction pick<T extends object, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  for (const key of keys) {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n", "import { AxGen } from '../dsp/generate.js';\nimport type { AxProgramForwardOptions } from '../dsp/program.js';\nimport { AxSignature } from '../dsp/sig.js';\nimport type { AxGenIn, AxGenOut } from '../dsp/types.js';\n\nexport class AxChainOfThought<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> extends AxGen<IN, OUT> {\n  constructor(\n    signature: Readonly<AxSignature | string>,\n    options?: Readonly<\n      AxProgramForwardOptions & { setVisibleReasoning?: boolean }\n    >\n  ) {\n    const sig = new AxSignature(signature);\n    const description = `Let's work this out in a step by step way in order to ensure we have the right answer.`;\n\n    sig.setOutputFields([\n      {\n        name: 'reason',\n        description,\n        isInternal: options?.setVisibleReasoning !== true,\n      },\n      ...sig.getOutputFields(),\n    ]);\n\n    super(sig, options);\n  }\n}\n", "import type { AxAIService } from '../ai/types.js';\nimport { AxGen } from '../dsp/generate.js';\nimport type { AxProgramForwardOptions } from '../dsp/program.js';\nimport { AxSignature } from '../dsp/sig.js';\nimport { AxStringUtil } from '../dsp/strutil.js';\nimport type { AxMessage } from '../dsp/types.js';\n\nimport { AxChainOfThought } from './cot.js';\n\nexport class AxRAG extends AxChainOfThought<\n  { context: string[]; question: string },\n  { answer: string }\n> {\n  private genQuery: AxGen<\n    { context: string[]; question: string },\n    { query: string }\n  >;\n  private queryFn: (query: string) => Promise<string>;\n  private maxHops: number;\n\n  constructor(\n    queryFn: (query: string) => Promise<string>,\n    options: Readonly<AxProgramForwardOptions & { maxHops?: number }>\n  ) {\n    const sig =\n      '\"Answer questions with short factoid answers.\" context:string[] \"may contain relevant facts\", question -> answer';\n    super(sig, options);\n\n    this.maxHops = options?.maxHops ?? 3;\n\n    const qsig = new AxSignature(\n      '\"Write a simple search query that will help answer a complex question.\" context?:string[] \"may contain relevant facts\", question -> query \"question to further our understanding\"'\n    );\n    this.genQuery = new AxGen<\n      { context: string[]; question: string },\n      { query: string }\n    >(qsig);\n    this.queryFn = queryFn;\n    // Note: genQuery is not registered as it has a different output signature than the parent\n  }\n\n  public override async forward(\n    ai: Readonly<AxAIService>,\n    values:\n      | { context: string[]; question: string }\n      | AxMessage<{ context: string[]; question: string }>[],\n    options?: Readonly<AxProgramForwardOptions>\n  ): Promise<{ answer: string }> {\n    // Extract question from values - handle both cases\n    let question: string;\n    if (Array.isArray(values)) {\n      // If values is an array of messages, find the most recent user message\n      const lastUserMessage = values.filter((msg) => msg.role === 'user').pop();\n      if (!lastUserMessage) {\n        throw new Error('No user message found in values array');\n      }\n      question = lastUserMessage.values.question;\n    } else {\n      // If values is a single object\n      question = values.question;\n    }\n\n    let hop = 0;\n    let context: string[] = [];\n\n    while (hop < this.maxHops) {\n      const query = await this.genQuery.forward(ai, { context, question });\n      const queryResult = await this.queryFn(query.query);\n      context = AxStringUtil.dedup([...context, queryResult]);\n\n      hop++;\n    }\n\n    const res = await super.forward(ai, { context, question }, options);\n    return res;\n  }\n}\n"],
  "mappings": "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AAI,OAAOxY,GAAS,UAAW,UAAU;AACvC,UAAM,EAAE,QAAA4hC,EAAO,IAAI5hC;AACnB8jB,UAAIA,EAAE,OAAQA,OAAMA,EAAE,SAAS8d,CAAM;IACvC;AAEI,SAAK,SACP,QAAQ,IACN,GAAGr8B,GAAS,YAAY,UAAU1E,CAAI,EAAE,CAAC;EAAK0E,GAAS,YACrD,KAAK,UAAUue,EAAE,IAAKA,OAAM,GAAGA,EAAE,EAAE,KAAKA,EAAE,KAAK,EAAE,CAAC,CACpD,CAAC,EACH;AAGF,QAAM+d,IAAe/d,EAAE,GAAG,CAAC;AAC3B,WAAK+d,IAIEA,EAAa,KAHX;EAIX;EAEO,WAAW7hC,GAA8C;AAC1D,WAAOA,EAAQ,SAAU,cAC3B,KAAK,QAAQA,EAAQ;EAEzB;AACF;AC9GO,IAAM8hC,KAAY,oBAAI,IAAI,CAC/B,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,QACA,SACA,SACA,QACA,MACA,cACA,aACA,eACA,UACA,OACA,YACA,MACA,SACA,OACA,MACA,MACA,YACA,aACA,WACA,SACA,cACA,MACA,SACA,WACA,MACA,OACA,SACA,MACA,MACA,OACA,SACA,UACA,UACA,SACA,SACA,WACA,QACA,YACA,UACA,MACA,SACA,WACA,YACA,UACA,MACA,OACA,YACA,WACA,OACA,WACA,UACA,WACA,UACA,YACA,UACA,WACA,YACA,MACA,MACA,SACA,cACA,UACA,cACA,eACA,iBACA,MACA,OACA,QACA,SACA,UACA,SACA,UACA,MACA,OACA,SACA,OACA,UACA,cACA,MACA,MACA,QACA,MACA,aACA,MACA,QACA,WACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,QACA,MACA,MACA,MACA,UACA,WACA,UACA,WACA,YACA,QACA,UACA,cACA,SACA,aACA,cACA,UACA,UACA,SACA,WACA,SACA,UACA,WACA,QACA,UACA,WACA,UACA,MACA,QACA,QACA,MACA,MACA,MACA,MACA,QACA,UACA,MACA,MACA,SACA,WACA,MACA,MACA,MACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,QACA,QACA,OACA,UACA,QACA,SACA,SACA,UACA,MACA,MACA,MACA,WACA,aACA,MACA,MACA,MACA,WACA,MACA,OACA,MACA,MACA,WACA,MACA,SACA,MACA,MACA,OACA,QACA,SACA,OACA,cACA,gBACA,YACA,eACA,WACA,cACA,YACA,iBACA,SACA,UACA,WACA,YACA,UACA,MACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,aACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,QACA,MACA,MACA,MACA,cACA,YACA,aACA,WACA,UACA,MACA,MACA,OACA,QACA,UACA,aACA,MACA,MACA,MACA,MACA,QACA,SACA,WACA,SACA,OACA,QACA,SACA,QACA,aACA,MACA,MACA,MACA,MACA,MACA,OACA,UACA,MACA,MACA,KACA,MACA,MACA,MACA,QACA,MACA,MACA,OACA,MACA,MACA,UACA,MACA,MACA,SACA,UACA,UACA,MACA,MACA,UACA,QACA,aACA,MACA,SACA,MACA,OACA,UACA,UACA,YACA,MACA,MACA,MACA,MACA,MACA,cACA,OACA,MACA,SACA,OACA,MACA,MACA,QACA,QACA,SACA,aACA,YACA,cACA,cACA,MACA,WACA,WACA,UACA,MACA,KACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,WACA,SACA,QACA,QACA,QACA,QACA,SACA,QACA,OACA,MACA,MACA,MACA,MACA,YACA,aACA,WACA,OACA,UACA,YACA,SACA,SACA,SACA,QACA,MACA,QACA,SACA,MACA,MACA,QACA,WACA,eACA,MACA,KACA,MACA,QACA,MACA,OACA,QACA,WACA,MACA,QACA,SACA,SACA,UACA,MACA,MACA,MACA,QACA,SACA,QACA,OACA,UACA,MACA,aACA,MACA,MACA,KACA,MACA,MACA,OACA,QACA,UACA,WACA,UACA,OACA,QACA,SACA,UACA,QACA,SACA,WACA,UACA,MACA,OACA,QACA,SACA,SACA,QACA,SACA,OACA,QACA,aACA,UACA,UACA,SACA,UACA,YACA,QACA,WACA,OACA,QACA,MACA,MACA,OACA,OACA,WACA,OACA,UACA,MACA,MACA,QACA,aACA,OACA,WACA,WACA,SACA,MACA,MACA,QACA,MACA,WACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,QACA,MACA,MACA,OACA,MACA,MACA,MACA,WACA,MACA,MACA,MACA,MACA,QACA,MACA,OACA,aACA,eACA,cACA,aACA,MACA,YACA,OACA,UACA,SACA,YACA,aACA,aACA,eACA,SACA,WACA,WACA,YACA,QACA,aACA,UACA,MACA,MACA,MACA,MACA,MACA,OACA,SACA,MACA,OACA,QACA,SACA,OACA,QACA,UACA,MACA,QACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,QACA,KACA,MACA,QACA,SACA,QACA,MACA,MACA,MACA,QACA,SACA,SACA,MACA,KACA,MACA,MACA,WACA,QACA,UACA,SACA,UACA,YACA,MACA,MACA,MACA,SACA,OACA,QACA,QACA,OACA,QACA,SACA,MACA,QACA,SACA,UACA,QACA,UACA,MACA,MACA,MACA,MACA,MACA,QACA,WACA,SACA,OACA,MACA,MACA,MACA,OACA,KACA,MACA,MACA,QACA,UACA,QACA,SACA,QACA,OACA,SACA,MACA,QACA,SACA,YACA,aACA,UACA,MACA,SACA,UACA,YACA,QACA,WACA,QACA,QACA,MACA,MACA,MACA,QACA,YACA,QACA,UACA,QACA,MACA,OACA,MACA,MACA,MACA,QACA,OACA,QACA,SACA,WACA,MACA,UACA,SACA,KACA,MACA,MACA,QACA,UACA,OACA,MACA,MACA,MACA,QACA,UACA,eACA,aACA,QACA,SACA,WACA,SACA,WACA,SACA,gBACA,OACA,QACA,MACA,MACA,QACA,UACA,MACA,MACA,MACA,MACA,UACA,OACA,QACA,eACA,SACA,OACA,YACA,OACA,OACA,SACA,WACA,SACA,OACA,WACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,UACA,YACA,aACA,MACA,MACA,MACA,OACA,SACA,MACA,MACA,MACA,MACA,MACA,QACA,MACA,OACA,MACA,WACA,MACA,QACA,OACA,QACA,QACA,QACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,SACA,UACA,aACA,MACA,SACA,OACA,QACA,aACA,OACA,WACA,QACA,WACA,MACA,SACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,QACA,aACA,SACA,OACA,QACA,cACA,gBACA,OACA,QACA,MACA,MACA,MACA,OACA,WACA,MACA,MACA,MACA,MACA,MACA,MACA,UACA,UACA,QACA,MACA,MACA,MACA,UACA,YACA,YACA,eACA,MACA,MACA,MACA,iBACA,WACA,cACA,cACA,aACA,YACA,YACA,SACA,YACA,MACA,MACA,MACA,OACA,MACA,KACA,MACA,MACA,OACA,WACA,SACA,MACA,KACA,MACA,MACA,OACA,UACA,MACA,MACA,MACA,WACA,UACA,cACA,UACA,YACA,OACA,QACA,aACA,cACA,WACA,WACA,cACA,YACA,mBACA,gBACA,YACA,aACA,WACA,MACA,MACA,MACA,SACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,KACA,MACA,MACA,QACA,QACA,OACA,OACA,UACA,QACA,MACA,MACA,MACA,OACA,UACA,YACA,WACA,OACA,UACA,QACA,UACA,WACA,SACA,QACA,QACA,UACA,YACA,QACA,WACA,aACA,SACA,WACA,MACA,SACA,QACA,UACA,OACA,QACA,SACA,UACA,QACA,SACA,UACA,WACA,aACA,aACA,QACA,UACA,SACA,UACA,SACA,MACA,QACA,eACA,iBACA,WACA,aACA,SACA,WACA,OACA,SACA,MACA,MACA,YACA,MACA,MACA,MACA,QACA,YACA,WACA,WACA,YACA,aACA,YACA,aACA,YACA,aACA,QACA,SACA,MACA,gBACA,aACA,WACA,cACA,MACA,MACA,MACA,MACA,SACA,QACA,YACA,OACA,iBACA,gBACA,QACA,gBACA,WACA,OACA,QACA,MACA,UACA,MACA,KACA,MACA,MACA,MACA,QACA,SACA,UACA,MACA,MACA,MACA,MACA,QACA,OACA,SACA,MACA,MACA,QACA,SACA,UACA,SACA,QACA,WACA,SACA,UACA,WACA,OACA,SACA,UACA,QACA,cACA,QACA,UACA,SACA,cACA,WACA,UACA,aACA,WACA,YACA,WACA,WACA,UACA,WACA,WACA,aACA,YACA,SACA,QACA,SACA,UACA,WACA,UACA,WACA,WACA,UACA,QACA,SACA,SACA,QACA,YACA,cACA,SACA,QACA,UACA,WACA,YACA,SACA,UACA,WACA,cACA,QACA,QACA,MACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,YACA,OACA,QACA,OACA,UACA,WACA,MACA,MACA,MACA,SACA,SACA,SACA,OACA,UACA,MACA,OACA,MACA,MACA,UACA,UACA,SACA,OACA,MACA,KACA,SACA,MACA,MACA,MACA,MACA,MACA,MACA,SACA,iBACA,UACA,UACA,YACA,SACA,QACA,MACA,MACA,QACA,OACA,MACA,MACA,OACA,QACA,UACA,YACA,cACA,QACA,SACA,WACA,MACA,KACA,MACA,SACA,WACA,MACA,MACA,MACA,QACA,OACA,OACA,MACA,MACA,OACA,QACA,aACA,MACA,MACA,MACA,MACA,KACA,MACA,QACA,SACA,OACA,QACA,SACA,UACA,OACA,MACA,OACA,QACA,WACA,QACA,SACA,UACA,QACA,QACA,SACA,SACA,UACA,WACA,SACA,QACA,YACA,WACA,SACA,UACA,QACA,UACA,YACA,UACA,SACA,cACA,WACA,WACA,WACA,UACA,WACA,aACA,YACA,WACA,SACA,SACA,QACA,WACA,OACA,QACA,WACA,SACA,UACA,QACA,YACA,QACA,SACA,SACA,OACA,SACA,MACA,UACA,QACA,W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",
  "names": ["s", "$", "y", "M", "t", "e", "n", "r", "v", "i", "u", "D", "S", "w", "a", "m", "f", "l", "g", "o", "d", "c", "h", "k", "s", "e", "t", "n", "r", "i", "o", "a", "f", "h", "u", "d", "l", "c", "m", "M", "Y", "v", "D", "w", "y", "L", "t", "n", "i", "o", "r", "e", "u", "f", "s", "v", "a", "s", "t", "i", "e", "f", "n", "u", "o", "r", "v", "isCompatible", "DiagComponentLogger", "_i", "DiagLogLevel", "DiagAPI", "_i", "__spreadArray", "__read", "self", "BaseContext", "self", "context", "NoopContextManager", "_i", "__spreadArray", "__read", "API_NAME", "ContextAPI", "context", "_i", "__spreadArray", "__read", "TraceFlags", "NonRecordingSpan", "context", "NoopTracer", "context", "ProxyTracer", "context", "NoopTracerProvider", "ProxyTracerProvider", "SpanKind", "API_NAME", "TraceAPI", "getModelInfo", "model", "modelInfo", "models", "modelEntry", "v", "mappedModel", "exactMatch", "normalizedName", "normalizedMatch", "webCrypto", "randomUUID", "sha256", "data", "encoder", "inputData", "hashBuffer", "b", "Hash", "chunk", "encoding", "hash", "i", "char", "createHash", "algorithm", "SSEParser", "options", "controller", "error", "rawData", "lines", "line", "colonIndex", "field", "value", "retryValue", "parsedData", "e", "TextDecodeTransformer", "text", "TextDecoderStreamPolyfill", "defaultRetryConfig", "defaultTimeoutMs", "textDecoderStream", "AxAIServiceError", "message", "url", "requestBody", "responseBody", "context", "_depth", "_options", "AxAIServiceStatusError", "status", "statusText", "AxAIServiceNetworkError", "originalError", "AxAIServiceResponseError", "AxAIServiceStreamTerminatedError", "lastChunk", "AxAIServiceTimeoutError", "timeoutMs", "AxAIServiceAbortedError", "reason", "AxAIServiceAuthenticationError", "AxAIRefusalError", "refusalMessage", "requestId", "safeReadResponseBody", "response", "calculateRetryDelay", "attempt", "config", "createRequestMetrics", "updateRetryMetrics", "metrics", "shouldRetry", "apiCall", "api", "json", "retryConfig", "timeoutId", "baseUrl", "apiPath", "apiUrl", "combinedAbortController", "userAbortHandler", "originalAbort", "res", "delay", "resolve", "resJson", "chunkCount", "trackingStream", "closed", "reader", "read", "done", "streamMetrics", "axGlobals", "result", "axSpanAttributes", "axSpanEvents", "AxLLMRequestTypeValues", "AxSpanKindValues", "TypeTransformer", "transformFn", "doneCallback", "obj", "val", "RespTransformStream", "ColorLog", "colorCode", "colorLog", "defaultOutput", "axCreateDefaultColorLogger", "output", "tags", "formattedMessage", "colorFunction", "defaultLogger", "axCreateDefaultTextLogger", "axCreateOptimizerLogger", "msg", "baseLogger", "isFirstPhase", "trialsMatch", "optimizerMatch", "optimizerName", "match", "simpleMatch", "scoreMatch", "score", "axDefaultOptimizerLogger", "formatChatMessage", "hideContent", "hideSystemPrompt", "fn", "args", "logChatRequestMessage", "logger", "logChatRequest", "chatPrompt", "logResponseResult", "r", "loggedFunctionCalls", "f", "params", "logResponse", "resp", "logResponseDelta", "delta", "logFunctionResults", "results", "sanitizeLabels", "labels", "sanitized", "key", "stringValue", "globalAIMetricsInstruments", "getOrCreateAIMetricsInstruments", "meter", "createMetricsInstruments", "recordLatencyMetric", "instruments", "type", "duration", "aiService", "recordLatencyStatsMetrics", "meanLatency", "p95Latency", "p99Latency", "recordErrorMetric", "recordErrorRateMetric", "errorRate", "recordRequestMetric", "recordTokenMetric", "tokens", "recordStreamingRequestMetric", "isStreaming", "recordFunctionCallMetric", "functionName", "latency", "recordRequestSizeMetric", "sizeBytes", "recordResponseSizeMetric", "recordModelConfigMetrics", "temperature", "maxTokens", "recordEstimatedCostMetric", "costUSD", "recordPromptLengthMetric", "lengthChars", "recordContextWindowUsageMetric", "usageRatio", "recordTimeoutMetric", "recordAbortMetric", "recordThinkingBudgetUsageMetric", "tokensUsed", "recordMultimodalRequestMetric", "hasImages", "hasAudio", "axBaseAIDefaultConfig", "axBaseAIDefaultCreativeConfig", "AxBaseAI", "aiImpl", "name", "apiURL", "headers", "defaults", "supportFor", "embedModel", "validateModels", "samples", "percentile", "sorted", "a", "index", "metricsInstruments", "isError", "modelUsage", "promptTokens", "completionTokens", "totalTokens", "thoughtsTokens", "req", "part", "totalLength", "info", "promptCostPer1M", "completionCostPer1M", "modelName", "functionCalls", "call", "modelConfig", "promptLength", "requestSize", "chatResponse", "responseSize", "chatResult", "contextUsage", "estimatedCost", "startTime", "validateAxMessageArray", "SpanKind", "span", "cleanFn", "cleanParams", "chatReq", "debug", "functions", "apiConfig", "reqValue", "setChatRequestEvents", "rt", "rv", "respFn", "wrappedRespFn", "state", "tokenUsage", "setChatResponseEvents", "doneCb", "_values", "embedReq", "resValue", "item", "excludeContentFromTrace", "userMessages", "prompt", "eventData", "userEventData", "thoughTokens", "toolCalls", "values", "keys", "AxAIAnthropicModel", "AxAIAnthropicVertexModel", "axModelInfoAnthropic", "axAIAnthropicDefaultConfig", "axAIAnthropicVertexDefaultConfig", "AxAIAnthropicImpl", "isVertex", "stream", "toolsChoice", "system", "otherMessages", "messages", "createMessages", "tools", "stopSequences", "topP", "topK", "n", "thinkingConfig", "levels", "finishReason", "mapFinishReason", "showThoughts", "sstate", "contentBlock", "id", "usage", "AxAIAnthropic", "apiKey", "projectId", "region", "Config", "mi", "items", "content", "input", "mergeAssistantMessages", "mergedMessages", "cur", "lastMessage", "stopReason", "AxAIOpenAIModel", "AxAIOpenAIEmbedModel", "AxAIOpenAIResponsesModel", "axModelInfoOpenAI", "axModelInfoOpenAIResponses", "isOpenAIThinkingModel", "thinkingModels", "axAIOpenAIDefaultConfig", "axAIOpenAIBestConfig", "axAIOpenAICreativeConfig", "axAIOpenAIFastConfig", "AxAIOpenAIImpl", "streamingUsage", "chatReqUpdater", "frequencyPenalty", "store", "isThinkingModel", "choices", "choice", "role", "refusal", "thought", "annotations", "oaiFinishReason", "Id", "c", "AxAIOpenAIBase", "AxAIOpenAI", "axAIAzureOpenAIDefaultConfig", "axAIAzureOpenAICreativeConfig", "axAIAzureOpenAIFastConfig", "axAIAzureOpenAIBestConfig", "AxAIAzureOpenAI", "resourceName", "deploymentName", "version", "host", "AxBalancer", "_AxBalancer", "services", "cs", "aMetrics", "bMetrics", "failure", "retries", "lastFailureTime", "timeSinceLastFailure", "backoffMs", "gotNextService", "serviceWithModel", "service", "referenceModelList", "referenceKeys", "modelList", "serviceKeys", "AxAICohereModel", "AxAICohereEmbedModel", "axModelInfoCohere", "axAICohereDefaultConfig", "axAICohereCreativeConfig", "AxAICohereImpl", "_config", "lastChatMsg", "restOfChat", "chatHistory", "createHistory", "props", "toolResults", "chat", "t", "ss", "AxAICohere", "createToolCall", "outputs", "parameters", "AxAIDeepSeekModel", "axModelInfoDeepSeek", "axAIDeepSeekDefaultConfig", "axAIDeepSeekCodeConfig", "AxAIDeepSeek", "AxAIGoogleGeminiModel", "AxAIGoogleGeminiEmbedModel", "AxAIGoogleGeminiSafetyCategory", "AxAIGoogleGeminiSafetyThreshold", "AxAIGoogleGeminiEmbedTypes", "axModelInfoGoogleGemini", "safetySettings", "axAIGoogleGeminiDefaultConfig", "axAIGoogleGeminiDefaultCreativeConfig", "AxAIGoogleGeminiImpl", "endpointId", "pf", "keyValue", "systemPrompts", "p", "systemInstruction", "contents", "parts", "toolConfig", "allowedFunctionNames", "generationConfig", "candidate", "embeddings", "prediction", "embedding", "AxAIGoogleGemini", "path", "AxRateLimiterTokenUsage", "refillRate", "now", "tokensToAdd", "AxAIGroqModel", "axModelInfoGroq", "axAIGroqDefaultConfig", "AxAIGroq", "Options", "rateLimiter", "tokensPerMin", "func", "axModelInfoHuggingFace", "AxAIHuggingFaceModel", "axAIHuggingFaceDefaultConfig", "axAIHuggingFaceCreativeConfig", "AxAIHuggingFaceImpl", "functionsList", "fc", "inputs", "AxAIHuggingFace", "AxAIMistralModel", "AxAIMistralEmbedModels", "axModelInfoMistral", "axAIMistralDefaultConfig", "axAIMistralBestConfig", "AxAIMistral", "max_completion_tokens", "messagesUpdated", "contentUpdated", "AxMockAIService", "_model", "sortedSamples", "p95Index", "p99Index", "totalRequests", "AxMultiServiceRouter", "description", "isInternal", "otherService", "modelKey", "_", "reqWithoutModel", "embedModelKey", "reqWithoutEmbedModel", "s", "serviceInstance", "firstServiceEntry", "entry", "axAIOllamaDefaultConfig", "axAIOllamaDefaultCreativeConfig", "AxAIOllama", "isOpenAIResponsesThinkingModel", "AxAIOpenAIResponsesImpl", "responsesReqUpdater", "ExhaustiveCheck", "excludeSystemMessages", "mappedContent", "assistantMessage", "invalidRole", "instructionsFromPrompt", "systemMessageFoundAndUsed", "finalInstructions", "includeFields", "reasoningSummary", "reasoningEffort", "mutableReq", "inputItems", "currentReasoning", "finalReqToProcess", "currentResult", "contentToText", "streamEvent", "event", "baseResult", "remoteId", "fileSearchItem", "webSearchItem", "computerItem", "codeItem", "imageItem", "shellItem", "mcpItem", "responseId", "refusalContent", "axAIOpenAIResponsesDefaultConfig", "axAIOpenAIResponsesBestConfig", "axAIOpenAIResponsesCreativeConfig", "AxAIOpenAIResponsesBase", "formattedModels", "AxAIOpenAIResponses", "AxAIRekaModel", "axModelInfoReka", "axAIRekaDefaultConfig", "axAIRekaBestConfig", "axAIRekaCreativeConfig", "axAIRekaFastConfig", "AxAIRekaImpl", "responses", "AxAIReka", "axModelInfoTogether", "axAITogetherDefaultConfig", "AxAITogether", "axValidateChatRequestMessage", "systemItem", "userItem", "contentItem", "contentType", "textItem", "audioItem", "assistantItem", "functionItem", "axValidateChatResponseResult", "resultsArray", "arrayIndex", "annotation", "callIndex", "functionCall", "validFinishReasons", "AxAI", "AxAIGrokModel", "AxAIGrokEmbedModels", "axModelInfoGrok", "axAIGrokDefaultConfig", "axAIGrokBestConfig", "AxAIGrok", "searchParams", "source", "AxDBBase", "fetch", "tracer", "update", "baseURL", "AxDBCloudflare", "accountId", "_update", "batchReq", "table", "metadata", "AxDBMemory", "ids", "matches", "distance", "dotProduct", "normA", "normB", "zeroVectorA", "zeroVectorB", "vectorA", "vectorB", "sqrtNormA", "sqrtNormB", "createPineconeQueryRequest", "AxDBPinecone", "AxDBWeaviate", "objects", "filter", "resMatches", "AxDB", "AxDBManager", "ai", "db", "chunkerInput", "initialChunks", "maxWordsPerChunk", "minWordsPerChunk", "chunks", "processChunks", "bs", "batch", "query", "topPercent", "abortSignal", "texts", "rewrittenQuery", "queries", "queryResults", "m", "tp", "resultItems", "getTopInPercent", "rankedItems", "currentChunk", "currentWordCount", "words", "wordCount", "remainingWords", "slice", "entries", "percent", "sortedEntries", "topTenPercentCount", "MemoryImpl", "debugRequest", "lastItem", "debugFunctionResults", "debugResponse", "log", "debugResponseDelta", "tagIndex", "indices", "acc", "AxMemory", "sessionId", "AxAssertionError", "extraFields", "assertAssertions", "asserts", "assert", "assertStreamingAssertions", "xstate", "final", "fieldAsserts", "currValue", "ValidationError", "fields", "toFieldType", "baseType", "validateJSONSchema", "schema", "errors", "validateSchemaObject", "validTypes", "subSchema", "requiredProp", "errorMessage", "AxFunctionError", "FunctionError", "funcId", "fieldName", "fieldSchema", "bulletPoints", "fieldError", "schemaDescription", "AxFunctionProcessor", "funcList", "fnSpec", "opt", "parseFunctions", "newFuncs", "existingFuncs", "processFunctions", "functionList", "mem", "traceId", "functionResultFormatter", "funcProc", "functionsExecuted", "promises", "functionResult", "errorEventData", "functionResults", "parseFunctionCalls", "createFunctionConfig", "definedFunctionCall", "firstStep", "axDefaultMetricsConfig", "globalGenMetricsInstruments", "getOrCreateGenMetricsInstruments", "activeMeter", "createGenMetricsInstruments", "axCheckMetricsHealth", "issues", "currentMetricsConfig", "axUpdateMetricsConfig", "axGetMetricsConfig", "maxLength", "recordGenerationMetric", "success", "signatureName", "recordMultiStepMetric", "stepsUsed", "maxSteps", "recordValidationErrorMetric", "errorType", "recordErrorCorrectionMetric", "attempts", "maxRetries", "recordFunctionCallingMetric", "functionsEnabled", "hadFunctionCalls", "functionErrorCorrection", "recordFieldProcessingMetric", "fieldProcessorsExecuted", "streamingFieldProcessorsExecuted", "recordStreamingMetric", "deltasEmitted", "finalizationDuration", "recordSamplesMetric", "samplesCount", "resultPickerUsed", "resultPickerLatency", "recordSignatureComplexityMetrics", "inputFields", "outputFields", "examplesCount", "demosCount", "recordPerformanceMetric", "metricType", "mergeFunctionCalls", "functionCallDeltas", "Fc", "dayjs", "utc", "timezone", "customParseFormat", "parseLLMFriendlyDate", "dateStr", "required", "ParseLlmFriendlyDate", "err", "parseLLMFriendlyDateTime", "ParseLlmFriendlyDateTime", "dateTimeStr", "dateTimeRegex", "dateTime", "timeZone", "format", "date", "formatDateWithTimezone", "updateProgressBar", "current", "total", "_elapsedTime", "progressBarWidth", "percentage", "filledBarLength", "emptyBarLength", "filledBar", "emptyBar", "successRate", "friendlyMsg", "validateValue", "ft", "validateSingleValue", "expectedType", "validImage", "validAudio", "isValid", "gotType", "mergeProgramUsage", "usages", "usageMap", "currentUsage", "parseMarkdownList", "listBullets", "numberedListRegex", "list", "trimmedLine", "mergeDeltas", "base", "currentDelta", "target", "baseValue", "deltaValue", "LRUCache", "maxSize", "firstKey", "globalPrefixCache", "matchesContent", "prefix", "startIndex", "prefixCache", "exactMatchIndex", "prefixes", "longestPartialMatch", "partialPrefix", "formatTime", "ms", "seconds", "minutes", "remainingSeconds", "hours", "remainingMinutes", "calculateETA", "elapsedMs", "msPerItem", "remainingItems", "etaMs", "updateDetailedProgress", "roundIndex", "elapsedTime", "example", "stats", "configInfo", "formattedTime", "eta", "exampleKeys", "k", "valueStr", "truncated", "resultStr", "truncatedResult", "extractValues", "sig", "strictMode", "streamingExtractValues", "streamingExtractFinalValue", "checkMissingRequiredFields", "_xstate", "missingFields", "skipEarlyFail", "expectedField", "prefixLen", "parsedValue", "validateAndParseFieldValue", "convertValueToType", "extractBlock", "className", "yieldDelta", "fieldIsArray", "fieldTypeName", "pos", "isFirstChunk", "d1", "d2", "d3", "streamValues", "prevField", "fieldValue", "processFieldProcessors", "fieldProcessors", "processor", "processFn", "addToMemory", "processStreamingFieldProcessors", "resultText", "_key", "getFieldProcessingMessage", "isCodeField", "fieldTitle", "processStreamingResponse", "states", "ProcessStreamingResponse", "finalizeStreamingResponse", "signature", "streamingFieldProcessors", "thoughtFieldName", "streamingAsserts", "funcs", "fx", "processResponse", "deltas", "shouldContinueSteps", "stopFunction", "lastMemItem", "stopFunctionExecuted", "isFunction", "isProcessor", "tag", "AxInstanceRegistry", "instance", "SignatureValidationError", "position", "suggestion", "SignatureParser", "optionalDesc", "remaining", "inputNames", "outputNames", "outputField", "start", "end", "before", "after", "pointer", "parseFieldFn", "section", "isOptional", "typeName", "isArray", "desc", "classNamesString", "fieldType", "suggestions", "camelCaseRegex", "snakeCaseRegex", "types", "foundType", "currentWord", "baseMessage", "suggestionPart", "fullMessage", "invalidMatch", "invalidId", "quoteChars", "quoteChar", "escaped", "startPos", "partialString", "strOrRegex", "found", "parseSignature", "AxSignatureValidationError", "AxSignature", "_AxSignature", "title", "parsedField", "validateField", "existingField", "inputField", "parsedFields", "parsed", "properties", "renderSignature", "renderField", "descriptionPart", "inputFieldsRendered", "outputFieldsRendered", "isValidCase", "inputString", "validateFieldType", "option", "trimmedOption", "AxProgram", "prog", "_ai", "child", "parentId", "examples", "traces", "Traces", "cu", "demos", "hasChildren", "hasMatchingDemo", "demo", "functionCallInstructions", "formattingRules", "AxPromptTemplate", "fieldTemplates", "task", "inArgs", "renderDescFields", "outArgs", "formatDescription", "renderInputFields", "renderOutputFields", "renderedExamples", "renderedDemos", "examplesInSystemPrompt", "completion", "combineConsecutiveStrings", "allTextExamples", "allTextDemos", "systemContent", "combinedItems", "systemPrompt", "history", "firstItem", "userContent", "groupedFields", "valuesList", "exampleContext", "renderedInputItem", "renderedOutputItem", "renderedItem", "demoContext", "inputRenderedItems", "outputRenderedItems", "renderedItems", "isEmptyValue", "processedValue", "processValue", "validateImage", "validated", "validateAudio", "requiredMsg", "separator", "previous", "str", "checkForFunctionCalls", "hasFunctionResults", "extractFunctionResults", "assistantMessages", "functionMessages", "assistantMsg", "funcCall", "funcResult", "selectFromSamples", "buffer", "resultPicker", "selectedIndex", "fieldResults", "selectFromSamplesInMemory", "lastMemory", "handleValidationError", "errorFields", "promptTemplate", "AxGen", "promptTemplateOptions", "streaming", "traceContext", "thinkingTokenBudget", "debugHideSystemPrompt", "memOptions", "promptTemplateClass", "currentPromptTemplateOptions", "promptRenderStart", "promptRenderDuration", "memoryUpdateStart", "memoryUpdateDuration", "multiStepLoop", "errCount", "generator", "allFunctionsExecuted", "e1", "assertionMetricsInstruments", "enhanceError", "stateCreationStart", "stateCreationDuration", "funcNames", "attributes", "traceLabel", "spanName", "currentContext", "trace", "errorCorrectionAttempts", "currentVersion", "resultPickerStart", "finalMetricsInstruments", "selectedResult", "AxGenerateError", "details", "trimNonAlphaNum", "splitIntoTwo", "matchResult", "firstPart", "secondPart", "dedup", "seq", "seen", "x", "extractIdAndText", "extractIndexPrefixedText", "batchArray", "arr", "size", "chunkedArr", "AxStringUtil", "AxDefaultResultReranker", "sortedIndexes", "originalIndex", "AxApacheTika", "Args", "fileData", "acceptValue", "fetchOptions", "files", "uploadPromises", "batchResults", "AxSimpleClassifierClass", "AxSimpleClassifier", "classes", "ret", "cutoff", "matchedClass", "stopwords", "filterTokens", "exclusions", "token", "countTokens", "counter", "normalizeText", "normalized", "emScore", "groundTruth", "f1Score", "predictionTokens", "groundTruthTokens", "predictionCounts", "groundTruthCounts", "numSame", "v1", "v2", "precision", "recall", "novelF1ScoreOptimized", "returnRecall", "historyTokens", "f1", "AxEvalUtil", "AxTestPrompt", "program", "metricFn", "st", "sumOfScores", "ex", "et", "averageScore", "AxHFDataLoader", "dataset", "split", "offset", "length", "ds", "rows", "count", "renameMap", "resultFieldName", "axDefaultOptimizerMetricsConfig", "globalOptimizerMetricsInstruments", "getOrCreateOptimizerMetricsInstruments", "createOptimizerMetricsInstruments", "currentOptimizerMetricsConfig", "axUpdateOptimizerMetricsConfig", "axGetOptimizerMetricsConfig", "sanitizeOptimizerLabels", "recordOptimizationMetric", "optimizerType", "programSignature", "recordConvergenceMetric", "rounds", "currentScore", "improvement", "stagnationRounds", "recordEarlyStoppingMetric", "recordResourceUsageMetric", "costIncurred", "memoryUsage", "recordOptimizationDurationMetric", "recordTeacherStudentMetric", "scoreImprovement", "recordCheckpointMetric", "operation", "recordParetoMetric", "frontSize", "solutionsGenerated", "hypervolume", "recordProgramComplexityMetric", "validationSetSize", "recordOptimizerPerformanceMetric", "recordOptimizerConfigurationMetric", "targetScore", "maxRounds", "AxDefaultCostTracker", "totalCost", "costPer1K", "AxBaseOptimizer", "costTracker", "seed", "bestScoreRound", "preferTeacher", "solutions", "constraintSolutions", "allSolutions", "paretoFront", "bestScore", "sol", "sampleExample", "samplePrediction", "sampleScores", "objectives", "weightCombinations", "weights", "weightedMetric", "scores", "weightedScore", "objective", "primaryObjective", "constraintMetric", "primaryScore", "penalty", "combinations", "equalWeights", "obj1", "obj2", "w1", "w2", "obj3", "valSet", "allScores", "testProgram", "evalSet", "avgScores", "sum", "solutionA", "isDominated", "dominatedCount", "j", "solutionB", "scoresA", "scoresB", "atLeastAsGood", "strictlyBetter", "scoreA", "scoreB", "firstSolution", "sortedSolutions", "prevScore2", "solution", "score1", "score2", "optimizerConfig", "bestConfiguration", "optimizerState", "saveFn", "checkpointId", "checkpoint", "loadFn", "round", "interval", "configuration", "currentCost", "AxBootstrapFewShot", "maxDemos", "aiOpt", "randomSample", "previousSuccessCount", "exList", "groupTracesByKeys", "programTraces", "groupedTraces", "programTrace", "programDemosArray", "programId", "array", "clonedArray", "caI", "caJ", "AxMiPRO", "level", "summaryPrompt", "sampleSize", "tip", "candidateIndex", "programSummary", "datasetSummary", "previousInstructions", "contextInfo", "instructionPrompt", "instruction", "enhancedTemplates", "instructions", "aiToUse", "tips", "tipIndex", "tipToUse", "selectedExamples", "idx", "bootstrappedDemos", "labeledExamples", "validationExamples", "bestConfig", "scoreHistory", "startRound", "currentTrial", "totalScore", "evalSize", "baseSize", "axMajorityVotePicker", "shuffled", "miproOptions", "optimizedGen", "axgen", "similarConfigs", "mean", "variance", "similarities", "diff", "totalWeight", "std", "z", "phi", "pdfValue", "a1", "a2", "a3", "a4", "a5", "sign", "absX", "y", "candidates", "numCandidates", "acquisitionValue", "counts", "sample", "bestKey", "bestCount", "strings", "isAxFieldType", "fieldNameMatch", "modifiedFieldName", "_o", "_i", "typeNoFlags", "convertFieldTypeToString", "isAxFieldDescriptor", "convertFieldDescriptorToString", "convertValueToSignatureString", "ax", "sigString", "arrowIndex", "descriptor", "language", "AxFlowDependencyAnalyzer", "mapping", "_nodeName", "dependencies", "stateAccessMatches", "tracker", "_target", "prop", "AxFlowExecutionPlanner", "stepFunction", "nodeName", "produces", "step", "processedSteps", "availableFields", "currentLevel", "currentLevelSteps", "dep", "optimizedSteps", "group", "parallelStep", "mergedState", "g", "AxFlow", "signatureOrAxGenOrClass", "programInstance", "transform", "currentBranch", "label", "dynamicContext", "nodeProgram", "nodeInputs", "predicate", "branchContext", "branchValue", "branchSteps", "currentState", "branches", "branchFn", "subContext", "AxFlowSubContextImpl", "resultKey", "mergeFunction", "mergedValue", "newState", "condition", "targetLabel", "maxIterations", "targetIndex", "feedbackStepIndex", "iterations", "iterationKey", "loopStartIndex", "placeholderStep", "loopBodySteps", "planInfo", "nodeGenerators", "initialState", "AxFlowTypedSubContextImpl", "AxDockerSession", "imageName", "volumes", "doNotPullImage", "binds", "containerConfig", "matchingContainers", "container", "randomIndex", "selectedContainer", "containerId", "remove", "timeout", "containers", "targetContainers", "stopResponse", "removeResponse", "all", "command", "createResponse", "execData", "startResponse", "endpoint", "AxEmbeddingAdapter", "extra", "embeds", "AxMCPClient", "transport", "expectedProtocolVersion", "override", "o", "pingPromise", "timeoutPromise", "reject", "method", "request", "responsePromise", "errorObj", "notification", "AxMCPHTTPSSETransport", "sseUrl", "AxMCPStreambleHTTPTransport", "mcpEndpoint", "authorization", "baseHeaders", "handler", "decoder", "processStream", "sessionIdHeader", "processChunk", "processChildAgentFunction", "childFunction", "parentValues", "parentInputKeys", "processedFunction", "childKeys", "injectionKeys", "removePropertiesFromSchema", "originalFunc", "childArgs", "funcOptions", "valuesToInject", "lastUserMessage", "pick", "updatedChildArgs", "addModelParameter", "descriptionError", "definitionError", "AxAgent", "definition", "agents", "disableSmartModelRouting", "excludeFieldsFromPassthrough", "agent", "toCamelCase", "mm", "boundFunc", "wrappedFunc", "valuesAndModel", "outFields", "parentAi", "parentKeys", "agentFuncs", "processOptions", "word", "lowerWord", "baseSchema", "modelProperty", "newProperties", "newRequired", "newSchema", "filteredRequired", "AxChainOfThought", "AxRAG", "queryFn", "qsig", "question", "hop", "queryResult"]
}
