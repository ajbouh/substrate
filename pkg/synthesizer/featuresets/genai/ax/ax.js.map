{
  "version": 3,
  "sources": ["../../../../../../ax/node_modules/dayjs/dayjs.min.js", "../../../../../../ax/node_modules/dayjs/plugin/customParseFormat.js", "../../../../../../ax/node_modules/dayjs/plugin/timezone.js", "../../../../../../ax/node_modules/dayjs/plugin/utc.js", "../../../../../../ax/node_modules/@opentelemetry/api/src/platform/browser/globalThis.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/version.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/internal/semver.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/internal/global-utils.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/diag/types.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/api/diag.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/context/context.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/context/NoopContextManager.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/api/context.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/trace_flags.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/invalid-span-constants.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/context-utils.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/NoopTracer.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace/span_kind.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/context-api.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/api/trace.ts", "../../../../../../ax/node_modules/@opentelemetry/api/src/trace-api.ts", "../../../../../../ax/src/ax/dsp/modelinfo.ts", "../../../../../../ax/src/ax/util/crypto.ts", "../../../../../../ax/src/ax/util/sse.ts", "../../../../../../ax/src/ax/util/stream.ts", "../../../../../../ax/src/ax/util/apicall.ts", "../../../../../../ax/src/ax/ai/base.ts", "../../../../../../ax/src/ax/dsp/globals.ts", "../../../../../../ax/src/ax/util/log.ts", "../../../../../../ax/src/ax/dsp/loggers.ts", "../../../../../../ax/src/ax/trace/trace.ts", "../../../../../../ax/src/ax/util/transform.ts", "../../../../../../ax/src/ax/ai/util.ts", "../../../../../../ax/src/ax/ai/debug.ts", "../../../../../../ax/src/ax/ai/metrics.ts", "../../../../../../ax/src/ax/ai/anthropic/types.ts", "../../../../../../ax/src/ax/ai/anthropic/info.ts", "../../../../../../ax/src/ax/ai/anthropic/api.ts", "../../../../../../ax/src/ax/ai/openai/chat_types.ts", "../../../../../../ax/src/ax/ai/openai/responses_types.ts", "../../../../../../ax/src/ax/ai/openai/info.ts", "../../../../../../ax/src/ax/ai/openai/api.ts", "../../../../../../ax/src/ax/ai/azure-openai/api.ts", "../../../../../../ax/src/ax/ai/balance.ts", "../../../../../../ax/src/ax/ai/capabilities.ts", "../../../../../../ax/src/ax/ai/cohere/types.ts", "../../../../../../ax/src/ax/ai/cohere/info.ts", "../../../../../../ax/src/ax/ai/cohere/api.ts", "../../../../../../ax/src/ax/ai/deepseek/types.ts", "../../../../../../ax/src/ax/ai/deepseek/info.ts", "../../../../../../ax/src/ax/ai/deepseek/api.ts", "../../../../../../ax/src/ax/ai/google-gemini/types.ts", "../../../../../../ax/src/ax/ai/google-gemini/info.ts", "../../../../../../ax/src/ax/ai/google-gemini/api.ts", "../../../../../../ax/src/ax/util/rate-limit.ts", "../../../../../../ax/src/ax/ai/groq/types.ts", "../../../../../../ax/src/ax/ai/groq/info.ts", "../../../../../../ax/src/ax/ai/groq/api.ts", "../../../../../../ax/src/ax/ai/huggingface/info.ts", "../../../../../../ax/src/ax/ai/huggingface/types.ts", "../../../../../../ax/src/ax/ai/huggingface/api.ts", "../../../../../../ax/src/ax/ai/mistral/types.ts", "../../../../../../ax/src/ax/ai/mistral/info.ts", "../../../../../../ax/src/ax/ai/mistral/api.ts", "../../../../../../ax/src/ax/ai/mock/api.ts", "../../../../../../ax/src/ax/ai/multiservice.ts", "../../../../../../ax/src/ax/ai/ollama/api.ts", "../../../../../../ax/src/ax/ai/openai/responses_api.ts", "../../../../../../ax/src/ax/ai/openai/responses_api_base.ts", "../../../../../../ax/src/ax/ai/processor.ts", "../../../../../../ax/src/ax/ai/reka/types.ts", "../../../../../../ax/src/ax/ai/reka/info.ts", "../../../../../../ax/src/ax/ai/reka/api.ts", "../../../../../../ax/src/ax/ai/router.ts", "../../../../../../ax/src/ax/ai/together/info.ts", "../../../../../../ax/src/ax/ai/together/api.ts", "../../../../../../ax/src/ax/ai/validate.ts", "../../../../../../ax/src/ax/ai/webllm/types.ts", "../../../../../../ax/src/ax/ai/webllm/info.ts", "../../../../../../ax/src/ax/ai/webllm/api.ts", "../../../../../../ax/src/ax/ai/x-grok/types.ts", "../../../../../../ax/src/ax/ai/x-grok/info.ts", "../../../../../../ax/src/ax/ai/x-grok/api.ts", "../../../../../../ax/src/ax/ai/wrap.ts", "../../../../../../ax/src/ax/db/base.ts", "../../../../../../ax/src/ax/db/cloudflare.ts", "../../../../../../ax/src/ax/db/memory.ts", "../../../../../../ax/src/ax/db/pinecone.ts", "../../../../../../ax/src/ax/db/weaviate.ts", "../../../../../../ax/src/ax/db/wrap.ts", "../../../../../../ax/src/ax/docs/manager.ts", "../../../../../../ax/src/ax/dsp/generate.ts", "../../../../../../ax/src/ax/mem/memory.ts", "../../../../../../ax/src/ax/dsp/asserts.ts", "../../../../../../ax/src/ax/dsp/metrics.ts", "../../../../../../ax/src/ax/dsp/errors.ts", "../../../../../../ax/src/ax/dsp/jsonschema.ts", "../../../../../../ax/src/ax/dsp/functions.ts", "../../../../../../ax/src/ax/dsp/datetime.ts", "../../../../../../ax/src/ax/dsp/util.ts", "../../../../../../ax/src/ax/dsp/extract.ts", "../../../../../../ax/src/ax/dsp/fieldProcessor.ts", "../../../../../../ax/src/ax/dsp/processResponse.ts", "../../../../../../ax/src/ax/dsp/registry.ts", "../../../../../../ax/src/ax/dsp/parser.ts", "../../../../../../ax/src/ax/dsp/sig.ts", "../../../../../../ax/src/ax/dsp/program.ts", "../../../../../../ax/src/ax/dsp/prompt.ts", "../../../../../../ax/src/ax/dsp/samples.ts", "../../../../../../ax/src/ax/dsp/strutil.ts", "../../../../../../ax/src/ax/docs/reranker.ts", "../../../../../../ax/src/ax/docs/tika.ts", "../../../../../../ax/src/ax/dsp/classifier.ts", "../../../../../../ax/src/ax/dsp/stopwords.ts", "../../../../../../ax/src/ax/dsp/eval.ts", "../../../../../../ax/src/ax/dsp/evaluate.ts", "../../../../../../ax/src/ax/dsp/loader.ts", "../../../../../../ax/src/ax/dsp/optimizerLogging.ts", "../../../../../../ax/src/ax/dsp/optimizer.ts", "../../../../../../ax/src/ax/dsp/optimizers/bootstrapFewshot.ts", "../../../../../../ax/src/ax/dsp/optimizers/pythonOptimizerClient.ts", "../../../../../../ax/src/ax/dsp/optimizers/miproV2.ts", "../../../../../../ax/src/ax/dsp/template.ts", "../../../../../../ax/src/ax/flow/dependencyAnalyzer.ts", "../../../../../../ax/src/ax/flow/batchUtil.ts", "../../../../../../ax/src/ax/flow/executionPlanner.ts", "../../../../../../ax/src/ax/flow/logger.ts", "../../../../../../ax/src/ax/flow/subContext.ts", "../../../../../../ax/src/ax/flow/flow.ts", "../../../../../../ax/src/ax/funcs/docker.ts", "../../../../../../ax/src/ax/funcs/embed.ts", "../../../../../../ax/src/ax/mcp/client.ts", "../../../../../../ax/src/ax/mcp/httpTransport.ts", "../../../../../../ax/src/ax/prompts/agent.ts", "../../../../../../ax/src/ax/prompts/rag.ts"],
  "sourcesContent": ["!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){\"use strict\";var t=1e3,e=6e4,n=36e5,r=\"millisecond\",i=\"second\",s=\"minute\",u=\"hour\",a=\"day\",o=\"week\",c=\"month\",f=\"quarter\",h=\"year\",d=\"date\",l=\"Invalid Date\",$=/^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/,y=/\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:\"en\",weekdays:\"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday\".split(\"_\"),months:\"January_February_March_April_May_June_July_August_September_October_November_December\".split(\"_\"),ordinal:function(t){var e=[\"th\",\"st\",\"nd\",\"rd\"],n=t%100;return\"[\"+t+(e[(n-20)%10]||e[n]||e[0])+\"]\"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:\"\"+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?\"+\":\"-\")+m(r,2,\"0\")+\":\"+m(i,2,\"0\")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||\"\").toLowerCase().replace(/s$/,\"\")},u:function(t){return void 0===t}},g=\"en\",D={};D[g]=M;var p=\"$isDayjsObject\",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if(\"string\"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split(\"-\");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n=\"object\"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if(\"string\"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||\"0\").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate(\"s\"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v=\"set\"+(this.$u?\"UTC\":\"\");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+\"Hours\",0);case u:return $(v+\"Minutes\",1);case s:return $(v+\"Seconds\",2);case i:return $(v+\"Milliseconds\",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f=\"set\"+(this.$u?\"UTC\":\"\"),l=(n={},n[a]=f+\"Date\",n[d]=f+\"Date\",n[c]=f+\"Month\",n[h]=f+\"FullYear\",n[u]=f+\"Hours\",n[s]=f+\"Minutes\",n[i]=f+\"Seconds\",n[r]=f+\"Milliseconds\",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||\"YYYY-MM-DDTHH:mm:ssZ\",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,\"0\")},$=f||function(t,e,n){var r=t<12?\"AM\":\"PM\";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case\"YY\":return String(e.$y).slice(-2);case\"YYYY\":return b.s(e.$y,4,\"0\");case\"M\":return a+1;case\"MM\":return b.s(a+1,2,\"0\");case\"MMM\":return h(n.monthsShort,a,c,3);case\"MMMM\":return h(c,a);case\"D\":return e.$D;case\"DD\":return b.s(e.$D,2,\"0\");case\"d\":return String(e.$W);case\"dd\":return h(n.weekdaysMin,e.$W,o,2);case\"ddd\":return h(n.weekdaysShort,e.$W,o,3);case\"dddd\":return o[e.$W];case\"H\":return String(s);case\"HH\":return b.s(s,2,\"0\");case\"h\":return d(1);case\"hh\":return d(2);case\"a\":return $(s,u,!0);case\"A\":return $(s,u,!1);case\"m\":return String(u);case\"mm\":return b.s(u,2,\"0\");case\"s\":return String(e.$s);case\"ss\":return b.s(e.$s,2,\"0\");case\"SSS\":return b.s(e.$ms,3,\"0\");case\"Z\":return i}return null}(t)||i.replace(\":\",\"\")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[[\"$ms\",r],[\"$s\",i],[\"$m\",s],[\"$H\",u],[\"$W\",a],[\"$M\",c],[\"$y\",h],[\"$D\",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));", "!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(t):(e=\"undefined\"!=typeof globalThis?globalThis:e||self).dayjs_plugin_customParseFormat=t()}(this,(function(){\"use strict\";var e={LTS:\"h:mm:ss A\",LT:\"h:mm A\",L:\"MM/DD/YYYY\",LL:\"MMMM D, YYYY\",LLL:\"MMMM D, YYYY h:mm A\",LLLL:\"dddd, MMMM D, YYYY h:mm A\"},t=/(\\[[^[]*\\])|([-_:/.,()\\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,n=/\\d/,r=/\\d\\d/,i=/\\d\\d?/,o=/\\d*[^-_:/,()\\s\\d]+/,s={},a=function(e){return(e=+e)+(e>68?1900:2e3)};var f=function(e){return function(t){this[e]=+t}},h=[/[+-]\\d\\d:?(\\d\\d)?|Z/,function(e){(this.zone||(this.zone={})).offset=function(e){if(!e)return 0;if(\"Z\"===e)return 0;var t=e.match(/([+-]|\\d\\d)/g),n=60*t[1]+(+t[2]||0);return 0===n?0:\"+\"===t[0]?-n:n}(e)}],u=function(e){var t=s[e];return t&&(t.indexOf?t:t.s.concat(t.f))},d=function(e,t){var n,r=s.meridiem;if(r){for(var i=1;i<=24;i+=1)if(e.indexOf(r(i,0,t))>-1){n=i>12;break}}else n=e===(t?\"pm\":\"PM\");return n},c={A:[o,function(e){this.afternoon=d(e,!1)}],a:[o,function(e){this.afternoon=d(e,!0)}],Q:[n,function(e){this.month=3*(e-1)+1}],S:[n,function(e){this.milliseconds=100*+e}],SS:[r,function(e){this.milliseconds=10*+e}],SSS:[/\\d{3}/,function(e){this.milliseconds=+e}],s:[i,f(\"seconds\")],ss:[i,f(\"seconds\")],m:[i,f(\"minutes\")],mm:[i,f(\"minutes\")],H:[i,f(\"hours\")],h:[i,f(\"hours\")],HH:[i,f(\"hours\")],hh:[i,f(\"hours\")],D:[i,f(\"day\")],DD:[r,f(\"day\")],Do:[o,function(e){var t=s.ordinal,n=e.match(/\\d+/);if(this.day=n[0],t)for(var r=1;r<=31;r+=1)t(r).replace(/\\[|\\]/g,\"\")===e&&(this.day=r)}],w:[i,f(\"week\")],ww:[r,f(\"week\")],M:[i,f(\"month\")],MM:[r,f(\"month\")],MMM:[o,function(e){var t=u(\"months\"),n=(u(\"monthsShort\")||t.map((function(e){return e.slice(0,3)}))).indexOf(e)+1;if(n<1)throw new Error;this.month=n%12||n}],MMMM:[o,function(e){var t=u(\"months\").indexOf(e)+1;if(t<1)throw new Error;this.month=t%12||t}],Y:[/[+-]?\\d+/,f(\"year\")],YY:[r,function(e){this.year=a(e)}],YYYY:[/\\d{4}/,f(\"year\")],Z:h,ZZ:h};function l(n){var r,i;r=n,i=s&&s.formats;for(var o=(n=r.replace(/(\\[[^\\]]+])|(LTS?|l{1,4}|L{1,4})/g,(function(t,n,r){var o=r&&r.toUpperCase();return n||i[r]||e[r]||i[o].replace(/(\\[[^\\]]+])|(MMMM|MM|DD|dddd)/g,(function(e,t,n){return t||n.slice(1)}))}))).match(t),a=o.length,f=0;f<a;f+=1){var h=o[f],u=c[h],d=u&&u[0],l=u&&u[1];o[f]=l?{regex:d,parser:l}:h.replace(/^\\[|\\]$/g,\"\")}return function(e){for(var t={},n=0,r=0;n<a;n+=1){var i=o[n];if(\"string\"==typeof i)r+=i.length;else{var s=i.regex,f=i.parser,h=e.slice(r),u=s.exec(h)[0];f.call(t,u),e=e.replace(u,\"\")}}return function(e){var t=e.afternoon;if(void 0!==t){var n=e.hours;t?n<12&&(e.hours+=12):12===n&&(e.hours=0),delete e.afternoon}}(t),t}}return function(e,t,n){n.p.customParseFormat=!0,e&&e.parseTwoDigitYear&&(a=e.parseTwoDigitYear);var r=t.prototype,i=r.parse;r.parse=function(e){var t=e.date,r=e.utc,o=e.args;this.$u=r;var a=o[1];if(\"string\"==typeof a){var f=!0===o[2],h=!0===o[3],u=f||h,d=o[2];h&&(d=o[2]),s=this.$locale(),!f&&d&&(s=n.Ls[d]),this.$d=function(e,t,n,r){try{if([\"x\",\"X\"].indexOf(t)>-1)return new Date((\"X\"===t?1e3:1)*e);var i=l(t)(e),o=i.year,s=i.month,a=i.day,f=i.hours,h=i.minutes,u=i.seconds,d=i.milliseconds,c=i.zone,m=i.week,M=new Date,Y=a||(o||s?1:M.getDate()),p=o||M.getFullYear(),v=0;o&&!s||(v=s>0?s-1:M.getMonth());var D,w=f||0,g=h||0,y=u||0,L=d||0;return c?new Date(Date.UTC(p,v,Y,w,g,y,L+60*c.offset*1e3)):n?new Date(Date.UTC(p,v,Y,w,g,y,L)):(D=new Date(p,v,Y,w,g,y,L),m&&(D=r(D).week(m).toDate()),D)}catch(e){return new Date(\"\")}}(t,a,r,n),this.init(),d&&!0!==d&&(this.$L=this.locale(d).$L),u&&t!=this.format(a)&&(this.$d=new Date(\"\")),s={}}else if(a instanceof Array)for(var c=a.length,m=1;m<=c;m+=1){o[1]=a[m-1];var M=n.apply(this,o);if(M.isValid()){this.$d=M.$d,this.$L=M.$L,this.init();break}m===c&&(this.$d=new Date(\"\"))}else i.call(this,e)}}}));", "!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e():\"function\"==typeof define&&define.amd?define(e):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_timezone=e()}(this,(function(){\"use strict\";var t={year:0,month:1,day:2,hour:3,minute:4,second:5},e={};return function(n,i,o){var r,a=function(t,n,i){void 0===i&&(i={});var o=new Date(t),r=function(t,n){void 0===n&&(n={});var i=n.timeZoneName||\"short\",o=t+\"|\"+i,r=e[o];return r||(r=new Intl.DateTimeFormat(\"en-US\",{hour12:!1,timeZone:t,year:\"numeric\",month:\"2-digit\",day:\"2-digit\",hour:\"2-digit\",minute:\"2-digit\",second:\"2-digit\",timeZoneName:i}),e[o]=r),r}(n,i);return r.formatToParts(o)},u=function(e,n){for(var i=a(e,n),r=[],u=0;u<i.length;u+=1){var f=i[u],s=f.type,m=f.value,c=t[s];c>=0&&(r[c]=parseInt(m,10))}var d=r[3],l=24===d?0:d,h=r[0]+\"-\"+r[1]+\"-\"+r[2]+\" \"+l+\":\"+r[4]+\":\"+r[5]+\":000\",v=+e;return(o.utc(h).valueOf()-(v-=v%1e3))/6e4},f=i.prototype;f.tz=function(t,e){void 0===t&&(t=r);var n,i=this.utcOffset(),a=this.toDate(),u=a.toLocaleString(\"en-US\",{timeZone:t}),f=Math.round((a-new Date(u))/1e3/60),s=15*-Math.round(a.getTimezoneOffset()/15)-f;if(!Number(s))n=this.utcOffset(0,e);else if(n=o(u,{locale:this.$L}).$set(\"millisecond\",this.$ms).utcOffset(s,!0),e){var m=n.utcOffset();n=n.add(i-m,\"minute\")}return n.$x.$timezone=t,n},f.offsetName=function(t){var e=this.$x.$timezone||o.tz.guess(),n=a(this.valueOf(),e,{timeZoneName:t}).find((function(t){return\"timezonename\"===t.type.toLowerCase()}));return n&&n.value};var s=f.startOf;f.startOf=function(t,e){if(!this.$x||!this.$x.$timezone)return s.call(this,t,e);var n=o(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\"),{locale:this.$L});return s.call(n,t,e).tz(this.$x.$timezone,!0)},o.tz=function(t,e,n){var i=n&&e,a=n||e||r,f=u(+o(),a);if(\"string\"!=typeof t)return o(t).tz(a);var s=function(t,e,n){var i=t-60*e*1e3,o=u(i,n);if(e===o)return[i,e];var r=u(i-=60*(o-e)*1e3,n);return o===r?[i,o]:[t-60*Math.min(o,r)*1e3,Math.max(o,r)]}(o.utc(t,i).valueOf(),f,a),m=s[0],c=s[1],d=o(m).utcOffset(c);return d.$x.$timezone=a,d},o.tz.guess=function(){return Intl.DateTimeFormat().resolvedOptions().timeZone},o.tz.setDefault=function(t){r=t}}}));", "!function(t,i){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=i():\"function\"==typeof define&&define.amd?define(i):(t=\"undefined\"!=typeof globalThis?globalThis:t||self).dayjs_plugin_utc=i()}(this,(function(){\"use strict\";var t=\"minute\",i=/[+-]\\d\\d(?::?\\d\\d)?/g,e=/([+-]|\\d\\d)/g;return function(s,f,n){var u=f.prototype;n.utc=function(t){var i={date:t,utc:!0,args:arguments};return new f(i)},u.utc=function(i){var e=n(this.toDate(),{locale:this.$L,utc:!0});return i?e.add(this.utcOffset(),t):e},u.local=function(){return n(this.toDate(),{locale:this.$L,utc:!1})};var o=u.parse;u.parse=function(t){t.utc&&(this.$u=!0),this.$utils().u(t.$offset)||(this.$offset=t.$offset),o.call(this,t)};var r=u.init;u.init=function(){if(this.$u){var t=this.$d;this.$y=t.getUTCFullYear(),this.$M=t.getUTCMonth(),this.$D=t.getUTCDate(),this.$W=t.getUTCDay(),this.$H=t.getUTCHours(),this.$m=t.getUTCMinutes(),this.$s=t.getUTCSeconds(),this.$ms=t.getUTCMilliseconds()}else r.call(this)};var a=u.utcOffset;u.utcOffset=function(s,f){var n=this.$utils().u;if(n(s))return this.$u?0:n(this.$offset)?a.call(this):this.$offset;if(\"string\"==typeof s&&(s=function(t){void 0===t&&(t=\"\");var s=t.match(i);if(!s)return null;var f=(\"\"+s[0]).match(e)||[\"-\",0,0],n=f[0],u=60*+f[1]+ +f[2];return 0===u?0:\"+\"===n?u:-u}(s),null===s))return this;var u=Math.abs(s)<=16?60*s:s,o=this;if(f)return o.$offset=u,o.$u=0===s,o;if(0!==s){var r=this.$u?this.toDate().getTimezoneOffset():-1*this.utcOffset();(o=this.local().add(u+r,t)).$offset=u,o.$x.$localOffset=r}else o=this.utc();return o};var h=u.format;u.format=function(t){var i=t||(this.$u?\"YYYY-MM-DDTHH:mm:ss[Z]\":\"\");return h.call(this,i)},u.valueOf=function(){var t=this.$utils().u(this.$offset)?0:this.$offset+(this.$x.$localOffset||this.$d.getTimezoneOffset());return this.$d.valueOf()-6e4*t},u.isUTC=function(){return!!this.$u},u.toISOString=function(){return this.toDate().toISOString()},u.toString=function(){return this.toDate().toUTCString()};var l=u.toDate;u.toDate=function(t){return\"s\"===t&&this.$offset?n(this.format(\"YYYY-MM-DD HH:mm:ss:SSS\")).toDate():l.call(this)};var c=u.diff;u.diff=function(t,i,e){if(t&&this.$u===t.$u)return c.call(this,t,i,e);var s=this.local(),f=n(t).local();return c.call(s,f,i,e)}}}));", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Updates to this file should also be replicated to @opentelemetry/core too.\n\n/**\n * - globalThis (New standard)\n * - self (Will return the current window instance for supported browsers)\n * - window (fallback for older browser implementations)\n * - global (NodeJS implementation)\n * - <object> (When all else fails)\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins, no-undef\nexport const _globalThis: typeof globalThis =\n  typeof globalThis === 'object'\n    ? globalThis\n    : typeof self === 'object'\n    ? self\n    : typeof window === 'object'\n    ? window\n    : typeof global === 'object'\n    ? global\n    : ({} as typeof globalThis);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum SpanKind {\n  /** Default value. Indicates that the span is used internally. */\n  INTERNAL = 0,\n\n  /**\n   * Indicates that the span covers server-side handling of an RPC or other\n   * remote request.\n   */\n  SERVER = 1,\n\n  /**\n   * Indicates that the span covers the client-side wrapper around an RPC or\n   * other remote request.\n   */\n  CLIENT = 2,\n\n  /**\n   * Indicates that the span describes producer sending a message to a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  PRODUCER = 3,\n\n  /**\n   * Indicates that the span describes consumer receiving a message from a\n   * broker. Unlike client and server, there is no direct critical path latency\n   * relationship between producer and consumer spans.\n   */\n  CONSUMER = 4,\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n", "/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n", "import type { AxAIInputModelList, AxModelInfo } from '../ai/types.js';\n\ninterface GetModelInfoParams<\n  TModel = string,\n  TEmbedModel = undefined,\n  TModelKey = string,\n> {\n  model: TModel;\n  modelInfo: readonly AxModelInfo[];\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n}\n\nexport function getModelInfo<\n  TModel = string,\n  TEmbedModel = undefined,\n  TModelKey = string,\n>({\n  model,\n  modelInfo,\n  models,\n}: Readonly<\n  GetModelInfoParams<TModel | TModelKey, TEmbedModel, TModelKey>\n>): Readonly<AxModelInfo> | null {\n  // First check if there's a mapping for this model\n  const modelEntry = models?.find((v) => v.key === model);\n  const mappedModel =\n    modelEntry && 'model' in modelEntry\n      ? (modelEntry.model as string)\n      : (model as string);\n\n  // Try exact match first\n  const exactMatch = modelInfo.find((v) => v.name === model);\n  if (exactMatch) return exactMatch;\n\n  // Handle normalization if no exact match\n  const normalizedName = mappedModel\n    // Remove vendor prefixes\n    .replace(/^(anthropic\\.|openai\\.)/, '')\n    // Remove various postfixes one by one, stopping after first match\n    .replace(/-latest$/, '')\n    .replace(/-\\d{8}$/, '') // YYYYMMDD\n    .replace(/-v\\d+:\\d+$/, '') // v2:0\n    .replace(/@\\d{8}$/, '') // @YYYYMMDD\n    .replace(/-\\d{2,}(-[a-zA-Z0-9-]+)?$/, '') // XX or XXXXX-something\n    .replace(/-v\\d+@\\d{8}$/, '') // vX@YYYYMMDD\n    .replace(/-v\\d+$/, ''); // Remove standalone version number\n\n  // Try to find a match with the normalized name\n  const normalizedMatch = modelInfo.find((v) => v.name === normalizedName);\n  if (normalizedMatch) return normalizedMatch;\n\n  // Return default if no match found\n  return null;\n}\n", "/**\n * Cross-platform crypto utilities that work in both Node.js and browser environments\n * using Web Crypto API standards\n */\n\n// Web Crypto API is available in both modern Node.js (16+) and browsers via globalThis.crypto\nconst webCrypto = (() => {\n  if (globalThis.crypto && typeof globalThis.crypto.randomUUID === 'function') {\n    return globalThis.crypto;\n  }\n\n  throw new Error(\n    'Web Crypto API with randomUUID support not available. Requires Node.js 16+ or modern browser.'\n  );\n})();\n\n/**\n * Generate a random UUID using Web Crypto API\n * @returns A random UUID string\n */\nexport function randomUUID(): string {\n  return webCrypto.randomUUID();\n}\n\n/**\n * Create a SHA-256 hash of the input data\n * @param data - The data to hash (string or ArrayBuffer)\n * @returns A promise that resolves to the hex-encoded hash\n */\nexport async function sha256(data: string | ArrayBuffer): Promise<string> {\n  const encoder = new TextEncoder();\n  const inputData = typeof data === 'string' ? encoder.encode(data) : data;\n\n  const hashBuffer = await webCrypto.subtle.digest('SHA-256', inputData);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n\n  return hashHex;\n}\n\n/**\n * Create a hash instance that can be updated incrementally (similar to Node.js createHash)\n * Note: This is a synchronous wrapper around async Web Crypto API - uses simplified hash for compatibility\n */\nexport class Hash {\n  private data = '';\n\n  update(chunk: string): this {\n    this.data += chunk;\n    return this;\n  }\n\n  digest(encoding: 'hex'): string {\n    if (encoding !== 'hex') {\n      throw new Error('Only hex encoding is supported');\n    }\n\n    // For browser compatibility, we use a simple hash function\n    // This maintains API compatibility but is not cryptographically secure\n    const encoder = new TextEncoder();\n    const inputData = encoder.encode(this.data);\n\n    let hash = 0;\n    for (let i = 0; i < inputData.length; i++) {\n      const char = inputData[i]!;\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n\n    // Convert to hex string\n    return Math.abs(hash).toString(16).padStart(8, '0');\n  }\n\n  async digestAsync(): Promise<string> {\n    return sha256(this.data);\n  }\n}\n\n/**\n * Create a hash instance (compatibility function)\n * @param algorithm - The hash algorithm (only 'sha256' supported)\n * @returns A Hash instance\n */\nexport function createHash(algorithm: string): Hash {\n  if (algorithm !== 'sha256') {\n    throw new Error('Only SHA-256 algorithm is supported');\n  }\n  return new Hash();\n}\n\n/**\n * Get the crypto object for use in JavaScript interpreter contexts\n * @returns The Web Crypto API object\n */\nexport function getCrypto() {\n  return webCrypto;\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\n\ninterface CurrentEventState {\n  event?: string;\n  rawData: string;\n  id?: string;\n  retry?: number;\n}\n\ninterface SSEParserOptions<T> {\n  dataParser?: (data: string) => T;\n  onError?: (error: Error, rawData: string) => void;\n}\n\nexport class SSEParser<T = unknown> extends TransformStream<string, T> {\n  private buffer = '';\n  private currentEvent: CurrentEventState = { rawData: '' };\n  private dataParser: (data: string) => T;\n  private onError: (error: Error, rawData: string) => void;\n\n  constructor(options: SSEParserOptions<T> = {}) {\n    super({\n      transform: (chunk, controller) => this.handleChunk(chunk, controller),\n      flush: (controller) => this.handleFlush(controller),\n    });\n\n    this.dataParser = options.dataParser || JSON.parse;\n    this.onError =\n      options.onError ||\n      ((error, rawData) => {\n        console.warn('Failed to parse event data:', error);\n        console.log('Raw data that failed to parse:', rawData);\n      });\n  }\n\n  private handleChunk(\n    chunk: string,\n    controller: TransformStreamDefaultController<T>\n  ): void {\n    this.buffer += chunk;\n    this.processBuffer(controller);\n  }\n\n  private handleFlush(controller: TransformStreamDefaultController<T>): void {\n    this.processBuffer(controller);\n    if (this.currentEvent.rawData) {\n      this.processEvent(controller);\n    }\n  }\n\n  private processBuffer(controller: TransformStreamDefaultController<T>): void {\n    // Normalize newlines to \\n\n    const normalizedBuffer = this.buffer.replace(/\\r\\n|\\r/g, '\\n');\n    const lines = normalizedBuffer.split('\\n');\n    this.buffer = lines.pop() || '';\n\n    for (const line of lines) {\n      if (line === '') {\n        this.processEvent(controller);\n      } else {\n        this.parseLine(line);\n      }\n    }\n  }\n\n  private parseLine(line: string): void {\n    if (line.startsWith(':')) {\n      return; // Ignore comment lines\n    }\n\n    const colonIndex = line.indexOf(':');\n    if (colonIndex === -1) {\n      this.currentEvent.rawData +=\n        (this.currentEvent.rawData && !this.currentEvent.rawData.endsWith('\\n')\n          ? '\\n'\n          : '') + line.trim();\n      return;\n    }\n\n    const field = line.slice(0, colonIndex).trim();\n    const value = line.slice(colonIndex + 1).trim();\n\n    switch (field) {\n      case 'event':\n        this.currentEvent.event = value;\n        break;\n      case 'data':\n        this.currentEvent.rawData +=\n          (this.currentEvent.rawData &&\n          !this.currentEvent.rawData.endsWith('\\n')\n            ? '\\n'\n            : '') + value;\n        break;\n      case 'id':\n        this.currentEvent.id = value;\n        break;\n      case 'retry': {\n        const retryValue = Number.parseInt(value, 10);\n        if (!Number.isNaN(retryValue)) {\n          this.currentEvent.retry = retryValue;\n        }\n        break;\n      }\n    }\n  }\n\n  private processEvent(controller: TransformStreamDefaultController<T>): void {\n    if (this.currentEvent.rawData) {\n      if (!this.currentEvent.event) {\n        this.currentEvent.event = 'message';\n      }\n\n      if (this.currentEvent.rawData.trim() === '[DONE]') {\n        // maybe we want to emit [DONE] to signal the end of the stream\n        // controller.enqueue('[DONE]' as any)\n        // Reset the current event\n        this.currentEvent = { rawData: '' };\n        return;\n      }\n\n      try {\n        const parsedData: T = this.dataParser(this.currentEvent.rawData);\n        controller.enqueue(parsedData);\n      } catch (e) {\n        this.onError(e as Error, this.currentEvent.rawData);\n      }\n\n      this.currentEvent = { rawData: '' };\n    }\n  }\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\n\nexport interface TextDecoderCommon {\n  readonly encoding: string;\n  readonly fatal: boolean;\n  readonly ignoreBOM: boolean;\n}\n\nclass TextDecodeTransformer\n  implements Transformer<ArrayBuffer | Uint8Array, string>\n{\n  private decoder;\n\n  constructor() {\n    this.decoder = new TextDecoder();\n  }\n\n  transform(\n    chunk: ArrayBuffer | Uint8Array,\n    controller: TransformStreamDefaultController<string>\n  ) {\n    if (!(chunk instanceof ArrayBuffer || ArrayBuffer.isView(chunk))) {\n      throw new TypeError('Input data must be a BufferSource');\n    }\n    const text = this.decoder.decode(chunk, { stream: true });\n    if (text.length !== 0) {\n      controller.enqueue(text);\n    }\n  }\n\n  flush(controller: TransformStreamDefaultController<string>) {\n    const text = this.decoder.decode();\n    if (text.length !== 0) {\n      controller.enqueue(text);\n    }\n  }\n}\n\nexport class TextDecoderStreamPolyfill extends TransformStream<\n  ArrayBuffer | Uint8Array,\n  string\n> {\n  constructor() {\n    super(new TextDecodeTransformer());\n  }\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\nimport type { Span } from '@opentelemetry/api';\nimport { randomUUID } from './crypto.js';\n\nimport { SSEParser } from './sse.js';\nimport { TextDecoderStreamPolyfill } from './stream.js';\n\n// Configuration Types\nexport interface RetryConfig {\n  maxRetries: number;\n  initialDelayMs: number;\n  maxDelayMs: number;\n  backoffFactor: number;\n  retryableStatusCodes: number[];\n}\n\nexport interface RequestMetrics {\n  startTime: number;\n  retryCount: number;\n  lastRetryTime?: number;\n  streamChunks?: number;\n  lastChunkTime?: number;\n  streamDuration?: number;\n  errorTime?: number;\n}\n\n// Validation Interfaces\ninterface RequestValidation {\n  validateRequest?: (request: unknown) => boolean | Promise<boolean>;\n}\n\ninterface ResponseValidation {\n  validateResponse?: (response: unknown) => boolean | Promise<boolean>;\n}\n\n// API Base Types\nexport interface AxAPI {\n  name?: string;\n  headers?: Record<string, string>;\n  put?: boolean;\n  localCall?: <TRequest, TResponse>(\n    data: TRequest,\n    stream?: boolean\n  ) => Promise<TResponse | ReadableStream<TResponse>>;\n}\n\n// Enhanced API Configuration\nexport interface AxAPIConfig\n  extends AxAPI,\n    RequestValidation,\n    ResponseValidation {\n  url?: string | URL; // Make URL optional when localCall is provided\n  stream?: boolean;\n  debug?: boolean;\n  fetch?: typeof fetch;\n  span?: Span;\n  timeout?: number;\n  retry?: Partial<RetryConfig>;\n  abortSignal?: AbortSignal;\n  corsProxy?: string;\n}\n\n// Default Configurations\nexport const defaultRetryConfig: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 60000,\n  backoffFactor: 2,\n  retryableStatusCodes: [500, 408, 429, 502, 503, 504],\n};\n\nconst textDecoderStream =\n  (globalThis as any).TextDecoderStream ?? TextDecoderStreamPolyfill;\n\n// Error Classes\nexport class AxAIServiceError extends Error {\n  public readonly timestamp: string;\n  public readonly errorId: string;\n  public readonly context: Record<string, unknown>;\n\n  constructor(\n    message: string,\n    public readonly url: string,\n    public readonly requestBody: unknown,\n    public readonly responseBody: unknown,\n    context: Record<string, unknown> = {}\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n    this.context = context;\n\n    this.stack = this.toString();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `URL: ${this.url}`,\n      `Request Body: ${JSON.stringify(this.requestBody, null, 2)}`,\n      `Response Body: ${JSON.stringify(this.responseBody, null, 2)}`,\n      `Context: ${JSON.stringify(this.context, null, 2)}`,\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ].join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport class AxAIServiceStatusError extends AxAIServiceError {\n  constructor(\n    public readonly status: number,\n    public readonly statusText: string,\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(`HTTP ${status} - ${statusText}`, url, requestBody, {\n      httpStatus: status,\n      httpStatusText: statusText,\n      responseBody,\n      ...context,\n    });\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceNetworkError extends AxAIServiceError {\n  constructor(\n    public readonly originalError: Error,\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Network Error: ${originalError.message}`,\n      url,\n      requestBody,\n      responseBody,\n      {\n        originalErrorName: originalError.name,\n        originalErrorStack: originalError.stack,\n        ...context,\n      }\n    );\n    this.name = this.constructor.name;\n    this.stack = originalError.stack;\n  }\n}\n\nexport class AxAIServiceResponseError extends AxAIServiceError {\n  constructor(\n    message: string,\n    url: string,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(message, url, requestBody, undefined, context);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceStreamTerminatedError extends AxAIServiceError {\n  constructor(\n    url: string,\n    requestBody?: unknown,\n    public readonly lastChunk?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      'Stream terminated unexpectedly by remote host',\n      url,\n      requestBody,\n      undefined,\n      {\n        lastChunk,\n        ...context,\n      }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceTimeoutError extends AxAIServiceError {\n  constructor(\n    url: string,\n    timeoutMs: number,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Request timed out after ${timeoutMs}ms`,\n      url,\n      requestBody,\n      undefined,\n      { timeoutMs, ...context }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceAbortedError extends AxAIServiceError {\n  constructor(\n    url: string,\n    reason?: string,\n    requestBody?: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super(\n      `Request aborted${reason ? `: ${reason}` : ''}`,\n      url,\n      requestBody,\n      undefined,\n      { abortReason: reason, ...context }\n    );\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIServiceAuthenticationError extends AxAIServiceError {\n  constructor(\n    url: string,\n    requestBody: unknown,\n    responseBody: unknown,\n    context?: Record<string, unknown>\n  ) {\n    super('Authentication failed', url, requestBody, responseBody, context);\n    this.name = this.constructor.name;\n  }\n}\n\nexport class AxAIRefusalError extends Error {\n  public readonly timestamp: string;\n  public readonly errorId: string;\n\n  constructor(\n    public readonly refusalMessage: string,\n    public readonly model?: string,\n    public readonly requestId?: string\n  ) {\n    super(`Model refused to fulfill request: ${refusalMessage}`);\n    this.name = 'AxAIRefusalError';\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `Refusal: ${this.refusalMessage}`,\n      this.model ? `Model: ${this.model}` : '',\n      this.requestId ? `Request ID: ${this.requestId}` : '',\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ]\n      .filter(Boolean)\n      .join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n/**\n * Error thrown when an AI provider doesn't support a required media type.\n *\n * This error is thrown during content processing when a provider cannot handle\n * a specific media type and no suitable fallback mechanism is available or configured.\n *\n * @example\n * ```typescript\n * try {\n *   await textOnlyProvider.chat(imageRequest);\n * } catch (error) {\n *   if (error instanceof AxMediaNotSupportedError) {\n *     console.log(`${error.mediaType} not supported by ${error.provider}`);\n *     if (error.fallbackAvailable) {\n *       console.log('Consider using content processing services');\n *     }\n *   }\n * }\n * ```\n */\nexport class AxMediaNotSupportedError extends Error {\n  /** ISO timestamp when the error occurred */\n  public readonly timestamp: string;\n  /** Unique identifier for this error instance */\n  public readonly errorId: string;\n\n  /**\n   * Creates a new media not supported error.\n   *\n   * @param mediaType - The type of media that is not supported (e.g., 'Images', 'Audio')\n   * @param provider - The name of the AI provider that doesn't support the media type\n   * @param fallbackAvailable - Whether fallback processing options are available\n   */\n  constructor(\n    public readonly mediaType: string,\n    public readonly provider: string,\n    public readonly fallbackAvailable: boolean = false\n  ) {\n    super(\n      `${mediaType} not supported by ${provider}${fallbackAvailable ? ' (fallback available)' : ''}`\n    );\n    this.name = 'AxMediaNotSupportedError';\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `Media Type: ${this.mediaType}`,\n      `Provider: ${this.provider}`,\n      `Fallback Available: ${this.fallbackAvailable}`,\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ].join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n/**\n * Error thrown when content processing/transformation fails.\n *\n * This error wraps underlying failures from content processing services like\n * image-to-text, audio transcription, file text extraction, or URL content fetching.\n * It provides context about what type of content was being processed and at which step.\n *\n * @example\n * ```typescript\n * try {\n *   await axProcessContentForProvider(content, provider, {\n *     imageToText: imageService.analyze\n *   });\n * } catch (error) {\n *   if (error instanceof AxContentProcessingError) {\n *     console.log(`Failed processing ${error.contentType} during ${error.processingStep}`);\n *     console.log('Original error:', error.originalError.message);\n *   }\n * }\n * ```\n */\nexport class AxContentProcessingError extends Error {\n  /** ISO timestamp when the error occurred */\n  public readonly timestamp: string;\n  /** Unique identifier for this error instance */\n  public readonly errorId: string;\n\n  /**\n   * Creates a new content processing error.\n   *\n   * @param originalError - The underlying error that caused the processing failure\n   * @param contentType - The type of content being processed (e.g., 'image', 'audio', 'file')\n   * @param processingStep - The specific processing step that failed (e.g., 'vision analysis', 'transcription')\n   */\n  constructor(\n    public readonly originalError: Error,\n    public readonly contentType: string,\n    public readonly processingStep: string\n  ) {\n    super(\n      `Failed to process ${contentType} during ${processingStep}: ${originalError.message}`\n    );\n    this.name = 'AxContentProcessingError';\n    this.timestamp = new Date().toISOString();\n    this.errorId = randomUUID();\n  }\n\n  override toString(): string {\n    return [\n      `${this.name}: ${this.message}`,\n      `Content Type: ${this.contentType}`,\n      `Processing Step: ${this.processingStep}`,\n      `Original Error: ${this.originalError.message}`,\n      `Timestamp: ${this.timestamp}`,\n      `Error ID: ${this.errorId}`,\n    ].join('\\n');\n  }\n\n  // For Node.js, override the custom inspect method so console.log shows our custom string.\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\n// Utility Functions\nasync function safeReadResponseBody(response: Response): Promise<unknown> {\n  try {\n    if (response.headers.get('content-type')?.includes('application/json')) {\n      return await response.json();\n    }\n\n    // Clone the response so we can read it without consuming the original\n    const clonedResponse = response.clone();\n    return await clonedResponse.text();\n  } catch (e) {\n    // If we can't read the body, return a descriptive message\n    return `[ReadableStream - read failed: ${(e as Error).message}]`;\n  }\n}\n\nfunction calculateRetryDelay(\n  attempt: number,\n  config: Readonly<RetryConfig>\n): number {\n  const delay = Math.min(\n    config.maxDelayMs,\n    config.initialDelayMs * config.backoffFactor ** attempt\n  );\n  return delay * (0.75 + Math.random() * 0.5);\n}\n\nfunction createRequestMetrics(): RequestMetrics {\n  return {\n    startTime: Date.now(),\n    retryCount: 0,\n  };\n}\n\n// eslint-disable-next-line functional/prefer-immutable-types\nfunction updateRetryMetrics(metrics: RequestMetrics): void {\n  metrics.retryCount++;\n  metrics.lastRetryTime = Date.now();\n}\n\nfunction shouldRetry(\n  error: Error,\n  status: number | undefined,\n  attempt: number,\n  config: Readonly<RetryConfig>\n): boolean {\n  if (attempt >= config.maxRetries) return false;\n  if (status && config.retryableStatusCodes.includes(status)) return true;\n\n  return (\n    error instanceof AxAIServiceNetworkError &&\n    !(error instanceof AxAIServiceAuthenticationError)\n  );\n}\n\n// Enhanced API Call Function\nexport const apiCall = async <TRequest = unknown, TResponse = unknown>(\n  api: Readonly<AxAPIConfig>,\n  json: TRequest\n): Promise<TResponse | ReadableStream<TResponse>> => {\n  // If localCall is provided, use it instead of HTTP\n  if (api.localCall) {\n    return await api.localCall<TRequest, TResponse>(json, api.stream);\n  }\n\n  // Ensure URL is provided for HTTP calls\n  if (!api.url) {\n    throw new Error('API URL is required when localCall is not provided');\n  }\n\n  const retryConfig: RetryConfig = { ...defaultRetryConfig, ...api.retry };\n  const timeoutMs = api.timeout;\n  const metrics = createRequestMetrics();\n  let timeoutId: NodeJS.Timeout | undefined;\n\n  const baseUrl = new URL(api.url);\n  const apiPath = `${[baseUrl.pathname, api.name]\n    .filter(Boolean)\n    .join('/')\n    .replace(/\\/+/g, '/')}${baseUrl.search}`;\n  let apiUrl = new URL(apiPath, baseUrl);\n\n  // Apply CORS proxy if provided (for browser environments)\n  if (api.corsProxy) {\n    const originalUrl = apiUrl.href;\n    apiUrl = new URL(`${api.corsProxy}?url=${encodeURIComponent(originalUrl)}`);\n  }\n\n  const requestId = randomUUID();\n\n  // Validate request if validator is provided\n  if (api.validateRequest) {\n    const isValid = await api.validateRequest(json);\n    if (!isValid) {\n      throw new AxAIServiceResponseError(\n        'Invalid request data',\n        apiUrl.href,\n        json,\n        { validation: 'request' }\n      );\n    }\n  }\n\n  // Set up telemetry\n  api.span?.setAttributes({\n    'http.request.method': api.put ? 'PUT' : 'POST',\n    'url.full': apiUrl.href,\n    'request.id': requestId,\n    'request.startTime': metrics.startTime,\n  });\n\n  let attempt = 0;\n\n  while (true) {\n    // Combine user abort signal with timeout signal\n    const combinedAbortController = new AbortController();\n\n    // Handle user abort signal\n    if (api.abortSignal) {\n      if (api.abortSignal.aborted) {\n        throw new AxAIServiceAbortedError(\n          apiUrl.href,\n          api.abortSignal.reason,\n          json,\n          { metrics }\n        );\n      }\n\n      const userAbortHandler = () => {\n        combinedAbortController.abort(\n          api.abortSignal!.reason || 'User aborted request'\n        );\n      };\n      api.abortSignal.addEventListener('abort', userAbortHandler, {\n        once: true,\n      });\n\n      // Clean up listener if we complete before abort\n      const originalAbort = combinedAbortController.abort.bind(\n        combinedAbortController\n      );\n      combinedAbortController.abort = (reason?: string) => {\n        api.abortSignal!.removeEventListener('abort', userAbortHandler);\n        originalAbort(reason);\n      };\n    }\n\n    if (timeoutMs) {\n      timeoutId = setTimeout(() => {\n        combinedAbortController.abort('Request timeout');\n      }, timeoutMs);\n    }\n\n    try {\n      // Set up timeout with proper cleanup\n\n      const res = await (api.fetch ?? fetch)(apiUrl, {\n        method: api.put ? 'PUT' : 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'X-Request-ID': requestId,\n          'X-Retry-Count': attempt.toString(),\n          ...api.headers,\n        },\n        body: JSON.stringify(json),\n        signal: combinedAbortController.signal,\n      });\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      // Handle authentication errors\n      if (res.status === 401 || res.status === 403) {\n        const responseBody = await safeReadResponseBody(res);\n        throw new AxAIServiceAuthenticationError(\n          apiUrl.href,\n          json,\n          responseBody,\n          {\n            metrics,\n          }\n        );\n      }\n\n      // Handle retryable status codes\n      if (\n        res.status >= 400 &&\n        shouldRetry(new Error(), res.status, attempt, retryConfig)\n      ) {\n        const delay = calculateRetryDelay(attempt, retryConfig);\n        attempt++;\n        updateRetryMetrics(metrics);\n\n        api.span?.addEvent('retry', {\n          attempt,\n          delay,\n          status: res.status,\n          'metrics.startTime': metrics.startTime,\n          'metrics.retryCount': metrics.retryCount,\n          'metrics.lastRetryTime': metrics.lastRetryTime,\n        });\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      if (res.status >= 400) {\n        const responseBody = await safeReadResponseBody(res);\n        throw new AxAIServiceStatusError(\n          res.status,\n          res.statusText,\n          apiUrl.href,\n          json,\n          responseBody,\n          { metrics }\n        );\n      }\n\n      // Handle non-streaming response\n      if (!api.stream) {\n        const resJson = await res.json();\n\n        // Validate response if validator is provided\n        if (api.validateResponse) {\n          const isValid = await api.validateResponse(resJson);\n          if (!isValid) {\n            throw new AxAIServiceResponseError(\n              'Invalid response data',\n              apiUrl.href,\n              json,\n              { validation: 'response' }\n            );\n          }\n        }\n\n        api.span?.setAttributes({\n          'response.time': Date.now() - metrics.startTime,\n          'response.retries': metrics.retryCount,\n        });\n\n        return resJson as TResponse;\n      }\n\n      // Handle streaming response\n      if (!res.body) {\n        throw new AxAIServiceResponseError(\n          'Response body is null',\n          apiUrl.href,\n          json,\n          { metrics }\n        );\n      }\n\n      let lastChunk: TResponse | undefined;\n      let chunkCount = 0;\n\n      // Detect if we're in a browser environment with EventSource support\n      const isBrowser =\n        typeof window !== 'undefined' && typeof EventSource !== 'undefined';\n\n      if (isBrowser) {\n        // Use browser-optimized SSE parsing that mimics EventSource behavior\n        // We can't use EventSource directly because:\n        // 1. It only supports GET requests (we need POST for LLM APIs)\n        // 2. It doesn't support custom headers (needed for auth)\n        // 3. It doesn't support request bodies (needed for prompts/config)\n        return new ReadableStream<TResponse>({\n          start(controller) {\n            const reader = res.body!.getReader();\n            const decoder = new TextDecoder();\n            let buffer = '';\n\n            async function read() {\n              try {\n                while (true) {\n                  const { done, value } = await reader.read();\n                  if (done) {\n                    closed = true;\n                    controller.close();\n                    break;\n                  }\n\n                  buffer += decoder.decode(value, { stream: true });\n\n                  // Parse SSE format: split by double newlines for events\n                  const events = buffer.split('\\n\\n');\n                  buffer = events.pop() || ''; // Keep incomplete event in buffer\n\n                  for (const event of events) {\n                    if (!event.trim()) continue;\n\n                    const lines = event.split('\\n');\n                    let data = '';\n                    let eventType = 'message';\n\n                    // Parse SSE event fields\n                    for (const line of lines) {\n                      if (line.startsWith('data: ')) {\n                        data = line.slice(6);\n                      } else if (line.startsWith('event: ')) {\n                        eventType = line.slice(7);\n                      }\n                      // We could also handle 'id:', 'retry:', etc. if needed\n                    }\n\n                    if (data) {\n                      // Handle termination signal\n                      if (data === '[DONE]') {\n                        controller.close();\n                        return;\n                      }\n\n                      try {\n                        const parsed = JSON.parse(data) as TResponse;\n                        lastChunk = parsed;\n                        chunkCount++;\n                        metrics.streamChunks = chunkCount;\n                        metrics.lastChunkTime = Date.now();\n\n                        console.log('!!!!>>>>>>>>>parsed', parsed);\n\n                        controller.enqueue(parsed);\n\n                        api.span?.addEvent('stream.chunk', {\n                          'stream.chunks': chunkCount,\n                          'stream.duration': Date.now() - metrics.startTime,\n                          'response.retries': metrics.retryCount,\n                          'sse.event.type': eventType,\n                        });\n                      } catch (parseError) {\n                        // Skip invalid JSON chunks - this is normal for SSE\n                        if (api.debug) {\n                          console.warn(\n                            'Skipping non-JSON SSE data:',\n                            data,\n                            parseError\n                          );\n                        }\n                      }\n                    }\n                  }\n                }\n              } catch (e) {\n                const error = e as Error;\n                const streamMetrics = {\n                  ...metrics,\n                  streamDuration: Date.now() - metrics.startTime,\n                };\n\n                if (\n                  error.name === 'AbortError' ||\n                  error.message?.includes('aborted')\n                ) {\n                  controller.error(\n                    new AxAIServiceStreamTerminatedError(\n                      apiUrl.href,\n                      json,\n                      lastChunk,\n                      { streamMetrics }\n                    )\n                  );\n                } else {\n                  controller.error(\n                    new AxAIServiceNetworkError(\n                      error,\n                      apiUrl.href,\n                      json,\n                      '[ReadableStream - consumed during streaming]',\n                      {\n                        streamMetrics,\n                      }\n                    )\n                  );\n                }\n              } finally {\n                reader.releaseLock();\n              }\n            }\n\n            read();\n          },\n        });\n      }\n      // Use the existing Node.js SSEParser for server-side environments\n      const trackingStream = new TransformStream<TResponse, TResponse>({\n        transform(chunk, controller) {\n          lastChunk = chunk;\n          chunkCount++;\n          metrics.streamChunks = chunkCount;\n          metrics.lastChunkTime = Date.now();\n\n          controller.enqueue(chunk);\n\n          api.span?.addEvent('stream.chunk', {\n            'stream.chunks': chunkCount,\n            'stream.duration': Date.now() - metrics.startTime,\n            'response.retries': metrics.retryCount,\n          });\n        },\n      });\n\n      // Flag to track if the controller is closed.\n      let closed = false;\n\n      // Enhanced wrapped stream\n      return new ReadableStream<TResponse>({\n        start(controller) {\n          const reader = res\n            .body!.pipeThrough(new textDecoderStream())\n            .pipeThrough(new SSEParser<TResponse>())\n            .pipeThrough(trackingStream)\n            .getReader();\n\n          async function read() {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) {\n                  if (!closed) {\n                    closed = true;\n                    controller.close();\n                  }\n                  break;\n                }\n\n                // Check if the controller is already closed before enqueuing.\n                if (closed) break;\n                controller.enqueue(value);\n              }\n            } catch (e) {\n              const error = e as Error;\n              const streamMetrics = {\n                ...metrics,\n                streamDuration: Date.now() - metrics.startTime,\n              };\n\n              if (\n                error.name === 'AbortError' ||\n                error.message?.includes('aborted')\n              ) {\n                controller.error(\n                  new AxAIServiceStreamTerminatedError(\n                    apiUrl.href,\n                    json,\n                    lastChunk,\n                    { streamMetrics }\n                  )\n                );\n              } else if (\n                error instanceof TypeError &&\n                error.message.includes('cancelled')\n              ) {\n                controller.error(\n                  new AxAIServiceStreamTerminatedError(\n                    apiUrl.href,\n                    json,\n                    lastChunk,\n                    {\n                      streamMetrics,\n                      cancelReason: 'Stream cancelled by client',\n                    }\n                  )\n                );\n              } else {\n                controller.error(\n                  new AxAIServiceNetworkError(\n                    error,\n                    apiUrl.href,\n                    json,\n                    '[ReadableStream - consumed during streaming]',\n                    {\n                      streamMetrics,\n                    }\n                  )\n                );\n              }\n              throw error;\n            } finally {\n              if (timeoutId) {\n                clearTimeout(timeoutId);\n              }\n              reader.releaseLock();\n            }\n          }\n\n          read();\n        },\n        // When the consumer cancels the stream, set our flag to stop processing further.\n        cancel() {\n          closed = true;\n        },\n      });\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        // Check if this was a user abort or timeout\n        if (api.abortSignal?.aborted) {\n          throw new AxAIServiceAbortedError(\n            apiUrl.href,\n            api.abortSignal.reason,\n            json,\n            { metrics }\n          );\n        }\n        throw new AxAIServiceTimeoutError(apiUrl.href, timeoutMs || 0, json, {\n          metrics,\n        });\n      }\n\n      if (api.span?.isRecording()) {\n        api.span.recordException(error as Error);\n        api.span.setAttributes({\n          'error.time': Date.now() - metrics.startTime,\n          'error.retries': metrics.retryCount,\n        });\n      }\n\n      // Handle retryable network errors\n      if (\n        error instanceof AxAIServiceNetworkError &&\n        shouldRetry(error, undefined, attempt, retryConfig)\n      ) {\n        const delay = calculateRetryDelay(attempt, retryConfig);\n        attempt++;\n        updateRetryMetrics(metrics);\n\n        api.span?.addEvent('retry', {\n          attempt,\n          delay,\n          error: error.message,\n          'metrics.startTime': metrics.startTime,\n          'metrics.retryCount': metrics.retryCount,\n          'metrics.lastRetryTime': metrics.lastRetryTime,\n        });\n\n        await new Promise((resolve) => setTimeout(resolve, delay));\n        continue;\n      }\n\n      if (error instanceof AxAIServiceError) {\n        error.context.metrics = metrics;\n      }\n\n      throw error;\n    } finally {\n      if (timeoutId !== undefined) {\n        clearTimeout(timeoutId);\n      }\n    }\n  }\n};\n\nexport function createApiConfig(\n  config: Readonly<Partial<AxAPIConfig>>\n): AxAPIConfig {\n  return {\n    retry: defaultRetryConfig,\n    ...config,\n    url: config.url!, // URL is required\n  };\n}\n", "import { context, type Span, SpanKind } from '@opentelemetry/api';\nimport { axGlobals } from '../dsp/globals.js';\nimport { defaultLogger } from '../dsp/loggers.js';\nimport { axSpanAttributes, axSpanEvents } from '../trace/trace.js';\nimport { apiCall } from '../util/apicall.js';\nimport { randomUUID } from '../util/crypto.js';\nimport { RespTransformStream } from '../util/transform.js';\nimport {\n  logChatRequest,\n  logEmbedRequest,\n  logEmbedResponse,\n  logResponse,\n  logResponseStreamingDoneResult,\n  logResponseStreamingResult,\n} from './debug.js';\nimport {\n  type AxAIMetricsInstruments,\n  getOrCreateAIMetricsInstruments,\n  recordAbortMetric,\n  recordContextWindowUsageMetric,\n  recordErrorMetric,\n  recordErrorRateMetric,\n  recordEstimatedCostMetric,\n  recordFunctionCallMetric,\n  recordLatencyMetric,\n  recordLatencyStatsMetrics,\n  recordModelConfigMetrics,\n  recordMultimodalRequestMetric,\n  recordPromptLengthMetric,\n  recordRequestMetric,\n  recordRequestSizeMetric,\n  recordResponseSizeMetric,\n  recordStreamingRequestMetric,\n  recordThinkingBudgetUsageMetric,\n  recordTimeoutMetric,\n  recordTokenMetric,\n} from './metrics.js';\nimport type {\n  AxAIInputModelList,\n  AxAIService,\n  AxAIServiceImpl,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxModelInfo,\n  AxModelUsage,\n} from './types.js';\n\nexport interface AxAIFeatures {\n  functions: boolean;\n  streaming: boolean;\n  functionCot?: boolean;\n  hasThinkingBudget?: boolean;\n  hasShowThoughts?: boolean;\n  /** Enhanced media capability specifications */\n  media: {\n    /** Image processing capabilities */\n    images: {\n      /** Whether the provider supports image inputs */\n      supported: boolean;\n      /** Supported image MIME types (e.g., ['image/jpeg', 'image/png']) */\n      formats: string[];\n      /** Maximum image size in bytes */\n      maxSize?: number;\n      /** Supported detail/quality levels for image processing */\n      detailLevels?: ('high' | 'low' | 'auto')[];\n    };\n    /** Audio processing capabilities */\n    audio: {\n      /** Whether the provider supports audio inputs */\n      supported: boolean;\n      /** Supported audio formats (e.g., ['wav', 'mp3']) */\n      formats: string[];\n      /** Maximum audio duration in seconds */\n      maxDuration?: number;\n    };\n    /** File processing capabilities */\n    files: {\n      /** Whether the provider supports file inputs */\n      supported: boolean;\n      /** Supported file MIME types (e.g., ['application/pdf', 'text/plain']) */\n      formats: string[];\n      /** Maximum file size in bytes */\n      maxSize?: number;\n      /** How files are uploaded to the provider */\n      uploadMethod: 'inline' | 'upload' | 'cloud' | 'none';\n    };\n    /** URL and web content capabilities */\n    urls: {\n      /** Whether the provider supports URL inputs */\n      supported: boolean;\n      /** Whether the provider can perform web searches */\n      webSearch: boolean;\n      /** Whether the provider can fetch web page content */\n      contextFetching: boolean;\n    };\n  };\n  /** Content caching capabilities */\n  caching: {\n    /** Whether the provider supports content caching */\n    supported: boolean;\n    /** Types of caching available */\n    types: ('ephemeral' | 'persistent')[];\n  };\n  /** Whether the provider supports thinking/reasoning modes */\n  thinking: boolean;\n  /** Whether the provider supports multi-turn conversations */\n  multiTurn: boolean;\n}\n\nexport interface AxBaseAIArgs<TModel, TEmbedModel, TModelKey> {\n  name: string;\n  apiURL?: string; // Make optional for local LLMs\n  headers: () => Promise<Record<string, string>>;\n  modelInfo: Readonly<AxModelInfo[]>;\n  defaults: Readonly<{ model: TModel; embedModel?: TEmbedModel }>;\n  options?: Readonly<AxAIServiceOptions>;\n  supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n}\n\nexport const axBaseAIDefaultConfig = (): AxModelConfig =>\n  structuredClone({\n    temperature: 0,\n    topK: 40,\n    topP: 0.9,\n  });\n\nexport const axBaseAIDefaultCreativeConfig = (): AxModelConfig =>\n  structuredClone({\n    temperature: 0.4,\n    topP: 0.7,\n    frequencyPenalty: 0.2,\n  });\n\nexport class AxBaseAI<\n  TModel,\n  TEmbedModel,\n  TChatRequest,\n  TEmbedRequest,\n  TChatResponse,\n  TChatResponseDelta,\n  TEmbedResponse,\n  TModelKey,\n> implements AxAIService<TModel, TEmbedModel, TModelKey>\n{\n  private debug = false;\n\n  private rt?: AxAIServiceOptions['rateLimiter'];\n  private fetch?: AxAIServiceOptions['fetch'];\n  private tracer?: AxAIServiceOptions['tracer'];\n  private meter?: AxAIServiceOptions['meter'];\n  private timeout?: AxAIServiceOptions['timeout'];\n  private excludeContentFromTrace?: boolean;\n  private models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n  private abortSignal?: AbortSignal;\n  private logger: AxLoggerFunction = axGlobals.logger ?? defaultLogger;\n  private corsProxy?: AxAIServiceOptions['corsProxy'];\n\n  private modelInfo: readonly AxModelInfo[];\n  private modelUsage?: AxModelUsage;\n  private embedModelUsage?: AxModelUsage;\n  private defaults: AxBaseAIArgs<TModel, TEmbedModel, TModelKey>['defaults'];\n  private lastUsedModelConfig?: AxModelConfig;\n  private lastUsedChatModel?: TModel;\n  private lastUsedEmbedModel?: TEmbedModel;\n\n  protected apiURL?: string;\n  protected name: string;\n  protected id: string;\n  protected headers: () => Promise<Record<string, string>>;\n  protected supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n\n  // Add private metrics tracking properties\n  private metrics: AxAIServiceMetrics = {\n    latency: {\n      chat: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n      embed: {\n        mean: 0,\n        p95: 0,\n        p99: 0,\n        samples: [],\n      },\n    },\n    errors: {\n      chat: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n      embed: {\n        count: 0,\n        rate: 0,\n        total: 0,\n      },\n    },\n  };\n\n  constructor(\n    private readonly aiImpl: Readonly<\n      AxAIServiceImpl<\n        TModel,\n        TEmbedModel,\n        TChatRequest,\n        TEmbedRequest,\n        TChatResponse,\n        TChatResponseDelta,\n        TEmbedResponse\n      >\n    >,\n    {\n      name,\n      apiURL,\n      headers,\n      modelInfo,\n      defaults,\n      options = {},\n      supportFor,\n      models,\n    }: Readonly<AxBaseAIArgs<TModel, TEmbedModel, TModelKey>>\n  ) {\n    this.name = name;\n    this.apiURL = apiURL || '';\n    this.headers = headers;\n    this.supportFor = supportFor;\n    this.tracer = options.tracer ?? axGlobals.tracer;\n    this.meter = options.meter ?? axGlobals.meter;\n    this.modelInfo = modelInfo;\n    this.models = models;\n    this.id = randomUUID();\n\n    const model = this.getModel(defaults.model) ?? defaults.model;\n    const embedModel =\n      this.getEmbedModel(defaults.embedModel) ?? defaults.embedModel;\n\n    this.defaults = { model, embedModel };\n\n    if (\n      !defaults.model ||\n      typeof defaults.model !== 'string' ||\n      defaults.model === ''\n    ) {\n      throw new Error('No model defined');\n    }\n\n    this.setOptions(options);\n\n    if (models) {\n      validateModels(models);\n    }\n  }\n\n  private getMetricsInstruments(): AxAIMetricsInstruments | undefined {\n    return getOrCreateAIMetricsInstruments(this.meter);\n  }\n\n  public setName(name: string): void {\n    this.name = name;\n  }\n\n  public getId(): string {\n    return this.id;\n  }\n\n  public setAPIURL(apiURL: string): void {\n    this.apiURL = apiURL;\n  }\n\n  public setHeaders(headers: () => Promise<Record<string, string>>): void {\n    this.headers = headers;\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.debug = options.debug ?? false;\n    this.rt = options.rateLimiter;\n    this.fetch = options.fetch;\n    this.timeout = options.timeout;\n    this.tracer = options.tracer ?? axGlobals.tracer;\n    this.meter = options.meter ?? axGlobals.meter;\n    this.excludeContentFromTrace = options.excludeContentFromTrace;\n    this.abortSignal = options.abortSignal;\n    this.logger = options.logger ?? axGlobals.logger ?? this.logger;\n    this.corsProxy = options.corsProxy;\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return {\n      debug: this.debug,\n      rateLimiter: this.rt,\n      fetch: this.fetch,\n      tracer: this.tracer,\n      meter: this.meter,\n      timeout: this.timeout,\n      excludeContentFromTrace: this.excludeContentFromTrace,\n      abortSignal: this.abortSignal,\n      logger: this.logger,\n      corsProxy: this.corsProxy,\n    };\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.logger;\n  }\n\n  getModelList() {\n    const models = [];\n    for (const model of this.models ?? []) {\n      if (model.isInternal) {\n        continue;\n      }\n\n      if ('model' in model && model.model) {\n        models.push({\n          key: model.key as TModelKey,\n          description: model.description,\n          model: model.model as string,\n        } as const);\n      }\n\n      if ('embedModel' in model && model.embedModel) {\n        models.push({\n          key: model.key as TModelKey,\n          description: model.description,\n          embedModel: model.embedModel as string,\n        } as const);\n      }\n    }\n\n    return models;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getFeatures(model?: TModel): AxAIFeatures {\n    return typeof this.supportFor === 'function'\n      ? this.supportFor(model ?? this.defaults.model)\n      : this.supportFor;\n  }\n\n  getLastUsedChatModel(): TModel | undefined {\n    return this.lastUsedChatModel;\n  }\n\n  getLastUsedEmbedModel(): TEmbedModel | undefined {\n    return this.lastUsedEmbedModel;\n  }\n\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.lastUsedModelConfig;\n  }\n\n  // Method to calculate percentiles\n  private calculatePercentile(\n    samples: readonly number[],\n    percentile: number\n  ): number {\n    if (samples.length === 0) return 0;\n    const sorted = [...samples].sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[index] ?? 0;\n  }\n\n  // Method to update latency metrics\n  private updateLatencyMetrics(type: 'chat' | 'embed', duration: number): void {\n    const metrics = this.metrics.latency[type];\n    metrics.samples.push(duration);\n\n    // Keep only last 1000 samples to prevent memory issues\n    if (metrics.samples.length > 1000) {\n      metrics.samples.shift();\n    }\n\n    // Update statistics\n    metrics.mean =\n      metrics.samples.reduce((a, b) => a + b, 0) / metrics.samples.length;\n    metrics.p95 = this.calculatePercentile(metrics.samples, 95);\n    metrics.p99 = this.calculatePercentile(metrics.samples, 99);\n\n    // Export to OpenTelemetry metrics\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n\n      // Record individual latency measurement\n      recordLatencyMetric(metricsInstruments, type, duration, this.name, model);\n\n      // Record latency statistics as gauges\n      recordLatencyStatsMetrics(\n        metricsInstruments,\n        type,\n        metrics.mean,\n        metrics.p95,\n        metrics.p99,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Method to update error metrics\n  private updateErrorMetrics(type: 'chat' | 'embed', isError: boolean): void {\n    const metrics = this.metrics.errors[type];\n    metrics.total++;\n    if (isError) {\n      metrics.count++;\n    }\n    metrics.rate = metrics.count / metrics.total;\n\n    // Export to OpenTelemetry metrics\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n\n      // Always record request count\n      recordRequestMetric(metricsInstruments, type, this.name, model);\n\n      // Record error count if there was an error\n      if (isError) {\n        recordErrorMetric(metricsInstruments, type, this.name, model);\n      }\n\n      // Record current error rate as a gauge\n      recordErrorRateMetric(\n        metricsInstruments,\n        type,\n        metrics.rate,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Method to record token usage metrics\n  private recordTokenUsage(modelUsage?: AxModelUsage): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments && modelUsage?.tokens) {\n      const { promptTokens, completionTokens, totalTokens, thoughtsTokens } =\n        modelUsage.tokens;\n\n      if (promptTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'input',\n          promptTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (completionTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'output',\n          completionTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (totalTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'total',\n          totalTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n\n      if (thoughtsTokens) {\n        recordTokenMetric(\n          metricsInstruments,\n          'thoughts',\n          thoughtsTokens,\n          this.name,\n          modelUsage.model\n        );\n      }\n    }\n  }\n\n  // Helper method to calculate request size in bytes\n  private calculateRequestSize(req: unknown): number {\n    try {\n      return new TextEncoder().encode(JSON.stringify(req)).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Helper method to calculate response size in bytes\n  private calculateResponseSize(response: unknown): number {\n    try {\n      return new TextEncoder().encode(JSON.stringify(response)).length;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Helper method to detect multimodal content\n  private detectMultimodalContent(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>\n  ): {\n    hasImages: boolean;\n    hasAudio: boolean;\n  } {\n    let hasImages = false;\n    let hasAudio = false;\n\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      for (const message of req.chatPrompt) {\n        if (message.role === 'user' && Array.isArray(message.content)) {\n          for (const part of message.content) {\n            if (part.type === 'image') {\n              hasImages = true;\n            } else if (part.type === 'audio') {\n              hasAudio = true;\n            }\n          }\n        }\n      }\n    }\n\n    return { hasImages, hasAudio };\n  }\n\n  // Helper method to calculate prompt length\n  private calculatePromptLength(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>\n  ): number {\n    let totalLength = 0;\n\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      for (const message of req.chatPrompt) {\n        if (message.role === 'system' || message.role === 'assistant') {\n          if (message.content) {\n            totalLength += message.content.length;\n          }\n        } else if (message.role === 'user') {\n          if (typeof message.content === 'string') {\n            totalLength += message.content.length;\n          } else if (Array.isArray(message.content)) {\n            for (const part of message.content) {\n              if (part.type === 'text') {\n                totalLength += part.text.length;\n              }\n            }\n          }\n        } else if (message.role === 'function') {\n          if (message.result) {\n            totalLength += message.result.length;\n          }\n        }\n      }\n    }\n\n    return totalLength;\n  }\n\n  // Helper method to calculate context window usage\n  private calculateContextWindowUsage(\n    model: TModel,\n    modelUsage?: AxModelUsage\n  ): number {\n    if (!modelUsage?.tokens?.promptTokens) return 0;\n\n    // Get model info to find context window size\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (!modelInfo?.contextWindow) return 0;\n\n    return modelUsage.tokens.promptTokens / modelInfo.contextWindow;\n  }\n\n  // Helper method to estimate cost\n  private estimateCost(model: TModel, modelUsage?: AxModelUsage): number {\n    if (!modelUsage?.tokens) return 0;\n\n    // Get model info to find pricing\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (\n      !modelInfo ||\n      (!modelInfo.promptTokenCostPer1M && !modelInfo.completionTokenCostPer1M)\n    )\n      return 0;\n\n    const { promptTokens = 0, completionTokens = 0 } = modelUsage.tokens;\n    const promptCostPer1M = modelInfo.promptTokenCostPer1M || 0;\n    const completionCostPer1M = modelInfo.completionTokenCostPer1M || 0;\n\n    return (\n      (promptTokens * promptCostPer1M) / 1000000 +\n      (completionTokens * completionCostPer1M) / 1000000\n    );\n  }\n\n  // Helper method to estimate cost by model name\n  private estimateCostByName(\n    modelName: string,\n    modelUsage?: AxModelUsage\n  ): number {\n    if (!modelUsage?.tokens) return 0;\n\n    // Get model info to find pricing\n    const modelInfo = this.modelInfo.find((info) => info.name === modelName);\n    if (\n      !modelInfo ||\n      (!modelInfo.promptTokenCostPer1M && !modelInfo.completionTokenCostPer1M)\n    )\n      return 0;\n\n    const { promptTokens = 0, completionTokens = 0 } = modelUsage.tokens;\n    const promptCostPer1M = modelInfo.promptTokenCostPer1M || 0;\n    const completionCostPer1M = modelInfo.completionTokenCostPer1M || 0;\n\n    return (\n      (promptTokens * promptCostPer1M) / 1000000 +\n      (completionTokens * completionCostPer1M) / 1000000\n    );\n  }\n\n  // Helper method to record function call metrics\n  private recordFunctionCallMetrics(\n    functionCalls?: readonly unknown[],\n    model?: TModel\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments || !functionCalls) return;\n\n    for (const call of functionCalls) {\n      if (\n        call &&\n        typeof call === 'object' &&\n        'function' in call &&\n        call.function &&\n        typeof call.function === 'object' &&\n        'name' in call.function\n      ) {\n        recordFunctionCallMetric(\n          metricsInstruments,\n          (call.function as { name: string }).name,\n          undefined, // latency would need to be tracked separately\n          this.name,\n          model as string\n        );\n      }\n    }\n  }\n\n  // Helper method to record timeout metrics\n  private recordTimeoutMetric(type: 'chat' | 'embed'): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n      recordTimeoutMetric(metricsInstruments, type, this.name, model);\n    }\n  }\n\n  // Helper method to record abort metrics\n  private recordAbortMetric(type: 'chat' | 'embed'): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      const model =\n        type === 'chat'\n          ? (this.lastUsedChatModel as string)\n          : (this.lastUsedEmbedModel as string);\n      recordAbortMetric(metricsInstruments, type, this.name, model);\n    }\n  }\n\n  // Comprehensive method to record all chat-related metrics\n  private recordChatMetrics(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>,\n    result?: AxChatResponse | ReadableStream<AxChatResponse>\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments) return;\n\n    const model = this.lastUsedChatModel as string;\n    const modelConfig = this.lastUsedModelConfig;\n\n    // Record streaming request metric\n    const isStreaming = modelConfig?.stream ?? false;\n    recordStreamingRequestMetric(\n      metricsInstruments,\n      'chat',\n      isStreaming,\n      this.name,\n      model\n    );\n\n    // Record multimodal request metric\n    const { hasImages, hasAudio } = this.detectMultimodalContent(req);\n    recordMultimodalRequestMetric(\n      metricsInstruments,\n      hasImages,\n      hasAudio,\n      this.name,\n      model\n    );\n\n    // Record prompt length metric\n    const promptLength = this.calculatePromptLength(req);\n    recordPromptLengthMetric(\n      metricsInstruments,\n      promptLength,\n      this.name,\n      model\n    );\n\n    // Record model configuration metrics\n    recordModelConfigMetrics(\n      metricsInstruments,\n      modelConfig?.temperature,\n      modelConfig?.maxTokens,\n      this.name,\n      model\n    );\n\n    // Record thinking budget usage if applicable\n    if (\n      options?.thinkingTokenBudget &&\n      this.modelUsage?.tokens?.thoughtsTokens\n    ) {\n      recordThinkingBudgetUsageMetric(\n        metricsInstruments,\n        this.modelUsage.tokens.thoughtsTokens,\n        this.name,\n        model\n      );\n    }\n\n    // Record request size\n    const requestSize = this.calculateRequestSize(req);\n    recordRequestSizeMetric(\n      metricsInstruments,\n      'chat',\n      requestSize,\n      this.name,\n      model\n    );\n\n    // Record response size and function calls for non-streaming responses\n    if (result && !isStreaming) {\n      const chatResponse = result as AxChatResponse;\n      const responseSize = this.calculateResponseSize(chatResponse);\n      recordResponseSizeMetric(\n        metricsInstruments,\n        'chat',\n        responseSize,\n        this.name,\n        model\n      );\n\n      // Record function call metrics\n      if (chatResponse.results) {\n        for (const chatResult of chatResponse.results) {\n          if (chatResult.functionCalls) {\n            this.recordFunctionCallMetrics(\n              chatResult.functionCalls,\n              this.lastUsedChatModel\n            );\n          }\n        }\n      }\n\n      // Record context window usage\n      const contextUsage = this.calculateContextWindowUsage(\n        this.lastUsedChatModel!,\n        chatResponse.modelUsage\n      );\n      if (contextUsage > 0) {\n        recordContextWindowUsageMetric(\n          metricsInstruments,\n          contextUsage,\n          this.name,\n          model\n        );\n      }\n\n      // Record estimated cost\n      const estimatedCost = this.estimateCost(\n        this.lastUsedChatModel!,\n        chatResponse.modelUsage\n      );\n      if (estimatedCost > 0) {\n        recordEstimatedCostMetric(\n          metricsInstruments,\n          'chat',\n          estimatedCost,\n          this.name,\n          model\n        );\n      }\n    }\n  }\n\n  // Comprehensive method to record all embed-related metrics\n  private recordEmbedMetrics(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    result: Readonly<AxEmbedResponse>\n  ): void {\n    const metricsInstruments = this.getMetricsInstruments();\n    if (!metricsInstruments) return;\n\n    const model = this.lastUsedEmbedModel as string;\n\n    // Record request size\n    const requestSize = this.calculateRequestSize(req);\n    recordRequestSizeMetric(\n      metricsInstruments,\n      'embed',\n      requestSize,\n      this.name,\n      model\n    );\n\n    // Record response size\n    const responseSize = this.calculateResponseSize(result);\n    recordResponseSizeMetric(\n      metricsInstruments,\n      'embed',\n      responseSize,\n      this.name,\n      model\n    );\n\n    // Record estimated cost\n    const estimatedCost = this.estimateCostByName(model, result.modelUsage);\n    if (estimatedCost > 0) {\n      recordEstimatedCostMetric(\n        metricsInstruments,\n        'embed',\n        estimatedCost,\n        this.name,\n        model\n      );\n    }\n  }\n\n  // Public method to get metrics\n  public getMetrics(): AxAIServiceMetrics {\n    return structuredClone(this.metrics);\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const startTime = performance.now();\n    let isError = false;\n    let result: AxChatResponse | ReadableStream<AxChatResponse>;\n\n    try {\n      result = await this._chat1(req, options);\n      return result;\n    } catch (error) {\n      isError = true;\n      // Check for specific error types\n      if (error instanceof Error) {\n        if (\n          error.message.includes('timeout') ||\n          error.name === 'TimeoutError'\n        ) {\n          this.recordTimeoutMetric('chat');\n        } else if (\n          error.message.includes('abort') ||\n          error.name === 'AbortError'\n        ) {\n          this.recordAbortMetric('chat');\n        }\n      }\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.updateLatencyMetrics('chat', duration);\n      this.updateErrorMetrics('chat', isError);\n\n      // Record additional metrics if successful\n      if (!isError) {\n        this.recordChatMetrics(req, options, result!);\n      }\n    }\n  }\n\n  private async _chat1(\n    req: Readonly<AxChatRequest<TModel | TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const model =\n      this.getModel(req.model) ?? (req.model as TModel) ?? this.defaults.model;\n\n    // Validate chat prompt messages for empty content\n    if (req.chatPrompt && Array.isArray(req.chatPrompt)) {\n      validateAxMessageArray(req.chatPrompt);\n    }\n\n    const modelConfig = {\n      ...this.aiImpl.getModelConfig(),\n      ...req.modelConfig,\n    };\n\n    // Check for thinkingTokenBudget support\n    if (\n      options?.thinkingTokenBudget &&\n      !this.getFeatures(model).hasThinkingBudget\n    ) {\n      throw new Error(\n        `Model ${model as string} does not support thinkingTokenBudget.`\n      );\n    }\n\n    // Check for showThoughts support\n    if (options?.showThoughts && !this.getFeatures(model).hasShowThoughts) {\n      throw new Error(\n        `Model ${model as string} does not support showThoughts.`\n      );\n    }\n\n    // Check for expensive model usage\n    const modelInfo = this.modelInfo.find(\n      (info) => info.name === (model as string)\n    );\n    if (modelInfo?.isExpensive && options?.useExpensiveModel !== 'yes') {\n      throw new Error(\n        `Model ${model as string} is marked as expensive and requires explicit confirmation. Set useExpensiveModel: \"yes\" to proceed.`\n      );\n    }\n\n    // stream is true by default unless explicitly set to false\n    modelConfig.stream =\n      (options?.stream !== undefined ? options.stream : modelConfig.stream) ??\n      true;\n\n    const canStream = this.getFeatures(model).streaming;\n    if (!canStream) {\n      modelConfig.stream = false;\n    }\n\n    if (this.tracer) {\n      return await this.tracer.startActiveSpan(\n        'AI Chat Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_OPERATION_NAME]: 'chat',\n            [axSpanAttributes.LLM_REQUEST_MODEL]: model as string,\n            [axSpanAttributes.LLM_REQUEST_MAX_TOKENS]:\n              modelConfig.maxTokens ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_TEMPERATURE]: modelConfig.temperature,\n            [axSpanAttributes.LLM_REQUEST_TOP_P]: modelConfig.topP ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_TOP_K]: modelConfig.topK ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_FREQUENCY_PENALTY]:\n              modelConfig.frequencyPenalty ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_PRESENCE_PENALTY]:\n              modelConfig.presencePenalty ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_STOP_SEQUENCES]:\n              modelConfig.stopSequences?.join(', ') ?? 'Not set',\n            [axSpanAttributes.LLM_REQUEST_LLM_IS_STREAMING]:\n              modelConfig.stream ?? 'Not set',\n          },\n        },\n        options?.traceContext ?? context.active(),\n        async (span) => {\n          return await this._chat2(model, modelConfig, req, options, span);\n        }\n      );\n    }\n    return await this._chat2(model, modelConfig, req, options);\n  }\n\n  private cleanupFunctionSchema(\n    fn: Readonly<NonNullable<AxChatRequest['functions']>[number]>\n  ): NonNullable<AxChatRequest['functions']>[number] {\n    const cleanFn = { ...fn };\n    if (cleanFn.parameters) {\n      const cleanParams = { ...cleanFn.parameters };\n\n      // Remove empty required array\n      if (\n        Array.isArray(cleanParams.required) &&\n        cleanParams.required.length === 0\n      ) {\n        delete cleanParams.required;\n      }\n\n      // Remove empty properties object\n      if (\n        cleanParams.properties &&\n        Object.keys(cleanParams.properties).length === 0\n      ) {\n        delete cleanParams.properties;\n      }\n\n      // After cleaning, remove the entire parameters object if it's effectively empty\n      // i.e., either no keys left or just { type: 'object' } remaining.\n      if (\n        Object.keys(cleanParams).length === 0 ||\n        (Object.keys(cleanParams).length === 1 && cleanParams.type === 'object')\n      ) {\n        delete cleanFn.parameters;\n      } else {\n        cleanFn.parameters = cleanParams;\n      }\n    }\n    return cleanFn;\n  }\n\n  private async _chat2(\n    model: TModel,\n    modelConfig: Readonly<AxModelConfig>,\n    chatReq: Readonly<Omit<AxChatRequest<TModel | TModelKey>, 'modelConfig'>>,\n    options?: Readonly<AxAIServiceOptions>,\n    span?: Span\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    if (!this.aiImpl.createChatReq) {\n      throw new Error('generateChatReq not implemented');\n    }\n\n    const debug = options?.debug ?? this.debug;\n\n    let functions: NonNullable<AxChatRequest['functions']> | undefined;\n\n    if (chatReq.functions && chatReq.functions.length > 0) {\n      functions = chatReq.functions.map((fn) => this.cleanupFunctionSchema(fn));\n    }\n\n    const req = {\n      ...chatReq,\n      model,\n      functions,\n      modelConfig,\n    };\n\n    // Store the last used model and config\n    this.lastUsedChatModel = model;\n    this.lastUsedModelConfig = modelConfig;\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = await this.aiImpl.createChatReq(\n        req,\n        options\n      );\n\n      if (span?.isRecording()) {\n        setChatRequestEvents(chatReq, span, this.excludeContentFromTrace);\n      }\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          localCall: apiConfig.localCall,\n          headers: await this.buildHeaders(apiConfig.headers),\n          stream: modelConfig.stream,\n          timeout: this.timeout,\n          debug,\n          fetch: this.fetch,\n          span,\n          abortSignal: options?.abortSignal ?? this.abortSignal,\n          corsProxy: this.corsProxy,\n        },\n        reqValue\n      );\n      return res;\n    };\n\n    if (debug) {\n      logChatRequest(\n        req.chatPrompt,\n        options?.stepIndex ?? 0,\n        options?.logger ?? this.logger,\n        options?.debugHideSystemPrompt\n      );\n    }\n\n    const rt = options?.rateLimiter ?? this.rt;\n    const rv = rt ? await rt(fn, { modelUsage: this.modelUsage }) : await fn();\n\n    if (modelConfig.stream) {\n      if (!this.aiImpl.createChatStreamResp) {\n        throw new Error('generateChatStreamResp not implemented');\n      }\n\n      const respFn = this.aiImpl.createChatStreamResp.bind(this);\n      const wrappedRespFn =\n        (state: object) => (resp: Readonly<TChatResponseDelta>) => {\n          const res = respFn(resp, state);\n          res.sessionId = options?.sessionId;\n\n          // Only call getTokenUsage if modelUsage is not already provided by the service\n          if (!res.modelUsage) {\n            const tokenUsage = this.aiImpl.getTokenUsage();\n            if (tokenUsage) {\n              res.modelUsage = {\n                ai: this.name,\n                model: model as string,\n                tokens: tokenUsage,\n              };\n            }\n          }\n          this.modelUsage = res.modelUsage;\n          this.recordTokenUsage(res.modelUsage);\n\n          if (span?.isRecording()) {\n            setChatResponseEvents(res, span, this.excludeContentFromTrace);\n          }\n\n          if (debug) {\n            // Log individual streaming results\n            for (const result of res.results) {\n              logResponseStreamingResult(\n                result,\n                result.index,\n                options?.logger ?? this.logger\n              );\n            }\n          }\n          return res;\n        };\n\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const doneCb = async (values: readonly AxChatResponse[]) => {\n        if (span?.isRecording()) {\n          span.end();\n        }\n        if (debug) {\n          logResponseStreamingDoneResult(\n            values,\n            options?.logger ?? this.logger\n          );\n        }\n      };\n\n      // Check if we're in browser environment for compatibility\n      const isBrowser = typeof window !== 'undefined';\n\n      if (isBrowser) {\n        // Use browser-compatible manual stream processing instead of pipeThrough\n        const sourceStream = rv as ReadableStream<TChatResponseDelta>;\n        const transformState = {};\n        const transformedValues: AxChatResponse[] = [];\n\n        return new ReadableStream<AxChatResponse>({\n          start(controller) {\n            const reader = sourceStream.getReader();\n\n            async function read() {\n              try {\n                while (true) {\n                  const { done, value } = await reader.read();\n                  if (done) {\n                    // Call done callback with all transformed values\n                    if (doneCb) {\n                      await doneCb(transformedValues);\n                    }\n                    controller.close();\n                    break;\n                  }\n\n                  const transformedValue = wrappedRespFn(transformState)(value);\n                  if (transformedValue) {\n                    transformedValues.push(transformedValue);\n                    controller.enqueue(transformedValue);\n                  }\n                }\n              } catch (error) {\n                controller.error(error);\n              } finally {\n                reader.releaseLock();\n              }\n            }\n\n            read();\n          },\n        });\n      }\n      // Use pipeThrough for Node.js environments where it's fully supported\n      const st = (rv as ReadableStream<TChatResponseDelta>).pipeThrough(\n        new RespTransformStream<TChatResponseDelta, AxChatResponse>(\n          wrappedRespFn({}),\n          doneCb\n        )\n      );\n      return st;\n    }\n\n    if (!this.aiImpl.createChatResp) {\n      throw new Error('generateChatResp not implemented');\n    }\n\n    const res = this.aiImpl.createChatResp(rv as TChatResponse);\n    res.sessionId = options?.sessionId;\n\n    // Only call getTokenUsage if modelUsage is not already provided by the service\n    if (!res.modelUsage) {\n      const tokenUsage = this.aiImpl.getTokenUsage();\n      if (tokenUsage) {\n        res.modelUsage = {\n          ai: this.name,\n          model: model as string,\n          tokens: tokenUsage,\n        };\n      }\n    }\n\n    if (res.modelUsage) {\n      this.modelUsage = res.modelUsage;\n      this.recordTokenUsage(res.modelUsage);\n    }\n\n    if (span?.isRecording()) {\n      setChatResponseEvents(res, span, this.excludeContentFromTrace);\n      span.end();\n    }\n\n    if (debug) {\n      logResponse(res, options?.logger ?? this.logger);\n    }\n\n    return res;\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    const startTime = performance.now();\n    let isError = false;\n    let result: AxEmbedResponse | undefined;\n\n    try {\n      result = await this._embed1(req, options);\n      return result;\n    } catch (error) {\n      isError = true;\n      // Check for specific error types\n      if (error instanceof Error) {\n        if (\n          error.message.includes('timeout') ||\n          error.name === 'TimeoutError'\n        ) {\n          this.recordTimeoutMetric('embed');\n        } else if (\n          error.message.includes('abort') ||\n          error.name === 'AbortError'\n        ) {\n          this.recordAbortMetric('embed');\n        }\n      }\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n      this.updateLatencyMetrics('embed', duration);\n      this.updateErrorMetrics('embed', isError);\n\n      // Record additional metrics if successful\n      if (!isError && result) {\n        this.recordEmbedMetrics(req, result);\n      }\n    }\n  }\n\n  private async _embed1(\n    req: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    const embedModel =\n      this.getEmbedModel(req.embedModel) ??\n      (req.embedModel as TEmbedModel) ??\n      this.defaults.embedModel;\n\n    if (!embedModel) {\n      throw new Error('No embed model defined');\n    }\n\n    if (this.tracer) {\n      await this.tracer?.startActiveSpan(\n        'AI Embed Request',\n        {\n          kind: SpanKind.SERVER,\n          attributes: {\n            [axSpanAttributes.LLM_SYSTEM]: this.name,\n            [axSpanAttributes.LLM_OPERATION_NAME]: 'embeddings',\n            [axSpanAttributes.LLM_REQUEST_MODEL]: embedModel as string,\n          },\n        },\n        options?.traceContext ?? context.active(),\n        async (span) => {\n          try {\n            return await this._embed2(embedModel, req, options, span);\n          } finally {\n            span.end();\n          }\n        }\n      );\n    }\n    return this._embed2(embedModel, req, options);\n  }\n\n  private async _embed2(\n    embedModel: TEmbedModel,\n    embedReq: Readonly<AxEmbedRequest<TEmbedModel>>,\n    options?: Readonly<AxAIServiceOptions>,\n    span?: Span\n  ): Promise<AxEmbedResponse> {\n    if (!this.aiImpl.createEmbedReq) {\n      throw new Error('generateEmbedReq not implemented');\n    }\n    if (!this.aiImpl.createEmbedResp) {\n      throw new Error('generateEmbedResp not implemented');\n    }\n\n    const createEmbedReq = this.aiImpl.createEmbedReq;\n    const debug = options?.debug ?? this.debug;\n\n    const req = {\n      ...embedReq,\n      embedModel,\n    };\n\n    // Store the last used embed model\n    this.lastUsedEmbedModel = embedModel;\n\n    if (debug) {\n      logEmbedRequest(\n        req.texts ?? [],\n        embedModel as string,\n        options?.logger ?? this.logger\n      );\n    }\n\n    const fn = async () => {\n      const [apiConfig, reqValue] = await createEmbedReq(req);\n\n      const res = await apiCall(\n        {\n          name: apiConfig.name,\n          url: this.apiURL,\n          localCall: apiConfig.localCall,\n          headers: await this.buildHeaders(apiConfig.headers),\n          debug,\n          fetch: this.fetch,\n          timeout: this.timeout,\n          span,\n          abortSignal: options?.abortSignal ?? this.abortSignal,\n          corsProxy: this.corsProxy,\n        },\n        reqValue\n      );\n      return res;\n    };\n\n    const resValue = this.rt\n      ? await this.rt(fn, { modelUsage: this.embedModelUsage })\n      : await fn();\n    const res = this.aiImpl.createEmbedResp?.(resValue as TEmbedResponse);\n\n    res.sessionId = options?.sessionId;\n\n    // Only call getTokenUsage if modelUsage is not already provided by the service\n    if (!res.modelUsage) {\n      const tokenUsage = this.aiImpl.getTokenUsage();\n      if (tokenUsage) {\n        res.modelUsage = {\n          ai: this.name,\n          model: embedModel as string,\n          tokens: tokenUsage,\n        };\n      }\n    }\n    this.embedModelUsage = res.modelUsage;\n    this.recordTokenUsage(res.modelUsage);\n\n    if (span?.isRecording() && res.modelUsage?.tokens) {\n      span.addEvent(axSpanEvents.GEN_AI_USAGE, {\n        [axSpanAttributes.LLM_USAGE_INPUT_TOKENS]:\n          res.modelUsage.tokens.promptTokens,\n        [axSpanAttributes.LLM_USAGE_OUTPUT_TOKENS]:\n          res.modelUsage.tokens.completionTokens ?? 0,\n        [axSpanAttributes.LLM_USAGE_TOTAL_TOKENS]:\n          res.modelUsage.tokens.totalTokens,\n      });\n    }\n\n    if (debug) {\n      logEmbedResponse(res.embeddings, options?.logger ?? this.logger);\n    }\n\n    span?.end();\n    return res;\n  }\n\n  private async buildHeaders(\n    headers: Record<string, string> = {}\n  ): Promise<Record<string, string>> {\n    return { ...headers, ...(await this.headers()) };\n  }\n\n  private getModelByKey(\n    modelName?: TModel | TEmbedModel | TModelKey\n  ): AxAIInputModelList<TModel, TEmbedModel, TModelKey>[number] | undefined {\n    if (!modelName) {\n      return undefined;\n    }\n    const item = this.models?.find((v) => v.key === modelName);\n    return item;\n  }\n\n  private getModel(modelName?: TModel | TModelKey): TModel | undefined {\n    const item = this.getModelByKey(modelName);\n    return item && 'model' in item ? item.model : undefined;\n  }\n\n  private getEmbedModel(\n    modelName?: TEmbedModel | TModelKey\n  ): TEmbedModel | undefined {\n    const item = this.getModelByKey(modelName);\n    return item && 'embedModel' in item ? item.embedModel : undefined;\n  }\n}\n\nexport function setChatRequestEvents(\n  req: Readonly<AxChatRequest<unknown>>,\n  span: Span,\n  excludeContentFromTrace?: boolean\n): void {\n  const userMessages: string[] = [];\n\n  if (\n    req.chatPrompt &&\n    Array.isArray(req.chatPrompt) &&\n    req.chatPrompt.length > 0\n  ) {\n    for (const prompt of req.chatPrompt) {\n      switch (prompt.role) {\n        case 'system':\n          if (prompt.content) {\n            const eventData: { content?: string } = {};\n            if (!excludeContentFromTrace) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_SYSTEM_MESSAGE, eventData);\n          }\n          break;\n        case 'user':\n          if (typeof prompt.content === 'string') {\n            userMessages.push(prompt.content);\n          } else if (Array.isArray(prompt.content)) {\n            for (const part of prompt.content) {\n              if (part.type === 'text') {\n                userMessages.push(part.text);\n              }\n            }\n          }\n          break;\n        case 'assistant': {\n          const functionCalls = prompt.functionCalls?.map((call) => {\n            return {\n              id: call.id,\n              type: call.type,\n              function: call.function.name,\n              arguments: call.function.params,\n            };\n          });\n\n          if (functionCalls && functionCalls.length > 0) {\n            const eventData: { content?: string; function_calls: string } = {\n              function_calls: JSON.stringify(functionCalls, null, 2),\n            };\n            if (!excludeContentFromTrace && prompt.content) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_ASSISTANT_MESSAGE, eventData);\n          } else if (prompt.content) {\n            const eventData: { content?: string } = {};\n            if (!excludeContentFromTrace) {\n              eventData.content = prompt.content;\n            }\n            span.addEvent(axSpanEvents.GEN_AI_ASSISTANT_MESSAGE, eventData);\n          }\n          break;\n        }\n\n        case 'function': {\n          const eventData: { content?: string; id: string } = {\n            id: prompt.functionId,\n          };\n          if (!excludeContentFromTrace) {\n            eventData.content = prompt.result;\n          }\n          span.addEvent(axSpanEvents.GEN_AI_TOOL_MESSAGE, eventData);\n          break;\n        }\n      }\n    }\n  }\n\n  // Always add user message event, even if empty\n  const userEventData: { content?: string } = {};\n  if (!excludeContentFromTrace) {\n    userEventData.content = userMessages.join('\\n');\n  }\n  span.addEvent(axSpanEvents.GEN_AI_USER_MESSAGE, userEventData);\n}\n\nexport function setChatResponseEvents(\n  res: Readonly<AxChatResponse>,\n  span: Span,\n  excludeContentFromTrace?: boolean\n) {\n  if (res.modelUsage?.tokens) {\n    const thoughTokens = res.modelUsage.tokens.thoughtsTokens\n      ? {\n          [axSpanAttributes.LLM_USAGE_THOUGHTS_TOKENS]:\n            res.modelUsage.tokens.thoughtsTokens,\n        }\n      : {};\n    span.addEvent(axSpanEvents.GEN_AI_USAGE, {\n      [axSpanAttributes.LLM_USAGE_INPUT_TOKENS]:\n        res.modelUsage.tokens.promptTokens,\n      [axSpanAttributes.LLM_USAGE_OUTPUT_TOKENS]:\n        res.modelUsage.tokens.completionTokens ?? 0,\n      [axSpanAttributes.LLM_USAGE_TOTAL_TOKENS]:\n        res.modelUsage.tokens.totalTokens,\n      ...thoughTokens,\n    });\n  }\n\n  if (!res.results) {\n    return;\n  }\n\n  for (let index = 0; index < res.results.length; index++) {\n    const result = res.results[index];\n    if (!result) {\n      continue;\n    }\n\n    // Skip empty results that have no meaningful content to avoid empty GEN_AI_CHOICE events\n    if (\n      !result.content &&\n      !result.thought &&\n      !result.functionCalls?.length &&\n      !result.finishReason\n    ) {\n      continue;\n    }\n\n    const toolCalls = result.functionCalls?.map((call) => {\n      return {\n        id: call.id,\n        type: call.type,\n        function: call.function.name,\n        arguments: call.function.params,\n      };\n    });\n\n    const message: { content?: string; tool_calls?: unknown[] } = {};\n\n    if (toolCalls && toolCalls.length > 0) {\n      if (!excludeContentFromTrace) {\n        message.content = result.content;\n      }\n      message.tool_calls = toolCalls;\n    } else {\n      if (!excludeContentFromTrace) {\n        message.content = result.content ?? '';\n      }\n    }\n\n    span.addEvent(axSpanEvents.GEN_AI_CHOICE, {\n      finish_reason: result.finishReason,\n      index,\n      message: JSON.stringify(message, null, 2),\n    });\n  }\n}\n\nexport function validateAxMessageArray<T>(values: T[]): void {\n  // Validate AxMessage array items\n  for (let i = 0; i < values.length; i++) {\n    const message = values[i];\n    if (!message || typeof message !== 'object') {\n      throw new Error(\n        `AxMessage array validation failed: Item at index ${i} is not a valid message object`\n      );\n    }\n    if (\n      'content' in message &&\n      typeof message.content === 'string' &&\n      message.content.trim() === ''\n    ) {\n      throw new Error(\n        `AxMessage array validation failed: Item at index ${i} has empty content`\n      );\n    }\n  }\n}\n\nfunction validateModels<TModel, TEmbedModel, TModelKey>(\n  models: Readonly<AxAIInputModelList<TModel, TEmbedModel, TModelKey>>\n): void {\n  // Validate duplicate keys in models.\n  const keys = new Set<TModelKey>();\n  for (const model of models) {\n    if (keys.has(model.key)) {\n      throw new Error(\n        `Duplicate model key detected: \"${model.key}\". Each model key must be unique.`\n      );\n    }\n    keys.add(model.key);\n  }\n}\n", "import type { Meter, Tracer } from '@opentelemetry/api';\n\nimport type { AxLoggerFunction } from '../ai/types.js';\nimport type { AxOptimizerLoggerFunction } from './optimizerTypes.js';\n\nexport type AxFunctionResultFormatter = (result: unknown) => string;\n\nexport const axGlobals = {\n  signatureStrict: true, // Controls reservedNames enforcement in signature parsing/validation\n  tracer: undefined as Tracer | undefined, // Global OpenTelemetry tracer for all AI operations\n  meter: undefined as Meter | undefined, // Global OpenTelemetry meter for metrics collection\n  logger: undefined as AxLoggerFunction | undefined, // Global logger for all AI operations\n  optimizerLogger: undefined as AxOptimizerLoggerFunction | undefined, // Global optimizer logger for all optimizer operations\n  functionResultFormatter: ((result: unknown) => {\n    return typeof result === 'string'\n      ? result\n      : result === undefined || result === null\n        ? ''\n        : JSON.stringify(result, null, 2);\n  }) as AxFunctionResultFormatter, // Global function result formatter\n};\n", "export class ColorLog {\n  // ANSI escape codes for different colors\n  private readonly ANSI_WHITE_BRIGHT = '\\x1b[97m';\n  private readonly ANSI_GREEN_BRIGHT = '\\x1b[92m';\n  private readonly ANSI_BLUE_BRIGHT = '\\x1b[94m';\n  private readonly ANSI_RED_BRIGHT = '\\x1b[91m';\n\n  private readonly ANSI_YELLOW = '\\x1b[93m';\n  private readonly ANSI_RED = '\\x1b[91m';\n  private readonly ANSI_RESET = '\\x1b[0m';\n  private readonly ANSI_ORANGE = '\\x1b[38;5;208m';\n  private readonly ANSI_WHITE = '\\x1b[37m';\n  private readonly ANSI_CYAN_BRIGHT = '\\x1b[96m';\n  private readonly ANSI_MAGENTA_BRIGHT = '\\x1b[95m';\n  private readonly ANSI_GRAY = '\\x1b[90m';\n\n  private readonly ANSI_GREEN = '\\x1b[32m';\n  private readonly ANSI_CYAN = '\\x1b[36m';\n  private readonly ANSI_MAGENTA = '\\x1b[35m';\n  private readonly ANSI_BLUE = '\\x1b[34m';\n  private readonly ANSI_YELLOW_DIM = '\\x1b[33m';\n\n  // Method to wrap text with the specified ANSI color code\n  private colorize(text: string, colorCode: string): string {\n    return `${colorCode}${text}${this.ANSI_RESET}`;\n  }\n\n  // Public methods to colorize text in various colors\n  public whiteBright(text: string): string {\n    return this.colorize(text, this.ANSI_WHITE_BRIGHT);\n  }\n\n  public greenBright(text: string): string {\n    return this.colorize(text, this.ANSI_GREEN_BRIGHT);\n  }\n\n  public blueBright(text: string): string {\n    return this.colorize(text, this.ANSI_BLUE_BRIGHT);\n  }\n\n  public redBright(text: string): string {\n    return this.colorize(text, this.ANSI_RED_BRIGHT);\n  }\n\n  public white(text: string): string {\n    return this.colorize(text, this.ANSI_WHITE);\n  }\n\n  public yellow(text: string): string {\n    return this.colorize(text, this.ANSI_YELLOW);\n  }\n\n  public red(text: string): string {\n    return this.colorize(text, this.ANSI_RED);\n  }\n\n  public orange(text: string): string {\n    return this.colorize(text, this.ANSI_ORANGE);\n  }\n\n  public cyanBright(text: string): string {\n    return this.colorize(text, this.ANSI_CYAN_BRIGHT);\n  }\n\n  public magentaBright(text: string): string {\n    return this.colorize(text, this.ANSI_MAGENTA_BRIGHT);\n  }\n\n  public gray(text: string): string {\n    return this.colorize(text, this.ANSI_GRAY);\n  }\n\n  public green(text: string): string {\n    return this.colorize(text, this.ANSI_GREEN);\n  }\n\n  public cyan(text: string): string {\n    return this.colorize(text, this.ANSI_CYAN);\n  }\n\n  public magenta(text: string): string {\n    return this.colorize(text, this.ANSI_MAGENTA);\n  }\n\n  public blue(text: string): string {\n    return this.colorize(text, this.ANSI_BLUE);\n  }\n\n  public yellowDim(text: string): string {\n    return this.colorize(text, this.ANSI_YELLOW_DIM);\n  }\n}\n", "import type {\n  AxChatRequest,\n  AxLoggerData,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport { ColorLog } from '../util/log.js';\n\nconst _colorLog = new ColorLog();\n\n// Default output function that writes to stdout\nconst defaultOutput = (message: string): void => {\n  console.log(message);\n};\n\n// Helper function to format chat message for display\nconst formatChatMessage = (\n  msg: AxChatRequest['chatPrompt'][number],\n  hideContent?: boolean,\n  cl?: ColorLog\n) => {\n  const colorize = (text: string, colorMethod?: keyof ColorLog) => {\n    if (cl && colorMethod && colorMethod in cl) {\n      return (cl[colorMethod] as (t: string) => string)(text);\n    }\n    return text;\n  };\n\n  switch (msg.role) {\n    case 'system':\n      return `${colorize('[ SYSTEM ]', 'magentaBright')}\\n${colorize(msg.content, 'magenta')}`;\n    case 'function':\n      return `${colorize('[ FUNCTION RESULT ]', 'yellow')}\\n${colorize(msg.result ?? '[No result]', 'yellowDim')}`;\n    case 'user': {\n      const header = `${colorize('[ USER ]', 'greenBright')}\\n`;\n      if (typeof msg.content === 'string') {\n        return header + colorize(msg.content, 'green');\n      }\n      const items = msg.content.map((item) => {\n        if (item.type === 'text') {\n          return colorize(item.text, 'green');\n        }\n        if (item.type === 'image') {\n          const content = hideContent ? '[Image]' : `[Image: ${item.image}]`;\n          return colorize(content, 'green');\n        }\n        if (item.type === 'audio') {\n          const content = hideContent ? '[Audio]' : `[Audio: ${item.data}]`;\n          return colorize(content, 'green');\n        }\n        return colorize('[Unknown content type]', 'gray');\n      });\n      return header + items.join('\\n');\n    }\n    case 'assistant': {\n      let header = colorize('[ ASSISTANT', 'cyanBright');\n      if (msg.name) {\n        header += ` ${msg.name}`;\n      }\n      header += ' ]';\n      let result = `${header}\\n`;\n      if (msg.content) {\n        result += `${colorize(msg.content, 'cyan')}\\n`;\n      }\n      if (msg.functionCalls && msg.functionCalls.length > 0) {\n        result += `${colorize('[ FUNCTION CALLS ]', 'yellow')}\\n`;\n        msg.functionCalls.forEach((call, i) => {\n          const params =\n            typeof call.function.params === 'string'\n              ? call.function.params\n              : JSON.stringify(call.function.params, null, 2);\n          result += colorize(\n            `${i + 1}. ${call.function.name}(${params}) [id: ${call.id}]`,\n            'yellowDim'\n          );\n          if (i < (msg.functionCalls?.length ?? 0) - 1) {\n            result += '\\n';\n          }\n        });\n        result += '\\n';\n      }\n      if (\n        !msg.content &&\n        (!msg.functionCalls || msg.functionCalls.length === 0)\n      ) {\n        result += colorize('[No content]', 'gray');\n      }\n      return result;\n    }\n    default:\n      return `${colorize('[ UNKNOWN ]', 'redBright')}\\n${colorize(JSON.stringify(msg), 'gray')}`;\n  }\n};\n\n// Factory function to create a default logger with customizable output\nexport const axCreateDefaultColorLogger = (\n  output: (message: string) => void = defaultOutput\n): AxLoggerFunction => {\n  const cl = new ColorLog();\n  const divider = cl.gray(`${''.repeat(60)}\\n`);\n  return (message: AxLoggerData) => {\n    const typedData = message;\n    let formattedMessage = '';\n\n    switch (typedData.name) {\n      case 'ChatRequestChatPrompt':\n        formattedMessage = `\\n${cl.blueBright(`[ CHAT REQUEST Step ${typedData.step} ]`)}\\n${divider}\\n`;\n        typedData.value.forEach((msg, i) => {\n          formattedMessage += formatChatMessage(msg, undefined, cl);\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        formattedMessage += `\\n${divider}`; // Keep closing for steps\n        break;\n      case 'FunctionResults':\n        formattedMessage = `\\n${cl.yellow('[ FUNCTION RESULTS ]')}\\n`;\n        typedData.value.forEach((result, i) => {\n          formattedMessage += cl.yellowDim(\n            `Function: ${result.functionId}\\nResult: ${result.result}`\n          );\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseResults':\n        formattedMessage = `\\n${cl.cyanBright('[ CHAT RESPONSE ]')}\\n`;\n        typedData.value.forEach((result, i) => {\n          formattedMessage += cl.cyan(result.content || '[No content]');\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseStreamingResult': {\n        const streamingContent =\n          typedData.value.delta || typedData.value.content || '';\n        // Add newline prefix if this is actual content (not just a delta)\n        formattedMessage = cl.cyanBright(streamingContent);\n        return;\n      }\n      case 'ChatResponseStreamingDoneResult': {\n        formattedMessage = `\\n${cl.cyanBright('[ CHAT RESPONSE ]')}\\n${divider}\\n`;\n        if (typedData.value.content) {\n          formattedMessage += cl.cyanBright(typedData.value.content);\n        }\n        if (typedData.value.functionCalls) {\n          formattedMessage += cl.cyanBright(\n            JSON.stringify(typedData.value.functionCalls, null, 2)\n          );\n        }\n        break;\n      }\n      case 'FunctionError':\n        formattedMessage = `\\n${cl.redBright(`[ FUNCTION ERROR #${typedData.index} ]`)}\\n${divider}\\n${cl.white(typedData.fixingInstructions)}\\n${cl.red(`Error: ${typedData.error}`)}`;\n        break;\n      case 'ValidationError':\n        formattedMessage = `\\n${cl.redBright(`[ VALIDATION ERROR #${typedData.index} ]`)}\\n${divider}\\n${cl.white(typedData.fixingInstructions)}\\n${cl.red(`Error: ${typedData.error}`)}`;\n        break;\n      case 'AssertionError':\n        formattedMessage = `\\n${cl.redBright(`[ ASSERTION ERROR #${typedData.index} ]`)}\\n${divider}\\n${cl.white(typedData.fixingInstructions)}\\n${cl.red(`Error: ${typedData.error}`)}`;\n        break;\n      case 'ResultPickerUsed':\n        formattedMessage = `${cl.greenBright('[ RESULT PICKER ]')}\\n${divider}\\n${cl.green(`Selected sample ${typedData.selectedIndex + 1} of ${typedData.sampleCount} (${typedData.latency.toFixed(2)}ms)`)}`;\n        break;\n      case 'Notification':\n        formattedMessage = `${cl.gray(`[ NOTIFICATION ${typedData.id} ]`)}\\n${divider}\\n${cl.white(typedData.value)}`;\n        break;\n      case 'EmbedRequest':\n        formattedMessage = `${cl.orange(`[ EMBED REQUEST ${typedData.embedModel} ]`)}\\n${divider}\\n`;\n        typedData.value.forEach((text, i) => {\n          formattedMessage += cl.white(\n            `Text ${i + 1}: ${text.substring(0, 100)}${text.length > 100 ? '...' : ''}`\n          );\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'EmbedResponse':\n        formattedMessage = `${cl.orange(`[ EMBED RESPONSE (${typedData.totalEmbeddings} embeddings) ]`)}\\n${divider}\\n`;\n        typedData.value.forEach((embedding, i) => {\n          formattedMessage += cl.white(\n            `Embedding ${i + 1}: [${embedding.sample.join(', ')}${embedding.truncated ? ', ...' : ''}] (length: ${embedding.length})`\n          );\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      default:\n        formattedMessage = cl.gray(JSON.stringify(typedData, null, 2));\n    }\n\n    output(formattedMessage);\n  };\n};\n\nexport const defaultLogger: AxLoggerFunction = axCreateDefaultColorLogger();\n\n// Factory function to create a text-only logger (no colors) with customizable output\nexport const axCreateDefaultTextLogger = (\n  output: (message: string) => void = defaultOutput\n): AxLoggerFunction => {\n  const divider = ''.repeat(60);\n  return (message: AxLoggerData) => {\n    const typedData = message;\n    let formattedMessage = '';\n\n    switch (typedData.name) {\n      case 'ChatRequestChatPrompt':\n        formattedMessage = `\\n[ CHAT REQUEST Step ${typedData.step} ]\\n${divider}\\n`;\n        typedData.value.forEach((msg, i) => {\n          formattedMessage += formatChatMessage(msg);\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        formattedMessage += `\\n${divider}`; // Keep closing for steps\n        break;\n      case 'FunctionResults':\n        formattedMessage = `\\n[ FUNCTION RESULTS ]\\n${divider}\\n`;\n        typedData.value.forEach((result, i) => {\n          formattedMessage += `Function: ${result.functionId}\\nResult: ${result.result}`;\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseResults':\n        formattedMessage = '\\n[ CHAT RESPONSE ]\\n';\n        typedData.value.forEach((result, i) => {\n          formattedMessage += result.content || '[No content]';\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'ChatResponseStreamingResult': {\n        // const streamingContent =\n        //   typedData.value.delta || typedData.value.content || '';\n        // // Add newline prefix if this is actual content (not just a delta)\n        // formattedMessage = streamingContent;\n        return;\n      }\n      case 'ChatResponseStreamingDoneResult': {\n        formattedMessage = '\\n[ CHAT RESPONSE ]\\n';\n        if (typedData.value.content) {\n          formattedMessage += typedData.value.content;\n        }\n        if (typedData.value.functionCalls) {\n          formattedMessage += JSON.stringify(\n            typedData.value.functionCalls,\n            null,\n            2\n          );\n        }\n        break;\n      }\n      case 'FunctionError':\n        formattedMessage = `\\n[ FUNCTION ERROR #${typedData.index} ]\\n${divider}\\n${typedData.fixingInstructions}\\nError: ${typedData.error}`;\n        break;\n      case 'ValidationError':\n        formattedMessage = `\\n[ VALIDATION ERROR #${typedData.index} ]\\n${divider}\\n${typedData.fixingInstructions}\\nError: ${typedData.error}`;\n        break;\n      case 'AssertionError':\n        formattedMessage = `\\n[ ASSERTION ERROR #${typedData.index} ]\\n${divider}\\n${typedData.fixingInstructions}\\nError: ${typedData.error}`;\n        break;\n      case 'ResultPickerUsed':\n        formattedMessage = `[ RESULT PICKER ]\\n${divider}\\nSelected sample ${typedData.selectedIndex + 1} of ${typedData.sampleCount} (${typedData.latency.toFixed(2)}ms)`;\n        break;\n      case 'Notification':\n        formattedMessage = `[ NOTIFICATION ${typedData.id} ]\\n${divider}\\n${typedData.value}`;\n        break;\n      case 'EmbedRequest':\n        formattedMessage = `[ EMBED REQUEST ${typedData.embedModel} ]\\n${divider}\\n`;\n        typedData.value.forEach((text, i) => {\n          formattedMessage += `Text ${i + 1}: ${text.substring(0, 100)}${text.length > 100 ? '...' : ''}`;\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      case 'EmbedResponse':\n        formattedMessage = `[ EMBED RESPONSE (${typedData.totalEmbeddings} embeddings) ]\\n${divider}\\n`;\n        typedData.value.forEach((embedding, i) => {\n          formattedMessage += `Embedding ${i + 1}: [${embedding.sample.join(', ')}${embedding.truncated ? ', ...' : ''}] (length: ${embedding.length})`;\n          if (i < typedData.value.length - 1)\n            formattedMessage += `\\n${divider}\\n`;\n        });\n        break;\n      default:\n        formattedMessage = JSON.stringify(typedData, null, 2);\n    }\n\n    output(formattedMessage);\n  };\n};\n", "export const axSpanAttributes = {\n  // LLM\n  LLM_SYSTEM: 'gen_ai.system',\n  LLM_OPERATION_NAME: 'gen_ai.operation.name',\n  LLM_REQUEST_MODEL: 'gen_ai.request.model',\n  LLM_REQUEST_MAX_TOKENS: 'gen_ai.request.max_tokens',\n  LLM_REQUEST_TEMPERATURE: 'gen_ai.request.temperature',\n  LLM_REQUEST_TOP_K: 'gen_ai.request.top_k',\n  LLM_REQUEST_FREQUENCY_PENALTY: 'gen_ai.request.frequency_penalty',\n  LLM_REQUEST_PRESENCE_PENALTY: 'gen_ai.request.presence_penalty',\n  LLM_REQUEST_STOP_SEQUENCES: 'gen_ai.request.stop_sequences',\n  LLM_REQUEST_LLM_IS_STREAMING: 'gen_ai.request.llm_is_streaming',\n  LLM_REQUEST_TOP_P: 'gen_ai.request.top_p',\n\n  LLM_USAGE_INPUT_TOKENS: 'gen_ai.usage.input_tokens',\n  LLM_USAGE_OUTPUT_TOKENS: 'gen_ai.usage.output_tokens',\n  LLM_USAGE_TOTAL_TOKENS: 'gen_ai.usage.total_tokens',\n  LLM_USAGE_THOUGHTS_TOKENS: 'gen_ai.usage.thoughts_tokens',\n\n  // Vector DB\n  DB_SYSTEM: 'db.system',\n  DB_TABLE: 'db.table',\n  DB_NAMESPACE: 'db.namespace',\n  DB_ID: 'db.id',\n  DB_QUERY_TEXT: 'db.query.text',\n  DB_VECTOR: 'db.vector',\n  DB_OPERATION_NAME: 'db.operation.name',\n  DB_VECTOR_QUERY_TOP_K: 'db.vector.query.top_k',\n\n  DB_QUERY_EMBEDDINGS: 'db.query.embeddings',\n  DB_QUERY_RESULT: 'db.query.result',\n\n  // Query Embeddings\n  DB_QUERY_EMBEDDINGS_VECTOR: 'db.query.embeddings.vector',\n\n  // Query Result (canonical format)\n  DB_QUERY_RESULT_ID: 'db.query.result.id',\n  DB_QUERY_RESULT_SCORE: 'db.query.result.score',\n  DB_QUERY_RESULT_DISTANCE: 'db.query.result.distance',\n  DB_QUERY_RESULT_METADATA: 'db.query.result.metadata',\n  DB_QUERY_RESULT_VECTOR: 'db.query.result.vector',\n  DB_QUERY_RESULT_DOCUMENT: 'db.query.result.document',\n};\n\nexport const axSpanEvents = {\n  GEN_AI_USER_MESSAGE: 'gen_ai.user.message',\n  GEN_AI_SYSTEM_MESSAGE: 'gen_ai.system.message',\n  GEN_AI_ASSISTANT_MESSAGE: 'gen_ai.assistant.message',\n  GEN_AI_TOOL_MESSAGE: 'gen_ai.tool.message', // For tool messages in request & response tool calls\n  GEN_AI_CHOICE: 'gen_ai.choice',\n  GEN_AI_USAGE: 'gen_ai.usage',\n};\n\nexport enum AxLLMRequestTypeValues {\n  COMPLETION = 'completion',\n  CHAT = 'chat',\n  RERANK = 'rerank',\n  UNKNOWN = 'unknown',\n}\n\nexport enum AxSpanKindValues {\n  WORKFLOW = 'workflow',\n  TASK = 'task',\n  AGENT = 'agent',\n  TOOL = 'tool',\n  UNKNOWN = 'unknown',\n}\n", "// Web Streams API types are now available globally via DOM types in tsconfig\n\nclass TypeTransformer<I, O> implements Transformer<I, O> {\n  private buffer?: O[];\n  private doneCallback?: (args0: readonly O[]) => Promise<void>;\n  private transformFn: (arg0: I) => O;\n\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    this.transformFn = transformFn;\n    this.doneCallback = doneCallback;\n    this.buffer = doneCallback ? [] : undefined;\n  }\n\n  async transform(obj: I, controller: TransformStreamDefaultController<O>) {\n    const val = this.transformFn(obj);\n    if (val) {\n      controller.enqueue(val);\n      this.buffer?.push(val);\n    }\n  }\n\n  async flush(controller: TransformStreamDefaultController<O>) {\n    await this.doneCallback?.(this.buffer ?? []);\n    controller.terminate();\n  }\n}\n\nexport class RespTransformStream<I, O> extends TransformStream<I, O> {\n  constructor(\n    transformFn: (arg0: I) => O,\n    doneCallback?: (args0: readonly O[]) => Promise<void>\n  ) {\n    super(new TypeTransformer<I, O>(transformFn, doneCallback));\n  }\n}\n", "/* eslint-disable @typescript-eslint/naming-convention */\nimport { createHash } from '../util/crypto.js';\n\nimport type { AxChatResponseResult, AxModelInfo } from './types.js';\n\nexport const findItemByNameOrAlias = (\n  list: readonly AxModelInfo[],\n  name: string\n): AxModelInfo | undefined => {\n  for (const item of list) {\n    if (item.name === name || item.aliases?.includes(name)) {\n      return item;\n    }\n  }\n  return undefined;\n};\n\nexport const uniqBy = <T>(\n  array: readonly T[],\n  uniqueField: (value: T) => unknown\n): T[] => {\n  const uniqueValues = new Map();\n\n  array.forEach((value: T) => {\n    const field = uniqueField(value);\n\n    if (!uniqueValues.has(field)) {\n      uniqueValues.set(field, value);\n    }\n  });\n\n  return Array.from(uniqueValues.values());\n};\n\nconst functionCallRe = /(\\w+)\\((.*)\\)/s;\n\nexport const parseFunction = (\n  value: string\n): { name: string; args?: string } | undefined => {\n  let v: string[] | null;\n\n  // extract function calls\n  v = functionCallRe.exec(value);\n  if (v !== null) {\n    const name = v.at(1)?.trim();\n    const args = v.at(2)?.trim();\n    if (!name || name.length === 0) {\n      throw new Error(`Invalid function format: ${value}`);\n    }\n    return { name, args };\n  }\n  return;\n};\n\nexport interface mergeFunctionsState {\n  lastId?: string;\n}\n\nexport function mergeFunctionCalls(\n  functionCalls: NonNullable<AxChatResponseResult['functionCalls']>,\n  functionCallDeltas: Readonly<\n    NonNullable<AxChatResponseResult['functionCalls']>\n  >\n) {\n  for (const Fc of functionCallDeltas) {\n    const fc = functionCalls.find((fc) => fc.id === Fc.id);\n\n    if (fc) {\n      if (typeof Fc.function.name === 'string' && Fc.function.name.length > 0) {\n        fc.function.name += Fc.function.name;\n      }\n\n      if (\n        typeof Fc.function.params === 'string' &&\n        Fc.function.params.length > 0\n      ) {\n        fc.function.params += Fc.function.params;\n      }\n\n      if (typeof Fc.function.params === 'object') {\n        fc.function.params = Fc.function.params;\n      }\n    } else {\n      functionCalls.push(Fc);\n    }\n  }\n}\n\nexport const hashObject = (obj: object) => {\n  const hash = createHash('sha256');\n  hash.update(JSON.stringify(obj));\n  return hash.digest('hex');\n};\n", "import type {\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxFunctionResult,\n  AxLoggerData,\n  AxLoggerFunction,\n} from './types.js';\nimport { mergeFunctionCalls } from './util.js';\n\nexport const logChatRequest = (\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>,\n  step: number,\n  logger: AxLoggerFunction,\n  hideSystemPrompt?: boolean\n) => {\n  // Filter out system messages if hideSystemPrompt is true\n  const filteredPrompt = hideSystemPrompt\n    ? chatPrompt.filter((msg) => msg.role !== 'system')\n    : [...chatPrompt]; // Create a mutable copy\n\n  const loggerData: AxLoggerData = {\n    name: 'ChatRequestChatPrompt',\n    step,\n    value: filteredPrompt as AxChatRequest['chatPrompt'],\n  };\n\n  logger(loggerData);\n};\n\nexport const logResponseResult = (\n  r: Readonly<AxChatResponse['results'][number] & { index: number }>,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ChatResponseResults',\n    value: [r],\n  };\n\n  logger(loggerData);\n};\n\nexport const logResponse = (\n  resp: Readonly<AxChatResponse>,\n  logger: AxLoggerFunction\n) => {\n  if (!resp.results) {\n    return;\n  }\n\n  const loggerData: AxLoggerData = {\n    name: 'ChatResponseResults',\n    value: resp.results as AxChatResponseResult[],\n  };\n\n  logger(loggerData);\n};\n\nexport const logResponseStreamingResult = (\n  result: AxChatResponseResult & { delta?: string },\n  index: number,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ChatResponseStreamingResult',\n    index,\n    value: result,\n  };\n\n  logger(loggerData);\n};\n\nexport function logResponseStreamingDoneResult(\n  values: readonly AxChatResponse[],\n  logger: AxLoggerFunction\n): void {\n  // Combine results by index\n  const combinedResults = new Map<number, AxChatResponseResult>();\n\n  for (const value of values) {\n    for (const result of value.results) {\n      if (!result) {\n        continue;\n      }\n\n      let existing = combinedResults.get(result.index);\n      if (!existing) {\n        existing = structuredClone(result);\n        combinedResults.set(result.index, existing);\n      } else {\n        if (result.content) {\n          existing.content = (existing.content ?? '') + result.content;\n        }\n        if (result.thought) {\n          existing.thought = (existing.thought ?? '') + result.thought;\n        }\n        if (result.finishReason) {\n          existing.finishReason = result.finishReason;\n        }\n        if (result.functionCalls) {\n          if (existing.functionCalls) {\n            mergeFunctionCalls(\n              existing.functionCalls,\n              structuredClone(result.functionCalls)\n            );\n          } else {\n            existing.functionCalls = structuredClone(result.functionCalls);\n          }\n        }\n      }\n    }\n  }\n\n  // Log each combined result\n  for (const result of combinedResults.values()) {\n    const loggerData: AxLoggerData = {\n      name: 'ChatResponseStreamingDoneResult',\n      index: result.index,\n      value: result,\n    };\n\n    logger(loggerData);\n  }\n}\n\nexport const logFunctionResults = (\n  results: Readonly<AxFunctionResult[]>,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'FunctionResults',\n    value: results as AxFunctionResult[],\n  };\n\n  logger(loggerData);\n};\n\nexport const logFunctionError = (\n  error: unknown,\n  index: number,\n  fixingInstructions: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'FunctionError',\n    index,\n    fixingInstructions,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logValidationError = (\n  error: unknown,\n  index: number,\n  fixingInstructions: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ValidationError',\n    index,\n    fixingInstructions,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logAssertionError = (\n  error: unknown,\n  index: number,\n  fixingInstructions: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'AssertionError',\n    index,\n    fixingInstructions,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logRefusalError = (\n  error: unknown,\n  index: number,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'RefusalError',\n    index,\n    error,\n  };\n\n  logger(loggerData);\n};\n\nexport const logNotification = (\n  id: string,\n  value: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'Notification',\n    id,\n    value,\n  };\n\n  logger(loggerData);\n};\n\nexport const logEmbedRequest = (\n  texts: readonly string[],\n  embedModel: string,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'EmbedRequest',\n    embedModel,\n    value: texts,\n  };\n\n  logger(loggerData);\n};\n\nexport const logEmbedResponse = (\n  embeddings: readonly (readonly number[])[],\n  logger: AxLoggerFunction\n) => {\n  // Show only a few embeddings for effect, not all\n  const sampleEmbeddings = embeddings.slice(0, 3).map((embedding) => ({\n    length: embedding.length,\n    sample: embedding.slice(0, 5), // Show first 5 values\n    truncated: embedding.length > 5,\n  }));\n\n  const loggerData: AxLoggerData = {\n    name: 'EmbedResponse',\n    totalEmbeddings: embeddings.length,\n    value: sampleEmbeddings,\n  };\n\n  logger(loggerData);\n};\n\nexport const logResultPickerUsed = (\n  sampleCount: number,\n  selectedIndex: number,\n  latency: number,\n  logger: AxLoggerFunction\n) => {\n  const loggerData: AxLoggerData = {\n    name: 'ResultPickerUsed',\n    sampleCount,\n    selectedIndex,\n    latency,\n  };\n\n  logger(loggerData);\n};\n", "import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\n// Utility function to sanitize metric labels\nconst sanitizeLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length to prevent excessive memory usage\n      sanitized[key] =\n        stringValue.length > 100 ? stringValue.substring(0, 100) : stringValue;\n    }\n  }\n  return sanitized;\n};\n\nexport interface AxAIMetricsInstruments {\n  latencyHistogram?: Histogram;\n  errorCounter?: Counter;\n  requestCounter?: Counter;\n  tokenCounter?: Counter;\n  inputTokenCounter?: Counter;\n  outputTokenCounter?: Counter;\n  errorRateGauge?: Gauge;\n  meanLatencyGauge?: Gauge;\n  p95LatencyGauge?: Gauge;\n  p99LatencyGauge?: Gauge;\n\n  streamingRequestsCounter?: Counter;\n\n  functionCallsCounter?: Counter;\n  functionCallLatencyHistogram?: Histogram;\n\n  requestSizeHistogram?: Histogram;\n  responseSizeHistogram?: Histogram;\n\n  temperatureGauge?: Gauge;\n  maxTokensGauge?: Gauge;\n\n  estimatedCostCounter?: Counter;\n\n  promptLengthHistogram?: Histogram;\n  contextWindowUsageGauge?: Gauge;\n\n  timeoutsCounter?: Counter;\n  abortsCounter?: Counter;\n\n  thinkingBudgetUsageCounter?: Counter;\n  multimodalRequestsCounter?: Counter;\n}\n\n// Singleton instance for AI metrics instruments\nlet globalAIMetricsInstruments: AxAIMetricsInstruments | undefined;\n\n// Function to get or create AI metrics instruments (singleton pattern)\nexport const getOrCreateAIMetricsInstruments = (\n  meter?: Meter\n): AxAIMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalAIMetricsInstruments) {\n    return globalAIMetricsInstruments;\n  }\n\n  if (meter) {\n    globalAIMetricsInstruments = createMetricsInstruments(meter);\n    return globalAIMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the AI metrics singleton (useful for testing)\nexport const resetAIMetricsInstruments = (): void => {\n  globalAIMetricsInstruments = undefined;\n};\n\nexport const createMetricsInstruments = (\n  meter: Meter\n): AxAIMetricsInstruments => {\n  return {\n    latencyHistogram: meter.createHistogram('ax_llm_request_duration_ms', {\n      description: 'Duration of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    errorCounter: meter.createCounter('ax_llm_errors_total', {\n      description: 'Total number of LLM request errors',\n    }),\n\n    requestCounter: meter.createCounter('ax_llm_requests_total', {\n      description: 'Total number of LLM requests',\n    }),\n\n    tokenCounter: meter.createCounter('ax_llm_tokens_total', {\n      description: 'Total number of LLM tokens consumed',\n    }),\n\n    inputTokenCounter: meter.createCounter('ax_llm_input_tokens_total', {\n      description: 'Total number of input/prompt tokens consumed',\n    }),\n\n    outputTokenCounter: meter.createCounter('ax_llm_output_tokens_total', {\n      description: 'Total number of output/completion tokens generated',\n    }),\n\n    errorRateGauge: meter.createGauge('ax_llm_error_rate', {\n      description: 'Current error rate as a percentage (0-100)',\n    }),\n\n    meanLatencyGauge: meter.createGauge('ax_llm_mean_latency_ms', {\n      description: 'Mean latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    p95LatencyGauge: meter.createGauge('ax_llm_p95_latency_ms', {\n      description: '95th percentile latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    p99LatencyGauge: meter.createGauge('ax_llm_p99_latency_ms', {\n      description: '99th percentile latency of LLM requests in milliseconds',\n      unit: 'ms',\n    }),\n\n    streamingRequestsCounter: meter.createCounter(\n      'ax_llm_streaming_requests_total',\n      {\n        description: 'Total number of streaming LLM requests',\n      }\n    ),\n\n    functionCallsCounter: meter.createCounter('ax_llm_function_calls_total', {\n      description: 'Total number of function/tool calls made',\n    }),\n\n    functionCallLatencyHistogram: meter.createHistogram(\n      'ax_llm_function_call_latency_ms',\n      {\n        description: 'Latency of function calls in milliseconds',\n        unit: 'ms',\n      }\n    ),\n\n    requestSizeHistogram: meter.createHistogram('ax_llm_request_size_bytes', {\n      description: 'Size of LLM request payloads in bytes',\n      unit: 'By',\n    }),\n\n    responseSizeHistogram: meter.createHistogram('ax_llm_response_size_bytes', {\n      description: 'Size of LLM response payloads in bytes',\n      unit: 'By',\n    }),\n\n    temperatureGauge: meter.createGauge('ax_llm_temperature_gauge', {\n      description: 'Temperature setting used for LLM requests',\n    }),\n\n    maxTokensGauge: meter.createGauge('ax_llm_max_tokens_gauge', {\n      description: 'Maximum tokens setting used for LLM requests',\n    }),\n\n    estimatedCostCounter: meter.createCounter('ax_llm_estimated_cost_total', {\n      description: 'Estimated cost of LLM requests in USD',\n      unit: '$',\n    }),\n\n    promptLengthHistogram: meter.createHistogram('ax_llm_prompt_length_chars', {\n      description: 'Length of prompts in characters',\n    }),\n\n    contextWindowUsageGauge: meter.createGauge(\n      'ax_llm_context_window_usage_ratio',\n      {\n        description: 'Context window utilization ratio (0-1)',\n      }\n    ),\n\n    timeoutsCounter: meter.createCounter('ax_llm_timeouts_total', {\n      description: 'Total number of timed out LLM requests',\n    }),\n\n    abortsCounter: meter.createCounter('ax_llm_aborts_total', {\n      description: 'Total number of aborted LLM requests',\n    }),\n\n    thinkingBudgetUsageCounter: meter.createCounter(\n      'ax_llm_thinking_budget_usage_total',\n      {\n        description: 'Total thinking budget tokens used',\n      }\n    ),\n\n    multimodalRequestsCounter: meter.createCounter(\n      'ax_llm_multimodal_requests_total',\n      {\n        description: 'Total number of multimodal requests (with images/audio)',\n      }\n    ),\n  };\n};\n\nexport const recordLatencyMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  duration: number,\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    if (instruments.latencyHistogram) {\n      const labels = sanitizeLabels({\n        operation: type,\n        ai_service: aiService,\n        ...(model ? { model } : {}),\n      });\n      instruments.latencyHistogram.record(duration, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record latency metric:', error);\n  }\n};\n\nexport const recordLatencyStatsMetrics = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  meanLatency: number,\n  p95Latency: number,\n  p99Latency: number,\n  aiService: string,\n  model?: string\n): void => {\n  const labels = {\n    operation: type,\n    ai_service: aiService,\n    ...(model ? { model } : {}),\n  };\n\n  if (instruments.meanLatencyGauge) {\n    instruments.meanLatencyGauge.record(meanLatency, labels);\n  }\n\n  if (instruments.p95LatencyGauge) {\n    instruments.p95LatencyGauge.record(p95Latency, labels);\n  }\n\n  if (instruments.p99LatencyGauge) {\n    instruments.p99LatencyGauge.record(p99Latency, labels);\n  }\n};\n\nexport const recordErrorMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    if (instruments.errorCounter) {\n      const labels = sanitizeLabels({\n        operation: type,\n        ai_service: aiService,\n        ...(model ? { model } : {}),\n      });\n      instruments.errorCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record error metric:', error);\n  }\n};\n\nexport const recordErrorRateMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  errorRate: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.errorRateGauge) {\n    instruments.errorRateGauge.record(errorRate * 100, {\n      // Convert to percentage\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.requestCounter) {\n    instruments.requestCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordTokenMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'input' | 'output' | 'total' | 'thoughts',\n  tokens: number,\n  aiService: string,\n  model?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n\n    // Record in the general token counter with type label\n    if (instruments.tokenCounter) {\n      instruments.tokenCounter.add(tokens, {\n        token_type: type,\n        ...labels,\n      });\n    }\n\n    // Also record in specific counters for input/output\n    if (type === 'input' && instruments.inputTokenCounter) {\n      instruments.inputTokenCounter.add(tokens, labels);\n    }\n\n    if (type === 'output' && instruments.outputTokenCounter) {\n      instruments.outputTokenCounter.add(tokens, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record token metric:', error);\n  }\n};\n\nexport const recordStreamingRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  isStreaming: boolean,\n  aiService: string,\n  model?: string\n): void => {\n  if (isStreaming && instruments.streamingRequestsCounter) {\n    instruments.streamingRequestsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordFunctionCallMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  functionName: string,\n  latency?: number,\n  aiService?: string,\n  model?: string\n): void => {\n  const labels = {\n    function_name: functionName,\n    ...(aiService ? { ai_service: aiService } : {}),\n    ...(model ? { model } : {}),\n  };\n\n  if (instruments.functionCallsCounter) {\n    instruments.functionCallsCounter.add(1, labels);\n  }\n\n  if (latency && instruments.functionCallLatencyHistogram) {\n    instruments.functionCallLatencyHistogram.record(latency, labels);\n  }\n};\n\nexport const recordRequestSizeMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  sizeBytes: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.requestSizeHistogram) {\n    instruments.requestSizeHistogram.record(sizeBytes, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordResponseSizeMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  sizeBytes: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.responseSizeHistogram) {\n    instruments.responseSizeHistogram.record(sizeBytes, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordModelConfigMetrics = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  temperature?: number,\n  maxTokens?: number,\n  aiService?: string,\n  model?: string\n): void => {\n  const labels = {\n    ...(aiService ? { ai_service: aiService } : {}),\n    ...(model ? { model } : {}),\n  };\n\n  if (temperature !== undefined && instruments.temperatureGauge) {\n    instruments.temperatureGauge.record(temperature, labels);\n  }\n\n  if (maxTokens !== undefined && instruments.maxTokensGauge) {\n    instruments.maxTokensGauge.record(maxTokens, labels);\n  }\n};\n\nexport const recordEstimatedCostMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  costUSD: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.estimatedCostCounter) {\n    instruments.estimatedCostCounter.add(costUSD, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordPromptLengthMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  lengthChars: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.promptLengthHistogram) {\n    instruments.promptLengthHistogram.record(lengthChars, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordContextWindowUsageMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  usageRatio: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.contextWindowUsageGauge) {\n    instruments.contextWindowUsageGauge.record(usageRatio, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordTimeoutMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.timeoutsCounter) {\n    instruments.timeoutsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordAbortMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  type: 'chat' | 'embed',\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.abortsCounter) {\n    instruments.abortsCounter.add(1, {\n      operation: type,\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordThinkingBudgetUsageMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  tokensUsed: number,\n  aiService: string,\n  model?: string\n): void => {\n  if (instruments.thinkingBudgetUsageCounter) {\n    instruments.thinkingBudgetUsageCounter.add(tokensUsed, {\n      ai_service: aiService,\n      ...(model ? { model } : {}),\n    });\n  }\n};\n\nexport const recordMultimodalRequestMetric = (\n  instruments: Readonly<AxAIMetricsInstruments>,\n  hasImages: boolean,\n  hasAudio: boolean,\n  aiService: string,\n  model?: string\n): void => {\n  if ((hasImages || hasAudio) && instruments.multimodalRequestsCounter) {\n    instruments.multimodalRequestsCounter.add(1, {\n      ai_service: aiService,\n      has_images: hasImages.toString(),\n      has_audio: hasAudio.toString(),\n      ...(model ? { model } : {}),\n    });\n  }\n};\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIAnthropicModel {\n  Claude4Opus = 'claude-opus-4-20250514',\n  Claude4Sonnet = 'claude-sonnet-4-20250514',\n  Claude37Sonnet = 'claude-3-7-sonnet-latest',\n\n  Claude35Sonnet = 'claude-3-5-sonnet-latest',\n  Claude35Haiku = 'claude-3-5-haiku-latest',\n\n  Claude3Opus = 'claude-3-opus-latest',\n  Claude3Sonnet = 'claude-3-sonnet-20240229',\n  Claude3Haiku = 'claude-3-haiku-20240307',\n\n  Claude21 = 'claude-2.1',\n  ClaudeInstant12 = 'claude-instant-1.2',\n}\n\nexport enum AxAIAnthropicVertexModel {\n  Claude37Sonnet = 'claude-3-7-sonnet',\n  Claude35Haiku = 'claude-3-5-haiku',\n  Claude35Sonnet = 'claude-3-5-sonnet',\n  Claude35SonnetV2 = 'claude-3-5-sonnet-v2',\n  Claude3Haiku = 'claude-3-haiku',\n  Claude3Opus = 'claude-3-opus',\n}\n\nexport type AxAIAnthropicThinkingConfig = {\n  type: 'enabled';\n  budget_tokens: number;\n};\n\nexport type AxAIAnthropicThinkingTokenBudgetLevels = {\n  minimal?: number;\n  low?: number;\n  medium?: number;\n  high?: number;\n  highest?: number;\n};\n\nexport type AxAIAnthropicConfig = AxModelConfig & {\n  model: AxAIAnthropicModel | AxAIAnthropicVertexModel;\n  thinking?: AxAIAnthropicThinkingConfig;\n  thinkingTokenBudgetLevels?: AxAIAnthropicThinkingTokenBudgetLevels;\n};\n\nexport type AxAIAnthropicChatRequestCacheParam = {\n  cache_control?: { type: 'ephemeral' };\n};\n\n// Type for the request to create a message using Anthropic's Messages API\nexport type AxAIAnthropicChatRequest = {\n  model?: string;\n  anthropic_version?: string;\n  messages: (\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | ({\n                  type: 'text';\n                  text: string;\n                } & AxAIAnthropicChatRequestCacheParam)\n              | ({\n                  type: 'image';\n                  source: { type: 'base64'; media_type: string; data: string };\n                } & AxAIAnthropicChatRequestCacheParam)\n              | {\n                  type: 'tool_result';\n                  is_error?: boolean;\n                  tool_use_id: string;\n                  content:\n                    | string\n                    | (\n                        | ({\n                            type: 'text';\n                            text: string;\n                          } & AxAIAnthropicChatRequestCacheParam)\n                        | ({\n                            type: 'image';\n                            source: {\n                              type: 'base64';\n                              media_type: string;\n                              data: string;\n                            };\n                          } & AxAIAnthropicChatRequestCacheParam)\n                      )[];\n                }\n            )[];\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | (\n              | { type: 'text'; text: string }\n              | { type: 'tool_use'; id: string; name: string; input: object }\n              | { type: 'thinking'; thinking: string; signature?: string }\n              | {\n                  type: 'redacted_thinking';\n                  thinking: string;\n                  signature?: string;\n                }\n            )[];\n      }\n  )[];\n  tools?: ({\n    name: string;\n    description: string;\n    input_schema?: object;\n  } & AxAIAnthropicChatRequestCacheParam)[];\n  tool_choice?: { type: 'auto' | 'any' } | { type: 'tool'; name?: string };\n  max_tokens?: number; // Maximum number of tokens to generate\n  // Optional metadata about the request\n  stop_sequences?: string[]; // Custom sequences that trigger the end of generation\n  stream?: boolean; // Whether to stream the response incrementally\n  system?:\n    | string\n    | ({\n        type: 'text';\n        text: string;\n      } & AxAIAnthropicChatRequestCacheParam)[]; // system prompt\n  temperature?: number; // Randomness of the response\n  top_p?: number; // Nucleus sampling probability\n  top_k?: number; // Sample from the top K options\n  thinking?: AxAIAnthropicThinkingConfig; // Extended thinking configuration\n  metadata?: {\n    user_id: string;\n  };\n};\n\nexport type AxAIAnthropicChatResponse = {\n  id: string; // Unique identifier for the response\n  type: 'message'; // Object type, always 'message' for this API\n  role: 'assistant'; // Conversational role of the generated message, always 'assistant'\n  content: (\n    | {\n        type: 'text';\n        text: string;\n      }\n    | {\n        id: string;\n        name: string;\n        type: 'tool_use';\n        input?: string;\n      }\n    | {\n        type: 'thinking';\n        thinking: string;\n        signature?: string;\n      }\n    | {\n        type: 'redacted_thinking';\n        thinking: string;\n        signature?: string;\n      }\n  )[];\n  model: string;\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use';\n  stop_sequence?: string;\n  usage: {\n    input_tokens: number;\n    output_tokens: number;\n  };\n};\n\nexport type AxAIAnthropicChatError = {\n  type: 'error';\n  error: {\n    type: 'authentication_error';\n    message: string;\n  };\n};\n\n// Represents the start of a message with an empty content array\nexport interface AxAIAnthropicMessageStartEvent {\n  type: 'message_start';\n  message: {\n    id: string;\n    type: 'message';\n    role: 'assistant';\n    content: [];\n    model: string;\n    stop_reason: null | string;\n    stop_sequence: null | string;\n    usage: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n}\n\n// Indicates the start of a content block within a message\nexport interface AxAIAnthropicContentBlockStartEvent {\n  index: number;\n  type: 'content_block_start';\n  content_block:\n    | {\n        type: 'text';\n        text: string;\n      }\n    | {\n        type: 'tool_use';\n        id: string;\n        name: string;\n        input: object;\n      }\n    | {\n        type: 'thinking';\n        thinking: string;\n      };\n}\n\n// Represents incremental updates to a content block\nexport interface AxAIAnthropicContentBlockDeltaEvent {\n  index: number;\n  type: 'content_block_delta';\n  delta:\n    | {\n        type: 'text_delta';\n        text: string;\n      }\n    | {\n        type: 'input_json_delta';\n        partial_json: string;\n      }\n    | {\n        type: 'thinking_delta';\n        thinking: string;\n      }\n    | {\n        type: 'signature_delta';\n        signature: string;\n      };\n}\n\n// Marks the end of a content block within a message\nexport interface AxAIAnthropicContentBlockStopEvent {\n  type: 'content_block_stop';\n  index: number;\n}\n\n// Indicates top-level changes to the final message object\nexport interface AxAIAnthropicMessageDeltaEvent {\n  type: 'message_delta';\n  delta: {\n    stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | null;\n    stop_sequence: string | null;\n  };\n  usage: {\n    output_tokens: number;\n  };\n}\n\n// Marks the end of a message\nexport interface AxAIAnthropicMessageStopEvent {\n  type: 'message_stop';\n}\n\n// Represents a ping event, which can occur any number of times\nexport interface AxAIAnthropicPingEvent {\n  type: 'ping';\n}\n\n// Represents an error event\nexport interface AxAIAnthropicErrorEvent {\n  type: 'error';\n  error: {\n    type: 'overloaded_error';\n    message: string;\n  };\n}\n\n// Union type for all possible event types in the stream\nexport type AxAIAnthropicChatResponseDelta =\n  | AxAIAnthropicMessageStartEvent\n  | AxAIAnthropicContentBlockStartEvent\n  | AxAIAnthropicContentBlockDeltaEvent\n  | AxAIAnthropicContentBlockStopEvent\n  | AxAIAnthropicMessageDeltaEvent\n  | AxAIAnthropicMessageStopEvent\n  | AxAIAnthropicPingEvent\n  | AxAIAnthropicErrorEvent;\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIAnthropicModel } from './types.js';\n\nexport const axModelInfoAnthropic: AxModelInfo[] = [\n  // 4\n  {\n    name: AxAIAnthropicModel.Claude4Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n    maxTokens: 32000,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIAnthropicModel.Claude4Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 64000,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  // 3.7\n  {\n    name: AxAIAnthropicModel.Claude37Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 64000,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  // 3.5\n  {\n    name: AxAIAnthropicModel.Claude35Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 8192,\n  },\n  {\n    name: AxAIAnthropicModel.Claude35Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 4.0,\n    maxTokens: 8192,\n  },\n  // 3\n  {\n    name: AxAIAnthropicModel.Claude3Opus,\n    currency: 'usd',\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 75.0,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Sonnet,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.Claude3Haiku,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 1.25,\n    maxTokens: 4096,\n  },\n  // 2.1\n  {\n    name: AxAIAnthropicModel.Claude21,\n    currency: 'usd',\n    promptTokenCostPer1M: 8.0,\n    completionTokenCostPer1M: 25,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIAnthropicModel.ClaudeInstant12,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2.24,\n    maxTokens: 4096,\n  },\n];\n", "import { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport { AxBaseAI, axBaseAIDefaultConfig } from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\nimport { axModelInfoAnthropic } from './info.js';\nimport {\n  type AxAIAnthropicChatError,\n  type AxAIAnthropicChatRequest,\n  type AxAIAnthropicChatResponse,\n  type AxAIAnthropicChatResponseDelta,\n  type AxAIAnthropicConfig,\n  type AxAIAnthropicContentBlockDeltaEvent,\n  type AxAIAnthropicContentBlockStartEvent,\n  type AxAIAnthropicErrorEvent,\n  type AxAIAnthropicMessageDeltaEvent,\n  type AxAIAnthropicMessageStartEvent,\n  AxAIAnthropicModel,\n  type AxAIAnthropicThinkingConfig,\n  AxAIAnthropicVertexModel,\n} from './types.js';\n\n/**\n * Clean function schema for Anthropic API compatibility\n * Anthropic uses input_schema and may not support certain JSON Schema fields\n */\nconst cleanSchemaForAnthropic = (schema: any): any => {\n  if (!schema || typeof schema !== 'object') {\n    return schema;\n  }\n\n  const cleaned = { ...schema };\n\n  // Remove fields that might cause issues with Anthropic\n  delete cleaned.additionalProperties;\n  delete cleaned.default;\n  delete cleaned.optional;\n  delete cleaned.oneOf;\n  delete cleaned.anyOf;\n  delete cleaned.allOf;\n\n  // Recursively clean properties\n  if (cleaned.properties && typeof cleaned.properties === 'object') {\n    cleaned.properties = Object.fromEntries(\n      Object.entries(cleaned.properties).map(([key, value]) => [\n        key,\n        cleanSchemaForAnthropic(value),\n      ])\n    );\n  }\n\n  // Recursively clean items (for arrays)\n  if (cleaned.items) {\n    cleaned.items = cleanSchemaForAnthropic(cleaned.items);\n  }\n\n  return cleaned;\n};\n\nexport const axAIAnthropicDefaultConfig = (): AxAIAnthropicConfig =>\n  structuredClone({\n    model: AxAIAnthropicModel.Claude37Sonnet,\n    maxTokens: 40000, // Ensure maxTokens is higher than highest thinking budget\n    thinkingTokenBudgetLevels: {\n      minimal: 1024,\n      low: 5000,\n      medium: 10000,\n      high: 20000,\n      highest: 32000,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIAnthropicVertexDefaultConfig = (): AxAIAnthropicConfig =>\n  structuredClone({\n    model: AxAIAnthropicVertexModel.Claude37Sonnet,\n    maxTokens: 40000, // Ensure maxTokens is higher than highest thinking budget\n    thinkingTokenBudgetLevels: {\n      minimal: 1024,\n      low: 5000,\n      medium: 10000,\n      high: 20000,\n      highest: 32000,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\n// Helper type to extract model keys from the models array\ntype ExtractModelKeys<T> = T extends readonly { key: infer K }[] ? K : never;\n\nexport interface AxAIAnthropicArgs<TModelKey = string> {\n  name: 'anthropic';\n  apiKey?: string | (() => Promise<string>);\n  projectId?: string;\n  region?: string;\n  config?: Readonly<Partial<AxAIAnthropicConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<\n    AxAIAnthropicModel | AxAIAnthropicVertexModel,\n    undefined,\n    TModelKey\n  >;\n}\n\nclass AxAIAnthropicImpl\n  implements\n    AxAIServiceImpl<\n      AxAIAnthropicModel | AxAIAnthropicVertexModel,\n      unknown,\n      AxAIAnthropicChatRequest,\n      unknown,\n      AxAIAnthropicChatResponse,\n      AxAIAnthropicChatResponseDelta,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n  private currentPromptConfig?: AxAIServiceOptions;\n\n  constructor(\n    private config: AxAIAnthropicConfig,\n    private isVertex: boolean\n  ) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens ?? 4096,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      stream: config.stream,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq = async (\n    req: Readonly<\n      AxInternalChatRequest<AxAIAnthropicModel | AxAIAnthropicVertexModel>\n    >,\n    config: Readonly<AxAIServiceOptions>\n  ): Promise<[AxAPI, AxAIAnthropicChatRequest]> => {\n    // Store config for use in response methods\n    this.currentPromptConfig = config;\n\n    const model = req.model;\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    let apiConfig: AxAPI;\n    if (this.isVertex) {\n      apiConfig = {\n        name: stream\n          ? `/models/${model}:streamRawPredict?alt=sse`\n          : `/models/${model}:rawPredict`,\n      };\n    } else {\n      apiConfig = {\n        name: '/messages',\n      };\n    }\n\n    let toolsChoice:\n      | { tool_choice: { type: 'auto' | 'any' | 'tool'; name?: string } }\n      | undefined;\n\n    if (req.functionCall && req.functions && req.functions.length > 0) {\n      if (typeof req.functionCall === 'string') {\n        switch (req.functionCall) {\n          case 'auto':\n            toolsChoice = { tool_choice: { type: 'auto' as const } };\n            break;\n          case 'required':\n            toolsChoice = { tool_choice: { type: 'any' as const } };\n            break;\n          case 'none':\n            throw new Error('functionCall none not supported');\n        }\n      } else if ('function' in req.functionCall) {\n        toolsChoice = {\n          tool_choice: {\n            type: 'tool' as const,\n            name: req.functionCall.function.name,\n          },\n        };\n      } else {\n        throw new Error('Invalid function call type, must be string or object');\n      }\n    }\n\n    const system = req.chatPrompt\n      .filter((msg) => msg.role === 'system')\n      .map((msg) => ({\n        type: 'text' as const,\n        text: msg.content,\n        ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n      }));\n\n    const otherMessages = req.chatPrompt.filter((msg) => msg.role !== 'system');\n\n    const messages = createMessages(otherMessages);\n\n    const tools: AxAIAnthropicChatRequest['tools'] = req.functions?.map(\n      (v) => ({\n        name: v.name,\n        description: v.description,\n        input_schema: v.parameters\n          ? cleanSchemaForAnthropic(v.parameters)\n          : undefined,\n      })\n    );\n\n    const maxTokens = req.modelConfig?.maxTokens ?? this.config.maxTokens;\n    const stopSequences =\n      req.modelConfig?.stopSequences ?? this.config.stopSequences;\n    const temperature = req.modelConfig?.temperature ?? this.config.temperature;\n    const topP = req.modelConfig?.topP ?? this.config.topP;\n    const topK = req.modelConfig?.topK ?? this.config.topK;\n    const n = req.modelConfig?.n ?? this.config.n;\n\n    if (n && n > 1) {\n      throw new Error('Anthropic does not support sampling (n > 1)');\n    }\n\n    // Handle thinking configuration\n    let thinkingConfig: AxAIAnthropicThinkingConfig | undefined;\n\n    if (this.config.thinking?.budget_tokens) {\n      thinkingConfig = this.config.thinking;\n    }\n\n    // Override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      const levels = this.config.thinkingTokenBudgetLevels;\n\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          // When thinkingTokenBudget is 'none', disable thinking entirely\n          thinkingConfig = undefined;\n          break;\n        case 'minimal':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.minimal ?? 1024,\n          };\n          break;\n        case 'low':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.low ?? 5000,\n          };\n          break;\n        case 'medium':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.medium ?? 10000,\n          };\n          break;\n        case 'high':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.high ?? 20000,\n          };\n          break;\n        case 'highest':\n          thinkingConfig = {\n            type: 'enabled',\n            budget_tokens: levels?.highest ?? 32000,\n          };\n          break;\n      }\n    }\n\n    const reqValue: AxAIAnthropicChatRequest = {\n      ...(this.isVertex\n        ? { anthropic_version: 'vertex-2023-10-16' }\n        : { model }),\n      ...(maxTokens ? { max_tokens: maxTokens } : {}),\n      ...(stopSequences && stopSequences.length > 0\n        ? { stop_sequences: stopSequences }\n        : {}),\n      // Only include temperature when thinking is not enabled\n      ...(temperature && !thinkingConfig ? { temperature } : {}),\n      // Only include top_p when thinking is not enabled, or when it's >= 0.95\n      ...(topP && (!thinkingConfig || topP >= 0.95) ? { top_p: topP } : {}),\n      // Only include top_k when thinking is not enabled\n      ...(topK && !thinkingConfig ? { top_k: topK } : {}),\n      ...toolsChoice,\n      ...(tools && tools.length > 0 ? { tools } : {}),\n      ...(stream ? { stream: true } : {}),\n      ...(system ? { system } : {}),\n      ...(thinkingConfig ? { thinking: thinkingConfig } : {}),\n      messages,\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIAnthropicChatResponse | AxAIAnthropicChatError>\n  ): AxChatResponse => {\n    if (resp.type === 'error') {\n      // Use AxAIRefusalError for authentication and API errors that could be refusal-related\n      throw new AxAIRefusalError(\n        resp.error.message,\n        undefined, // model not specified in error response\n        undefined // requestId not specified in error response\n      );\n    }\n\n    const finishReason = mapFinishReason(resp.stop_reason);\n\n    // Determine if thoughts should be shown\n    const showThoughts =\n      this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n      this.currentPromptConfig?.showThoughts !== false;\n\n    const results = resp.content\n      .map((msg, index): AxChatResponseResult => {\n        if (msg.type === 'tool_use') {\n          return {\n            index,\n            id: msg.id,\n            functionCalls: [\n              {\n                id: msg.id,\n                type: 'function' as const,\n                function: {\n                  name: msg.name,\n                  params: msg.input,\n                },\n              },\n            ],\n            finishReason,\n          };\n        }\n        if (\n          (msg.type === 'thinking' || msg.type === 'redacted_thinking') &&\n          showThoughts\n        ) {\n          return {\n            index,\n            thought: msg.thinking,\n            id: resp.id,\n            finishReason,\n          };\n        }\n        return {\n          index,\n          content: msg.type === 'text' ? msg.text : '',\n          id: resp.id,\n          finishReason,\n        };\n      })\n      .filter(\n        (result) =>\n          result.content !== '' ||\n          result.thought !== undefined ||\n          result.functionCalls !== undefined\n      );\n\n    this.tokensUsed = {\n      promptTokens: resp.usage.input_tokens,\n      completionTokens: resp.usage.output_tokens,\n      totalTokens: resp.usage.input_tokens + resp.usage.output_tokens,\n    };\n\n    return { results, remoteId: resp.id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIAnthropicChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    if (!('type' in resp)) {\n      throw new Error('Invalid Anthropic streaming event');\n    }\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>;\n    };\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {};\n    }\n\n    if (resp.type === 'error') {\n      const { error } = resp as unknown as AxAIAnthropicErrorEvent;\n      throw new AxAIRefusalError(\n        error.message,\n        undefined, // model not specified in error event\n        undefined // requestId not specified in error event\n      );\n    }\n\n    const index = 0;\n\n    if (resp.type === 'message_start') {\n      const { message } = resp as unknown as AxAIAnthropicMessageStartEvent;\n      const results = [{ index, content: '', id: message.id }];\n\n      this.tokensUsed = {\n        promptTokens: message.usage?.input_tokens ?? 0,\n        completionTokens: message.usage?.output_tokens ?? 0,\n        totalTokens:\n          (message.usage?.input_tokens ?? 0) +\n          (message.usage?.output_tokens ?? 0),\n      };\n      return { results };\n    }\n\n    if (resp.type === 'content_block_start') {\n      const { content_block: contentBlock } =\n        resp as unknown as AxAIAnthropicContentBlockStartEvent;\n\n      if (contentBlock.type === 'text') {\n        return {\n          results: [{ index, content: contentBlock.text }],\n        };\n      }\n      if (contentBlock.type === 'thinking') {\n        // Determine if thoughts should be shown\n        const showThoughts =\n          this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n          this.currentPromptConfig?.showThoughts !== false;\n        if (showThoughts) {\n          return {\n            results: [{ index, thought: contentBlock.thinking }],\n          };\n        }\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (contentBlock.type === 'tool_use') {\n        if (\n          typeof contentBlock.id === 'string' &&\n          typeof resp.index === 'number' &&\n          !sstate.indexIdMap[resp.index]\n        ) {\n          sstate.indexIdMap[resp.index] = contentBlock.id;\n          const functionCalls = [\n            {\n              id: contentBlock.id,\n              type: 'function' as const,\n              function: {\n                name: contentBlock.name,\n                params: '',\n              },\n            },\n          ];\n          return {\n            results: [{ index, functionCalls }],\n          };\n        }\n      }\n    }\n\n    if (resp.type === 'content_block_delta') {\n      const { delta } = resp as unknown as AxAIAnthropicContentBlockDeltaEvent;\n      if (delta.type === 'text_delta') {\n        return {\n          results: [{ index, content: delta.text }],\n        };\n      }\n      if (delta.type === 'thinking_delta') {\n        // Determine if thoughts should be shown\n        const showThoughts =\n          this.currentPromptConfig?.thinkingTokenBudget !== 'none' &&\n          this.currentPromptConfig?.showThoughts !== false;\n        if (showThoughts) {\n          return {\n            results: [{ index, thought: delta.thinking }],\n          };\n        }\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (delta.type === 'signature_delta') {\n        // Signature deltas are handled internally by Anthropic,\n        // we don't need to expose them in the response\n        return {\n          results: [{ index, content: '' }],\n        };\n      }\n      if (delta.type === 'input_json_delta') {\n        const id = sstate.indexIdMap[resp.index];\n        if (!id) {\n          throw new Error(`invalid streaming index no id found: ${resp.index}`);\n        }\n        const functionCalls = [\n          {\n            id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: delta.partial_json,\n            },\n          },\n        ];\n        return {\n          results: [{ index, functionCalls }],\n        };\n      }\n    }\n\n    if (resp.type === 'message_delta') {\n      const { delta, usage } =\n        resp as unknown as AxAIAnthropicMessageDeltaEvent;\n\n      this.tokensUsed = {\n        promptTokens: 0,\n        completionTokens: usage.output_tokens,\n        totalTokens: usage.output_tokens,\n      };\n\n      const results = [\n        {\n          index,\n          content: '',\n          finishReason: mapFinishReason(delta.stop_reason),\n        },\n      ];\n      return { results };\n    }\n\n    return {\n      results: [{ index, content: '' }],\n    };\n  };\n}\n\nexport class AxAIAnthropic<TModelKey = string> extends AxBaseAI<\n  AxAIAnthropicModel | AxAIAnthropicVertexModel,\n  unknown,\n  AxAIAnthropicChatRequest,\n  never,\n  AxAIAnthropicChatResponse,\n  AxAIAnthropicChatResponseDelta,\n  never,\n  TModelKey\n> {\n  // Static factory method for automatic type inference\n  static create<const T extends AxAIAnthropicArgs<any>>(\n    options: T\n  ): T extends { models: infer M }\n    ? AxAIAnthropic<ExtractModelKeys<M>>\n    : AxAIAnthropic<string> {\n    return new AxAIAnthropic(options) as any;\n  }\n\n  constructor({\n    apiKey,\n    projectId,\n    region,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIAnthropicArgs<TModelKey>, 'name'>>) {\n    const isVertex = projectId !== undefined && region !== undefined;\n\n    let apiURL: string;\n    let headers: () => Promise<Record<string, string>>;\n\n    if (isVertex) {\n      if (!apiKey) {\n        throw new Error('Anthropic Vertex API key not set');\n      }\n      if (typeof apiKey !== 'function') {\n        throw new Error(\n          'Anthropic Vertex API key must be a function for token-based authentication'\n        );\n      }\n      apiURL = `https://${region}-aiplatform.googleapis.com/v1/projects/${projectId}/locations/${region}/publishers/anthropic/`;\n      headers = async () => ({\n        Authorization: `Bearer ${await apiKey()}`,\n      });\n    } else {\n      if (!apiKey) {\n        throw new Error('Anthropic API key not set');\n      }\n      apiURL = 'https://api.anthropic.com/v1';\n      headers = async () => ({\n        'anthropic-version': '2023-06-01',\n        'anthropic-beta': 'prompt-caching-2024-07-31',\n        'x-api-key': typeof apiKey === 'function' ? await apiKey() : apiKey,\n      });\n    }\n\n    const Config = {\n      ...axAIAnthropicDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIAnthropicImpl(Config, isVertex);\n\n    const supportFor = (\n      model: AxAIAnthropicModel | AxAIAnthropicVertexModel\n    ) => {\n      const mi = getModelInfo<\n        AxAIAnthropicModel | AxAIAnthropicVertexModel,\n        undefined,\n        TModelKey\n      >({\n        model,\n        modelInfo: axModelInfoAnthropic,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        functionCot: true,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 5 * 1024 * 1024, // 5MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n            maxDuration: 0,\n          },\n          files: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            uploadMethod: 'none' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: true,\n          types: ['ephemeral'] as ('ephemeral' | 'persistent')[],\n        },\n        thinking: mi?.hasThinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    super(aiImpl, {\n      name: 'Anthropic',\n      apiURL,\n      headers,\n      modelInfo: axModelInfoAnthropic,\n      defaults: { model: Config.model },\n      options,\n      supportFor,\n      models,\n    });\n  }\n}\n\ntype AnthropicMsg = AxAIAnthropicChatRequest['messages'][0];\ntype AnthropicMsgRoleUser = Extract<AnthropicMsg, { role: 'user' }>;\ntype AnthropicMsgRoleUserToolResult = Extract<\n  AnthropicMsgRoleUser['content'][0],\n  { type: 'tool_result' }\n>;\n\nfunction createMessages(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>\n): AxAIAnthropicChatRequest['messages'] {\n  const items: AxAIAnthropicChatRequest['messages'] = chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'function': {\n        const content: AnthropicMsgRoleUserToolResult[] = [\n          {\n            type: 'tool_result' as const,\n            content: msg.result,\n            tool_use_id: msg.functionId,\n            ...(msg.isError ? { is_error: true } : {}),\n            ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n          },\n        ];\n\n        return {\n          role: 'user' as const,\n          content,\n        };\n      }\n      case 'user': {\n        if (typeof msg.content === 'string') {\n          return {\n            role: 'user' as const,\n            content: msg.content,\n          };\n        }\n        const content = msg.content.map((v) => {\n          switch (v.type) {\n            case 'text':\n              return {\n                type: 'text' as const,\n                text: v.text,\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              };\n            case 'image':\n              return {\n                type: 'image' as const,\n                source: {\n                  type: 'base64' as const,\n                  media_type: v.mimeType,\n                  data: v.image,\n                },\n                ...(v.cache ? { cache: { type: 'ephemeral' } } : {}),\n              };\n            default:\n              throw new Error('Invalid content type');\n          }\n        });\n        return {\n          role: 'user' as const,\n          content,\n        };\n      }\n      case 'assistant': {\n        let content: Extract<\n          AxAIAnthropicChatRequest['messages'][0],\n          { role: 'assistant' }\n        >['content'] = '';\n\n        if (typeof msg.content === 'string') {\n          content = msg.content;\n        }\n        if (typeof msg.functionCalls !== 'undefined') {\n          content = msg.functionCalls.map((v) => {\n            let input: object = {};\n            if (typeof v.function.params === 'string') {\n              input = JSON.parse(v.function.params);\n            } else if (typeof v.function.params === 'object') {\n              input = v.function.params as object;\n            }\n            return {\n              type: 'tool_use' as const,\n              id: v.id,\n              name: v.function.name,\n              input,\n              ...(msg.cache ? { cache: { type: 'ephemeral' } } : {}),\n            };\n          });\n        }\n        return {\n          role: 'assistant' as const,\n          content,\n        };\n      }\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n\n  return mergeAssistantMessages(items);\n}\n\n// Anthropic and some others need this in non-streaming mode\nfunction mergeAssistantMessages(\n  messages: Readonly<AxAIAnthropicChatRequest['messages']>\n): AxAIAnthropicChatRequest['messages'] {\n  const mergedMessages: AxAIAnthropicChatRequest['messages'] = [];\n\n  for (const [i, cur] of messages.entries()) {\n    // Continue if not an assistant message or first message\n    if (cur.role !== 'assistant') {\n      mergedMessages.push(cur);\n      continue;\n    }\n\n    // Merge current message with the previous one if both are from the assistant\n    if (i > 0 && messages.at(i - 1)?.role === 'assistant') {\n      const lastMessage = mergedMessages.pop();\n\n      mergedMessages.push({\n        ...(lastMessage ? lastMessage : {}),\n        ...cur,\n      });\n    } else {\n      mergedMessages.push(cur);\n    }\n  }\n\n  return mergedMessages;\n}\n\nfunction mapFinishReason(\n  stopReason?: AxAIAnthropicChatResponse['stop_reason'] | null\n): AxChatResponse['results'][0]['finishReason'] | undefined {\n  if (!stopReason) {\n    return undefined;\n  }\n  switch (stopReason) {\n    case 'stop_sequence':\n      return 'stop';\n    case 'max_tokens':\n      return 'length';\n    case 'tool_use':\n      return 'function_call';\n    case 'end_turn':\n      return 'stop';\n    default:\n      return 'stop';\n  }\n}\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIOpenAIModel {\n  // Non-reasoning models\n  GPT4 = 'gpt-4',\n  GPT41 = 'gpt-4.1',\n  GPT41Mini = 'gpt-4.1-mini',\n  GPT4O = 'gpt-4o',\n  GPT4OMini = 'gpt-4o-mini',\n  GPT4ChatGPT4O = 'chatgpt-4o-latest',\n  GPT4Turbo = 'gpt-4-turbo',\n  GPT35Turbo = 'gpt-3.5-turbo',\n  GPT35TurboInstruct = 'gpt-3.5-turbo-instruct',\n  GPT35TextDavinci002 = 'text-davinci-002',\n  GPT3TextBabbage002 = 'text-babbage-002',\n  GPT3TextAda001 = 'text-ada-001',\n  // Reasoning models\n  O1 = 'o1',\n  O1Mini = 'o1-mini',\n  O3 = 'o3',\n  O3Mini = 'o3-mini',\n  O4Mini = 'o4-mini',\n}\n\nexport enum AxAIOpenAIEmbedModel {\n  TextEmbeddingAda002 = 'text-embedding-ada-002',\n  TextEmbedding3Small = 'text-embedding-3-small',\n  TextEmbedding3Large = 'text-embedding-3-large',\n}\n\n// Web search annotation types\nexport type AxAIOpenAIUrlCitation = {\n  url: string;\n  title?: string;\n  description?: string;\n};\n\nexport type AxAIOpenAIAnnotation = {\n  type: 'url_citation';\n  url_citation: AxAIOpenAIUrlCitation;\n};\n\nexport type AxAIOpenAIConfig<TModel, TEmbedModel> = Omit<\n  AxModelConfig,\n  'topK'\n> & {\n  model: TModel;\n  embedModel?: TEmbedModel;\n  user?: string;\n  responseFormat?: 'json_object';\n  bestOf?: number;\n  logitBias?: Map<string, number>;\n  suffix?: string | null;\n  stop?: string[];\n  logprobs?: number;\n  echo?: boolean;\n  dimensions?: number;\n  reasoningEffort?: 'low' | 'medium' | 'high';\n  store?: boolean;\n  serviceTier?: 'auto' | 'default' | 'flex';\n  webSearchOptions?: {\n    searchContextSize?: 'low' | 'medium' | 'high';\n    userLocation?: {\n      approximate: {\n        type: 'approximate';\n        city?: string;\n        country?: string;\n        region?: string;\n        timezone?: string;\n      };\n    } | null;\n  };\n};\n\nexport type AxAIOpenAILogprob = {\n  tokens: string[];\n  token_logprobs: number[];\n  top_logprobs: Map<string, number>;\n  text_offset: number[];\n};\n\nexport type AxAIOpenAIUsage = {\n  prompt_tokens: number;\n  completion_tokens: number;\n  total_tokens: number;\n};\n\nexport interface AxAIOpenAIResponseDelta<T> {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    delta: T;\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }[];\n  usage?: AxAIOpenAIUsage;\n  system_fingerprint: string;\n}\n\nexport type AxAIOpenAIChatRequest<TModel> = {\n  model: TModel;\n  reasoning_effort?: 'low' | 'medium' | 'high';\n  store?: boolean;\n  messages: (\n    | { role: 'system'; content: string }\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | {\n                  type: string;\n                  text: string;\n                }\n              | {\n                  type: 'image_url';\n                  image_url: { url: string; details?: 'high' | 'low' | 'auto' };\n                }\n              | {\n                  type: 'input_audio';\n                  input_audio: { data: string; format?: 'wav' };\n                }\n              | {\n                  type: 'file';\n                  file: {\n                    file_data: string;\n                    filename: string;\n                  };\n                }\n            )[];\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | {\n              type: string;\n              text: string;\n            };\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content?:\n          | string\n          | {\n              type: string;\n              text: string;\n            };\n        name?: string;\n        tool_calls: {\n          type: 'function';\n          function: {\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments?: string;\n          };\n        }[];\n      }\n    | { role: 'tool'; content: string; tool_call_id: string }\n  )[];\n  tools?: {\n    type: 'function';\n    function: {\n      name: string;\n      description: string;\n      parameters?: object;\n    };\n  }[];\n  tool_choice?:\n    | 'none'\n    | 'auto'\n    | 'required'\n    | { type: 'function'; function: { name: string } };\n  response_format?: { type: string };\n  max_completion_tokens?: number;\n  temperature?: number;\n  top_p?: number;\n  n?: number;\n  stream?: boolean;\n  stop?: readonly string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  logit_bias?: Map<string, number>;\n  user?: string;\n  organization?: string;\n  web_search_options?: {\n    search_context_size?: 'low' | 'medium' | 'high';\n    user_location?: {\n      approximate: {\n        type: 'approximate';\n        city?: string;\n        country?: string;\n        region?: string;\n        timezone?: string;\n      };\n    } | null;\n  };\n};\n\nexport type AxAIOpenAIChatResponse = {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: string;\n  choices: {\n    index: number;\n    message: {\n      role: string;\n      content: string | null;\n      refusal: string | null;\n      reasoning_content?: string;\n      annotations?: AxAIOpenAIAnnotation[];\n      tool_calls?: {\n        id: string;\n        type: 'function';\n        // eslint-disable-next-line functional/functional-parameters\n        function: { name: string; arguments: string };\n      }[];\n    };\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }[];\n  usage?: AxAIOpenAIUsage;\n  error?: {\n    message: string;\n    type: string;\n    param: string;\n    code: number;\n  };\n  system_fingerprint: string;\n};\n\nexport type AxAIOpenAIChatResponseDelta = AxAIOpenAIResponseDelta<{\n  content: string | null;\n  refusal?: string | null;\n  reasoning_content?: string;\n  role?: string;\n  annotations?: AxAIOpenAIAnnotation[];\n  tool_calls?: (NonNullable<\n    AxAIOpenAIChatResponse['choices'][0]['message']['tool_calls']\n  >[0] & {\n    index: number;\n  })[];\n}>;\n\nexport type AxAIOpenAIEmbedRequest<TEmbedModel> = {\n  input: readonly string[];\n  model: TEmbedModel;\n  dimensions?: number;\n  user?: string;\n};\n\nexport type AxAIOpenAIEmbedResponse = {\n  model: string;\n  data: {\n    embedding: readonly number[];\n    index: number;\n  }[];\n  usage: AxAIOpenAIUsage;\n};\n", "import type {\n  AxChatRequest,\n  AxChatResponseResult,\n  AxModelConfig,\n} from '../types.js';\n\n// Extended model enum for the responses API that includes models only available on responses API\nexport enum AxAIOpenAIResponsesModel {\n  // Non-reasoning models\n  GPT4 = 'gpt-4',\n  GPT41 = 'gpt-4.1',\n  GPT41Mini = 'gpt-4.1-mini',\n  GPT4O = 'gpt-4o',\n  GPT4OMini = 'gpt-4o-mini',\n  GPT4ChatGPT4O = 'chatgpt-4o-latest',\n  GPT4Turbo = 'gpt-4-turbo',\n  GPT35Turbo = 'gpt-3.5-turbo',\n  GPT35TurboInstruct = 'gpt-3.5-turbo-instruct',\n  GPT35TextDavinci002 = 'text-davinci-002',\n  GPT3TextBabbage002 = 'text-babbage-002',\n  GPT3TextAda001 = 'text-ada-001',\n  // Reasoning models\n  O1Pro = 'o1-pro',\n  O1 = 'o1',\n  O1Mini = 'o1-mini',\n  O3Pro = 'o3-pro',\n  O3 = 'o3',\n  O3Mini = 'o3-mini',\n  O4Mini = 'o4-mini',\n}\n\n// Define content part types directly based on AxChatRequest structure\nexport interface TextContentPart {\n  type: 'text';\n  text: string;\n  cache?: boolean;\n}\n\nexport interface ImageContentPart {\n  type: 'image';\n  mimeType: string;\n  image: string;\n  details?: 'high' | 'low' | 'auto';\n  cache?: boolean;\n}\n\nexport interface AudioContentPart {\n  type: 'audio';\n  data: string;\n  format?: 'wav';\n  cache?: boolean;\n}\n\n// Union of all content part types\nexport type UserMessageContentItem =\n  | TextContentPart\n  | ImageContentPart\n  | AudioContentPart;\n\n// export type  for function calls as defined in AxChatResponseResult\nexport type FunctionCallType = NonNullable<\n  AxChatResponseResult['functionCalls']\n>[number];\n\n// export type  for the items in req.functions\nexport type RequestFunctionDefinition = NonNullable<\n  AxChatRequest['functions']\n>[number];\n\n// --- AxAIOpenAI /v1/responses Specific Request Types ---\n\n// Content parts for input messages\nexport interface AxAIOpenAIResponsesInputTextContentPart {\n  readonly type: 'text';\n  text: string; // Made mutable for stream aggregation\n}\n\nexport interface AxAIOpenAIResponsesInputImageUrlContentPart {\n  readonly type: 'image_url';\n  readonly image_url: {\n    readonly url: string;\n    readonly details?: 'low' | 'high' | 'auto';\n  };\n}\n\nexport interface AxAIOpenAIResponsesInputAudioContentPart {\n  readonly type: 'input_audio'; // This is an assumption based on compatibility needs\n  readonly input_audio: {\n    readonly data: string; // base64 encoded audio\n    readonly format?: string; // e.g., 'wav', 'mp3'\n  };\n}\n\nexport type AxAIOpenAIResponsesInputContentPart =\n  | AxAIOpenAIResponsesInputTextContentPart\n  | AxAIOpenAIResponsesInputImageUrlContentPart\n  | AxAIOpenAIResponsesInputAudioContentPart;\n\n// Input Item: Message\nexport interface AxAIOpenAIResponsesInputMessageItem {\n  readonly type: 'message';\n  readonly role: 'system' | 'user' | 'assistant' | 'developer';\n  readonly content: string | ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n  readonly name?: string; // Optional name for user/assistant messages\n  // status?: 'in_progress' | 'completed' | 'incomplete' // Typically for response items\n}\n\n// Input Item: Function Call (representing a past call by the model)\nexport interface AxAIOpenAIResponsesInputFunctionCallItem {\n  readonly type: 'function_call';\n  readonly id?: string; // Optional unique ID of this item in the context\n  readonly call_id: string; // The ID that links this call to its output\n  readonly name: string;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: string; // JSON string of arguments\n  // status?: string // Typically for response items\n}\n\n// Input Item: Function Call Output (representing the result of a past call)\nexport interface AxAIOpenAIResponsesInputFunctionCallOutputItem {\n  readonly type: 'function_call_output';\n  readonly id?: string; // Optional unique ID of this item in the context\n  readonly call_id: string;\n  readonly output: string; // JSON string of the output\n  // status?: string // Typically for response items\n}\n\n// Union of all possible input items\n// Add other item types here as needed (e.g., FileSearch, WebSearch, Reasoning items)\nexport type AxAIOpenAIResponsesInputItem =\n  | string // Simple text input\n  | AxAIOpenAIResponsesInputMessageItem\n  | AxAIOpenAIResponsesInputFunctionCallItem\n  | AxAIOpenAIResponsesInputFunctionCallOutputItem;\n\n// Tool Definitions\nexport interface AxAIOpenAIResponsesDefineFunctionTool {\n  readonly type: 'function';\n  readonly name: string;\n  readonly description?: string;\n  readonly parameters: object; // JSON schema\n  readonly strict?: boolean; // Default true\n}\n\n// Add other tool definitions (FileSearch, WebSearch, etc.)\n// export interface AxAIOpenAIResponsesDefineFileSearchTool { type: 'file_search'; vector_store_ids: string[]; ... }\n// export interface AxAIOpenAIResponsesDefineWebSearchTool { type: 'web_search_preview'; ... }\n\nexport type AxAIOpenAIResponsesToolDefinition =\n  AxAIOpenAIResponsesDefineFunctionTool; // | AxAIOpenAIResponsesDefineFileSearchTool | ...\n\n// Tool Choice\nexport type AxAIOpenAIResponsesToolChoice =\n  | 'none'\n  | 'auto'\n  | 'required'\n  | { readonly type: 'function'; readonly name: string }\n  | { readonly type: 'file_search' }; // And other hosted tools\n// | { type: 'web_search_preview' }\n// | { type: 'code_interpreter' }\n\n// Main Request for /v1/responses\nexport interface AxAIOpenAIResponsesRequest<TModel = AxAIOpenAIResponsesModel> {\n  readonly input: string | ReadonlyArray<AxAIOpenAIResponsesInputItem>;\n  readonly model: TModel;\n  readonly background?: boolean | null;\n  readonly include?: ReadonlyArray<\n    | 'file_search_call.results'\n    | 'message.input_image.image_url'\n    | 'computer_call_output.output.image_url'\n    | 'reasoning.encrypted_content'\n    | 'code_interpreter_call.outputs'\n  > | null;\n  readonly instructions?: string | null; // Maps to system prompt\n  readonly max_output_tokens?: number | null;\n  readonly metadata?: Readonly<Record<string, string>> | null;\n  readonly parallel_tool_calls?: boolean | null;\n  readonly previous_response_id?: string | null;\n  readonly reasoning?: {\n    readonly effort?: 'low' | 'medium' | 'high' | null;\n    readonly summary?: 'auto' | 'concise' | 'detailed' | null; // 'generate_summary' is deprecated\n  } | null;\n  readonly service_tier?: 'auto' | 'default' | 'flex' | null;\n  readonly store?: boolean | null; // Whether to store for later retrieval\n  readonly stream?: boolean | null;\n  readonly temperature?: number | null;\n  readonly text?: {\n    readonly format?:\n      | { readonly type: 'text' }\n      | { readonly type: 'json_object' } // Older JSON mode\n      | { readonly type: 'json_schema'; readonly json_schema?: object } // Structured Outputs\n      | null;\n  } | null;\n  readonly tool_choice?: AxAIOpenAIResponsesToolChoice | null;\n  readonly tools?: ReadonlyArray<AxAIOpenAIResponsesToolDefinition> | null;\n  readonly top_p?: number | null;\n  readonly truncation?: 'auto' | 'disabled' | null; // How to handle context window overflow\n  readonly user?: string | null; // User identifier for tracking/moderation\n  readonly seed?: number | null; // Added seed from later in the code\n}\n\n// --- AxAIOpenAI /v1/responses Specific Response Types ---\n\n// Output Item: Message (from assistant)\nexport interface AxAIOpenAIResponsesOutputMessageItem {\n  type: 'message'; // Mutable during construction\n  id: string; // Mutable during construction\n  role: 'assistant'; // Mutable during construction\n  content: ReadonlyArray<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n  status: 'in_progress' | 'completed' | 'incomplete'; // Mutable during construction\n}\n\n// Output Item: Function Call (emitted by the model)\nexport interface AxAIOpenAIResponsesFunctionCallItem {\n  type: 'function_call'; // Mutable during construction\n  id: string; // Mutable during construction\n  call_id: string; // Mutable during construction\n  name: string; // Mutable during construction\n  // eslint-disable-next-line functional/functional-parameters\n  arguments: string; // Mutable during construction (appendable)\n  status?: 'in_progress' | 'completed' | 'incomplete' | 'searching' | 'failed'; // Mutable\n}\n\n// Output Item: Reasoning (if requested and supported)\nexport interface AxAIOpenAIResponsesReasoningItem {\n  readonly type: 'reasoning'; // Typically not built incrementally in the same way by client\n  readonly id: string;\n  readonly summary: ReadonlyArray<{\n    type: 'summary_text';\n    text: string;\n  }>;\n  readonly encrypted_content?: string | null;\n  readonly status?: 'in_progress' | 'completed' | 'incomplete';\n}\n\n// Add this new export interface for output_text parts\nexport interface AxAIOpenAIResponsesOutputTextContentPart {\n  readonly type: 'output_text';\n  readonly text: string;\n  readonly annotations?: ReadonlyArray<unknown>;\n}\n\nexport interface AxAIOpenAIResponsesOutputRefusalContentPart {\n  readonly type: 'refusal';\n  readonly refusal: string;\n}\n\n// Add export interface for reasoning summary parts\nexport interface AxAIOpenAIResponsesReasoningSummaryPart {\n  readonly type: 'summary_text';\n  readonly text: string;\n}\n\n// Update the union of all possible output items\nexport type AxAIOpenAIResponsesOutputItem =\n  | AxAIOpenAIResponsesOutputMessageItem\n  | AxAIOpenAIResponsesFunctionCallItem\n  | AxAIOpenAIResponsesReasoningItem\n  | AxAIOpenAIResponsesFileSearchToolCall\n  | AxAIOpenAIResponsesWebSearchToolCall\n  | AxAIOpenAIResponsesComputerToolCall\n  | AxAIOpenAIResponsesCodeInterpreterToolCall\n  | AxAIOpenAIResponsesImageGenerationToolCall\n  | AxAIOpenAIResponsesLocalShellToolCall\n  | AxAIOpenAIResponsesMCPToolCall;\n\n// Main Response from /v1/responses (non-streaming)\nexport interface AxAIOpenAIResponsesResponse {\n  readonly id: string; // Response ID\n  readonly object: string; // e.g., \"response\"\n  readonly created: number; // Timestamp\n  readonly model: string; // Model ID used\n  readonly output: ReadonlyArray<AxAIOpenAIResponsesOutputItem>;\n  readonly usage?: {\n    readonly prompt_tokens: number;\n    readonly completion_tokens: number; // Or output_tokens / generated_tokens\n    readonly total_tokens: number;\n    // reasoning_tokens?: number // if applicable and included\n  } | null;\n}\n\n// --- Streaming Event Types for /v1/responses ---\n\n// Base streaming event interface\nexport interface AxAIOpenAIResponsesStreamEventBase {\n  readonly type: string;\n  readonly sequence_number: number;\n}\n\n// Response lifecycle events\nexport interface AxAIOpenAIResponsesResponseCreatedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.created';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.in_progress';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.completed';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.failed';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseIncompleteEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.incomplete';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\nexport interface AxAIOpenAIResponsesResponseQueuedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.queued';\n  readonly response: Readonly<AxAIOpenAIResponsesResponse>;\n}\n\n// Output item events\nexport interface AxAIOpenAIResponsesOutputItemAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_item.added';\n  readonly output_index: number;\n  readonly item: Readonly<AxAIOpenAIResponsesOutputItem>;\n}\n\nexport interface AxAIOpenAIResponsesOutputItemDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_item.done';\n  readonly output_index: number;\n  readonly item: Readonly<AxAIOpenAIResponsesOutputItem>;\n}\n\n// Content part events\nexport interface AxAIOpenAIResponsesContentPartAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.content_part.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly part: Readonly<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n}\n\nexport interface AxAIOpenAIResponsesContentPartDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.content_part.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly part: Readonly<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >;\n}\n\n// Text delta events\nexport interface AxAIOpenAIResponsesOutputTextDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesOutputTextDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly text: string;\n}\n\n// Refusal events\nexport interface AxAIOpenAIResponsesRefusalDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.refusal.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesRefusalDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.refusal.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly refusal: string;\n}\n\n// Function call events\nexport interface AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.function_call_arguments.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.function_call_arguments.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: string;\n}\n\n// File search events\nexport interface AxAIOpenAIResponsesFileSearchCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchCallSearchingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.searching';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.file_search_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\n// Web search events\nexport interface AxAIOpenAIResponsesWebSearchCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesWebSearchCallSearchingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.searching';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesWebSearchCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.web_search_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\n// Reasoning events\nexport interface AxAIOpenAIResponsesReasoningDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesReasoningDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly text: string;\n}\n\n// Reasoning summary events\nexport interface AxAIOpenAIResponsesReasoningSummaryPartAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_part.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly part: Readonly<AxAIOpenAIResponsesReasoningSummaryPart>;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryPartDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_part.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly part: Readonly<AxAIOpenAIResponsesReasoningSummaryPart>;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_text.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly delta: string;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryTextDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary_text.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly text: string;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesReasoningSummaryDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.reasoning_summary.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly summary_index: number;\n  readonly text: string;\n}\n\n// Image generation events\nexport interface AxAIOpenAIResponsesImageGenerationCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallGeneratingEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.generating';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.completed';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationCallPartialImageEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.image_generation_call.partial_image';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly partial_image_index: number;\n  readonly partial_image_b64: string;\n}\n\n// MCP events\nexport interface AxAIOpenAIResponsesMCPCallInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.in_progress';\n  readonly item_id: string;\n  readonly output_index: number;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.arguments.delta';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly delta: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallArgumentsDoneEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.arguments.done';\n  readonly item_id: string;\n  readonly output_index: number;\n  // eslint-disable-next-line functional/functional-parameters\n  readonly arguments: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPCallCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.completed';\n}\n\nexport interface AxAIOpenAIResponsesMCPCallFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_call.failed';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsInProgressEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.in_progress';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsCompletedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.completed';\n}\n\nexport interface AxAIOpenAIResponsesMCPListToolsFailedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.mcp_list_tools.failed';\n}\n\n// Annotation events\nexport interface AxAIOpenAIResponsesOutputTextAnnotationAddedEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'response.output_text_annotation.added';\n  readonly item_id: string;\n  readonly output_index: number;\n  readonly content_index: number;\n  readonly annotation_index: number;\n  readonly annotation: object;\n}\n\n// Error event\nexport interface AxAIOpenAIResponsesErrorEvent\n  extends AxAIOpenAIResponsesStreamEventBase {\n  readonly type: 'error';\n  readonly code: string | null;\n  readonly message: string;\n  readonly param: string | null;\n}\n\n// Union of all streaming events\nexport type AxAIOpenAIResponsesStreamEvent =\n  | AxAIOpenAIResponsesResponseCreatedEvent\n  | AxAIOpenAIResponsesResponseInProgressEvent\n  | AxAIOpenAIResponsesResponseCompletedEvent\n  | AxAIOpenAIResponsesResponseFailedEvent\n  | AxAIOpenAIResponsesResponseIncompleteEvent\n  | AxAIOpenAIResponsesResponseQueuedEvent\n  | AxAIOpenAIResponsesOutputItemAddedEvent\n  | AxAIOpenAIResponsesOutputItemDoneEvent\n  | AxAIOpenAIResponsesContentPartAddedEvent\n  | AxAIOpenAIResponsesContentPartDoneEvent\n  | AxAIOpenAIResponsesOutputTextDeltaEvent\n  | AxAIOpenAIResponsesOutputTextDoneEvent\n  | AxAIOpenAIResponsesRefusalDeltaEvent\n  | AxAIOpenAIResponsesRefusalDoneEvent\n  | AxAIOpenAIResponsesFunctionCallArgumentsDeltaEvent\n  | AxAIOpenAIResponsesFunctionCallArgumentsDoneEvent\n  | AxAIOpenAIResponsesFileSearchCallInProgressEvent\n  | AxAIOpenAIResponsesFileSearchCallSearchingEvent\n  | AxAIOpenAIResponsesFileSearchCallCompletedEvent\n  | AxAIOpenAIResponsesWebSearchCallInProgressEvent\n  | AxAIOpenAIResponsesWebSearchCallSearchingEvent\n  | AxAIOpenAIResponsesWebSearchCallCompletedEvent\n  | AxAIOpenAIResponsesReasoningDeltaEvent\n  | AxAIOpenAIResponsesReasoningDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryPartAddedEvent\n  | AxAIOpenAIResponsesReasoningSummaryPartDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryTextDeltaEvent\n  | AxAIOpenAIResponsesReasoningSummaryTextDoneEvent\n  | AxAIOpenAIResponsesReasoningSummaryDeltaEvent\n  | AxAIOpenAIResponsesReasoningSummaryDoneEvent\n  | AxAIOpenAIResponsesImageGenerationCallInProgressEvent\n  | AxAIOpenAIResponsesImageGenerationCallGeneratingEvent\n  | AxAIOpenAIResponsesImageGenerationCallCompletedEvent\n  | AxAIOpenAIResponsesImageGenerationCallPartialImageEvent\n  | AxAIOpenAIResponsesMCPCallInProgressEvent\n  | AxAIOpenAIResponsesMCPCallArgumentsDeltaEvent\n  | AxAIOpenAIResponsesMCPCallArgumentsDoneEvent\n  | AxAIOpenAIResponsesMCPCallCompletedEvent\n  | AxAIOpenAIResponsesMCPCallFailedEvent\n  | AxAIOpenAIResponsesMCPListToolsInProgressEvent\n  | AxAIOpenAIResponsesMCPListToolsCompletedEvent\n  | AxAIOpenAIResponsesMCPListToolsFailedEvent\n  | AxAIOpenAIResponsesOutputTextAnnotationAddedEvent\n  | AxAIOpenAIResponsesErrorEvent;\n\n// Legacy delta export interface for backward compatibility - now maps to the new streaming events\nexport interface AxAIOpenAIResponsesResponseDelta {\n  readonly id?: string; // Overall response ID, appears in first event usually\n  readonly model?: string; // Model ID, might appear in first event\n  readonly event?: string; // e.g., 'response.delta', 'response.item_delta', 'response.done'\n\n  // If event is 'response.delta' or 'response.item_delta'\n  readonly delta?: {\n    // For message content delta\n    readonly content?: string; // If item is a message part\n    // For tool call argument delta\n    // eslint-disable-next-line functional/functional-parameters\n    readonly arguments?: string; // If item is a function_call part\n    // Other potential delta fields based on item type\n  };\n\n  // If event is 'response.item_created', 'response.item_delta', 'response.item_completed'\n  readonly item_index?: number; // Index of the item in the `items` array\n  readonly item?: Partial<Readonly<AxAIOpenAIResponsesOutputItem>>; // The item being streamed or its delta\n\n  // If event is 'response.done'\n  readonly response?: Readonly<AxAIOpenAIResponsesResponse>; // The final full response object (often without items if streamed separately)\n  readonly usage?: {\n    readonly prompt_tokens: number;\n    readonly completion_tokens: number;\n    readonly total_tokens: number;\n    // reasoning_tokens?: number\n  } | null; // Usage often comes in the 'response.done' event or with stream_options\n}\n\n// export type  for the function that updates the request before sending\nexport type ResponsesReqUpdater<\n  TModel,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> = (req: Readonly<TResponsesReq>) => Readonly<TResponsesReq>;\n\n// Utility export type  to make properties of T mutable\nexport type Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\nexport type AxAIOpenAIResponsesConfig<TModel, TEmbedModel> = Omit<\n  AxModelConfig,\n  'topK'\n> & {\n  model: TModel;\n  embedModel?: TEmbedModel;\n  user?: string;\n  bestOf?: number;\n  logitBias?: Map<string, number>;\n  suffix?: string | null;\n  stop?: string[];\n  logprobs?: number;\n  echo?: boolean;\n  dimensions?: number;\n  reasoningEffort?: 'low' | 'medium' | 'high';\n  reasoningSummary?: 'auto' | 'concise' | 'detailed';\n  store?: boolean;\n  systemPrompt?: string;\n  parallelToolCalls?: boolean;\n  seed?: number;\n  responseFormat?: 'text' | 'json_object' | 'json_schema';\n  serviceTier?: 'auto' | 'default' | 'flex';\n};\n\n// ToolCall response types\nexport interface AxAIOpenAIResponsesToolCallBase {\n  id: string;\n  type: string;\n  status?: string;\n}\n\nexport interface AxAIOpenAIResponsesFileSearchToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'file_search_call';\n  queries: string[];\n  results?: {\n    file_id: string;\n    filename: string;\n    score: number;\n    text: string;\n    attributes?: Record<string, string | boolean | number>;\n  }[];\n}\n\nexport interface AxAIOpenAIResponsesWebSearchToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'web_search_call';\n  queries: string[];\n}\n\nexport interface AxAIOpenAIResponsesComputerToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'computer_call';\n  action: object;\n}\n\nexport interface AxAIOpenAIResponsesCodeInterpreterToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'code_interpreter_call';\n  code: string;\n  results?: unknown[];\n}\n\nexport interface AxAIOpenAIResponsesImageGenerationToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'image_generation_call';\n  result?: string;\n}\n\nexport interface AxAIOpenAIResponsesLocalShellToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'local_shell_call';\n  action: object;\n}\n\nexport interface AxAIOpenAIResponsesMCPToolCall\n  extends AxAIOpenAIResponsesToolCallBase {\n  type: 'mcp_call';\n  name: string;\n  args: string;\n  server_label: string;\n  output?: string;\n  error?: string;\n}\n\nexport type AxAIOpenAIResponsesToolCall =\n  | AxAIOpenAIResponsesFunctionCallItem\n  | AxAIOpenAIResponsesFileSearchToolCall\n  | AxAIOpenAIResponsesWebSearchToolCall\n  | AxAIOpenAIResponsesComputerToolCall\n  | AxAIOpenAIResponsesCodeInterpreterToolCall\n  | AxAIOpenAIResponsesImageGenerationToolCall\n  | AxAIOpenAIResponsesLocalShellToolCall\n  | AxAIOpenAIResponsesMCPToolCall;\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIOpenAIEmbedModel, AxAIOpenAIModel } from './chat_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoOpenAI: AxModelInfo[] = [\n  // Not Reasoning models\n  {\n    name: AxAIOpenAIModel.GPT4,\n    currency: 'usd',\n    promptTokenCostPer1M: 30,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.GPT41,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 8,\n  },\n  {\n    name: AxAIOpenAIModel.GPT41Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1.6,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4OMini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4ChatGPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIModel.GPT4Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n  },\n  {\n    name: AxAIOpenAIModel.GPT35Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  // Reasoning models\n  {\n    name: AxAIOpenAIModel.O1,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.O1Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 14.4,\n  },\n  {\n    name: AxAIOpenAIModel.O3,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIModel.O3Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n  },\n  {\n    name: AxAIOpenAIModel.O4Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n  },\n  // Embedding models\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbeddingAda002,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.02,\n    completionTokenCostPer1M: 0.02,\n  },\n  {\n    name: AxAIOpenAIEmbedModel.TextEmbedding3Large,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.13,\n    completionTokenCostPer1M: 0.13,\n  },\n];\n\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoOpenAIResponses: AxModelInfo[] = [\n  // Not Reasoning models\n  {\n    name: AxAIOpenAIResponsesModel.GPT4,\n    currency: 'usd',\n    promptTokenCostPer1M: 30,\n    completionTokenCostPer1M: 60,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT41,\n    currency: 'usd',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 8,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT41Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1.6,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4OMini,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4ChatGPT4O,\n    currency: 'usd',\n    promptTokenCostPer1M: 5,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT4Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 10,\n    completionTokenCostPer1M: 30,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.GPT35Turbo,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  // Reasoning models\n  {\n    name: AxAIOpenAIResponsesModel.O1Pro,\n    currency: 'usd',\n    promptTokenCostPer1M: 150,\n    completionTokenCostPer1M: 600,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n    isExpensive: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O1,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O3Pro,\n    currency: 'usd',\n    promptTokenCostPer1M: 20,\n    completionTokenCostPer1M: 80,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n    isExpensive: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O3,\n    currency: 'usd',\n    promptTokenCostPer1M: 15,\n    completionTokenCostPer1M: 60,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIOpenAIModel.O3Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIOpenAIResponsesModel.O4Mini,\n    currency: 'usd',\n    promptTokenCostPer1M: 1.1,\n    completionTokenCostPer1M: 4.4,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n];\n", "import { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport {\n  type AxAIFeatures,\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\nimport {\n  type AxAIOpenAIChatRequest,\n  type AxAIOpenAIChatResponse,\n  type AxAIOpenAIChatResponseDelta,\n  type AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  type AxAIOpenAIEmbedRequest,\n  type AxAIOpenAIEmbedResponse,\n  AxAIOpenAIModel,\n} from './chat_types.js';\nimport { axModelInfoOpenAI } from './info.js';\n\n/**\n * Checks if the given OpenAI model is a thinking/reasoning model.\n * Thinking models (o1, o3, o4 series) have different parameter restrictions.\n */\nexport const isOpenAIThinkingModel = (model: string): boolean => {\n  const thinkingModels = [\n    AxAIOpenAIModel.O1,\n    AxAIOpenAIModel.O1Mini,\n    AxAIOpenAIModel.O3,\n    AxAIOpenAIModel.O3Mini,\n    AxAIOpenAIModel.O4Mini,\n    // Pro models (string values since they're not in the regular chat enum)\n    'o1-pro',\n    'o3-pro',\n  ];\n  return (\n    thinkingModels.includes(model as AxAIOpenAIModel) ||\n    thinkingModels.includes(model)\n  );\n};\n\nexport const axAIOpenAIDefaultConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT41,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIOpenAIBestConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    ...axAIOpenAIDefaultConfig(),\n    model: AxAIOpenAIModel.GPT41,\n  });\n\nexport const axAIOpenAICreativeConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> =>\n  structuredClone({\n    model: AxAIOpenAIModel.GPT41,\n    embedModel: AxAIOpenAIEmbedModel.TextEmbedding3Small,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport const axAIOpenAIFastConfig = (): AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIDefaultConfig(),\n  model: AxAIOpenAIModel.GPT41Mini,\n});\n\nexport interface AxAIOpenAIArgs<\n  TName = 'openai',\n  TModel = AxAIOpenAIModel,\n  TEmbedModel = AxAIOpenAIEmbedModel,\n  TModelKey = string,\n  TChatReq extends\n    AxAIOpenAIChatRequest<TModel> = AxAIOpenAIChatRequest<TModel>,\n> extends Omit<\n    AxAIOpenAIBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>,\n    'config' | 'supportFor' | 'modelInfo'\n  > {\n  name: TName;\n  modelInfo?: AxModelInfo[];\n  config?: Partial<\n    AxAIOpenAIBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>['config']\n  >;\n}\n\ntype ChatReqUpdater<TModel, TChatReq extends AxAIOpenAIChatRequest<TModel>> = (\n  req: Readonly<TChatReq>\n) => TChatReq;\n\nexport interface AxAIOpenAIBaseArgs<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TChatReq extends AxAIOpenAIChatRequest<TModel>,\n> {\n  apiKey: string;\n  apiURL?: string;\n  config: Readonly<AxAIOpenAIConfig<TModel, TEmbedModel>>;\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>;\n  modelInfo: Readonly<AxModelInfo[]>;\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n  chatReqUpdater?: ChatReqUpdater<TModel, TChatReq>;\n  supportFor: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n}\n\nclass AxAIOpenAIImpl<\n  TModel,\n  TEmbedModel,\n  TChatReq extends AxAIOpenAIChatRequest<TModel>,\n> implements\n    AxAIServiceImpl<\n      TModel,\n      TEmbedModel,\n      AxAIOpenAIChatRequest<TModel>,\n      AxAIOpenAIEmbedRequest<TEmbedModel>,\n      AxAIOpenAIChatResponse,\n      AxAIOpenAIChatResponseDelta,\n      AxAIOpenAIEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private readonly config: Readonly<AxAIOpenAIConfig<TModel, TEmbedModel>>,\n    private streamingUsage: boolean,\n    private readonly chatReqUpdater?: ChatReqUpdater<TModel, TChatReq>\n  ) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    };\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<TModel>>,\n\n    config: Readonly<AxAIServiceOptions>\n  ): [AxAPI, AxAIOpenAIChatRequest<TModel>] {\n    const model = req.model;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    };\n\n    const tools = req.functions?.map((v) => ({\n      type: 'function' as const,\n      function: {\n        name: v.name,\n        description: v.description,\n        parameters: v.parameters,\n      },\n    }));\n\n    const toolsChoice =\n      !req.functionCall && req.functions && req.functions.length > 0\n        ? 'auto'\n        : req.functionCall;\n\n    const messages = createMessages(req);\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;\n\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    const store = this.config.store;\n\n    const isThinkingModel = isOpenAIThinkingModel(model as string);\n\n    let reqValue: AxAIOpenAIChatRequest<TModel> = {\n      model,\n      messages,\n      response_format: this.config?.responseFormat\n        ? { type: this.config.responseFormat }\n        : undefined,\n      tools,\n      tool_choice: toolsChoice,\n      // For thinking models, don't set these parameters as they're not supported\n      ...(isThinkingModel\n        ? {}\n        : {\n            max_completion_tokens:\n              req.modelConfig?.maxTokens ?? this.config.maxTokens,\n            temperature:\n              req.modelConfig?.temperature ?? this.config.temperature,\n            top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,\n            n: req.modelConfig?.n ?? this.config.n,\n            presence_penalty:\n              req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n            ...(frequencyPenalty\n              ? { frequency_penalty: frequencyPenalty }\n              : {}),\n          }),\n      stop: req.modelConfig?.stopSequences ?? this.config.stop,\n      logit_bias: this.config.logitBias,\n      ...(stream && this.streamingUsage\n        ? { stream: true, stream_options: { include_usage: true } }\n        : {}),\n      ...(store ? { store: store } : {}),\n      ...(this.config.serviceTier\n        ? { service_tier: this.config.serviceTier }\n        : {}),\n      ...(this.config.user ? { user: this.config.user } : {}),\n    };\n\n    if (this.config.reasoningEffort) {\n      reqValue.reasoning_effort = this.config.reasoningEffort;\n    }\n\n    if (this.config.webSearchOptions) {\n      reqValue.web_search_options = {\n        ...(this.config.webSearchOptions.searchContextSize && {\n          search_context_size: this.config.webSearchOptions.searchContextSize,\n        }),\n        ...(this.config.webSearchOptions.userLocation && {\n          user_location: {\n            approximate: {\n              type: 'approximate',\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .city && {\n                city: this.config.webSearchOptions.userLocation.approximate\n                  .city,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .country && {\n                country:\n                  this.config.webSearchOptions.userLocation.approximate.country,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .region && {\n                region:\n                  this.config.webSearchOptions.userLocation.approximate.region,\n              }),\n              ...(this.config.webSearchOptions.userLocation.approximate\n                .timezone && {\n                timezone:\n                  this.config.webSearchOptions.userLocation.approximate\n                    .timezone,\n              }),\n            },\n          },\n        }),\n      };\n    }\n\n    // Then, override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          reqValue.reasoning_effort = undefined; // Explicitly set to undefined\n          break;\n        case 'minimal':\n          reqValue.reasoning_effort = 'low';\n          break;\n        case 'low':\n          reqValue.reasoning_effort = 'medium';\n          break;\n        case 'medium':\n          reqValue.reasoning_effort = 'high';\n          break;\n        case 'high':\n          reqValue.reasoning_effort = 'high';\n          break;\n        case 'highest':\n          reqValue.reasoning_effort = 'high';\n          break;\n      }\n    }\n\n    if (this.chatReqUpdater) {\n      reqValue = this.chatReqUpdater(reqValue as TChatReq);\n    }\n\n    return [apiConfig, reqValue];\n  }\n\n  createEmbedReq(\n    req: Readonly<AxInternalEmbedRequest<TEmbedModel>>\n  ): [AxAPI, AxAIOpenAIEmbedRequest<TEmbedModel>] {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embeddings',\n    };\n\n    const reqValue = {\n      model: model,\n      input: req.texts,\n      dimensions: this.config.dimensions,\n    };\n\n    return [apiConfig, reqValue];\n  }\n\n  createChatResp(resp: Readonly<AxAIOpenAIChatResponse>): AxChatResponse {\n    const { id, usage, choices, error } = resp;\n\n    if (error) {\n      throw error;\n    }\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    const results = choices.map((choice) => {\n      // Check for refusal and throw exception if present\n      if (choice.message.refusal) {\n        throw new AxAIRefusalError(choice.message.refusal, resp.model, resp.id);\n      }\n\n      const finishReason = mapFinishReason(choice.finish_reason);\n\n      const functionCalls = choice.message.tool_calls?.map(\n        ({ id, function: { arguments: params, name } }) => ({\n          id: id,\n          type: 'function' as const,\n          function: { name, params },\n        })\n      );\n\n      return {\n        index: choice.index,\n        id: `${choice.index}`,\n        content: choice.message.content ?? undefined,\n        thought: choice.message.reasoning_content,\n        annotations: choice.message.annotations,\n        functionCalls,\n        finishReason,\n      };\n    });\n\n    return {\n      results,\n      remoteId: id,\n    };\n  }\n\n  createChatStreamResp(\n    resp: Readonly<AxAIOpenAIChatResponseDelta>,\n    state: object\n  ): AxChatResponse {\n    const { id, usage, choices } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    const sstate = state as {\n      indexIdMap: Record<number, string>;\n    };\n\n    if (!sstate.indexIdMap) {\n      sstate.indexIdMap = {};\n    }\n\n    const results = choices.map(\n      ({\n        index,\n        delta: {\n          content,\n          role,\n          refusal,\n          tool_calls: toolCalls,\n          reasoning_content: thought,\n          annotations,\n        },\n        finish_reason: oaiFinishReason,\n      }) => {\n        // Check for refusal and throw exception if present\n        if (refusal) {\n          throw new AxAIRefusalError(refusal, undefined, id);\n        }\n\n        const finishReason = mapFinishReason(oaiFinishReason);\n\n        const functionCalls = toolCalls\n          ?.map(({ id: Id, index, function: { name, arguments: params } }) => {\n            if (\n              typeof Id === 'string' &&\n              typeof index === 'number' &&\n              !sstate.indexIdMap[index]\n            ) {\n              sstate.indexIdMap[index] = Id;\n            }\n\n            const id = sstate.indexIdMap[index];\n            if (!id) {\n              return null;\n            }\n\n            return {\n              id,\n              type: 'function' as const,\n              function: { name, params },\n            };\n          })\n          .filter((v) => v !== null);\n\n        return {\n          index,\n          content: content ?? undefined,\n          role,\n          thought,\n          annotations,\n          functionCalls,\n          finishReason,\n          id,\n        };\n      }\n    );\n\n    return { results };\n  }\n\n  createEmbedResp(resp: Readonly<AxAIOpenAIEmbedResponse>): AxEmbedResponse {\n    const { data, usage } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.prompt_tokens,\n          completionTokens: usage.completion_tokens,\n          totalTokens: usage.total_tokens,\n        }\n      : undefined;\n\n    return { embeddings: data.map((v) => v.embedding) };\n  }\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIOpenAIChatResponse['choices'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const;\n    case 'length':\n      return 'length' as const;\n    case 'content_filter':\n      return 'error' as const;\n    case 'tool_calls':\n      return 'function_call' as const;\n  }\n};\n\nfunction createMessages<TModel>(\n  req: Readonly<AxInternalChatRequest<TModel>>\n): AxAIOpenAIChatRequest<TModel>['messages'] {\n  type UserContent = Extract<\n    AxAIOpenAIChatRequest<TModel>['messages'][number],\n    { role: 'user' }\n  >['content'];\n\n  const openaiReq = req.chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return { role: 'system' as const, content: msg.content };\n\n      case 'user': {\n        const content: UserContent = Array.isArray(msg.content)\n          ? msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  const url = `data:${c.mimeType};base64,${c.image}`;\n                  return {\n                    type: 'image_url' as const,\n                    image_url: { url, details: c.details ?? 'auto' },\n                  };\n                }\n                case 'audio': {\n                  const data = c.data;\n                  return {\n                    type: 'input_audio' as const,\n                    input_audio: {\n                      data,\n                      format: c.format === 'wav' ? 'wav' : undefined,\n                    },\n                  };\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            })\n          : msg.content;\n        return {\n          role: 'user' as const,\n          ...(msg.name ? { name: msg.name } : {}),\n          content,\n        };\n      }\n\n      case 'assistant': {\n        const toolCalls = msg.functionCalls?.map((v) => ({\n          id: v.id,\n          type: 'function' as const,\n          function: {\n            name: v.function.name,\n            arguments:\n              typeof v.function.params === 'object'\n                ? JSON.stringify(v.function.params)\n                : v.function.params,\n          },\n        }));\n\n        if (toolCalls && toolCalls.length > 0) {\n          return {\n            role: 'assistant' as const,\n            ...(msg.content ? { content: msg.content } : {}),\n            name: msg.name,\n            tool_calls: toolCalls,\n          };\n        }\n\n        if (msg.content === undefined) {\n          throw new Error(\n            'Assistant content is required when no tool calls are provided'\n          );\n        }\n\n        return {\n          role: 'assistant' as const,\n          content: msg.content,\n          ...(msg.name ? { name: msg.name } : {}),\n        };\n      }\n\n      case 'function':\n        return {\n          role: 'tool' as const,\n          content: msg.result,\n          tool_call_id: msg.functionId,\n        };\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n  return openaiReq;\n}\n\nexport class AxAIOpenAIBase<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TChatReq extends\n    AxAIOpenAIChatRequest<TModel> = AxAIOpenAIChatRequest<TModel>,\n> extends AxBaseAI<\n  TModel,\n  TEmbedModel,\n  AxAIOpenAIChatRequest<TModel>,\n  AxAIOpenAIEmbedRequest<TEmbedModel>,\n  AxAIOpenAIChatResponse,\n  AxAIOpenAIChatResponseDelta,\n  AxAIOpenAIEmbedResponse,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo,\n    models,\n    chatReqUpdater,\n    supportFor,\n  }: Readonly<\n    Omit<AxAIOpenAIBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>, 'name'>\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    const aiImpl = new AxAIOpenAIImpl<TModel, TEmbedModel, TChatReq>(\n      config,\n      options?.streamingUsage ?? true,\n      chatReqUpdater\n    );\n\n    super(aiImpl, {\n      name: 'OpenAI',\n      apiURL: apiURL ? apiURL : 'https://api.openai.com/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo,\n      defaults: {\n        model: config.model,\n        embedModel: config.embedModel,\n      },\n      options,\n      supportFor,\n      models,\n    });\n  }\n}\n\nexport class AxAIOpenAI<TModelKey = string> extends AxAIOpenAIBase<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<\n    Omit<\n      AxAIOpenAIArgs<\n        'openai',\n        AxAIOpenAIModel,\n        AxAIOpenAIEmbedModel,\n        TModelKey\n      >,\n      'name'\n    >\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    modelInfo = [...axModelInfoOpenAI, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIModel) => {\n      const mi = getModelInfo<AxAIOpenAIModel, AxAIOpenAIEmbedModel, TModelKey>(\n        {\n          model,\n          modelInfo,\n          models: models as AxAIInputModelList<\n            AxAIOpenAIModel,\n            AxAIOpenAIEmbedModel,\n            TModelKey\n          >,\n        }\n      );\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 20 * 1024 * 1024, // 20MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: true,\n            formats: ['wav', 'mp3', 'ogg'],\n            maxDuration: 25 * 60, // 25 minutes\n          },\n          files: {\n            supported: true,\n            formats: [\n              'text/plain',\n              'application/pdf',\n              'image/jpeg',\n              'image/png',\n            ],\n            maxSize: 512 * 1024 * 1024, // 512MB\n            uploadMethod: 'upload' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: true, // Available via web search options\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: mi?.hasThinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    super({\n      apiKey,\n      config: {\n        ...axAIOpenAIDefaultConfig(),\n        ...config,\n      },\n      options,\n      modelInfo,\n      models,\n      supportFor,\n    });\n\n    super.setName('OpenAI');\n  }\n}\n", "import { getModelInfo } from '../../dsp/modelinfo.js';\nimport {\n  type AxAIOpenAIArgs,\n  AxAIOpenAIBase,\n  axAIOpenAIBestConfig,\n  axAIOpenAICreativeConfig,\n  axAIOpenAIDefaultConfig,\n  axAIOpenAIFastConfig,\n} from '../openai/api.js';\nimport type {\n  AxAIOpenAIConfig,\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIModel,\n} from '../openai/chat_types.js';\nimport { axModelInfoOpenAI } from '../openai/info.js';\n\nexport const axAIAzureOpenAIDefaultConfig = axAIOpenAIDefaultConfig;\n\nexport const axAIAzureOpenAICreativeConfig = axAIOpenAICreativeConfig;\n\nexport const axAIAzureOpenAIFastConfig = axAIOpenAIFastConfig;\n\nexport const axAIAzureOpenAIBestConfig = axAIOpenAIBestConfig;\n\nexport type AxAIAzureOpenAIConfig = AxAIOpenAIConfig<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel\n>;\nexport type AxAIAzureOpenAIArgs<TModelKey> = AxAIOpenAIArgs<\n  'azure-openai',\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey\n> & {\n  resourceName: string;\n  deploymentName: string;\n  version?: string;\n};\n\nexport class AxAIAzureOpenAI<TModelKey> extends AxAIOpenAIBase<\n  AxAIOpenAIModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    resourceName,\n    deploymentName,\n    version = 'api-version=2024-02-15-preview',\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIAzureOpenAIArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Azure OpenAPI API key not set');\n    }\n    if (!resourceName || resourceName === '') {\n      throw new Error('Azure OpenAPI resource name not set');\n    }\n    if (!deploymentName || deploymentName === '') {\n      throw new Error('Azure OpenAPI deployment id not set');\n    }\n\n    const Config = {\n      ...axAIAzureOpenAIDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoOpenAI, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIModel) => {\n      const mi = getModelInfo<AxAIOpenAIModel, AxAIOpenAIEmbedModel, TModelKey>(\n        {\n          model,\n          modelInfo,\n          models,\n        }\n      );\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        functionCot: false,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 20 * 1024 * 1024, // 20MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n            maxDuration: 0,\n          },\n          files: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            uploadMethod: 'none' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: mi?.hasThinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      models,\n      modelInfo,\n      supportFor,\n    });\n\n    const host = resourceName.includes('://')\n      ? resourceName\n      : `https://${resourceName}.openai.azure.com/`;\n\n    super.setName('Azure OpenAI');\n\n    super.setAPIURL(\n      new URL(\n        `/openai/deployments/${deploymentName}?api-version=${version}`,\n        host\n      ).href\n    );\n\n    super.setHeaders(async () => ({ 'api-key': apiKey }));\n  }\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport {\n  AxAIServiceAuthenticationError,\n  AxAIServiceError,\n  AxAIServiceNetworkError,\n  AxAIServiceResponseError,\n  AxAIServiceStatusError,\n  AxAIServiceStreamTerminatedError,\n  AxAIServiceTimeoutError,\n} from '../util/apicall.js';\n\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n} from './types.js';\n\n// Helper type to extract model keys from a service\ntype ExtractServiceModelKeys<T> = T extends AxAIService<any, any, infer K>\n  ? K\n  : never;\n\n// Helper type to extract model keys from an array of services\ntype ExtractAllModelKeys<T extends readonly any[]> = T extends readonly [\n  infer First,\n  ...infer Rest,\n]\n  ? ExtractServiceModelKeys<First> | ExtractAllModelKeys<Rest>\n  : never;\n\n/**\n * Options for the balancer.\n */\nexport type AxBalancerOptions<TModelKey = string> = {\n  comparator?: (\n    a: AxAIService<unknown, unknown, TModelKey>,\n    b: AxAIService<unknown, unknown, TModelKey>\n  ) => number;\n  debug?: boolean;\n  initialBackoffMs?: number;\n  maxBackoffMs?: number;\n  maxRetries?: number;\n};\n\n/**\n * Balancer that rotates through services.\n */\nexport class AxBalancer<\n  TServices extends readonly AxAIService<\n    any,\n    any,\n    any\n  >[] = readonly AxAIService[],\n  TModelKey = ExtractAllModelKeys<TServices>,\n> implements AxAIService<unknown, unknown, TModelKey>\n{\n  private services: AxAIService<unknown, unknown, TModelKey>[];\n  private currentServiceIndex = 0;\n  private currentService: AxAIService<unknown, unknown, TModelKey>;\n  private debug: boolean;\n  private initialBackoffMs: number;\n  private maxBackoffMs: number;\n  private maxRetries: number;\n  private serviceFailures: Map<\n    string,\n    { retries: number; lastFailureTime: number }\n  > = new Map();\n\n  constructor(services: TServices, options?: AxBalancerOptions<TModelKey>) {\n    if (services.length === 0) {\n      throw new Error('No AI services provided.');\n    }\n\n    validateModels(\n      services as readonly AxAIService<unknown, unknown, TModelKey>[]\n    );\n\n    this.services = [...services].sort(\n      options?.comparator ?? AxBalancer.metricComparator<TModelKey>\n    ) as AxAIService<unknown, unknown, TModelKey>[];\n\n    const cs = this.services[this.currentServiceIndex];\n    if (cs === undefined) {\n      throw new Error('Error initializing the AI services.'); // More specific error message\n    }\n    this.currentService = cs;\n    this.debug = options?.debug ?? true;\n    this.initialBackoffMs = options?.initialBackoffMs ?? 1000;\n    this.maxBackoffMs = options?.maxBackoffMs ?? 32000;\n    this.maxRetries = options?.maxRetries ?? 3;\n  }\n\n  /**\n   * Static factory method for type-safe balancer creation with automatic model key inference.\n   */\n  static create<const TServices extends readonly AxAIService<any, any, any>[]>(\n    services: TServices,\n    options?: AxBalancerOptions<ExtractAllModelKeys<TServices>>\n  ): AxBalancer<TServices, ExtractAllModelKeys<TServices>> {\n    return new AxBalancer(services, options);\n  }\n  getLastUsedChatModel(): unknown {\n    return this.currentService.getLastUsedChatModel();\n  }\n  getLastUsedEmbedModel(): unknown {\n    return this.currentService.getLastUsedEmbedModel();\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.currentService.getLastUsedModelConfig();\n  }\n\n  /**\n   * Service comparator that respects the input order of services.\n   */\n  public static inputOrderComparator = () => 0;\n\n  /**\n   * Service comparator that sorts services by cost.\n   */\n\n  // Requires a rethink\n  /*\n    public static costComparator = (a: AxAIService, b: AxAIService) => {\n      const aInfo = a.getModelInfo()\n      const bInfo = b.getModelInfo()\n      const aTotalCost =\n        (aInfo.promptTokenCostPer1M || Infinity) +\n        (aInfo.completionTokenCostPer1M || Infinity)\n      const bTotalCost =\n        (bInfo.promptTokenCostPer1M || Infinity) +\n        (bInfo.completionTokenCostPer1M || Infinity)\n      return aTotalCost - bTotalCost\n    }\n    */\n\n  public static metricComparator = <TModelKey = string>(\n    a: AxAIService<unknown, unknown, TModelKey>,\n    b: AxAIService<unknown, unknown, TModelKey>\n  ) => {\n    const aMetrics = a.getMetrics();\n    const bMetrics = b.getMetrics();\n    // Compare mean chat latency between services\n    return aMetrics.latency.chat.mean - bMetrics.latency.chat.mean;\n  };\n\n  getModelList(): AxAIModelList<TModelKey> | undefined {\n    return this.currentService.getModelList();\n  }\n\n  private getNextService(): boolean {\n    const cs = this.services[++this.currentServiceIndex];\n    if (cs === undefined) {\n      return false;\n    }\n    this.currentService = cs;\n    return true;\n  }\n\n  private reset(): void {\n    this.currentServiceIndex = 0;\n    const cs = this.services[this.currentServiceIndex];\n    if (cs === undefined) {\n      throw new Error('No AI services provided.');\n    }\n    this.currentService = cs;\n  }\n\n  getName(): string {\n    return this.currentService.getName();\n  }\n\n  getId(): string {\n    return this.currentService.getId();\n  }\n\n  getFeatures(model?: string) {\n    return this.currentService.getFeatures(model);\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.currentService.getMetrics();\n  }\n\n  private canRetryService(): boolean {\n    const failure = this.serviceFailures.get(this.currentService.getId());\n    if (!failure) return true;\n\n    const { retries, lastFailureTime } = failure;\n    const timeSinceLastFailure = Date.now() - lastFailureTime;\n\n    const backoffMs = Math.min(\n      this.initialBackoffMs * 2 ** retries,\n      this.maxBackoffMs\n    );\n    return timeSinceLastFailure >= backoffMs;\n  }\n\n  private handleFailure(): boolean {\n    const failure = this.serviceFailures.get(this.currentService.getId());\n    const retries = (failure?.retries ?? 0) + 1;\n\n    this.serviceFailures.set(this.currentService.getId(), {\n      retries,\n      lastFailureTime: Date.now(),\n    });\n\n    if (this.debug) {\n      console.warn(\n        `AxBalancer: Service ${this.currentService.getName()} failed (retry ${retries}/${this.maxRetries})`\n      );\n    }\n\n    if (retries >= this.maxRetries) {\n      const gotNextService = this.getNextService();\n      if (this.debug) {\n        console.warn(\n          `AxBalancer: Switching to service ${this.currentService.getName()}`\n        );\n      }\n      return gotNextService;\n    }\n\n    return true;\n  }\n\n  private handleSuccess(): void {\n    this.serviceFailures.delete(this.currentService.getId());\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    this.reset();\n\n    while (true) {\n      if (!this.canRetryService()) {\n        if (!this.getNextService()) {\n          throw new Error('All services exhausted');\n        }\n        continue;\n      }\n\n      try {\n        const response = await this.currentService.chat(req, options);\n        this.handleSuccess();\n        return response;\n      } catch (e) {\n        if (!(e instanceof AxAIServiceError)) {\n          throw e;\n        }\n\n        switch (e.constructor) {\n          case AxAIServiceAuthenticationError:\n            // Handle authentication failure, e.g., refresh token, prompt user to re-login\n            throw e;\n\n          case AxAIServiceStatusError:\n            // Handle specific HTTP error codes, e.g., display a user-friendly message for a 404 Not Found\n            break;\n\n          case AxAIServiceNetworkError:\n            // Handle network issues, e.g., display a message about checking network connectivity\n            break;\n\n          case AxAIServiceResponseError:\n            // Handle errors related to processing the response, e.g., log the error and retry the request\n            break;\n\n          case AxAIServiceStreamTerminatedError:\n            // Handle unexpected stream termination, e.g., retry the request or display an error message\n            break;\n\n          case AxAIServiceTimeoutError:\n            // Handle request timeouts, e.g., increase timeout, retry, or display an error message\n            break;\n\n          default:\n            throw e;\n          // Handle unexpected AxAIServiceErrors\n        }\n\n        if (!this.handleFailure()) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    this.reset();\n\n    while (true) {\n      if (!this.canRetryService()) {\n        if (!this.getNextService()) {\n          throw new Error('All services exhausted');\n        }\n        continue;\n      }\n\n      try {\n        const response = await this.currentService.embed(req, options);\n        this.handleSuccess();\n        return response;\n      } catch (e) {\n        if (!this.handleFailure()) {\n          throw e;\n        }\n      }\n    }\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.currentService.setOptions(options);\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.currentService.getOptions();\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.currentService.getLogger();\n  }\n}\n\nfunction validateModels<TModelKey = string>(\n  services: readonly AxAIService<unknown, unknown, TModelKey>[]\n) {\n  // Check if any service has a model list.\n  const serviceWithModel = services.find(\n    (service) => service.getModelList() !== undefined\n  );\n  if (!serviceWithModel) {\n    // No service provides a model list; no validation needed.\n    return;\n  }\n\n  // Use the first service with a model list as the reference.\n  const referenceModelList = serviceWithModel.getModelList();\n  if (!referenceModelList) {\n    throw new Error('No model list found in any service.');\n  }\n  const referenceKeys = new Set(referenceModelList.map((model) => model.key));\n\n  // Validate that all services provide a model list with the same keys.\n  for (let i = 0; i < services.length; i++) {\n    const service = services[i];\n    if (!service) {\n      throw new Error(`Service at index ${i} is undefined`);\n    }\n    const modelList = service.getModelList();\n    if (!modelList) {\n      throw new Error(\n        `Service at index ${i} (${service.getName()}) has no model list while another service does.`\n      );\n    }\n\n    const serviceKeys = new Set(modelList.map((model) => model.key));\n\n    // Check for missing keys compared to the reference\n    for (const key of referenceKeys) {\n      if (!serviceKeys.has(key)) {\n        throw new Error(\n          `Service at index ${i} (${service.getName()}) is missing model \"${key}\"`\n        );\n      }\n    }\n    // Check for extra keys not in the reference\n    for (const key of serviceKeys) {\n      if (!referenceKeys.has(key)) {\n        throw new Error(\n          `Service at index ${i} (${service.getName()}) has extra model \"${key}\"`\n        );\n      }\n    }\n  }\n}\n", "import type { AxAIService, AxChatRequest } from './types.js';\nimport type { MediaRequirements } from './processor.js';\n\n/**\n * Represents a provider's compatibility score for a specific request\n */\nexport interface ProviderCapabilityScore {\n  /** The AI service provider */\n  provider: AxAIService;\n  /** Numerical score based on capability match (higher is better) */\n  score: number;\n  /** List of capabilities the provider is missing for this request */\n  missingCapabilities: string[];\n  /** List of capabilities the provider supports for this request */\n  supportedCapabilities: string[];\n}\n\n/**\n * Result of validating whether a provider can handle a request\n */\nexport interface CapabilityValidationResult {\n  /** Whether the provider fully supports the request */\n  isSupported: boolean;\n  /** List of capabilities the provider is missing */\n  missingCapabilities: string[];\n  /** Non-critical issues or limitations */\n  warnings: string[];\n  /** Suggested alternatives for missing capabilities */\n  alternatives: string[];\n}\n\n/**\n * Analyzes a chat request to determine what capabilities it requires from AI providers.\n *\n * This function examines the request content to identify:\n * - Media types (images, audio, files, URLs)\n * - Function calling requirements\n * - Streaming requirements\n * - Caching requirements\n * - Token usage estimation\n *\n * @param request - The chat request to analyze\n * @returns Object containing detailed capability requirements and token estimation\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeRequestRequirements({\n *   chatPrompt: [{\n *     role: 'user',\n *     content: [\n *       { type: 'text', text: 'Analyze this image:' },\n *       { type: 'image', image: 'base64...', details: 'high' }\n *     ]\n *   }]\n * });\n *\n * console.log(requirements.hasImages); // true\n * console.log(requirements.estimatedTokens); // ~95\n * ```\n */\nexport function axAnalyzeRequestRequirements(\n  request: AxChatRequest\n): MediaRequirements & {\n  requiresFunctions: boolean;\n  requiresStreaming: boolean;\n  requiresCaching: boolean;\n  contentTypes: Set<string>;\n  estimatedTokens: number;\n} {\n  let hasImages = false;\n  let hasAudio = false;\n  let hasFiles = false;\n  let hasUrls = false;\n  let requiresFunctions = false;\n  let requiresStreaming = false;\n  let requiresCaching = false;\n  const contentTypes = new Set<string>();\n  let estimatedTokens = 0;\n\n  // Analyze chat prompt content\n  if (request.chatPrompt && Array.isArray(request.chatPrompt)) {\n    for (const message of request.chatPrompt) {\n      if (message.role === 'user' && Array.isArray(message.content)) {\n        for (const part of message.content) {\n          contentTypes.add(part.type);\n\n          switch (part.type) {\n            case 'image':\n              hasImages = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate ~85 tokens per image (OpenAI's default)\n              estimatedTokens += 85;\n              break;\n            case 'audio':\n              hasAudio = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate based on duration (rough: 1 token per second)\n              estimatedTokens += part.duration || 60;\n              break;\n            case 'file':\n              hasFiles = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate based on extracted text length\n              estimatedTokens += Math.ceil(\n                (part.extractedText?.length || 1000) / 4\n              );\n              break;\n            case 'url':\n              hasUrls = true;\n              if (part.cache) requiresCaching = true;\n              // Estimate based on cached content length\n              estimatedTokens += Math.ceil(\n                (part.cachedContent?.length || 2000) / 4\n              );\n              break;\n            case 'text':\n              if (part.cache) requiresCaching = true;\n              // Standard token estimation: ~4 characters per token\n              estimatedTokens += Math.ceil(part.text.length / 4);\n              break;\n          }\n        }\n      } else if ('content' in message && typeof message.content === 'string') {\n        estimatedTokens += Math.ceil(message.content.length / 4);\n      }\n\n      if ('cache' in message && message.cache) requiresCaching = true;\n    }\n  }\n\n  // Check for function requirements\n  if (request.functions && request.functions.length > 0) {\n    requiresFunctions = true;\n  }\n\n  // Check for streaming requirements\n  if (request.modelConfig?.stream === true) {\n    requiresStreaming = true;\n  }\n\n  // Check capability preferences\n  if (request.capabilities) {\n    if (request.capabilities.requiresImages) hasImages = true;\n    if (request.capabilities.requiresAudio) hasAudio = true;\n    if (request.capabilities.requiresFiles) hasFiles = true;\n    if (request.capabilities.requiresWebSearch) hasUrls = true;\n  }\n\n  return {\n    hasImages,\n    hasAudio,\n    hasFiles,\n    hasUrls,\n    requiresFunctions,\n    requiresStreaming,\n    requiresCaching,\n    contentTypes,\n    estimatedTokens,\n  };\n}\n\n/**\n * Validates whether an AI provider can handle a request with specific requirements.\n *\n * Compares the provider's feature set against the analyzed request requirements\n * to determine compatibility, missing capabilities, and potential issues.\n *\n * @param provider - The AI service provider to validate\n * @param requirements - Requirements object from axAnalyzeRequestRequirements()\n * @returns Validation result with support status, missing capabilities, and alternatives\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeRequestRequirements(request);\n * const validation = axValidateProviderCapabilities(openaiProvider, requirements);\n *\n * if (!validation.isSupported) {\n *   console.log('Missing:', validation.missingCapabilities);\n *   console.log('Try:', validation.alternatives);\n * }\n * ```\n */\nexport function axValidateProviderCapabilities(\n  provider: AxAIService,\n  requirements: ReturnType<typeof axAnalyzeRequestRequirements>\n): CapabilityValidationResult {\n  const features = provider.getFeatures();\n  const missingCapabilities: string[] = [];\n  const warnings: string[] = [];\n  const alternatives: string[] = [];\n\n  // Check media capabilities\n  if (requirements.hasImages && !features.media.images.supported) {\n    missingCapabilities.push('Image support');\n    alternatives.push('Use altText for images or imageToText service');\n  }\n\n  if (requirements.hasAudio && !features.media.audio.supported) {\n    missingCapabilities.push('Audio support');\n    alternatives.push('Pre-transcribe audio or use transcription field');\n  }\n\n  if (requirements.hasFiles && !features.media.files.supported) {\n    missingCapabilities.push('File support');\n    alternatives.push('Pre-extract text content or use extractedText field');\n  }\n\n  if (requirements.hasUrls && !features.media.urls.supported) {\n    missingCapabilities.push('URL/Web search support');\n    alternatives.push('Pre-fetch content or use cachedContent field');\n  }\n\n  // Check function capabilities\n  if (requirements.requiresFunctions && !features.functions) {\n    missingCapabilities.push('Function calling');\n  }\n\n  // Check streaming capabilities\n  if (requirements.requiresStreaming && !features.streaming) {\n    missingCapabilities.push('Streaming responses');\n    alternatives.push('Use non-streaming mode');\n  }\n\n  // Check caching capabilities\n  if (requirements.requiresCaching && !features.caching.supported) {\n    missingCapabilities.push('Content caching');\n    alternatives.push('Repeated content will not be cached');\n  }\n\n  // Add warnings for potential issues\n  if (requirements.hasImages && features.media.images.supported) {\n    const maxSize = features.media.images.maxSize;\n    if (maxSize && maxSize < 10 * 1024 * 1024) {\n      // Less than 10MB\n      warnings.push(\n        `Image size limit is ${Math.round(maxSize / (1024 * 1024))}MB`\n      );\n    }\n  }\n\n  if (requirements.hasAudio && features.media.audio.supported) {\n    const maxDuration = features.media.audio.maxDuration;\n    if (maxDuration && maxDuration < 600) {\n      // Less than 10 minutes\n      warnings.push(\n        `Audio duration limit is ${Math.round(maxDuration / 60)} minutes`\n      );\n    }\n  }\n\n  const isSupported = missingCapabilities.length === 0;\n\n  return {\n    isSupported,\n    missingCapabilities,\n    warnings,\n    alternatives,\n  };\n}\n\n/**\n * Scores multiple AI providers based on how well they meet request requirements.\n *\n * Uses a weighted scoring system where providers earn points for supported capabilities:\n * - Base functionality: +10 points\n * - Media support (images/audio/files/URLs): +25 points each\n * - Core features (functions/streaming/caching): +8-15 points each\n * - Missing critical capabilities: -10 points each\n * - Bonus points for advanced features (large file support, persistent caching, etc.)\n *\n * @param providers - Array of AI service providers to score\n * @param requirements - Requirements object from axAnalyzeRequestRequirements()\n * @returns Array of scored providers sorted by score (highest first)\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeRequestRequirements(request);\n * const scores = axScoreProvidersForRequest([openai, gemini, cohere], requirements);\n *\n * console.log(`Best: ${scores[0].provider.getName()} (${scores[0].score} points)`);\n * console.log(`Supports: ${scores[0].supportedCapabilities.join(', ')}`);\n * ```\n */\nexport function axScoreProvidersForRequest(\n  providers: AxAIService[],\n  requirements: ReturnType<typeof axAnalyzeRequestRequirements>\n): ProviderCapabilityScore[] {\n  return providers\n    .map((provider) => {\n      const features = provider.getFeatures();\n      const validation = axValidateProviderCapabilities(provider, requirements);\n\n      let score = 0;\n      const supportedCapabilities: string[] = [];\n\n      // Base score for being a functioning provider\n      score += 10;\n\n      // Media support scoring (high weight)\n      if (requirements.hasImages) {\n        if (features.media.images.supported) {\n          score += 25;\n          supportedCapabilities.push('Images');\n\n          // Bonus for better image capabilities\n          if (features.media.images.detailLevels?.includes('high')) {\n            score += 5;\n          }\n          if (\n            features.media.images.maxSize &&\n            features.media.images.maxSize > 10 * 1024 * 1024\n          ) {\n            score += 3; // Large image support\n          }\n        }\n      }\n\n      if (requirements.hasAudio) {\n        if (features.media.audio.supported) {\n          score += 25;\n          supportedCapabilities.push('Audio');\n\n          // Bonus for longer audio support\n          if (\n            features.media.audio.maxDuration &&\n            features.media.audio.maxDuration > 600\n          ) {\n            score += 5;\n          }\n        }\n      }\n\n      if (requirements.hasFiles) {\n        if (features.media.files.supported) {\n          score += 25;\n          supportedCapabilities.push('Files');\n\n          // Bonus for different upload methods\n          if (features.media.files.uploadMethod === 'cloud') {\n            score += 3;\n          }\n        }\n      }\n\n      if (requirements.hasUrls) {\n        if (features.media.urls.supported) {\n          score += 25;\n          supportedCapabilities.push('URLs');\n\n          // Bonus for web search\n          if (features.media.urls.webSearch) {\n            score += 5;\n          }\n        }\n      }\n\n      // Core capability scoring (medium weight)\n      if (requirements.requiresFunctions) {\n        if (features.functions) {\n          score += 15;\n          supportedCapabilities.push('Functions');\n\n          // Bonus for chain-of-thought with functions\n          if (features.functionCot) {\n            score += 3;\n          }\n        }\n      }\n\n      if (requirements.requiresStreaming) {\n        if (features.streaming) {\n          score += 10;\n          supportedCapabilities.push('Streaming');\n        }\n      }\n\n      if (requirements.requiresCaching) {\n        if (features.caching.supported) {\n          score += 8;\n          supportedCapabilities.push('Caching');\n\n          // Bonus for persistent caching\n          if (features.caching.types.includes('persistent')) {\n            score += 3;\n          }\n        }\n      }\n\n      // Additional capability bonuses (low weight)\n      if (features.thinking) {\n        score += 2;\n      }\n\n      if (features.multiTurn) {\n        score += 2;\n      }\n\n      if (features.hasThinkingBudget) {\n        score += 1;\n      }\n\n      if (features.hasShowThoughts) {\n        score += 1;\n      }\n\n      // Penalty for missing critical capabilities\n      score -= validation.missingCapabilities.length * 10;\n\n      return {\n        provider,\n        score,\n        missingCapabilities: validation.missingCapabilities,\n        supportedCapabilities,\n      };\n    })\n    .sort((a, b) => b.score - a.score); // Sort by score descending\n}\n\n/**\n * Automatically selects the optimal AI provider for a given request.\n *\n * Analyzes the request requirements, scores available providers, and returns\n * the best match based on capability compatibility and scoring algorithm.\n *\n * @param request - The chat request to find a provider for\n * @param availableProviders - Array of available AI service providers\n * @param options - Selection options\n * @param options.requireExactMatch - Only return providers with full capability support\n * @param options.allowDegradation - Allow providers that require content processing fallbacks\n * @returns The optimal AI service provider\n * @throws Error if no suitable provider found or requirements not met\n *\n * @example\n * ```typescript\n * // Automatic selection with degradation allowed\n * const provider = axSelectOptimalProvider(\n *   multiModalRequest,\n *   [openai, gemini, cohere],\n *   { allowDegradation: true }\n * );\n *\n * // Strict matching - must support all features natively\n * const provider = axSelectOptimalProvider(\n *   imageRequest,\n *   [openai, gemini],\n *   { requireExactMatch: true }\n * );\n * ```\n */\nexport function axSelectOptimalProvider(\n  request: AxChatRequest,\n  availableProviders: AxAIService[],\n  options: {\n    requireExactMatch?: boolean;\n    allowDegradation?: boolean;\n  } = {}\n): AxAIService {\n  if (availableProviders.length === 0) {\n    throw new Error('No providers available');\n  }\n\n  const requirements = axAnalyzeRequestRequirements(request);\n  const scoredProviders = axScoreProvidersForRequest(\n    availableProviders,\n    requirements\n  );\n\n  if (options.requireExactMatch) {\n    // Only consider providers that fully support all requirements\n    const fullyCompatible = scoredProviders.filter(\n      (p) => p.missingCapabilities.length === 0\n    );\n    if (fullyCompatible.length === 0) {\n      throw new Error(\n        `No providers fully support the request requirements: ${\n          scoredProviders[0]?.missingCapabilities.join(', ') ||\n          'unknown requirements'\n        }`\n      );\n    }\n    return fullyCompatible[0].provider;\n  }\n\n  if (!options.allowDegradation) {\n    // Check if the best provider is missing critical capabilities\n    const bestProvider = scoredProviders[0];\n    if (bestProvider.missingCapabilities.length > 0) {\n      throw new Error(\n        `Best available provider (${bestProvider.provider.getName()}) is missing: ${bestProvider.missingCapabilities.join(\n          ', '\n        )}`\n      );\n    }\n  }\n\n  return scoredProviders[0].provider;\n}\n\n/**\n * Generates a comprehensive compatibility report for a request across all providers.\n *\n * Provides detailed analysis including requirement breakdown, provider scoring,\n * recommendations, and human-readable compatibility summary.\n *\n * @param request - The chat request to analyze\n * @param availableProviders - Array of available AI service providers\n * @returns Comprehensive compatibility report with analysis and recommendations\n *\n * @example\n * ```typescript\n * const report = axGetCompatibilityReport(request, [openai, gemini, cohere]);\n *\n * console.log(report.summary); // \"OpenAI supports 4/4 requirements (100% compatibility)\"\n * console.log('Requirements:', report.requirements);\n *\n * for (const score of report.providerScores) {\n *   console.log(`${score.provider.getName()}: ${score.score} points`);\n *   console.log(`  Missing: ${score.missingCapabilities.join(', ')}`);\n * }\n * ```\n */\nexport function axGetCompatibilityReport(\n  request: AxChatRequest,\n  availableProviders: AxAIService[]\n): {\n  requirements: ReturnType<typeof axAnalyzeRequestRequirements>;\n  providerScores: ProviderCapabilityScore[];\n  recommendedProvider: AxAIService | null;\n  summary: string;\n} {\n  const requirements = axAnalyzeRequestRequirements(request);\n  const providerScores = axScoreProvidersForRequest(\n    availableProviders,\n    requirements\n  );\n\n  const recommendedProvider = providerScores[0]?.provider || null;\n\n  const totalRequirements = [\n    requirements.hasImages && 'images',\n    requirements.hasAudio && 'audio',\n    requirements.hasFiles && 'files',\n    requirements.hasUrls && 'URLs',\n    requirements.requiresFunctions && 'functions',\n    requirements.requiresStreaming && 'streaming',\n    requirements.requiresCaching && 'caching',\n  ].filter(Boolean).length;\n\n  const supportedRequirements = recommendedProvider\n    ? providerScores[0].supportedCapabilities.length\n    : 0;\n\n  const summary = recommendedProvider\n    ? `${recommendedProvider.getName()} supports ${supportedRequirements}/${totalRequirements} requirements (${Math.round(\n        (supportedRequirements / Math.max(totalRequirements, 1)) * 100\n      )}% compatibility)`\n    : 'No suitable providers found';\n\n  return {\n    requirements,\n    providerScores,\n    recommendedProvider,\n    summary,\n  };\n}\n\n/**\n * Filters providers that support a specific media type.\n *\n * @param providers - Array of AI service providers to filter\n * @param mediaType - The media type to check support for\n * @returns Array of providers that support the specified media type\n *\n * @example\n * ```typescript\n * const imageProviders = axGetProvidersWithMediaSupport(allProviders, 'images');\n * console.log(`${imageProviders.length} providers support images`);\n * ```\n */\nexport function axGetProvidersWithMediaSupport(\n  providers: AxAIService[],\n  mediaType: 'images' | 'audio' | 'files' | 'urls'\n): AxAIService[] {\n  return providers.filter((provider) => {\n    const features = provider.getFeatures();\n    return features.media[mediaType].supported;\n  });\n}\n\n/**\n * Analyzes format compatibility across providers for a specific media type.\n *\n * @param providers - Array of AI service providers to analyze\n * @param mediaType - The media type to check format support for\n * @returns Object mapping each supported format to the providers that support it\n *\n * @example\n * ```typescript\n * const compatibility = axGetFormatCompatibility(allProviders, 'images');\n * console.log('JPEG support:', compatibility['image/jpeg']?.map(p => p.getName()));\n * console.log('PNG support:', compatibility['image/png']?.map(p => p.getName()));\n * ```\n */\nexport function axGetFormatCompatibility(\n  providers: AxAIService[],\n  mediaType: 'images' | 'audio' | 'files'\n): {\n  [format: string]: AxAIService[];\n} {\n  const compatibility: { [format: string]: AxAIService[] } = {};\n\n  for (const provider of providers) {\n    const features = provider.getFeatures();\n    const mediaFeatures = features.media[mediaType];\n\n    if (mediaFeatures.supported) {\n      for (const format of mediaFeatures.formats) {\n        if (!compatibility[format]) {\n          compatibility[format] = [];\n        }\n        compatibility[format].push(provider);\n      }\n    }\n  }\n\n  return compatibility;\n}\n", "import type { AxModelConfig } from '../types.js';\n\n/**\n * Cohere: Models for text generation\n */\nexport enum AxAICohereModel {\n  CommandRPlus = 'command-r-plus',\n  CommandR = 'command-r',\n  Command = 'command',\n  CommandLight = 'command-light',\n}\n\n/**\n * Cohere: Models for use in embeddings\n */\nexport enum AxAICohereEmbedModel {\n  EmbedEnglishV30 = 'embed-english-v3.0',\n  EmbedEnglishLightV30 = 'embed-english-light-v3.0',\n  EmbedMultiLingualV30 = 'embed-multilingual-v3.0',\n  EmbedMultiLingualLightV30 = 'embed-multilingual-light-v3.0',\n}\n\n/**\n * Cohere: Model options for text generation\n */\nexport type AxAICohereConfig = AxModelConfig & {\n  model: AxAICohereModel;\n  embedModel?: AxAICohereEmbedModel;\n};\n\nexport type AxAICohereChatResponseToolCalls = {\n  name: string;\n  parameters?: object;\n}[];\n\nexport type AxAICohereChatRequestToolResults = {\n  call: AxAICohereChatResponseToolCalls[0];\n  outputs: object[];\n}[];\n\nexport type AxAICohereChatRequest = {\n  message?: string;\n  preamble?: string;\n  chat_history: (\n    | {\n        role: 'CHATBOT';\n        message: string;\n        tool_calls?: AxAICohereChatResponseToolCalls;\n      }\n    | {\n        role: 'SYSTEM';\n        message: string;\n      }\n    | {\n        role: 'USER';\n        message: string;\n      }\n    | {\n        role: 'TOOL';\n        message?: string;\n        tool_results: AxAICohereChatRequestToolResults;\n      }\n  )[];\n\n  model: AxAICohereModel;\n  max_tokens?: number;\n  temperature?: number;\n  k?: number;\n  p?: number;\n  frequency_penalty?: number;\n  presence_penalty?: number;\n  end_sequences?: readonly string[];\n  stop_sequences?: string[];\n  tools?: {\n    name: string;\n    description: string;\n    parameter_definitions: Record<\n      string,\n      {\n        description: string;\n        type: string;\n        required: boolean;\n      }\n    >;\n  }[];\n  tool_results?: AxAICohereChatRequestToolResults;\n};\n\nexport type AxAICohereChatResponse = {\n  response_id: string;\n  meta: {\n    billed_units: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n  generation_id: string;\n  text: string;\n  finish_reason:\n    | 'COMPLETE'\n    | 'ERROR'\n    | 'ERROR_TOXIC'\n    | 'ERROR_LIMIT'\n    | 'USER_CANCEL'\n    | 'MAX_TOKENS';\n  tool_calls: AxAICohereChatResponseToolCalls;\n};\n\nexport type AxAICohereChatResponseDelta = AxAICohereChatResponse & {\n  event_type:\n    | 'stream-start'\n    | 'text-generation'\n    | 'tool-calls-generation'\n    | 'stream-end';\n};\n\nexport type AxAICohereEmbedRequest = {\n  texts: readonly string[];\n  model: AxAICohereEmbedModel;\n  truncate: string;\n};\n\nexport type AxAICohereEmbedResponse = {\n  id: string;\n  texts: string[];\n  model: AxAICohereEmbedModel;\n  embeddings: number[][];\n};\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAICohereEmbedModel, AxAICohereModel } from './types.js';\n\nexport const axModelInfoCohere: AxModelInfo[] = [\n  {\n    name: AxAICohereModel.CommandRPlus,\n    currency: 'usd',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAICohereModel.CommandR,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.Command,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n  {\n    name: AxAICohereModel.CommandLight,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedEnglishV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n  {\n    name: AxAICohereEmbedModel.EmbedMultiLingualLightV30,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.1,\n  },\n];\n", "import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoCohere } from './info.js';\nimport {\n  type AxAICohereChatRequest,\n  type AxAICohereChatResponse,\n  type AxAICohereChatResponseDelta,\n  type AxAICohereConfig,\n  AxAICohereEmbedModel,\n  type AxAICohereEmbedRequest,\n  type AxAICohereEmbedResponse,\n  AxAICohereModel,\n} from './types.js';\n\nexport const axAICohereDefaultConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandRPlus,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAICohereCreativeConfig = (): AxAICohereConfig =>\n  structuredClone({\n    model: AxAICohereModel.CommandR,\n    embedModel: AxAICohereEmbedModel.EmbedEnglishV30,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport interface AxAICohereArgs<TModelKey> {\n  name: 'cohere';\n  apiKey: string;\n  config?: Readonly<Partial<AxAICohereConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAICohereModel, AxAICohereEmbedModel, TModelKey>;\n}\n\nclass AxAICohereImpl\n  implements\n    AxAIServiceImpl<\n      AxAICohereModel,\n      AxAICohereEmbedModel,\n      AxAICohereChatRequest,\n      AxAICohereEmbedRequest,\n      AxAICohereChatResponse,\n      AxAICohereChatResponseDelta,\n      AxAICohereEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAICohereConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      frequencyPenalty: config.frequencyPenalty,\n      presencePenalty: config.presencePenalty,\n      endSequences: config.endSequences,\n      stopSequences: config.stopSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<AxAICohereModel>>\n  ): [AxAPI, AxAICohereChatRequest] {\n    const model = req.model;\n\n    const lastChatMsg = req.chatPrompt.at(-1);\n    const restOfChat = req.chatPrompt.slice(0, -1);\n\n    let message: AxAICohereChatRequest['message'] | undefined;\n\n    if (\n      lastChatMsg &&\n      lastChatMsg.role === 'user' &&\n      typeof lastChatMsg.content === 'string'\n    ) {\n      message = lastChatMsg?.content;\n    }\n\n    const chatHistory = createHistory(restOfChat);\n\n    type PropValue = NonNullable<\n      AxAICohereChatRequest['tools']\n    >[0]['parameter_definitions'][0];\n\n    const tools: AxAICohereChatRequest['tools'] = req.functions?.map((v) => {\n      const props: Record<string, PropValue> = {};\n      if (v.parameters?.properties) {\n        for (const [key, value] of Object.entries(v.parameters.properties)) {\n          props[key] = {\n            description: value.description,\n            type: value.type,\n            required: v.parameters.required?.includes(key) ?? false,\n          };\n        }\n      }\n\n      return {\n        name: v.name,\n        description: v.description,\n        parameter_definitions: props,\n      };\n    });\n\n    type FnType = Extract<AxChatRequest['chatPrompt'][0], { role: 'function' }>;\n\n    const toolResults: AxAICohereChatRequest['tool_results'] = (\n      req.chatPrompt as FnType[]\n    )\n      .filter((chat) => chat.role === 'function')\n      .map((chat) => {\n        const fn = tools?.find((t) => t.name === chat.functionId);\n        if (!fn) {\n          throw new Error('Function not found');\n        }\n        return {\n          call: { name: fn.name, parameters: fn.parameter_definitions },\n          outputs: [{ result: chat.result ?? '' }],\n        };\n      });\n\n    const apiConfig = {\n      name: '/chat',\n    };\n\n    const reqValue: AxAICohereChatRequest = {\n      message,\n      model,\n      tools,\n      ...(toolResults && !message ? { tool_results: toolResults } : {}),\n      chat_history: chatHistory,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      k: req.modelConfig?.topK ?? this.config.topK,\n      p: req.modelConfig?.topP ?? this.config.topP,\n      frequency_penalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      end_sequences: this.config.endSequences,\n      stop_sequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n    };\n\n    return [apiConfig, reqValue];\n  }\n\n  createEmbedReq = (\n    req: Readonly<AxInternalEmbedRequest<AxAICohereEmbedModel>>\n  ): [AxAPI, AxAICohereEmbedRequest] => {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embed',\n    };\n\n    const reqValue = {\n      model,\n      texts: req.texts ?? [],\n      input_type: 'classification',\n      truncate: '',\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (resp: Readonly<AxAICohereChatResponse>): AxChatResponse => {\n    this.tokensUsed = resp.meta.billed_units\n      ? {\n          promptTokens: resp.meta.billed_units.input_tokens,\n          completionTokens: resp.meta.billed_units.output_tokens,\n          totalTokens:\n            resp.meta.billed_units.input_tokens +\n            resp.meta.billed_units.output_tokens,\n        }\n      : undefined;\n\n    let finishReason: AxChatResponse['results'][0]['finishReason'];\n    if ('finish_reason' in resp) {\n      switch (resp.finish_reason) {\n        case 'COMPLETE':\n          finishReason = 'stop';\n          break;\n        case 'MAX_TOKENS':\n          finishReason = 'length';\n          break;\n        case 'ERROR':\n          throw new Error('Finish reason: ERROR');\n        case 'ERROR_TOXIC':\n          throw new Error('Finish reason: CONTENT_FILTER');\n        default:\n          finishReason = 'stop';\n          break;\n      }\n    }\n\n    let functionCalls: AxChatResponse['results'][0]['functionCalls'];\n\n    if ('tool_calls' in resp) {\n      functionCalls = resp.tool_calls?.map(\n        (v): NonNullable<AxChatResponse['results'][0]['functionCalls']>[0] => {\n          return {\n            id: v.name,\n            type: 'function' as const,\n            function: { name: v.name, params: v.parameters },\n          };\n        }\n      );\n    }\n\n    const results: AxChatResponse['results'] = [\n      {\n        index: 0,\n        id: resp.generation_id,\n        content: resp.text,\n        functionCalls,\n        finishReason,\n      },\n    ];\n\n    return { results, remoteId: resp.response_id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAICohereChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    const ss = state as {\n      generation_id?: string;\n    };\n\n    if (resp.event_type === 'stream-start') {\n      ss.generation_id = resp.generation_id;\n    }\n\n    this.tokensUsed = {\n      promptTokens: 0,\n      completionTokens: resp.meta.billed_units?.output_tokens ?? 0,\n      totalTokens: resp.meta.billed_units?.output_tokens ?? 0,\n    };\n\n    const { results } = this.createChatResp(resp);\n    const result = results[0];\n    if (!result) {\n      throw new Error('No result');\n    }\n\n    result.id = ss.generation_id ?? '';\n    return { results };\n  };\n\n  createEmbedResp(resp: Readonly<AxAICohereEmbedResponse>): AxEmbedResponse {\n    return {\n      remoteId: resp.id,\n      embeddings: resp.embeddings,\n    };\n  }\n}\n\nexport class AxAICohere<TModelKey> extends AxBaseAI<\n  AxAICohereModel,\n  AxAICohereEmbedModel,\n  AxAICohereChatRequest,\n  AxAICohereEmbedRequest,\n  AxAICohereChatResponse,\n  AxAICohereChatResponseDelta,\n  AxAICohereEmbedResponse,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAICohereArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Cohere API key not set');\n    }\n    const Config = {\n      ...axAICohereDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAICohereImpl(Config);\n\n    super(aiImpl, {\n      name: 'Cohere',\n      apiURL: 'https://api.cohere.ai/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo: axModelInfoCohere,\n      defaults: { model: Config.model },\n      supportFor: {\n        functions: true,\n        streaming: true,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            detailLevels: [] as ('high' | 'low' | 'auto')[],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n            maxDuration: 0,\n          },\n          files: {\n            supported: false,\n            formats: [],\n            maxSize: 0,\n            uploadMethod: 'none' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      options,\n      models,\n    });\n  }\n}\nfunction createHistory(\n  chatPrompt: Readonly<AxChatRequest['chatPrompt']>\n): AxAICohereChatRequest['chat_history'] {\n  return chatPrompt.map((chat) => {\n    let message = '';\n\n    if (\n      chat.role === 'system' ||\n      chat.role === 'assistant' ||\n      chat.role === 'user'\n    ) {\n      if (typeof chat.content === 'string') {\n        message = chat.content;\n      } else {\n        throw new Error('Multi-modal content not supported');\n      }\n    }\n\n    switch (chat.role) {\n      case 'user':\n        return { role: 'USER' as const, message };\n      case 'system':\n        return { role: 'SYSTEM' as const, message };\n      case 'assistant': {\n        const toolCalls = createToolCall(chat.functionCalls);\n        return {\n          role: 'CHATBOT' as const,\n          message,\n          tool_calls: toolCalls,\n        };\n      }\n      case 'function': {\n        const functionCalls = chatPrompt\n          .map((v) => {\n            if (v.role === 'assistant') {\n              return v.functionCalls?.find((f) => f.id === chat.functionId);\n            }\n            return undefined;\n          })\n          .filter((v) => v !== undefined);\n\n        const call = createToolCall(functionCalls)?.at(0);\n\n        if (!call) {\n          throw new Error('Function call not found');\n        }\n\n        const outputs = [{ result: chat.result }];\n        return {\n          role: 'TOOL' as const,\n          tool_results: [\n            {\n              call,\n              outputs,\n            },\n          ],\n        };\n      }\n      default:\n        throw new Error('Unknown role');\n    }\n  });\n}\nfunction createToolCall(\n  functionCalls: Readonly<\n    Extract<\n      AxChatRequest['chatPrompt'][0],\n      { role: 'assistant' }\n    >['functionCalls']\n  >\n) {\n  return functionCalls?.map((v) => {\n    const parameters =\n      typeof v.function.params === 'string'\n        ? JSON.parse(v.function.params)\n        : v.function.params;\n    return { name: v.function.name, parameters };\n  });\n}\n", "/**\n * DeepSeek: Models for text generation\n */\nexport enum AxAIDeepSeekModel {\n  DeepSeekChat = 'deepseek-chat',\n  DeepSeekCoder = 'deepseek-coder',\n  DeepSeekReasoner = 'deepseek-reasoner',\n}\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIDeepSeekModel } from './types.js';\n\nexport const axModelInfoDeepSeek: AxModelInfo[] = [\n  {\n    name: AxAIDeepSeekModel.DeepSeekChat,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.27,\n    completionTokenCostPer1M: 1.1,\n  },\n  {\n    name: AxAIDeepSeekModel.DeepSeekReasoner,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.55,\n    completionTokenCostPer1M: 2.19,\n  },\n];\n", "import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nimport { axModelInfoDeepSeek } from './info.js';\nimport { AxAIDeepSeekModel } from './types.js';\n\ntype DeepSeekConfig = AxAIOpenAIConfig<AxAIDeepSeekModel, undefined>;\n\nexport const axAIDeepSeekDefaultConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekChat,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIDeepSeekCodeConfig = (): DeepSeekConfig =>\n  structuredClone({\n    model: AxAIDeepSeekModel.DeepSeekCoder,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport type AxAIDeepSeekArgs<TModelKey> = AxAIOpenAIArgs<\n  'deepseek',\n  AxAIDeepSeekModel,\n  undefined,\n  TModelKey\n>;\n\nexport class AxAIDeepSeek<TModelKey> extends AxAIOpenAIBase<\n  AxAIDeepSeekModel,\n  undefined,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIDeepSeekArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('DeepSeek API key not set');\n    }\n    const Config = {\n      ...axAIDeepSeekDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoDeepSeek, ...(modelInfo ?? [])];\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.deepseek.com',\n      modelInfo,\n      supportFor: {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: false,\n        hasShowThoughts: false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      models,\n    });\n\n    super.setName('DeepSeek');\n  }\n}\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIGoogleGeminiModel {\n  Gemini25Pro = 'gemini-2.5-pro',\n  Gemini25Flash = 'gemini-2.5-flash',\n  Gemini25FlashLite = 'gemini-2.5-flash-lite',\n  Gemini20Flash = 'gemini-2.0-flash',\n  Gemini20FlashLite = 'gemini-2.0-flash-lite',\n  Gemini1Pro = 'gemini-1.0-pro',\n  Gemini15Flash = 'gemini-1.5-flash',\n  Gemini15Flash002 = 'gemini-1.5-flash-002',\n  Gemini15Flash8B = 'gemini-1.5-flash-8b',\n  Gemini15Pro = 'gemini-1.5-pro',\n}\n\nexport enum AxAIGoogleGeminiEmbedModel {\n  GeminiEmbedding = 'gemini-embedding-exp',\n  TextEmbeddingLarge = 'text-embedding-large-exp-03-07',\n  TextEmbedding004 = 'text-embedding-004',\n  TextEmbedding005 = 'text-embedding-005',\n}\n\nexport enum AxAIGoogleGeminiSafetyCategory {\n  HarmCategoryHarassment = 'HARM_CATEGORY_HARASSMENT',\n  HarmCategoryHateSpeech = 'HARM_CATEGORY_HATE_SPEECH',\n  HarmCategorySexuallyExplicit = 'HARM_CATEGORY_SEXUALLY_EXPLICIT',\n  HarmCategoryDangerousContent = 'HARM_CATEGORY_DANGEROUS_CONTENT',\n}\n\nexport enum AxAIGoogleGeminiSafetyThreshold {\n  BlockNone = 'BLOCK_NONE',\n  BlockOnlyHigh = 'BLOCK_ONLY_HIGH',\n  BlockMediumAndAbove = 'BLOCK_MEDIUM_AND_ABOVE',\n  BlockLowAndAbove = 'BLOCK_LOW_AND_ABOVE',\n  BlockDefault = 'HARM_BLOCK_THRESHOLD_UNSPECIFIED',\n}\n\nexport enum AxAIGoogleGeminiEmbedTypes {\n  SemanticSimilarity = 'SEMANTIC_SIMILARITY',\n  Classification = 'CLASSIFICATION',\n  Clustering = 'CLUSTERING',\n  RetrievalDocument = 'RETRIEVAL_DOCUMENT',\n  RetrievalQuery = 'RETRIEVAL_QUERY',\n  QuestionAnswering = 'QUESTION_ANSWERING',\n  FactVerification = 'FACT_VERIFICATION',\n  CodeRetrievalQuery = 'CODE_RETRIEVAL_QUERY',\n}\n\nexport type AxAIGoogleGeminiContent = {\n  role: 'user' | 'model';\n  parts: AxAIGoogleGeminiContentPart[];\n};\n\n// Part type with common fields intersected with a union of data fields\nexport type AxAIGoogleGeminiContentPart = {\n  thought?: boolean;\n  metadata?: { videoMetadata: object };\n} & (\n  | { text: string }\n  | {\n      inlineData: {\n        mimeType: string;\n        data: string;\n      };\n    }\n  | {\n      functionCall: {\n        name: string;\n        args: object;\n      };\n    }\n  | {\n      functionResponse: {\n        name: string;\n        response: object;\n      };\n    }\n  | {\n      fileData: {\n        mimeType: string;\n        fileUri: string;\n      };\n    }\n  | { executableCode: object }\n  | { codeExecutionResult: object }\n);\n\nexport type AxAIGoogleGeminiToolFunctionDeclaration = {\n  name: string;\n  description?: string;\n  parameters?: object;\n};\n\nexport type AxAIGoogleGeminiToolGoogleSearchRetrieval = {\n  dynamic_retrieval_config: {\n    mode?: 'MODE_DYNAMIC';\n    dynamic_threshold?: number;\n  };\n};\n\nexport type AxAIGoogleGeminiTool = {\n  function_declarations?: AxAIGoogleGeminiToolFunctionDeclaration[];\n  code_execution?: object;\n  google_search_retrieval?: AxAIGoogleGeminiToolGoogleSearchRetrieval;\n  google_search?: object;\n  url_context?: object;\n};\n\nexport type AxAIGoogleGeminiToolConfig = {\n  function_calling_config: {\n    mode: 'ANY' | 'NONE' | 'AUTO';\n    allowed_function_names?: string[];\n  };\n};\n\nexport type AxAIGoogleGeminiGenerationConfig = {\n  temperature?: number;\n  topP?: number;\n  topK?: number;\n  frequencyPenalty?: number;\n  candidateCount?: number;\n  maxOutputTokens?: number;\n  stopSequences?: readonly string[];\n  responseMimeType?: string;\n  thinkingConfig?: {\n    thinkingBudget?: number;\n    includeThoughts?: boolean;\n  };\n};\n\nexport type AxAIGoogleGeminiSafetySettings = {\n  category: AxAIGoogleGeminiSafetyCategory;\n  threshold: AxAIGoogleGeminiSafetyThreshold;\n}[];\n\nexport type AxAIGoogleGeminiChatRequest = {\n  contents: AxAIGoogleGeminiContent[];\n  tools?: AxAIGoogleGeminiTool[];\n  toolConfig?: AxAIGoogleGeminiToolConfig;\n  systemInstruction?: AxAIGoogleGeminiContent;\n  generationConfig: AxAIGoogleGeminiGenerationConfig;\n  safetySettings?: AxAIGoogleGeminiSafetySettings;\n};\n\nexport type AxAIGoogleGeminiChatResponse = {\n  candidates: {\n    content: AxAIGoogleGeminiContent;\n\n    finishReason:\n      | 'STOP'\n      | 'MAX_TOKENS'\n      | 'SAFETY'\n      | 'RECITATION'\n      | 'OTHER'\n      | 'BLOCKLIST'\n      | 'PROHIBITED_CONTENT'\n      | 'SPII'\n      | 'MALFORMED_FUNCTION_CALL'\n      | 'UNEXPECTED_TOOL_CALL'\n      | 'FINISH_REASON_UNSPECIFIED';\n    citationMetadata: {\n      citations: {\n        startIndex: number;\n        endIndex: number;\n        uri: string;\n        title: string;\n        license: string;\n        publicationDate: {\n          year: number;\n          month: number;\n          day: number;\n        };\n      }[];\n    };\n  }[];\n  usageMetadata: {\n    promptTokenCount: number;\n    candidatesTokenCount: number;\n    totalTokenCount: number;\n    thoughtsTokenCount: number;\n  };\n};\n\nexport type AxAIGoogleGeminiChatResponseDelta = AxAIGoogleGeminiChatResponse;\n\nexport type AxAIGoogleGeminiThinkingConfig = {\n  thinkingTokenBudget?: number;\n  includeThoughts?: boolean;\n};\n\nexport type AxAIGoogleGeminiThinkingTokenBudgetLevels = {\n  minimal?: number;\n  low?: number;\n  medium?: number;\n  high?: number;\n  highest?: number;\n};\n\n/**\n * AxAIGoogleGeminiConfig: Configuration options for Google Gemini API\n */\nexport type AxAIGoogleGeminiConfig = AxModelConfig & {\n  model: AxAIGoogleGeminiModel;\n  embedModel?: AxAIGoogleGeminiEmbedModel;\n  safetySettings?: AxAIGoogleGeminiSafetySettings;\n  embedType?: AxAIGoogleGeminiEmbedTypes;\n  dimensions?: number;\n  autoTruncate?: boolean;\n  thinking?: AxAIGoogleGeminiThinkingConfig;\n  thinkingTokenBudgetLevels?: AxAIGoogleGeminiThinkingTokenBudgetLevels;\n  urlContext?: string;\n};\n\n/**\n * AxAIGoogleGeminiEmbedRequest: Structure for making an embedding request to the Google Gemini API.\n */\nexport type AxAIGoogleGeminiBatchEmbedRequest = {\n  requests: {\n    model: string;\n    content: {\n      parts: { text: string }[];\n    };\n  }[];\n};\n\n/**\n * AxAIGoogleGeminiEmbedResponse: Structure for handling responses from the Google Gemini API embedding requests.\n */\nexport type AxAIGoogleGeminiBatchEmbedResponse = {\n  embeddings: {\n    values: number[];\n  }[];\n};\n\n/**\n * AxAIGoogleVertexBatchEmbedRequest: Structure for making an embedding request to the Google Vertex API.\n */\nexport type AxAIGoogleVertexBatchEmbedRequest = {\n  instances: {\n    content: string;\n    task_type?: AxAIGoogleGeminiEmbedTypes;\n  }[];\n  parameters: {\n    autoTruncate?: boolean;\n    outputDimensionality?: number;\n  };\n};\n\n/**\n * AxAIGoogleVertexBatchEmbedResponse: Structure for handling responses from the Google Vertex API embedding requests.\n */\nexport type AxAIGoogleVertexBatchEmbedResponse = {\n  predictions: {\n    embeddings: {\n      values: number[];\n    };\n  }[];\n};\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIGoogleGeminiModel } from './types.js';\n\n/**\n * AxAIGoogleGemini: Model information\n */\nexport const axModelInfoGoogleGemini: AxModelInfo[] = [\n  {\n    name: AxAIGoogleGeminiModel.Gemini25Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 2.5,\n    completionTokenCostPer1M: 15.0,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini25Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 15.0,\n    completionTokenCostPer1M: 3.5,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini25FlashLite,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.1,\n    completionTokenCostPer1M: 0.4,\n    hasThinkingBudget: true,\n    hasShowThoughts: true,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini20Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.01,\n    completionTokenCostPer1M: 0.4,\n  },\n\n  {\n    name: AxAIGoogleGeminiModel.Gemini20FlashLite,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.0,\n    completionTokenCostPer1M: 0.0,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.075,\n    completionTokenCostPer1M: 0.3,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Flash8B,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.0375,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini15Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 1.25,\n    completionTokenCostPer1M: 5.0,\n  },\n  {\n    name: AxAIGoogleGeminiModel.Gemini1Pro,\n    currency: 'usd',\n    characterIsToken: false,\n    promptTokenCostPer1M: 0.5,\n    completionTokenCostPer1M: 1.5,\n  },\n];\n", "import { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAPI } from '../../util/apicall.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport { randomUUID } from '../../util/crypto.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\nimport { axModelInfoGoogleGemini } from './info.js';\nimport {\n  type AxAIGoogleGeminiBatchEmbedRequest,\n  type AxAIGoogleGeminiBatchEmbedResponse,\n  type AxAIGoogleGeminiChatRequest,\n  type AxAIGoogleGeminiChatResponse,\n  type AxAIGoogleGeminiChatResponseDelta,\n  type AxAIGoogleGeminiConfig,\n  type AxAIGoogleGeminiContent,\n  type AxAIGoogleGeminiContentPart,\n  AxAIGoogleGeminiEmbedModel,\n  type AxAIGoogleGeminiGenerationConfig,\n  AxAIGoogleGeminiModel,\n  AxAIGoogleGeminiSafetyCategory,\n  type AxAIGoogleGeminiSafetySettings,\n  AxAIGoogleGeminiSafetyThreshold,\n  type AxAIGoogleVertexBatchEmbedRequest,\n  type AxAIGoogleVertexBatchEmbedResponse,\n} from './types.js';\n\n/**\n * Clean function schema for Gemini API compatibility by removing unsupported fields\n * Gemini doesn't support: additionalProperties, default, optional, maximum, oneOf, anyOf\n */\nconst cleanSchemaForGemini = (schema: any): any => {\n  if (!schema || typeof schema !== 'object') {\n    return schema;\n  }\n\n  const cleaned = { ...schema };\n\n  // Remove unsupported fields\n  delete cleaned.additionalProperties;\n  delete cleaned.default;\n  delete cleaned.optional;\n  delete cleaned.maximum;\n  delete cleaned.oneOf;\n  delete cleaned.anyOf;\n\n  // Recursively clean properties\n  if (cleaned.properties && typeof cleaned.properties === 'object') {\n    cleaned.properties = Object.fromEntries(\n      Object.entries(cleaned.properties).map(([key, value]) => [\n        key,\n        cleanSchemaForGemini(value),\n      ])\n    );\n  }\n\n  // Recursively clean items (for arrays)\n  if (cleaned.items) {\n    cleaned.items = cleanSchemaForGemini(cleaned.items);\n  }\n\n  return cleaned;\n};\n\nconst safetySettings: AxAIGoogleGeminiSafetySettings = [\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHarassment,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryHateSpeech,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategorySexuallyExplicit,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n  {\n    category: AxAIGoogleGeminiSafetyCategory.HarmCategoryDangerousContent,\n    threshold: AxAIGoogleGeminiSafetyThreshold.BlockNone,\n  },\n];\n\n/**\n * AxAIGoogleGemini: Default Model options for text generation\n */\nexport const axAIGoogleGeminiDefaultConfig = (): AxAIGoogleGeminiConfig =>\n  structuredClone<AxAIGoogleGeminiConfig>({\n    model: AxAIGoogleGeminiModel.Gemini25Flash,\n    embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding005,\n    safetySettings,\n    thinkingTokenBudgetLevels: {\n      minimal: 200,\n      low: 800,\n      medium: 5000,\n      high: 10000,\n      highest: 24500,\n    },\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIGoogleGeminiDefaultCreativeConfig =\n  (): AxAIGoogleGeminiConfig =>\n    structuredClone<AxAIGoogleGeminiConfig>({\n      model: AxAIGoogleGeminiModel.Gemini20Flash,\n      embedModel: AxAIGoogleGeminiEmbedModel.TextEmbedding005,\n      safetySettings,\n      thinkingTokenBudgetLevels: {\n        minimal: 200,\n        low: 800,\n        medium: 5000,\n        high: 10000,\n        highest: 24500,\n      },\n      ...axBaseAIDefaultCreativeConfig(),\n    });\n\nexport interface AxAIGoogleGeminiOptionsTools {\n  codeExecution?: boolean;\n  googleSearchRetrieval?: {\n    mode?: 'MODE_DYNAMIC';\n    dynamicThreshold?: number;\n  };\n  googleSearch?: boolean;\n  urlContext?: boolean;\n}\n\nexport interface AxAIGoogleGeminiArgs<TModelKey> {\n  name: 'google-gemini';\n  apiKey?: string | (() => Promise<string>);\n  projectId?: string;\n  region?: string;\n  endpointId?: string;\n  config?: Readonly<Partial<AxAIGoogleGeminiConfig>>;\n  options?: Readonly<AxAIServiceOptions & AxAIGoogleGeminiOptionsTools>;\n  models?: AxAIInputModelList<\n    AxAIGoogleGeminiModel,\n    AxAIGoogleGeminiEmbedModel,\n    TModelKey\n  >;\n  modelInfo?: AxModelInfo[];\n}\n\nclass AxAIGoogleGeminiImpl\n  implements\n    AxAIServiceImpl<\n      AxAIGoogleGeminiModel,\n      AxAIGoogleGeminiEmbedModel,\n      AxAIGoogleGeminiChatRequest,\n      AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n      AxAIGoogleGeminiChatResponse,\n      AxAIGoogleGeminiChatResponseDelta,\n      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private config: AxAIGoogleGeminiConfig,\n    private isVertex: boolean,\n    private endpointId?: string,\n    private apiKey?: string | (() => Promise<string>),\n    private options?: AxAIGoogleGeminiArgs<any>['options']\n  ) {\n    if (!this.isVertex && this.config.autoTruncate) {\n      throw new Error('Auto truncate is not supported for GoogleGemini');\n    }\n  }\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq = async (\n    req: Readonly<AxInternalChatRequest<AxAIGoogleGeminiModel>>,\n    config: Readonly<AxAIServiceOptions>\n  ): Promise<[AxAPI, AxAIGoogleGeminiChatRequest]> => {\n    const model = req.model;\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    let apiConfig: AxAPI;\n    if (this.endpointId) {\n      apiConfig = {\n        name: stream\n          ? `/${this.endpointId}:streamGenerateContent?alt=sse`\n          : `/${this.endpointId}:generateContent`,\n      };\n    } else {\n      apiConfig = {\n        name: stream\n          ? `/models/${model}:streamGenerateContent?alt=sse`\n          : `/models/${model}:generateContent`,\n      };\n    }\n\n    if (!this.isVertex) {\n      const pf = stream ? '&' : '?';\n      const keyValue =\n        typeof this.apiKey === 'function' ? await this.apiKey() : this.apiKey;\n      apiConfig.name += `${pf}key=${keyValue}`;\n    }\n\n    const systemPrompts = req.chatPrompt\n      .filter((p) => p.role === 'system')\n      .map((p) => p.content);\n\n    const systemInstruction =\n      systemPrompts.length > 0\n        ? {\n            role: 'user' as const,\n            parts: [{ text: systemPrompts.join(' ') }],\n          }\n        : undefined;\n\n    const contents: AxAIGoogleGeminiContent[] = req.chatPrompt\n      .filter((p) => p.role !== 'system')\n      .map((msg, i) => {\n        switch (msg.role) {\n          case 'user': {\n            const parts: AxAIGoogleGeminiContentPart[] = Array.isArray(\n              msg.content\n            )\n              ? msg.content.map((c, i) => {\n                  switch (c.type) {\n                    case 'text':\n                      return { text: c.text };\n                    case 'image':\n                      return {\n                        inlineData: { mimeType: c.mimeType, data: c.image },\n                      };\n                    default:\n                      throw new Error(\n                        `Chat prompt content type not supported (index: ${i})`\n                      );\n                  }\n                })\n              : [{ text: msg.content }];\n            return {\n              role: 'user' as const,\n              parts,\n            };\n          }\n\n          case 'assistant': {\n            let parts: AxAIGoogleGeminiContentPart[] = [];\n\n            if (msg.functionCalls) {\n              parts = msg.functionCalls.map((f) => {\n                const args =\n                  typeof f.function.params === 'string'\n                    ? JSON.parse(f.function.params)\n                    : f.function.params;\n                return {\n                  functionCall: {\n                    name: f.function.name,\n                    args: args,\n                  },\n                };\n              });\n\n              if (!parts) {\n                throw new Error('Function call is empty');\n              }\n\n              return {\n                role: 'model' as const,\n                parts,\n              };\n            }\n\n            if (!msg.content) {\n              throw new Error('Assistant content is empty');\n            }\n\n            parts = [{ text: msg.content }];\n            return {\n              role: 'model' as const,\n              parts,\n            };\n          }\n\n          case 'function': {\n            if (!('functionId' in msg)) {\n              throw new Error(`Chat prompt functionId is empty (index: ${i})`);\n            }\n            const parts: AxAIGoogleGeminiContentPart[] = [\n              {\n                functionResponse: {\n                  name: msg.functionId,\n                  response: { result: msg.result },\n                },\n              },\n            ];\n\n            return {\n              role: 'user' as const,\n              parts,\n            };\n          }\n\n          default:\n            throw new Error(\n              `Invalid role: ${JSON.stringify(msg)} (index: ${i})`\n            );\n        }\n      });\n\n    let tools: AxAIGoogleGeminiChatRequest['tools'] | undefined = [];\n\n    if (req.functions && req.functions.length > 0) {\n      // Clean function schemas for Gemini compatibility\n      const cleanedFunctions = req.functions.map((fn) => ({\n        ...fn,\n        parameters: fn.parameters\n          ? cleanSchemaForGemini(fn.parameters)\n          : undefined,\n      }));\n      tools.push({ function_declarations: cleanedFunctions });\n    }\n\n    if (this.options?.codeExecution) {\n      tools.push({ code_execution: {} });\n    }\n\n    if (this.options?.googleSearchRetrieval) {\n      tools.push({\n        google_search_retrieval: {\n          dynamic_retrieval_config: this.options.googleSearchRetrieval,\n        },\n      });\n    }\n\n    if (this.options?.googleSearch) {\n      tools.push({ google_search: {} });\n    }\n\n    if (this.options?.urlContext) {\n      tools.push({ url_context: {} });\n    }\n\n    if (tools.length === 0) {\n      tools = undefined;\n    }\n\n    let toolConfig:\n      | {\n          function_calling_config: {\n            mode: 'NONE' | 'AUTO' | 'ANY';\n            allowedFunctionNames?: string[];\n          };\n        }\n      | undefined;\n\n    if (req.functionCall) {\n      if (req.functionCall === 'none') {\n        toolConfig = { function_calling_config: { mode: 'NONE' as const } };\n      } else if (req.functionCall === 'auto') {\n        toolConfig = { function_calling_config: { mode: 'AUTO' as const } };\n      } else if (req.functionCall === 'required') {\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n        };\n      } else {\n        const allowedFunctionNames = req.functionCall.function?.name\n          ? {\n              allowedFunctionNames: [req.functionCall.function.name],\n            }\n          : {};\n        toolConfig = {\n          function_calling_config: { mode: 'ANY' as const },\n          ...allowedFunctionNames,\n        };\n      }\n    } else if (tools && tools.length > 0) {\n      toolConfig = { function_calling_config: { mode: 'AUTO' as const } };\n    }\n\n    const thinkingConfig: AxAIGoogleGeminiGenerationConfig['thinkingConfig'] =\n      {};\n\n    if (this.config.thinking?.includeThoughts) {\n      thinkingConfig.includeThoughts = true;\n    }\n\n    if (this.config.thinking?.thinkingTokenBudget) {\n      thinkingConfig.thinkingBudget = this.config.thinking.thinkingTokenBudget;\n    }\n\n    // Then, override based on prompt-specific config\n    if (config?.thinkingTokenBudget) {\n      //The thinkingBudget must be an integer in the range 0 to 24576\n      const levels = this.config.thinkingTokenBudgetLevels;\n\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          thinkingConfig.thinkingBudget = 0; // Explicitly set to 0\n          thinkingConfig.includeThoughts = false; // When thinkingTokenBudget is 'none', disable showThoughts\n          break;\n        case 'minimal':\n          thinkingConfig.thinkingBudget = levels?.minimal ?? 200;\n          break;\n        case 'low':\n          thinkingConfig.thinkingBudget = levels?.low ?? 800;\n          break;\n        case 'medium':\n          thinkingConfig.thinkingBudget = levels?.medium ?? 5000;\n          break;\n        case 'high':\n          thinkingConfig.thinkingBudget = levels?.high ?? 10000;\n          break;\n        case 'highest':\n          thinkingConfig.thinkingBudget = levels?.highest ?? 24500;\n          break;\n      }\n    }\n\n    if (config?.showThoughts !== undefined) {\n      // Only override includeThoughts if thinkingTokenBudget is not 'none'\n      if (config?.thinkingTokenBudget !== 'none') {\n        thinkingConfig.includeThoughts = config.showThoughts;\n      }\n    }\n\n    const generationConfig: AxAIGoogleGeminiGenerationConfig = {\n      maxOutputTokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      topP: req.modelConfig?.topP ?? this.config.topP,\n      topK: req.modelConfig?.topK ?? this.config.topK,\n      frequencyPenalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      candidateCount: 1,\n      stopSequences:\n        req.modelConfig?.stopSequences ?? this.config.stopSequences,\n      responseMimeType: 'text/plain',\n\n      ...(Object.keys(thinkingConfig).length > 0 ? { thinkingConfig } : {}),\n    };\n\n    const safetySettings = this.config.safetySettings;\n\n    const reqValue: AxAIGoogleGeminiChatRequest = {\n      contents,\n      tools,\n      toolConfig,\n      systemInstruction,\n      generationConfig,\n      safetySettings,\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createEmbedReq = async (\n    req: Readonly<AxInternalEmbedRequest<AxAIGoogleGeminiEmbedModel>>\n  ): Promise<\n    [\n      AxAPI,\n      AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n    ]\n  > => {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    let apiConfig: AxAPI;\n    let reqValue:\n      | AxAIGoogleGeminiBatchEmbedRequest\n      | AxAIGoogleVertexBatchEmbedRequest;\n\n    if (this.isVertex) {\n      if (this.endpointId) {\n        apiConfig = {\n          name: `/${this.endpointId}:predict`,\n        };\n      } else {\n        apiConfig = {\n          name: `/models/${model}:predict`,\n        };\n      }\n\n      reqValue = {\n        instances: req.texts.map((text) => ({\n          content: text,\n          ...(this.config.embedType && { taskType: this.config.embedType }),\n        })),\n        parameters: {\n          autoTruncate: this.config.autoTruncate,\n          outputDimensionality: this.config.dimensions,\n        },\n      };\n    } else {\n      const keyValue =\n        typeof this.apiKey === 'function' ? this.apiKey() : this.apiKey;\n      apiConfig = {\n        name: `/models/${model}:batchEmbedContents?key=${keyValue}`,\n      };\n\n      reqValue = {\n        requests: req.texts.map((text) => ({\n          model: `models/${model}`,\n          content: { parts: [{ text }] },\n          outputDimensionality: this.config.dimensions,\n          ...(this.config.embedType && { taskType: this.config.embedType }),\n        })),\n      };\n    }\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponse>\n  ): AxChatResponse => {\n    const results: AxChatResponseResult[] = resp.candidates?.map(\n      (candidate) => {\n        const result: AxChatResponseResult = { index: 0 };\n\n        switch (candidate.finishReason) {\n          case 'MAX_TOKENS':\n            result.finishReason = 'length';\n            break;\n          case 'STOP':\n            result.finishReason = 'stop';\n            break;\n          case 'SAFETY':\n            throw new AxAIRefusalError(\n              'Content was blocked due to safety settings',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'RECITATION':\n            throw new AxAIRefusalError(\n              'Content was blocked due to recitation policy',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'MALFORMED_FUNCTION_CALL':\n            throw new AxAIRefusalError(\n              'Function call was malformed and blocked',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'UNEXPECTED_TOOL_CALL':\n            throw new AxAIRefusalError(\n              'Unexpected tool call',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'FINISH_REASON_UNSPECIFIED':\n            throw new AxAIRefusalError(\n              'Finish reason unspecified',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'BLOCKLIST':\n            throw new AxAIRefusalError(\n              'Content was blocked due to blocklist',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'PROHIBITED_CONTENT':\n            throw new AxAIRefusalError(\n              'Content was blocked due to prohibited content',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'SPII':\n            throw new AxAIRefusalError(\n              'Content was blocked due to SPII',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n          case 'OTHER':\n            throw new AxAIRefusalError(\n              'Other finish reason',\n              undefined, // model not available in candidate\n              undefined // requestId not available\n            );\n        }\n\n        if (!candidate.content || !candidate.content.parts) {\n          return result;\n        }\n\n        for (const part of candidate.content.parts) {\n          if ('text' in part) {\n            if ('thought' in part && part.thought) {\n              result.thought = part.text;\n            } else {\n              result.content = part.text;\n            }\n            continue;\n          }\n\n          if ('functionCall' in part) {\n            result.functionCalls = [\n              {\n                id: randomUUID(),\n                type: 'function',\n                function: {\n                  name: part.functionCall.name,\n                  params: part.functionCall.args,\n                },\n              },\n            ];\n          }\n        }\n        return result;\n      }\n    );\n\n    if (resp.usageMetadata) {\n      this.tokensUsed = {\n        totalTokens: resp.usageMetadata.totalTokenCount,\n        promptTokens: resp.usageMetadata.promptTokenCount,\n        completionTokens: resp.usageMetadata.candidatesTokenCount,\n        thoughtsTokens: resp.usageMetadata.thoughtsTokenCount,\n      };\n    }\n    return { results };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIGoogleGeminiChatResponseDelta>\n  ): AxChatResponse => {\n    return this.createChatResp(resp);\n  };\n\n  createEmbedResp = (\n    resp: Readonly<\n      AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse\n    >\n  ): AxEmbedResponse => {\n    let embeddings: number[][];\n    if (this.isVertex) {\n      embeddings = (resp as AxAIGoogleVertexBatchEmbedResponse).predictions.map(\n        (prediction) => prediction.embeddings.values\n      );\n    } else {\n      embeddings = (resp as AxAIGoogleGeminiBatchEmbedResponse).embeddings.map(\n        (embedding) => embedding.values\n      );\n    }\n\n    return {\n      embeddings,\n    };\n  };\n}\n\n// Helper type to extract model keys from the models array\ntype ExtractModelKeys<T> = T extends readonly { key: infer K }[] ? K : never;\n\nexport class AxAIGoogleGemini<TModelKey = string> extends AxBaseAI<\n  AxAIGoogleGeminiModel,\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiChatRequest,\n  AxAIGoogleGeminiBatchEmbedRequest | AxAIGoogleVertexBatchEmbedRequest,\n  AxAIGoogleGeminiChatResponse,\n  AxAIGoogleGeminiChatResponseDelta,\n  AxAIGoogleGeminiBatchEmbedResponse | AxAIGoogleVertexBatchEmbedResponse,\n  TModelKey\n> {\n  // Static factory method for automatic type inference\n  static create<const T extends AxAIGoogleGeminiArgs<any>>(\n    options: T\n  ): T extends { models: infer M }\n    ? AxAIGoogleGemini<ExtractModelKeys<M>>\n    : AxAIGoogleGemini<string> {\n    return new AxAIGoogleGemini(options) as any;\n  }\n\n  constructor({\n    apiKey,\n    projectId,\n    region,\n    endpointId,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGoogleGeminiArgs<TModelKey>, 'name'>>) {\n    const isVertex = projectId !== undefined && region !== undefined;\n\n    let apiURL: string;\n    let headers: () => Promise<Record<string, string>>;\n\n    if (isVertex) {\n      if (!apiKey) {\n        throw new Error('GoogleGemini Vertex API key not set');\n      }\n      if (typeof apiKey !== 'function') {\n        throw new Error(\n          'GoogleGemini Vertex API key must be a function for token-based authentication'\n        );\n      }\n\n      let path: string;\n      if (endpointId) {\n        path = 'endpoints';\n      } else {\n        path = 'publishers/google';\n      }\n\n      const tld = region === 'global' ? 'aiplatform' : `${region}-aiplatform`;\n      apiURL = `https://${tld}.googleapis.com/v1/projects/${projectId}/locations/${region}/${path}`;\n      headers = async () => ({\n        Authorization: `Bearer ${typeof apiKey === 'function' ? await apiKey() : apiKey}`,\n      });\n    } else {\n      if (!apiKey) {\n        throw new Error('GoogleGemini AI API key not set');\n      }\n      apiURL = 'https://generativelanguage.googleapis.com/v1beta';\n      headers = async () => ({});\n    }\n\n    const Config = {\n      ...axAIGoogleGeminiDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIGoogleGeminiImpl(\n      Config,\n      isVertex,\n      endpointId,\n      apiKey,\n      options\n    );\n\n    modelInfo = [...axModelInfoGoogleGemini, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIGoogleGeminiModel) => {\n      const mi = getModelInfo<\n        AxAIGoogleGeminiModel,\n        AxAIGoogleGeminiEmbedModel,\n        TModelKey\n      >({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        functionCot: false,\n        media: {\n          images: {\n            supported: true,\n            formats: ['image/jpeg', 'image/png', 'image/gif', 'image/webp'],\n            maxSize: 20 * 1024 * 1024, // 20MB\n            detailLevels: ['high', 'low', 'auto'] as (\n              | 'high'\n              | 'low'\n              | 'auto'\n            )[],\n          },\n          audio: {\n            supported: true,\n            formats: ['wav', 'mp3', 'aac', 'ogg'],\n            maxDuration: 9.5 * 60, // 9.5 minutes for cloud storage\n          },\n          files: {\n            supported: true,\n            formats: [\n              'application/pdf',\n              'text/plain',\n              'text/csv',\n              'text/html',\n              'text/xml',\n            ],\n            maxSize: 2 * 1024 * 1024 * 1024, // 2GB\n            uploadMethod: 'cloud' as 'inline' | 'upload' | 'cloud' | 'none',\n          },\n          urls: {\n            supported: true,\n            webSearch: true,\n            contextFetching: true,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: mi?.hasThinkingBudget ?? false,\n        multiTurn: true,\n      };\n    };\n\n    super(aiImpl, {\n      name: 'GoogleGeminiAI',\n      apiURL,\n      headers,\n      modelInfo,\n      defaults: {\n        model: Config.model as AxAIGoogleGeminiModel,\n        embedModel: Config.embedModel as AxAIGoogleGeminiEmbedModel,\n      },\n      options,\n      supportFor,\n      models,\n    });\n  }\n}\n", "import { ColorLog } from './log.js';\n\nconst colorLog = new ColorLog();\n\nexport interface AxRateLimiterTokenUsageOptions {\n  debug?: boolean;\n}\n\nexport class AxRateLimiterTokenUsage {\n  private options?: Readonly<AxRateLimiterTokenUsageOptions>;\n  private maxTokens: number;\n  private refillRate: number;\n  private currentTokens: number;\n  private lastRefillTime: number;\n\n  constructor(\n    maxTokens: number,\n    refillRate: number,\n    options?: Readonly<AxRateLimiterTokenUsageOptions>\n  ) {\n    this.maxTokens = maxTokens;\n    this.refillRate = refillRate;\n    this.currentTokens = maxTokens;\n    this.lastRefillTime = Date.now();\n    this.options = options;\n  }\n\n  private refillTokens() {\n    const now = Date.now();\n    const timeElapsed = (now - this.lastRefillTime) / 1000; // Convert ms to seconds\n    const tokensToAdd = timeElapsed * this.refillRate;\n    this.currentTokens = Math.min(\n      this.maxTokens,\n      this.currentTokens + tokensToAdd\n    );\n    this.lastRefillTime = now;\n  }\n\n  private async waitUntilTokensAvailable(tokens: number): Promise<void> {\n    this.refillTokens();\n    if (this.currentTokens >= tokens) {\n      this.currentTokens -= tokens;\n      return;\n    }\n    if (this.options?.debug) {\n      console.log(\n        colorLog.red(\n          `Rate limiter: Waiting for ${tokens - this.currentTokens} tokens`\n        )\n      );\n    }\n    await new Promise((resolve) => setTimeout(resolve, 100)); // Wait for 100ms before checking again\n    return this.waitUntilTokensAvailable(tokens); // Recursive call\n  }\n\n  public async acquire(tokens: number): Promise<void> {\n    await this.waitUntilTokensAvailable(tokens);\n  }\n}\n\n/**\n * Example usage of the rate limiter. Limits to 5800 tokens per minute.\nconst rateLimiter = new AxRateLimiterTokenUsage(5800, 5800 / 60);\n\nconst axRateLimiterFunction = async (func, info) => {\n  const totalTokens = info.modelUsage?.totalTokens || 0;\n  await rateLimiter.acquire(totalTokens);\n  return func();\n};\n**/\n", "export enum AxAIGroqModel {\n  Llama3_8B = 'llama3-8b-8192',\n  Llama33_70B = 'llama-3.3-70b-versatile',\n  Mixtral_8x7B = 'mixtral-8x7b-32768',\n  Gemma2_9B = 'gemma2-9b-it',\n}\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIGroqModel } from './types.js';\n\n/**\n * AxAIGroq: Model information\n */\nexport const axModelInfoGroq: AxModelInfo[] = [\n  {\n    name: AxAIGroqModel.Gemma2_9B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.2,\n  },\n  {\n    name: AxAIGroqModel.Llama33_70B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.59,\n    completionTokenCostPer1M: 0.79,\n  },\n  {\n    name: AxAIGroqModel.Llama3_8B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.05,\n    completionTokenCostPer1M: 0.08,\n  },\n  {\n    name: AxAIGroqModel.Mixtral_8x7B,\n    currency: 'usd',\n    characterIsToken: true,\n    promptTokenCostPer1M: 0.24,\n    completionTokenCostPer1M: 0.24,\n  },\n];\n", "import { AxRateLimiterTokenUsage } from '../../util/rate-limit.js';\nimport { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\nimport type {\n  AxAIServiceOptions,\n  AxModelInfo,\n  AxRateLimiterFunction,\n} from '../types.js';\n\nimport { axModelInfoGroq } from './info.js';\nimport { AxAIGroqModel } from './types.js';\n\ntype AxAIGroqAIConfig = AxAIOpenAIConfig<AxAIGroqModel, undefined>;\n\nconst axAIGroqDefaultConfig = (): AxAIGroqAIConfig =>\n  structuredClone({\n    model: AxAIGroqModel.Llama33_70B,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport type AxAIGroqArgs<TModelKey> = AxAIOpenAIArgs<\n  'groq',\n  AxAIGroqModel,\n  undefined,\n  TModelKey\n> & {\n  options?: Readonly<AxAIServiceOptions> & { tokensPerMinute?: number };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIGroq<TModelKey> extends AxAIOpenAIBase<\n  AxAIGroqModel,\n  undefined,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGroqArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Groq API key not set');\n    }\n    const Config = {\n      ...axAIGroqDefaultConfig(),\n      ...config,\n    };\n\n    const Options = {\n      ...options,\n      streamingUsage: false,\n    };\n\n    modelInfo = [...axModelInfoGroq, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options: Options,\n      modelInfo,\n      apiURL: 'https://api.groq.com/openai/v1',\n      models,\n      supportFor,\n    });\n\n    super.setName('Groq');\n    this.setOptions(Options);\n  }\n\n  override setOptions = (options: Readonly<AxAIServiceOptions>) => {\n    const rateLimiter = this.newRateLimiter(options);\n    super.setOptions({ ...options, rateLimiter });\n  };\n\n  private newRateLimiter = (\n    options: Readonly<AxAIGroqArgs<any>['options']>\n  ) => {\n    if (options?.rateLimiter) {\n      return options.rateLimiter;\n    }\n\n    const tokensPerMin = options?.tokensPerMinute ?? 4800;\n    const rt = new AxRateLimiterTokenUsage(tokensPerMin, tokensPerMin / 60, {\n      debug: options?.debug,\n    });\n\n    const rtFunc: AxRateLimiterFunction = async (func, info) => {\n      const totalTokens = info.modelUsage?.tokens?.totalTokens || 0;\n      await rt.acquire(totalTokens);\n      return await func();\n    };\n\n    return rtFunc;\n  };\n}\n", "import type { AxModelInfo } from '../types.js';\n\n/**\n * HuggingFace: Model information\n */\nexport const axModelInfoHuggingFace: AxModelInfo[] = [];\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIHuggingFaceModel {\n  MetaLlama270BChatHF = 'meta-llama/Llama-2-70b-chat-hf',\n}\n\nexport type AxAIHuggingFaceConfig = AxModelConfig & {\n  model: AxAIHuggingFaceModel;\n  returnFullText?: boolean;\n  doSample?: boolean;\n  maxTime?: number;\n  useCache?: boolean;\n  waitForModel?: boolean;\n};\n\nexport type AxAIHuggingFaceRequest = {\n  model: AxAIHuggingFaceModel;\n  inputs: string;\n  parameters: {\n    max_new_tokens?: number;\n    repetition_penalty?: number;\n    temperature?: number;\n    top_p?: number;\n    top_k?: number;\n    return_full_text?: boolean;\n    num_return_sequences?: number;\n    do_sample?: boolean;\n    max_time?: number;\n  };\n  options?: {\n    use_cache?: boolean;\n    wait_for_model?: boolean;\n  };\n};\n\nexport type AxAIHuggingFaceResponse = {\n  generated_text: string;\n};\n", "import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoHuggingFace } from './info.js';\nimport {\n  type AxAIHuggingFaceConfig,\n  AxAIHuggingFaceModel,\n  type AxAIHuggingFaceRequest,\n  type AxAIHuggingFaceResponse,\n} from './types.js';\n\nexport const axAIHuggingFaceDefaultConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIHuggingFaceCreativeConfig = (): AxAIHuggingFaceConfig =>\n  structuredClone({\n    model: AxAIHuggingFaceModel.MetaLlama270BChatHF,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport interface AxAIHuggingFaceArgs<TModelKey> {\n  name: 'huggingface';\n  apiKey: string;\n  config?: Readonly<Partial<AxAIHuggingFaceConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAIHuggingFaceModel, undefined, TModelKey>;\n}\n\nclass AxAIHuggingFaceImpl\n  implements\n    AxAIServiceImpl<\n      AxAIHuggingFaceModel,\n      unknown,\n      AxAIHuggingFaceRequest,\n      unknown,\n      AxAIHuggingFaceResponse,\n      unknown,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAIHuggingFaceConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      n: config.n,\n      presencePenalty: config.presencePenalty,\n    } as AxModelConfig;\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest<AxAIHuggingFaceModel>>\n  ): [AxAPI, AxAIHuggingFaceRequest] => {\n    const model = req.model;\n\n    const functionsList = req.functions\n      ? `Functions:\\n${JSON.stringify(req.functions, null, 2)}\\n`\n      : '';\n\n    const prompt = req.chatPrompt\n      ?.map((msg) => {\n        switch (msg.role) {\n          case 'user':\n            return `User: ${msg.content}`;\n          case 'system':\n            return `System: ${msg.content}`;\n          case 'function':\n            return `Function Result: ${msg.result}`;\n          case 'assistant': {\n            const fc = msg.functionCalls\n              ?.map((fc) => {\n                const args =\n                  typeof fc.function.params === 'string'\n                    ? fc.function.params\n                    : JSON.stringify(fc.function.params);\n\n                return `${fc.function.name}(${args})`;\n              })\n              .join('\\n');\n            if (fc) {\n              return `Assistant: ${msg.content}\\n Functions:\\n${fc}`;\n            }\n            return `Assistant: ${msg.content}`;\n          }\n          default:\n            throw new Error('Unknown role');\n        }\n\n        //return `${msg.role}: ${msg.content}`;\n      })\n      .join('\\n');\n\n    const inputs = `${functionsList} ${prompt}`.trim();\n\n    const apiConfig = {\n      name: '/models',\n    };\n\n    const reqValue: AxAIHuggingFaceRequest = {\n      model,\n      inputs,\n      parameters: {\n        max_new_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n        repetition_penalty:\n          req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n        temperature: req.modelConfig?.temperature ?? this.config.temperature,\n        top_p: req.modelConfig?.topP ?? this.config.topP,\n        top_k: req.modelConfig?.topK ?? this.config.topK,\n        return_full_text: this.config.returnFullText,\n        num_return_sequences: this.config.n,\n        do_sample: this.config.doSample,\n        max_time: this.config.maxTime,\n      },\n      options: {\n        use_cache: this.config.useCache,\n        wait_for_model: this.config.waitForModel,\n      },\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (\n    resp: Readonly<AxAIHuggingFaceResponse>\n  ): AxChatResponse => {\n    return {\n      results: [\n        {\n          index: 0,\n          content: resp.generated_text,\n        },\n      ],\n    };\n  };\n}\n\nexport class AxAIHuggingFace<TModelKey> extends AxBaseAI<\n  AxAIHuggingFaceModel,\n  unknown,\n  AxAIHuggingFaceRequest,\n  unknown,\n  AxAIHuggingFaceResponse,\n  unknown,\n  unknown,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIHuggingFaceArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('HuggingFace API key not set');\n    }\n    const Config = {\n      ...axAIHuggingFaceDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIHuggingFaceImpl(Config);\n\n    super(aiImpl, {\n      name: 'HuggingFace',\n      apiURL: 'https://api-inference.huggingface.co',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo: axModelInfoHuggingFace,\n      defaults: { model: Config.model },\n      options,\n      supportFor: {\n        functions: false,\n        streaming: false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      models,\n    });\n  }\n}\n", "// cspell:ignore mistral, mixtral, codestral, nemo\n\nexport enum AxAIMistralModel {\n  Mistral7B = 'open-mistral-7b',\n  Mistral8x7B = 'open-mixtral-8x7b',\n  MistralSmall = 'mistral-small-latest',\n  MistralNemo = 'mistral-nemo-latest',\n  MistralLarge = 'mistral-large-latest',\n  Codestral = 'codestral-latest',\n  OpenCodestralMamba = 'open-codestral-mamba',\n  OpenMistralNemo = 'open-mistral-nemo-latest',\n}\n\nexport enum AxAIMistralEmbedModels {\n  MistralEmbed = 'mistral-embed',\n}\n", "// cspell:ignore mistral, mixtral, codestral, nemo\n\nimport type { AxModelInfo } from '../types.js';\n\nimport { AxAIMistralModel } from './types.js';\n\nexport const axModelInfoMistral: AxModelInfo[] = [\n  {\n    name: AxAIMistralModel.Mistral7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.Mistral8x7B,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.7,\n    completionTokenCostPer1M: 0.7,\n  },\n  {\n    name: AxAIMistralModel.MistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.15,\n    completionTokenCostPer1M: 0.15,\n  },\n  {\n    name: AxAIMistralModel.MistralSmall,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.MistralLarge,\n    currency: 'USD',\n    promptTokenCostPer1M: 2,\n    completionTokenCostPer1M: 6,\n  },\n  {\n    name: AxAIMistralModel.Codestral,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.2,\n    completionTokenCostPer1M: 0.6,\n  },\n  {\n    name: AxAIMistralModel.OpenCodestralMamba,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.25,\n    completionTokenCostPer1M: 0.25,\n  },\n  {\n    name: AxAIMistralModel.OpenMistralNemo,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.3,\n  },\n];\n", "import { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type {\n  AxAIOpenAIChatRequest,\n  AxAIOpenAIConfig,\n} from '../openai/chat_types.js';\nimport type { AxAIServiceOptions, AxModelInfo } from '../types.js';\n\nimport { axModelInfoMistral } from './info.js';\nimport { type AxAIMistralEmbedModels, AxAIMistralModel } from './types.js';\n\ntype AxAIMistralConfig = AxAIOpenAIConfig<\n  AxAIMistralModel,\n  AxAIMistralEmbedModels\n>;\n\nexport const axAIMistralDefaultConfig = (): AxAIMistralConfig =>\n  structuredClone({\n    model: AxAIMistralModel.MistralSmall,\n    ...axBaseAIDefaultConfig(),\n    topP: 1,\n  });\n\nexport const axAIMistralBestConfig = (): AxAIMistralConfig =>\n  structuredClone({\n    ...axAIMistralDefaultConfig(),\n    model: AxAIMistralModel.MistralLarge,\n  });\n\nexport type AxAIMistralChatRequest = Omit<\n  AxAIOpenAIChatRequest<AxAIMistralModel>,\n  'max_completion_tokens' | 'stream_options' | 'messages'\n> & {\n  max_tokens?: number;\n  messages: (\n    | { role: 'system'; content: string }\n    | {\n        role: 'user';\n        content:\n          | string\n          | (\n              | {\n                  type: 'text';\n                  text: string;\n                }\n              | {\n                  type: 'image_url';\n                  image_url: string;\n                }\n            )[];\n        name?: string;\n      }\n    | {\n        role: 'assistant';\n        content: string;\n        name?: string;\n        tool_calls?: {\n          type: 'function';\n          function: {\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments?: string;\n          };\n        }[];\n      }\n    | { role: 'tool'; content: string; tool_call_id: string }\n  )[];\n};\n\nexport type AxAIMistralArgs<TModelKey> = AxAIOpenAIArgs<\n  'mistral',\n  AxAIMistralModel,\n  AxAIMistralEmbedModels,\n  TModelKey\n> & {\n  options?: Readonly<AxAIServiceOptions> & { tokensPerMinute?: number };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIMistral<TModelKey> extends AxAIOpenAIBase<\n  AxAIMistralModel,\n  AxAIMistralEmbedModels,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIMistralArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Mistral API key not set');\n    }\n    const Config = {\n      ...axAIMistralDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoMistral, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n\n    // Chat request updater to add Grok's search parameters\n    const chatReqUpdater = (\n      req: Readonly<AxAIOpenAIChatRequest<AxAIMistralModel>>\n    ): AxAIMistralChatRequest => {\n      // eslint-disable-next-line @typescript-eslint/naming-convention\n      const { max_completion_tokens, messages, ...result } =\n        req as AxAIOpenAIChatRequest<AxAIMistralModel>;\n\n      return {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        ...(result as any),\n        messages: this.updateMessages(messages),\n        max_tokens: max_completion_tokens,\n      };\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.mistral.ai/v1',\n      modelInfo,\n      models,\n      supportFor,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      chatReqUpdater: chatReqUpdater as any,\n    });\n\n    super.setName('Mistral');\n  }\n\n  private updateMessages(\n    messages: AxAIOpenAIChatRequest<AxAIMistralModel>['messages']\n  ) {\n    const messagesUpdated: AxAIOpenAIChatRequest<AxAIMistralModel>['messages'] =\n      [];\n\n    if (!Array.isArray(messages)) {\n      return messages;\n    }\n\n    for (const message of messages) {\n      if (message.role === 'user' && Array.isArray(message.content)) {\n        const contentUpdated = message.content.map((item) => {\n          if (\n            typeof item === 'object' &&\n            item !== null &&\n            'image_url' in item\n          ) {\n            return {\n              type: 'image_url' as const,\n              image_url: { url: item.image_url?.url },\n            };\n          }\n          return item;\n        });\n        messagesUpdated.push({ ...message, content: contentUpdated });\n      } else {\n        messagesUpdated.push(message);\n      }\n    }\n\n    return messagesUpdated;\n  }\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\nimport { randomUUID } from '../../util/crypto.js';\n\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerData,\n  AxLoggerFunction,\n  AxModelConfig,\n  AxModelInfoWithProvider,\n} from '../types.js';\nimport type { AxAIFeatures } from '../base.js';\n\nexport type AxMockAIServiceConfig<TModelKey> = {\n  name?: string;\n  id?: string;\n  modelInfo?: Partial<AxModelInfoWithProvider>;\n  embedModelInfo?: AxModelInfoWithProvider;\n  features?: { functions?: boolean; streaming?: boolean };\n  models?: AxAIModelList<TModelKey>;\n  options?: AxAIServiceOptions;\n  chatResponse?:\n    | AxChatResponse\n    | ReadableStream<AxChatResponse>\n    | (() => Promise<AxChatResponse | ReadableStream<AxChatResponse>>)\n    | ((\n        req: Readonly<AxChatRequest<unknown>>,\n        options?: Readonly<AxAIServiceOptions>\n      ) => Promise<AxChatResponse | ReadableStream<AxChatResponse>>);\n\n  embedResponse?:\n    | AxEmbedResponse\n    | ((\n        req: Readonly<AxEmbedRequest>\n      ) => AxEmbedResponse | Promise<AxEmbedResponse>);\n  shouldError?: boolean;\n  errorMessage?: string;\n  latencyMs?: number;\n};\n\nexport class AxMockAIService<TModelKey>\n  implements AxAIService<unknown, unknown, TModelKey>\n{\n  private metrics: AxAIServiceMetrics = {\n    latency: {\n      chat: { mean: 0, p95: 0, p99: 0, samples: [] },\n      embed: { mean: 0, p95: 0, p99: 0, samples: [] },\n    },\n    errors: {\n      chat: { count: 0, rate: 0, total: 0 },\n      embed: { count: 0, rate: 0, total: 0 },\n    },\n  };\n\n  constructor(private readonly config: AxMockAIServiceConfig<TModelKey> = {}) {\n    this.config.id = this.config.id ?? randomUUID();\n  }\n  getLastUsedChatModel(): unknown {\n    return this.config.modelInfo?.name ?? 'mock-model';\n  }\n  getLastUsedEmbedModel(): unknown {\n    return this.config.embedModelInfo?.name ?? 'mock-embed-model';\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.config.modelInfo\n      ? {\n          maxTokens: this.config.modelInfo.maxTokens,\n          temperature: 0.7, // Default temperature\n          stream: this.config.features?.streaming ?? false,\n        }\n      : undefined;\n  }\n\n  getName(): string {\n    return this.config.name ?? 'mock-ai-service';\n  }\n\n  getId(): string {\n    return this.config.id ?? 'mock-ai-service-id';\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  getFeatures(_model?: string): AxAIFeatures {\n    return {\n      functions: this.config.features?.functions ?? false,\n      streaming: this.config.features?.streaming ?? false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n  }\n\n  getModelList(): AxAIModelList<TModelKey> | undefined {\n    return this.config.models;\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.metrics;\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<unknown>>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxAIServiceOptions>\n  ) {\n    if (this.config.latencyMs) {\n      await new Promise((resolve) =>\n        setTimeout(resolve, this.config.latencyMs)\n      );\n    }\n\n    if (this.config.shouldError) {\n      throw new Error(this.config.errorMessage ?? 'Mock chat error');\n    }\n\n    this.updateMetrics('chat');\n\n    if (typeof this.config.chatResponse === 'function') {\n      return await this.config.chatResponse(req);\n    }\n\n    return (\n      this.config.chatResponse ?? {\n        results: [\n          {\n            index: 0,\n            content: 'Mock response',\n            finishReason: 'stop',\n          },\n        ],\n        modelUsage: {\n          ai: this.getName(),\n          model: 'mock-model',\n          tokens: {\n            promptTokens: 10,\n            completionTokens: 5,\n            totalTokens: 15,\n          },\n        },\n      }\n    );\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    if (this.config.latencyMs) {\n      await new Promise((resolve) =>\n        setTimeout(resolve, this.config.latencyMs)\n      );\n    }\n\n    if (this.config.shouldError) {\n      throw new Error(this.config.errorMessage ?? 'Mock embed error');\n    }\n\n    this.updateMetrics('embed');\n\n    if (typeof this.config.embedResponse === 'function') {\n      return this.config.embedResponse(req);\n    }\n\n    return (\n      this.config.embedResponse ?? {\n        embeddings: [[0.1, 0.2, 0.3]],\n        modelUsage: {\n          ai: this.getName(),\n          model: 'mock-model',\n          tokens: {\n            promptTokens: 5,\n            completionTokens: 0,\n            totalTokens: 5,\n          },\n        },\n      }\n    );\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.config.options = options;\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.config.options ?? {};\n  }\n\n  getLogger(): AxLoggerFunction {\n    return (\n      this.config.options?.logger ??\n      ((message: string | AxLoggerData) => {\n        console.log(message);\n      })\n    );\n  }\n\n  private updateMetrics(type: 'chat' | 'embed'): void {\n    const latency = this.config.latencyMs ?? 0;\n    this.metrics.latency[type].samples.push(latency);\n    const samples = this.metrics.latency[type].samples;\n\n    // Update mean\n    this.metrics.latency[type].mean =\n      samples.reduce((a, b) => a + b, 0) / samples.length;\n\n    // Calculate percentiles only if we have enough samples\n    if (samples.length > 0) {\n      const sortedSamples = [...samples].sort((a, b) => a - b);\n\n      // For p95, we need at least 20 samples for meaningful calculation (1/0.05)\n      const p95Index = Math.max(0, Math.floor(sortedSamples.length * 0.95) - 1);\n      this.metrics.latency[type].p95 = sortedSamples[p95Index] ?? latency;\n\n      // For p99, we need at least 100 samples for meaningful calculation (1/0.01)\n      const p99Index = Math.max(0, Math.floor(sortedSamples.length * 0.99) - 1);\n      this.metrics.latency[type].p99 = sortedSamples[p99Index] ?? latency;\n    }\n\n    if (this.config.shouldError) {\n      this.metrics.errors[type].count++;\n      this.metrics.errors[type].total++;\n\n      // Calculate error rate against total requests, not just samples\n      const totalRequests = this.metrics.latency[type].samples.length;\n      this.metrics.errors[type].rate =\n        totalRequests > 0 ? this.metrics.errors[type].count / totalRequests : 0;\n    }\n  }\n}\n\n// Example usage:\n/*\nconst mockService = new MockAIService({\n  name: 'test-service',\n  modelInfo: {\n    name: 'test-model',\n    provider: 'test-provider',\n    promptTokenCostPer1M: 200,\n    completionTokenCostPer1M: 150,\n  },\n  features: {\n    functions: true,\n    streaming: true,\n  },\n  chatResponse: async (req) => ({\n    results: [\n      {\n        content: `Processed request with ${req.chatPrompt.length} messages`,\n        finishReason: 'stop',\n      },\n    ],\n    modelUsage: {\n      promptTokens: 20,\n      completionTokens: 10,\n      totalTokens: 30,\n    },\n  }),\n  latencyMs: 100,\n})\n*/\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n  AxModelConfig,\n} from './types.js';\nimport type { AxAIFeatures } from './base.js';\n\ntype AxAIServiceListItem<\n  TModel = unknown,\n  TEmbedModel = unknown,\n  TModelKey = string,\n> = {\n  key: TModelKey;\n  service: AxAIService<TModel, TEmbedModel, TModelKey>;\n  description: string;\n  isInternal?: boolean;\n};\n\n// Helper type to extract model keys from a service\ntype ExtractServiceModelKeys<T> = T extends AxAIService<any, any, infer K>\n  ? K\n  : T extends AxAIServiceListItem<any, any, infer K>\n    ? K\n    : never;\n\n// Helper type to extract model keys from an array of services\ntype ExtractAllModelKeys<T extends readonly any[]> = T extends readonly [\n  infer First,\n  ...infer Rest,\n]\n  ? ExtractServiceModelKeys<First> | ExtractAllModelKeys<Rest>\n  : never;\n\nexport class AxMultiServiceRouter<\n  TServices extends readonly (\n    | AxAIService\n    | AxAIServiceListItem<any, any, any>\n  )[] = readonly AxAIService[],\n  TModelKey = ExtractAllModelKeys<TServices>,\n> implements AxAIService<unknown, unknown, TModelKey>\n{\n  private options?: AxAIServiceOptions;\n  private lastUsedService?: AxAIService<unknown, unknown, TModelKey>;\n\n  private services: Map<\n    TModelKey,\n    {\n      isInternal?: boolean;\n      description: string;\n      model?: string;\n      embedModel?: string;\n      service: AxAIService<unknown, unknown, TModelKey>;\n    }\n  > = new Map();\n  /**\n   * Constructs a new multi-service router.\n   * It validates that each service provides a unique set of model keys,\n   * then builds a lookup (map) for routing the chat/embed requests.\n   */\n  constructor(services: TServices) {\n    if (services.length === 0) {\n      throw new Error('No AI services provided.');\n    }\n\n    // Determine input type based on first element (assuming homogeneous array)\n\n    for (const [index, item] of services.entries()) {\n      const isKeyBased = 'key' in item;\n\n      if (isKeyBased) {\n        if (this.services.has(item.key as TModelKey)) {\n          throw new Error(`Duplicate model key: ${item.key}`);\n        }\n\n        const { service, description, isInternal } = item;\n\n        this.services.set(item.key as TModelKey, {\n          service: service as AxAIService<unknown, unknown, TModelKey>,\n          description,\n          isInternal,\n        });\n      } else {\n        const modelList = item.getModelList() as\n          | AxAIModelList<TModelKey>\n          | undefined;\n\n        if (!modelList) {\n          throw new Error(\n            `Service ${index} \\`${item.getName()}\\` has no model list.`\n          );\n        }\n\n        for (const v of modelList) {\n          if (this.services.has(v.key)) {\n            const otherService = this.services.get(v.key)?.service;\n            throw new Error(\n              `Service ${index} \\`${item.getName()}\\` has duplicate model key: ${v.key} as service ${otherService?.getName()}`\n            );\n          }\n          if ('model' in v && typeof v.model) {\n            this.services.set(v.key, {\n              description: v.description,\n              service: item as AxAIService<unknown, unknown, TModelKey>,\n              model: v.model,\n            });\n          } else if ('embedModel' in v && v.embedModel) {\n            this.services.set(v.key, {\n              description: v.description,\n              service: item as AxAIService<unknown, unknown, TModelKey>,\n              embedModel: v.embedModel,\n            });\n          } else {\n            throw new Error(\n              `Key ${v.key} in model list for service ${index} \\`${item.getName()}\\` is missing a model or embedModel property.`\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Static factory method for type-safe multi-service router creation with automatic model key inference.\n   */\n  static create<\n    const TServices extends readonly (\n      | AxAIService\n      | AxAIServiceListItem<any, any, any>\n    )[],\n  >(\n    services: TServices\n  ): AxMultiServiceRouter<TServices, ExtractAllModelKeys<TServices>> {\n    return new AxMultiServiceRouter(services);\n  }\n  getLastUsedChatModel(): unknown | undefined {\n    return this.lastUsedService?.getLastUsedChatModel();\n  }\n  getLastUsedEmbedModel(): unknown | undefined {\n    return this.lastUsedService?.getLastUsedEmbedModel();\n  }\n  getLastUsedModelConfig(): AxModelConfig | undefined {\n    return this.lastUsedService?.getLastUsedModelConfig();\n  }\n\n  /**\n   * Delegates the chat call to the service matching the provided model key.\n   */\n  async chat(\n    req: Readonly<AxChatRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    const modelKey = req.model as TModelKey;\n    if (!modelKey) {\n      throw new Error('Model key must be specified for multi-service');\n    }\n\n    const item = this.services.get(modelKey);\n    if (!item) {\n      throw new Error(`No service found for model key: ${modelKey}`);\n    }\n\n    this.lastUsedService = item.service;\n\n    if (!item.model) {\n      const { model: _, ...reqWithoutModel } = req;\n      return await item.service.chat(reqWithoutModel, options);\n    }\n\n    return await item.service.chat({ model: modelKey, ...req }, options);\n  }\n\n  /**\n   * Delegates the embed call to the service matching the provided embed model key.\n   */\n  async embed(\n    req: Readonly<AxEmbedRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    const embedModelKey = req.embedModel as TModelKey;\n    if (!embedModelKey) {\n      throw new Error('Embed model key must be specified for multi-service');\n    }\n\n    const item = this.services.get(embedModelKey);\n    if (!item) {\n      throw new Error(`No service found for embed model key: ${embedModelKey}`);\n    }\n\n    this.lastUsedService = item.service;\n\n    if (!item.model) {\n      const { embedModel: _, ...reqWithoutEmbedModel } = req;\n      return await item.service.embed(reqWithoutEmbedModel, options);\n    }\n\n    return await item.service.embed(\n      { embedModel: embedModelKey, ...req },\n      options\n    );\n  }\n\n  /**\n   * Returns a composite ID built from the IDs of the underlying services.\n   */\n  getId(): string {\n    return `MultiServiceRouter:${Array.from(this.services.values())\n      .map((s) => s.service.getId())\n      .join(',')}`;\n  }\n\n  /**\n   * Returns the name of this router.\n   */\n  getName(): string {\n    return 'MultiServiceRouter';\n  }\n\n  /**\n   * Aggregates all available models across the underlying services.\n   */\n  getModelList(): AxAIModelList<TModelKey> {\n    return Array.from(this.services)\n      .filter(([, value]) => !value.isInternal)\n      .map(([key, v]) => {\n        if (v.model) {\n          return { key, description: v.description, model: v.model };\n        }\n        if (v.embedModel) {\n          return { key, description: v.description, embedModel: v.embedModel };\n        }\n        throw new Error(`Service ${key} has no model or embedModel`);\n      });\n  }\n\n  /**\n   * If a model key is provided, delegate to the corresponding service's features.\n   * Otherwise, returns a default feature set.\n   */\n  getFeatures(model?: TModelKey): AxAIFeatures {\n    if (model) {\n      const service = this.services.get(model);\n      if (service) {\n        return service.service.getFeatures(model);\n      }\n    }\n    return {\n      functions: false,\n      streaming: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n  }\n\n  /**\n   * Returns aggregated metrics from the underlying service.\n   * Uses the metrics from the last service that was used,\n   * or falls back to the first service if none has been used.\n   */\n  getMetrics(): AxAIServiceMetrics {\n    let serviceInstance = this.lastUsedService;\n    if (!serviceInstance) {\n      const firstServiceEntry = this.services.values().next().value;\n      if (firstServiceEntry) {\n        // Check if it's the service directly or the wrapped object\n        serviceInstance =\n          'service' in firstServiceEntry\n            ? firstServiceEntry.service\n            : firstServiceEntry;\n      }\n    }\n\n    if (!serviceInstance) {\n      throw new Error('No service available to get metrics.');\n    }\n    return serviceInstance.getMetrics();\n  }\n\n  /**\n   * Sets options on all underlying services.\n   */\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    for (const service of this.services.values()) {\n      service.service.setOptions(options);\n    }\n    this.options = options;\n  }\n\n  /**\n   * Returns the options from the last used service,\n   * or falls back to the first service if none has been used.\n   */\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.options ?? {};\n  }\n\n  /**\n   * Returns the logger from the last used service,\n   * or falls back to the first service if none has been used.\n   */\n  getLogger(): AxLoggerFunction {\n    let serviceInstance = this.lastUsedService;\n    if (!serviceInstance) {\n      const firstServiceEntry = this.services.values().next().value;\n      if (firstServiceEntry) {\n        serviceInstance = firstServiceEntry.service;\n      }\n    }\n\n    if (!serviceInstance) {\n      throw new Error('No service available to get logger.');\n    }\n    return serviceInstance.getLogger();\n  }\n\n  /**\n   * Sets a service entry for a given key. This method is intended for testing purposes.\n   * @param key - The model key\n   * @param entry - The service entry to set\n   */\n  setServiceEntry(\n    key: TModelKey,\n    entry: {\n      isInternal?: boolean;\n      description: string;\n      model?: string;\n      embedModel?: string;\n      service: AxAIService<unknown, unknown, TModelKey>;\n    }\n  ): void {\n    this.services.set(key, entry);\n  }\n}\n", "import {\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nexport type AxAIOllamaAIConfig = AxAIOpenAIConfig<string, string>;\n\nexport const axAIOllamaDefaultConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  });\n\nexport const axAIOllamaDefaultCreativeConfig = (): AxAIOllamaAIConfig =>\n  structuredClone({\n    ...axBaseAIDefaultCreativeConfig(),\n    model: 'nous-hermes2',\n    embedModel: 'all-minilm',\n  });\n\nexport type AxAIOllamaArgs<TModelKey> = AxAIOpenAIArgs<\n  'ollama',\n  string,\n  string,\n  TModelKey\n> & {\n  model?: string;\n  embedModel?: string;\n  url?: string;\n};\n\n/**\n * OllamaAI: AI Service\n */\nexport class AxAIOllama<TModelKey> extends AxAIOpenAIBase<\n  string,\n  string,\n  TModelKey\n> {\n  constructor({\n    apiKey = 'not-set',\n    url = 'http://localhost:11434/v1',\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIOllamaArgs<TModelKey>, 'name'>>) {\n    const Config = {\n      ...axAIOllamaDefaultConfig(),\n      ...config,\n    };\n    super({\n      apiKey,\n      options,\n      config: Config,\n      apiURL: url,\n      models,\n      modelInfo: [],\n      supportFor: {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: false,\n        hasShowThoughts: false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n    });\n\n    super.setName('Ollama');\n  }\n}\n", "import type {\n  AxAIOpenAIEmbedRequest,\n  AxAIOpenAIEmbedResponse,\n  AxAPI,\n} from '@ax-llm/ax/index.js';\nimport { AxAIRefusalError } from '../../util/apicall.js';\nimport type {\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\nimport type {\n  AxAIOpenAIResponsesCodeInterpreterToolCall,\n  AxAIOpenAIResponsesComputerToolCall,\n  AxAIOpenAIResponsesConfig,\n  AxAIOpenAIResponsesDefineFunctionTool,\n  AxAIOpenAIResponsesFileSearchToolCall,\n  AxAIOpenAIResponsesImageGenerationToolCall,\n  AxAIOpenAIResponsesInputContentPart,\n  AxAIOpenAIResponsesInputItem,\n  AxAIOpenAIResponsesInputMessageItem,\n  AxAIOpenAIResponsesLocalShellToolCall,\n  AxAIOpenAIResponsesMCPToolCall,\n  AxAIOpenAIResponsesOutputRefusalContentPart,\n  AxAIOpenAIResponsesOutputTextContentPart,\n  AxAIOpenAIResponsesRequest,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n  AxAIOpenAIResponsesStreamEvent,\n  AxAIOpenAIResponsesToolDefinition,\n  AxAIOpenAIResponsesWebSearchToolCall,\n  Mutable,\n  RequestFunctionDefinition,\n  ResponsesReqUpdater,\n  UserMessageContentItem,\n} from './responses_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n/**\n * Checks if the given OpenAI Responses model is a thinking/reasoning model.\n * Thinking models (o1, o3, o4 series) have different parameter restrictions.\n */\nexport const isOpenAIResponsesThinkingModel = (model: string): boolean => {\n  const thinkingModels = [\n    AxAIOpenAIResponsesModel.O1,\n    AxAIOpenAIResponsesModel.O1Mini,\n    AxAIOpenAIResponsesModel.O1Pro,\n    AxAIOpenAIResponsesModel.O3,\n    AxAIOpenAIResponsesModel.O3Mini,\n    AxAIOpenAIResponsesModel.O3Pro,\n    AxAIOpenAIResponsesModel.O4Mini,\n  ];\n  return thinkingModels.includes(model as AxAIOpenAIResponsesModel);\n};\n\nexport class AxAIOpenAIResponsesImpl<\n  TModel,\n  TEmbedModel, // Kept for interface compatibility, but not used by this impl.\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> implements\n    AxAIServiceImpl<\n      TModel,\n      TEmbedModel,\n      Readonly<AxAIOpenAIResponsesRequest<TModel>>, // ChatReq (now ResponsesReq)\n      Readonly<AxAIOpenAIEmbedRequest<TEmbedModel>>, // EmbedReq\n      Readonly<AxAIOpenAIResponsesResponse>, // ChatResp (now ResponsesResp)\n      Readonly<AxAIOpenAIResponsesResponseDelta>, // ChatRespDelta (now ResponsesRespDelta)\n      Readonly<AxAIOpenAIEmbedResponse> // EmbedResp\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(\n    private readonly config: Readonly<\n      AxAIOpenAIResponsesConfig<TModel, TEmbedModel>\n    >,\n    private readonly streamingUsage: boolean, // If /v1/responses supports include_usage for streams\n    private readonly responsesReqUpdater?: ResponsesReqUpdater<\n      TModel,\n      TResponsesReq\n    >\n  ) {}\n\n  getTokenUsage(): Readonly<AxTokenUsage> | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): Readonly<AxModelConfig> {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens, // maps to max_output_tokens\n      temperature: config.temperature,\n      // presencePenalty, frequencyPenalty are not direct params in /v1/responses\n      stopSequences: config.stopSequences, // /v1/responses uses 'truncation' or relies on item structure\n      topP: config.topP,\n      // n: config.n, // Not a direct parameter in /v1/responses\n      stream: config.stream,\n    };\n  }\n\n  private mapInternalContentToResponsesInput(\n    content: ReadonlyArray<UserMessageContentItem> // Expects an array of content items, string case handled by caller\n  ): ReadonlyArray<AxAIOpenAIResponsesInputContentPart> {\n    const mappedParts: Mutable<AxAIOpenAIResponsesInputContentPart>[] =\n      content.map((part: UserMessageContentItem) => {\n        // AxUserMessageContentItem ensures part is one of {type: text}, {type: image}, {type: audio}\n        if (part.type === 'text') {\n          return { type: 'text', text: part.text };\n        }\n        if (part.type === 'image') {\n          const url = `data:${part.mimeType};base64,${part.image}`;\n          return {\n            type: 'image_url',\n            image_url: { url, details: part.details ?? 'auto' },\n          };\n        }\n        if (part.type === 'audio') {\n          return {\n            type: 'input_audio',\n            input_audio: {\n              data: part.data,\n              format: part.format === 'wav' ? 'wav' : undefined,\n            },\n          };\n        }\n        // This should be exhaustive given AxUserMessageContentItem's definition\n        const ExhaustiveCheck: never = part;\n        throw new Error(\n          `Unsupported content part: ${JSON.stringify(ExhaustiveCheck)}`\n        );\n      });\n    return mappedParts as ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n  }\n\n  private createResponsesReqInternalInput(\n    chatPrompt: ReadonlyArray<AxChatRequest<TModel>['chatPrompt'][number]>,\n    excludeSystemMessages = false // New parameter\n  ): ReadonlyArray<AxAIOpenAIResponsesInputItem> {\n    // Map from AxChatPromptItemType roles to AxAIOpenAI /v1/responses API roles:\n    // - 'system' -> 'system' (may be skipped if excludeSystemMessages is true)\n    // - 'user' -> 'user'\n    // - 'assistant' -> 'assistant'\n    // - 'function' -> Special handling for function call outputs (different structure)\n    //\n    // Note: AxAIOpenAI's /v1/responses API also supports a 'developer' role that isn't\n    // currently mapped from our AxChatPromptItemType structure.\n\n    const items: Mutable<AxAIOpenAIResponsesInputItem>[] = [];\n    for (const msg of chatPrompt) {\n      if (excludeSystemMessages && msg.role === 'system') {\n        continue; // Skip system messages if they are handled by top-level 'instructions'\n      }\n\n      let mappedContent:\n        | string\n        | ReadonlyArray<AxAIOpenAIResponsesInputContentPart>;\n      // Type guard for content based on role\n      if (\n        msg.role === 'system' ||\n        msg.role === 'user' ||\n        (msg.role === 'assistant' && msg.content)\n      ) {\n        if (typeof msg.content === 'string') {\n          mappedContent = msg.content;\n        } else if (Array.isArray(msg.content)) {\n          // Only for user role typically\n          mappedContent = this.mapInternalContentToResponsesInput(\n            msg.content as ReadonlyArray<UserMessageContentItem>\n          );\n        } else {\n          // Handle cases where content might be undefined for assistant, or unexpected type\n          if (msg.role === 'assistant' && !msg.content && msg.functionCalls) {\n            // This is fine, assistant message can be just functionCalls\n          } else {\n            throw new Error(`Invalid content type for role ${msg.role}`);\n          }\n          mappedContent = ''; // Default or skip\n        }\n      } else if (msg.role === 'function') {\n        // Function role does not have 'content' in the same way, it has 'result'\n        mappedContent = ''; // Placeholder, not directly used for content field in function_call_output\n      } else {\n        mappedContent = ''; // Default for roles that might not have content or are handled differently\n      }\n\n      switch (msg.role) {\n        case 'system': // Will be skipped if excludeSystemMessages is true\n          items.push({\n            type: 'message',\n            role: 'system',\n            content: mappedContent as string,\n          });\n          break;\n        case 'user':\n          items.push({\n            type: 'message',\n            role: 'user',\n            content: mappedContent,\n            name: msg.name,\n          });\n          break;\n        case 'assistant':\n          if (msg.content || msg.functionCalls) {\n            // Assistant can have content, functionCalls, or both\n            const assistantMessage: Mutable<AxAIOpenAIResponsesInputMessageItem> =\n              {\n                type: 'message',\n                role: 'assistant',\n                content: '',\n              }; // Start with empty content\n            if (msg.content) {\n              assistantMessage.content = mappedContent;\n            }\n            if (msg.name) {\n              assistantMessage.name = msg.name;\n            }\n            // If only function calls, content might remain empty or not be applicable in the same way for AxAIOpenAI item\n            // AxAIOpenAI /v1/responses expects assistant messages with tool calls to be structured carefully.\n            // For now, pushing the textual content if present. Tool calls are separate items.\n            if (msg.content)\n              items.push(\n                assistantMessage as AxAIOpenAIResponsesInputMessageItem\n              );\n\n            if (msg.functionCalls) {\n              for (const call of msg.functionCalls) {\n                items.push({\n                  type: 'function_call',\n                  call_id: call.id,\n                  name: call.function.name,\n                  arguments:\n                    typeof call.function.params === 'object'\n                      ? JSON.stringify(call.function.params)\n                      : call.function.params || '',\n                });\n              }\n            }\n          }\n          break;\n        case 'function': // This is a tool result\n          items.push({\n            type: 'function_call_output',\n            call_id: msg.functionId!,\n            output: msg.result!,\n          });\n          break;\n        default: {\n          // Fix for any type\n          const invalidRole = (msg as { role: string }).role;\n          throw new Error(`Invalid role in chat prompt: ${invalidRole}`);\n        }\n      }\n    }\n    return items as ReadonlyArray<AxAIOpenAIResponsesInputItem>;\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<TModel>>,\n    config: Readonly<AxAIServiceOptions>\n  ): [Readonly<AxAPI>, Readonly<AxAIOpenAIResponsesRequest<TModel>>] {\n    const model = req.model;\n    const apiConfig: Readonly<AxAPI> = { name: '/responses' };\n\n    let instructionsFromPrompt: string | null = null;\n    let systemMessageFoundAndUsed = false;\n    if (req.chatPrompt) {\n      for (const item of req.chatPrompt) {\n        if (item.role === 'system' && typeof item.content === 'string') {\n          instructionsFromPrompt = item.content;\n          systemMessageFoundAndUsed = true;\n          break;\n        }\n      }\n    }\n\n    const finalInstructions =\n      instructionsFromPrompt ?? this.config.systemPrompt ?? null;\n\n    const tools: ReadonlyArray<AxAIOpenAIResponsesToolDefinition> | undefined =\n      req.functions?.map(\n        (\n          v: Readonly<RequestFunctionDefinition>\n        ): AxAIOpenAIResponsesDefineFunctionTool => ({\n          type: 'function' as const,\n          name: v.name,\n          description: v.description,\n          parameters: v.parameters ?? {},\n        })\n      );\n\n    // Set include field based on showThoughts option, but override if thinkingTokenBudget is 'none'\n    const includeFields: // | 'file_search_call.results'\n    'message.input_image.image_url'[] =\n      // | 'computer_call_output.output.image_url'\n      // | 'reasoning.encrypted_content'\n      // | 'code_interpreter_call.outputs'\n      [];\n\n    const isThinkingModel = isOpenAIResponsesThinkingModel(model as string);\n\n    let reasoningSummary = this.config.reasoningSummary;\n\n    if (!config?.showThoughts) {\n      reasoningSummary = undefined;\n    } else if (!reasoningSummary) {\n      reasoningSummary = 'auto';\n    }\n\n    let reasoningEffort = this.config.reasoningEffort;\n\n    // Handle thinkingTokenBudget config parameter\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          reasoningEffort = undefined;\n          break;\n        case 'minimal':\n          reasoningEffort = 'low';\n          break;\n        case 'low':\n          reasoningEffort = 'medium';\n          break;\n        case 'medium':\n        case 'high':\n        case 'highest':\n          reasoningEffort = 'high';\n          break;\n      }\n    }\n\n    const mutableReq: Mutable<AxAIOpenAIResponsesRequest<TModel>> = {\n      model,\n      input: '', // Will be set below\n      instructions: finalInstructions,\n      tools: tools?.length ? tools : undefined,\n      tool_choice:\n        req.functionCall === 'none' ||\n        req.functionCall === 'auto' ||\n        req.functionCall === 'required'\n          ? req.functionCall\n          : typeof req.functionCall === 'object' && req.functionCall.function\n            ? { type: 'function', name: req.functionCall.function.name }\n            : undefined,\n      // For thinking models, don't set these parameters as they're not supported\n      ...(isThinkingModel\n        ? {\n            max_output_tokens:\n              req.modelConfig?.maxTokens ?? this.config.maxTokens ?? undefined,\n          }\n        : {\n            temperature:\n              req.modelConfig?.temperature ??\n              this.config.temperature ??\n              undefined,\n            top_p: req.modelConfig?.topP ?? this.config.topP ?? undefined,\n            presence_penalty:\n              req.modelConfig?.presencePenalty ??\n              this.config.presencePenalty ??\n              undefined,\n            frequency_penalty:\n              req.modelConfig?.frequencyPenalty ??\n              this.config.frequencyPenalty ??\n              undefined,\n          }),\n      stream: req.modelConfig?.stream ?? this.config.stream ?? false, // Sourced from modelConfig or global config\n      // Optional fields from AxAIOpenAIResponsesRequest that need to be in Mutable for initialization\n      background: undefined,\n      include: includeFields.length > 0 ? includeFields : undefined,\n      metadata: undefined,\n      parallel_tool_calls: this.config.parallelToolCalls,\n      previous_response_id: undefined,\n      ...(reasoningEffort\n        ? {\n            reasoning: {\n              effort: reasoningEffort,\n              summary: reasoningSummary,\n            },\n          }\n        : {}),\n      service_tier: this.config.serviceTier,\n      store: this.config.store,\n      text: undefined,\n      truncation: undefined,\n      user: this.config.user,\n      seed: this.config.seed,\n    };\n\n    // Populate from this.config if properties exist on AxAIOpenAIConfig\n    if (this.config.user) mutableReq.user = this.config.user;\n    if (this.config.parallelToolCalls !== undefined)\n      mutableReq.parallel_tool_calls = this.config.parallelToolCalls;\n    if (this.config.responseFormat)\n      mutableReq.text = {\n        format: {\n          type: this.config.responseFormat as\n            | 'text'\n            | 'json_object'\n            | 'json_schema',\n        },\n      };\n    if (this.config.seed) mutableReq.seed = this.config.seed;\n    // TODO: Check AxAIOpenAIConfig for other fields like store, background, include, metadata, service_tier, truncation\n\n    const inputItems = req.chatPrompt\n      ? this.createResponsesReqInternalInput(\n          req.chatPrompt,\n          systemMessageFoundAndUsed\n        )\n      : [];\n\n    if (inputItems.length > 0) {\n      mutableReq.input = inputItems;\n    } else if (\n      req.chatPrompt &&\n      req.chatPrompt.length === 1 &&\n      req.chatPrompt[0]?.role === 'user' &&\n      req.chatPrompt[0]?.content &&\n      typeof req.chatPrompt[0].content === 'string' &&\n      !finalInstructions\n    ) {\n      // Fallback to simple string input if only one user message and no instructions\n      mutableReq.input = req.chatPrompt[0].content;\n    } else if (inputItems.length === 0 && !finalInstructions) {\n      throw new Error('Responses API request must have input or instructions.');\n    }\n\n    let currentReasoning = mutableReq.reasoning ?? {};\n    if (this.config.reasoningEffort) {\n      currentReasoning = {\n        ...currentReasoning,\n        effort: this.config.reasoningEffort,\n      };\n    }\n\n    // Handle thinkingTokenBudget config parameter\n    if (config?.thinkingTokenBudget) {\n      switch (config.thinkingTokenBudget) {\n        case 'none':\n          // When thinkingTokenBudget is 'none', remove reasoning entirely\n          currentReasoning = {};\n          break;\n        case 'minimal':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'low',\n          };\n          break;\n        case 'low':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'medium',\n          };\n          break;\n        case 'medium':\n        case 'high':\n        case 'highest':\n          currentReasoning = {\n            ...currentReasoning,\n            effort: 'high',\n          };\n          break;\n      }\n    }\n\n    if (Object.keys(currentReasoning).length > 0 && currentReasoning.effort) {\n      mutableReq.reasoning = currentReasoning;\n    } else {\n      mutableReq.reasoning = undefined; // Ensure reasoning is not sent if empty or only has non-effort keys by mistake\n    }\n\n    let finalReqToProcess: Readonly<AxAIOpenAIResponsesRequest<TModel>> =\n      mutableReq as Readonly<AxAIOpenAIResponsesRequest<TModel>>;\n\n    if (this.responsesReqUpdater) {\n      finalReqToProcess = this.responsesReqUpdater(\n        finalReqToProcess as Readonly<TResponsesReq>\n      );\n    }\n\n    return [apiConfig, finalReqToProcess];\n  }\n\n  // Create Chat Response from /v1/responses (non-streaming)\n  createChatResp(\n    resp: Readonly<AxAIOpenAIResponsesResponse>\n  ): Readonly<AxChatResponse> {\n    const { id, output, usage } = resp;\n\n    if (usage) {\n      this.tokensUsed = {\n        promptTokens: usage.prompt_tokens,\n        completionTokens: usage.completion_tokens,\n        totalTokens: usage.total_tokens,\n      };\n    }\n\n    const currentResult: Partial<AxChatResponseResult> = {};\n\n    for (const item of output ?? []) {\n      switch (item.type) {\n        case 'message':\n          currentResult.id = item.id;\n          currentResult.content = contentToText(item.content, id);\n          currentResult.finishReason =\n            item.status === 'completed' ? 'stop' : 'content_filter';\n          break;\n\n        case 'reasoning':\n          currentResult.id = item.id;\n          // Use encrypted_content if available (when showThoughts is enabled), otherwise use summary\n          if (item.encrypted_content) {\n            currentResult.thought = item.encrypted_content;\n          } else {\n            currentResult.thought = item.summary\n              .map((s: string | object) =>\n                typeof s === 'object' ? JSON.stringify(s) : s\n              )\n              .join('\\n');\n          }\n          break;\n\n        case 'file_search_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'file_search',\n                params: {\n                  queries: item.queries,\n                  results: item.results,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'web_search_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'web_search',\n                params: {\n                  queries: item.queries,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'computer_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'computer_use',\n                params: {\n                  action: item.action,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'code_interpreter_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'code_interpreter',\n                params: {\n                  code: item.code,\n                  results: item.results,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'image_generation_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'image_generation',\n                params: {\n                  result: item.result,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'local_shell_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'local_shell',\n                params: {\n                  action: item.action,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'mcp_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: 'mcp',\n                params: {\n                  name: item.name,\n                  args: item.args,\n                  serverLabel: item.server_label,\n                  output: item.output,\n                  error: item.error,\n                },\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n        case 'function_call':\n          currentResult.id = item.id;\n          currentResult.functionCalls = [\n            {\n              id: item.id,\n              type: 'function' as const,\n              function: {\n                name: item.name,\n                params: item.arguments,\n              },\n            },\n          ];\n          currentResult.finishReason = 'function_call';\n          break;\n      }\n    }\n\n    return {\n      results: [{ ...currentResult, index: 0 }],\n      remoteId: id,\n    };\n  }\n\n  // Create Chat Stream Response from /v1/responses stream events\n  createChatStreamResp(\n    streamEvent: Readonly<AxAIOpenAIResponsesResponseDelta>\n  ): Readonly<AxChatResponse> {\n    // Handle new streaming event format\n    const event = streamEvent as AxAIOpenAIResponsesStreamEvent;\n\n    // Create a basic result structure\n    const baseResult: AxChatResponseResult = {\n      index: 0,\n      id: '',\n      content: '',\n      finishReason: 'stop',\n    };\n\n    let remoteId: string | undefined;\n\n    switch (event.type) {\n      case 'response.created':\n      case 'response.in_progress':\n      case 'response.queued':\n        // Response lifecycle events - return empty content with metadata\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_res_0`;\n        break;\n\n      case 'response.output_item.added':\n        // New output item added\n        switch (event.item.type) {\n          case 'message':\n            baseResult.id = event.item.id;\n            baseResult.content = contentToText(\n              event.item.content,\n              event.item.id\n            );\n            break;\n          case 'function_call':\n            baseResult.id = event.item.id;\n            baseResult.functionCalls = [\n              {\n                id: event.item.id,\n                type: 'function' as const,\n                function: {\n                  name: event.item.name,\n                  params: event.item.arguments,\n                },\n              },\n            ];\n            break;\n          case 'file_search_call':\n            {\n              const fileSearchItem =\n                event.item as AxAIOpenAIResponsesFileSearchToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: fileSearchItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'file_search',\n                    params: {\n                      queries: fileSearchItem.queries || [],\n                      results: fileSearchItem.results?.map((r) => ({\n                        fileId: r.file_id,\n                        filename: r.filename,\n                        score: r.score,\n                        text: r.text,\n                        attributes: r.attributes,\n                      })),\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'web_search_call':\n            {\n              const webSearchItem =\n                event.item as AxAIOpenAIResponsesWebSearchToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: webSearchItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'web_search',\n                    params: {\n                      queries: webSearchItem.queries || [],\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'computer_call':\n            {\n              const computerItem =\n                event.item as AxAIOpenAIResponsesComputerToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: computerItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'computer_use',\n                    params: {\n                      action: computerItem.action || {},\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'code_interpreter_call':\n            {\n              const codeItem =\n                event.item as AxAIOpenAIResponsesCodeInterpreterToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: codeItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'code_interpreter',\n                    params: {\n                      code: codeItem.code || '',\n                      results: codeItem.results,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'image_generation_call':\n            {\n              const imageItem =\n                event.item as AxAIOpenAIResponsesImageGenerationToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: imageItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'image_generation',\n                    params: {\n                      result: imageItem.result,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'local_shell_call':\n            {\n              const shellItem =\n                event.item as AxAIOpenAIResponsesLocalShellToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: shellItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'local_shell',\n                    params: {\n                      action: shellItem.action || {},\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          case 'mcp_call':\n            {\n              const mcpItem = event.item as AxAIOpenAIResponsesMCPToolCall;\n              baseResult.id = event.item.id;\n              baseResult.functionCalls = [\n                {\n                  id: mcpItem.id,\n                  type: 'function' as const,\n                  function: {\n                    name: 'mcp',\n                    params: {\n                      name: mcpItem.name || '',\n                      args: mcpItem.args || '',\n                      serverLabel: mcpItem.server_label || '',\n                      output: mcpItem.output,\n                      error: mcpItem.error,\n                    },\n                  },\n                },\n              ];\n            }\n            break;\n          // case 'reasoning':\n          //     {\n          //         const reasoningItem =\n          //             event.item as AxAIOpenAIResponsesReasoningItem\n          //         baseResult.id = event.item.id\n          //         // Use encrypted_content if available (when showThoughts is enabled), otherwise use summary\n          //         if (reasoningItem.encrypted_content) {\n          //             baseResult.thought = reasoningItem.encrypted_content\n          //         } else if (reasoningItem.summary) {\n          //             baseResult.thought = reasoningItem.summary\n          //                 .map((s: string | object) =>\n          //                     typeof s === 'object' ? JSON.stringify(s) : s\n          //                 )\n          //                 .join('\\n')\n          //         }\n          //     }\n          //     break\n        }\n        break;\n\n      case 'response.content_part.added':\n        // Content part added - return the initial text if any\n        baseResult.id = event.item_id;\n        baseResult.content = contentToText([event.part], event.item_id);\n        break;\n\n      case 'response.output_text.delta':\n        // Text delta - return just the delta content\n        baseResult.id = event.item_id;\n        baseResult.content = event.delta;\n        break;\n\n      case 'response.output_text.done':\n        break;\n\n      case 'response.function_call_arguments.delta':\n        // Function call arguments delta - return delta with empty name\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.delta,\n            },\n          },\n        ];\n        break;\n\n      // case 'response.function_call_arguments.done':\n      //     // Function call arguments done - don't return function calls here\n      //     // The mergeFunctionCalls will handle combining name and arguments\n      //     baseResult.id = event.item_id\n      //     baseResult.finishReason = 'function_call'\n      //     break\n\n      case 'response.reasoning_summary_text.delta':\n        // Reasoning summary delta\n        baseResult.id = event.item_id;\n        baseResult.thought = event.delta;\n        break;\n\n      // case 'response.reasoning_summary_text.done':\n      //     // Reasoning summary done\n      //     baseResult.id = event.item_id\n      //     baseResult.thought = event.text\n      //     break\n\n      // File search tool events\n      case 'response.file_search_call.in_progress':\n      case 'response.file_search_call.searching':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.file_search_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      // Web search tool events\n      case 'response.web_search_call.in_progress':\n      case 'response.web_search_call.searching':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.web_search_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      // Image generation tool events\n      case 'response.image_generation_call.in_progress':\n      case 'response.image_generation_call.generating':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.image_generation_call.completed':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.image_generation_call.partial_image':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        // Could potentially add partial image data to content or a special field\n        break;\n\n      // MCP tool events\n      case 'response.mcp_call.in_progress':\n        baseResult.id = event.item_id;\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.mcp_call.arguments.delta':\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.delta,\n            },\n          },\n        ];\n        break;\n\n      case 'response.mcp_call.arguments.done':\n        baseResult.id = event.item_id;\n        baseResult.functionCalls = [\n          {\n            id: event.item_id,\n            type: 'function' as const,\n            function: {\n              name: '',\n              params: event.arguments,\n            },\n          },\n        ];\n        break;\n\n      case 'response.mcp_call.completed':\n      case 'response.mcp_call.failed':\n        // These events don't have item_id, use a generic ID\n        baseResult.id = 'mcp_call_event';\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.mcp_list_tools.in_progress':\n      case 'response.mcp_list_tools.completed':\n      case 'response.mcp_list_tools.failed':\n        // MCP list tools events don't have item_id\n        baseResult.id = 'mcp_list_tools_event';\n        baseResult.finishReason = 'function_call';\n        break;\n\n      case 'response.output_item.done':\n        // Item completion\n\n        switch (event.item.type) {\n          case 'message':\n            baseResult.id = event.item.id;\n            baseResult.finishReason =\n              event.item.status === 'completed' ? 'stop' : 'error';\n            break;\n          case 'function_call':\n          case 'file_search_call':\n          case 'web_search_call':\n          case 'computer_call':\n          case 'code_interpreter_call':\n          case 'image_generation_call':\n          case 'local_shell_call':\n          case 'mcp_call':\n            // Tool calls completed - finishReason indicates function execution needed\n            baseResult.id = event.item.id;\n            baseResult.finishReason = 'function_call';\n            break;\n          // case 'reasoning':\n          //     // Reasoning completed\n          //     baseResult.id = event.item.id\n          //     break\n        }\n        break;\n\n      case 'response.completed':\n        // Response completion - handle usage\n        if (event.response.usage) {\n          this.tokensUsed = {\n            promptTokens: event.response.usage.prompt_tokens,\n            completionTokens: event.response.usage.completion_tokens,\n            totalTokens: event.response.usage.total_tokens,\n          };\n        }\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_completed`;\n        baseResult.finishReason = 'stop';\n        break;\n\n      case 'response.failed':\n        // Response failure\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_failed`;\n        baseResult.finishReason = 'error';\n        break;\n\n      case 'response.incomplete':\n        // Response incomplete\n        remoteId = event.response.id;\n        baseResult.id = `${event.response.id}_incomplete`;\n        baseResult.finishReason = 'length';\n        break;\n\n      case 'error':\n        // Error event\n        baseResult.id = 'error';\n        baseResult.content = `Error: ${event.message}`;\n        baseResult.finishReason = 'error';\n        break;\n\n      default:\n        // For unhandled events, return empty result\n        baseResult.id = 'unknown';\n        break;\n    }\n\n    return {\n      results: [baseResult],\n      remoteId,\n    } as Readonly<AxChatResponse>;\n  }\n\n  createEmbedReq(\n    req: Readonly<AxInternalEmbedRequest<TEmbedModel>>\n  ): [AxAPI, AxAIOpenAIEmbedRequest<TEmbedModel>] {\n    const model = req.embedModel;\n\n    if (!model) {\n      throw new Error('Embed model not set');\n    }\n\n    if (!req.texts || req.texts.length === 0) {\n      throw new Error('Embed texts is empty');\n    }\n\n    const apiConfig = {\n      name: '/embeddings',\n    };\n\n    const reqValue = {\n      model: model,\n      input: req.texts,\n      dimensions: this.config.dimensions,\n    };\n\n    return [apiConfig, reqValue];\n  }\n}\n\n// const getThought = (item: AxAIOpenAIResponsesReasoningItem): string => {\n//     if (item.encrypted_content) {\n//         return item.encrypted_content\n//     }\n//     return item.summary.map((s) => s.text).join('\\n')\n// }\n\nconst contentToText = (\n  content: ReadonlyArray<\n    | AxAIOpenAIResponsesOutputTextContentPart\n    | AxAIOpenAIResponsesOutputRefusalContentPart\n  >,\n  responseId?: string\n): string => {\n  // Check for refusal content and throw exception\n  const refusalContent = content.filter((c) => c.type === 'refusal');\n  if (refusalContent.length > 0) {\n    const refusalMessage = refusalContent.map((c) => c.refusal).join('\\n');\n    throw new AxAIRefusalError(refusalMessage, undefined, responseId);\n  }\n\n  // Return only text content\n  return content\n    .filter((c) => c.type === 'output_text')\n    .map((c) => c.text)\n    .join('\\n');\n};\n", "import type { AxAIOpenAIResponsesConfig } from '@ax-llm/ax/index.js';\nimport { getModelInfo } from '../../dsp/modelinfo.js';\nimport type { AxAIFeatures } from '../base.js';\nimport { AxBaseAI } from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceOptions,\n  AxModelInfo,\n} from '../types.js';\nimport type {\n  AxAIOpenAIEmbedRequest,\n  AxAIOpenAIEmbedResponse,\n} from './chat_types.js';\nimport { AxAIOpenAIEmbedModel } from './chat_types.js';\nimport { axModelInfoOpenAIResponses } from './info.js';\nimport { AxAIOpenAIResponsesImpl } from './responses_api.js';\nimport type {\n  AxAIOpenAIResponsesRequest,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n} from './responses_types.js';\nimport { AxAIOpenAIResponsesModel } from './responses_types.js';\n\n// Helper functions to create default configurations\nexport const axAIOpenAIResponsesDefaultConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  embedModel: AxAIOpenAIEmbedModel.TextEmbeddingAda002,\n  temperature: 0.7,\n  topP: 1,\n  stream: true,\n  //   reasoningEffort: 'medium',\n});\n\nexport const axAIOpenAIResponsesBestConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIResponsesDefaultConfig(),\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  temperature: 0.5,\n});\n\nexport const axAIOpenAIResponsesCreativeConfig = (): AxAIOpenAIResponsesConfig<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel\n> => ({\n  ...axAIOpenAIResponsesDefaultConfig(),\n  model: AxAIOpenAIResponsesModel.GPT4O,\n  temperature: 0.9,\n});\n\n// Arguments for AxAIOpenAIResponsesBase constructor\ninterface AxAIOpenAIResponsesBaseArgs<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> {\n  apiKey: string;\n  config: AxAIOpenAIResponsesConfig<TModel, TEmbedModel>;\n  options?: {\n    streamingUsage?: boolean;\n  } & AxAIServiceOptions;\n  apiURL?: string;\n  modelInfo?: ReadonlyArray<AxModelInfo>;\n  models?: AxAIInputModelList<TModel, TEmbedModel, TModelKey>;\n  responsesReqUpdater?: (\n    req: Readonly<TResponsesReq>\n  ) => Readonly<TResponsesReq>;\n  supportFor?: AxAIFeatures | ((model: TModel) => AxAIFeatures);\n}\n\n/**\n * Base class for OpenAI AI services using the /v1/responses API endpoint\n */\nexport class AxAIOpenAIResponsesBase<\n  TModel,\n  TEmbedModel,\n  TModelKey,\n  TResponsesReq extends AxAIOpenAIResponsesRequest<TModel>,\n> extends AxBaseAI<\n  TModel,\n  TEmbedModel,\n  AxAIOpenAIResponsesRequest<TModel>,\n  AxAIOpenAIEmbedRequest<TEmbedModel>,\n  AxAIOpenAIResponsesResponse,\n  AxAIOpenAIResponsesResponseDelta,\n  AxAIOpenAIEmbedResponse,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = [],\n    models,\n    responsesReqUpdater,\n    supportFor = {\n      functions: true,\n      streaming: true,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    },\n  }: Readonly<\n    AxAIOpenAIResponsesBaseArgs<TModel, TEmbedModel, TModelKey, TResponsesReq>\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    const aiImpl = new AxAIOpenAIResponsesImpl<\n      TModel,\n      TEmbedModel,\n      TResponsesReq\n    >(config, options?.streamingUsage ?? true, responsesReqUpdater);\n\n    // Convert models to the expected format if needed\n    const formattedModels = models as\n      | AxAIInputModelList<TModel, TEmbedModel, TModelKey>\n      | undefined;\n\n    super(aiImpl, {\n      name: 'OpenAI',\n      apiURL: apiURL ? apiURL : 'https://api.openai.com/v1',\n      headers: async () => ({ Authorization: `Bearer ${apiKey}` }),\n      modelInfo,\n      defaults: {\n        model: config.model,\n        embedModel: config.embedModel,\n      },\n      options,\n      supportFor,\n      models: formattedModels,\n    });\n  }\n}\n\n/**\n * Ready-to-use implementation of the OpenAI Responses API client\n * This class uses OpenAI's /v1/responses API endpoint which supports text, image, and audio inputs\n */\n\nexport interface AxAIOpenAIResponsesArgs<\n  TName = 'openai-responses',\n  TModel = AxAIOpenAIResponsesModel,\n  TEmbedModel = AxAIOpenAIEmbedModel,\n  TModelKey = string,\n  TChatReq extends\n    AxAIOpenAIResponsesRequest<TModel> = AxAIOpenAIResponsesRequest<TModel>,\n> extends Omit<\n    AxAIOpenAIResponsesBaseArgs<TModel, TEmbedModel, TModelKey, TChatReq>,\n    'config' | 'supportFor' | 'modelInfo'\n  > {\n  name: TName;\n  modelInfo?: AxModelInfo[];\n  config?: Partial<\n    AxAIOpenAIResponsesBaseArgs<\n      TModel,\n      TEmbedModel,\n      TModelKey,\n      TChatReq\n    >['config']\n  >;\n}\n\nexport class AxAIOpenAIResponses<\n  TModelKey = string,\n> extends AxAIOpenAIResponsesBase<\n  AxAIOpenAIResponsesModel,\n  AxAIOpenAIEmbedModel,\n  TModelKey,\n  AxAIOpenAIResponsesRequest<AxAIOpenAIResponsesModel>\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<\n    Omit<\n      AxAIOpenAIResponsesArgs<\n        'openai-responses',\n        AxAIOpenAIResponsesModel,\n        AxAIOpenAIEmbedModel,\n        TModelKey\n      >,\n      'name'\n    >\n  >) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('OpenAI API key not set');\n    }\n\n    // Use the original OpenAI model info since it contains both chat and embed models\n    modelInfo = [...axModelInfoOpenAIResponses, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIOpenAIResponsesModel) => {\n      const mi = getModelInfo<\n        AxAIOpenAIResponsesModel,\n        AxAIOpenAIEmbedModel,\n        TModelKey\n      >({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      };\n    };\n\n    super({\n      apiKey,\n      config: {\n        ...axAIOpenAIResponsesDefaultConfig(),\n        ...config,\n      },\n      options,\n      modelInfo,\n      models,\n      supportFor,\n    });\n  }\n}\n", "import {\n  AxContentProcessingError,\n  AxMediaNotSupportedError,\n} from '../util/apicall.js';\nimport type { AxAIService } from './types.js';\n\n/**\n * Configuration options for content processing and fallback behavior\n */\nexport interface ProcessingOptions {\n  /** How to handle unsupported content types: 'error' throws, 'degrade' converts to text, 'skip' omits */\n  fallbackBehavior?: 'error' | 'degrade' | 'skip';\n  /** Service to convert images to text descriptions */\n  imageToText?: (imageData: string) => Promise<string>;\n  /** Service to convert audio to text transcriptions */\n  audioToText?: (audioData: string, format?: string) => Promise<string>;\n  /** Service to extract text from files */\n  fileToText?: (fileData: string, mimeType: string) => Promise<string>;\n  /** Service to fetch and extract text from URLs */\n  urlToText?: (url: string) => Promise<string>;\n}\n\n/**\n * Represents processed content that has been converted to text format\n */\nexport interface ProcessedContent {\n  /** Content type after processing (always 'text') */\n  type: 'text';\n  /** The processed text content */\n  text: string;\n}\n\n/**\n * Indicates what types of media content are present in a request\n */\nexport interface MediaRequirements {\n  /** Whether the content includes images */\n  hasImages: boolean;\n  /** Whether the content includes audio */\n  hasAudio: boolean;\n  /** Whether the content includes files */\n  hasFiles: boolean;\n  /** Whether the content includes URLs */\n  hasUrls: boolean;\n}\n\n/**\n * Processes content for a specific AI provider, handling unsupported media types.\n *\n * This function takes mixed content (text, images, audio, files, URLs) and transforms\n * it to formats supported by the target provider. Unsupported content types are\n * handled according to the fallback behavior:\n * - 'error': Throws AxMediaNotSupportedError\n * - 'degrade': Converts to text using fallback services or alt text\n * - 'skip': Omits the unsupported content\n *\n * @param content - The content to process (string, object, or array of content items)\n * @param provider - The target AI service provider\n * @param options - Processing options including fallback behavior and conversion services\n * @returns Promise resolving to array of processed content items (all converted to text)\n * @throws AxMediaNotSupportedError when fallbackBehavior is 'error' and content is unsupported\n * @throws AxContentProcessingError when a conversion service fails\n *\n * @example\n * ```typescript\n * const processed = await axProcessContentForProvider(\n *   [\n *     { type: 'text', text: 'Analyze this:' },\n *     { type: 'image', image: 'base64...', altText: 'Chart showing sales data' }\n *   ],\n *   textOnlyProvider,\n *   {\n *     fallbackBehavior: 'degrade',\n *     imageToText: async (data) => await visionService.describe(data)\n *   }\n * );\n * // Result: [{ type: 'text', text: 'Analyze this:' }, { type: 'text', text: 'Chart showing sales data' }]\n * ```\n */\nexport async function axProcessContentForProvider(\n  content: any,\n  provider: AxAIService,\n  options: ProcessingOptions = {}\n): Promise<ProcessedContent[]> {\n  if (typeof content === 'string') {\n    return [{ type: 'text', text: content }];\n  }\n\n  if (!Array.isArray(content)) {\n    return [{ type: 'text', text: String(content) }];\n  }\n\n  const features = provider.getFeatures();\n  const processedContent: ProcessedContent[] = [];\n\n  for (const item of content) {\n    try {\n      switch (item.type) {\n        case 'text':\n          processedContent.push({ type: 'text', text: item.text });\n          break;\n\n        case 'image':\n          if (features.media.images.supported) {\n            // Provider supports images - validate and pass through as text description\n            if (item.altText) {\n              processedContent.push({\n                type: 'text',\n                text: `[Image: ${item.altText}]`,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: '[Image content]',\n              });\n            }\n          } else if (item.altText) {\n            // Fallback to alt text\n            processedContent.push({ type: 'text', text: item.altText });\n          } else if (options.imageToText) {\n            // Use AI vision service to describe image\n            try {\n              const description = await options.imageToText(item.image);\n              processedContent.push({ type: 'text', text: description });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'image',\n                'vision analysis'\n              );\n            }\n          } else {\n            // Handle based on fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'Images',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue; // Skip this content item\n              default:\n                processedContent.push({\n                  type: 'text',\n                  text: '[Image content not supported by this provider]',\n                });\n            }\n          }\n          break;\n\n        case 'audio':\n          if (features.media.audio.supported) {\n            // Provider supports audio - use transcription if available\n            if (item.transcription) {\n              processedContent.push({\n                type: 'text',\n                text: item.transcription,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: '[Audio content]',\n              });\n            }\n          } else if (item.transcription) {\n            // Use provided transcription\n            processedContent.push({ type: 'text', text: item.transcription });\n          } else if (options.audioToText) {\n            // Use speech-to-text service\n            try {\n              const transcription = await options.audioToText(\n                item.data,\n                item.format\n              );\n              processedContent.push({ type: 'text', text: transcription });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'audio',\n                'transcription'\n              );\n            }\n          } else {\n            // Fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'Audio',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue;\n              case 'degrade':\n                processedContent.push({\n                  type: 'text',\n                  text: '[Audio content not supported by this provider]',\n                });\n            }\n          }\n          break;\n\n        case 'file':\n          if (features.media.files.supported) {\n            // Provider supports files - use extracted text if available\n            if (item.extractedText) {\n              processedContent.push({\n                type: 'text',\n                text: item.extractedText,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: `[File: ${item.filename}]`,\n              });\n            }\n          } else if (item.extractedText) {\n            processedContent.push({ type: 'text', text: item.extractedText });\n          } else if (options.fileToText) {\n            try {\n              const extractedText = await options.fileToText(\n                item.data,\n                item.mimeType\n              );\n              processedContent.push({ type: 'text', text: extractedText });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'file',\n                'text extraction'\n              );\n            }\n          } else {\n            // Fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'Files',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue;\n              default:\n                processedContent.push({\n                  type: 'text',\n                  text: `[File: ${item.filename} - content not accessible by this provider]`,\n                });\n            }\n          }\n          break;\n\n        case 'url':\n          if (features.media.urls.supported) {\n            // Provider supports URLs - use cached content if available\n            if (item.cachedContent) {\n              processedContent.push({\n                type: 'text',\n                text: item.cachedContent,\n              });\n            } else {\n              processedContent.push({\n                type: 'text',\n                text: `[Link: ${item.url}${item.title ? ` - ${item.title}` : ''}]`,\n              });\n            }\n          } else if (item.cachedContent) {\n            processedContent.push({ type: 'text', text: item.cachedContent });\n          } else if (options.urlToText) {\n            try {\n              const fetchedContent = await options.urlToText(item.url);\n              processedContent.push({ type: 'text', text: fetchedContent });\n            } catch (error) {\n              throw new AxContentProcessingError(\n                error as Error,\n                'url',\n                'content fetching'\n              );\n            }\n          } else {\n            // Fallback behavior\n            switch (options.fallbackBehavior) {\n              case 'error':\n                throw new AxMediaNotSupportedError(\n                  'URLs',\n                  provider.getName(),\n                  false\n                );\n              case 'skip':\n                continue;\n              case 'degrade':\n                processedContent.push({\n                  type: 'text',\n                  text: `[Link: ${item.url}${item.title ? ` - ${item.title}` : ''}]`,\n                });\n            }\n          }\n          break;\n\n        default:\n          // Pass through any unrecognized content types as text\n          if (typeof item === 'object' && item.text) {\n            processedContent.push({ type: 'text', text: item.text });\n          } else {\n            processedContent.push({ type: 'text', text: String(item) });\n          }\n      }\n    } catch (error) {\n      if (\n        error instanceof AxMediaNotSupportedError ||\n        error instanceof AxContentProcessingError\n      ) {\n        throw error;\n      }\n      throw new AxContentProcessingError(\n        error as Error,\n        item.type || 'unknown',\n        'content processing'\n      );\n    }\n  }\n\n  return processedContent;\n}\n\n/**\n * Analyzes a chat prompt to determine what media types it contains.\n *\n * Scans through chat messages to identify the types of media content present,\n * which can be used for provider capability matching and routing decisions.\n *\n * @param chatPrompt - Array of chat messages to analyze\n * @returns Object indicating which media types are present in the chat prompt\n *\n * @example\n * ```typescript\n * const requirements = axAnalyzeChatPromptRequirements([\n *   {\n *     role: 'user',\n *     content: [\n *       { type: 'text', text: 'Analyze this:' },\n *       { type: 'image', image: 'base64...' },\n *       { type: 'file', filename: 'report.pdf' }\n *     ]\n *   }\n * ]);\n * // Result: { hasImages: true, hasAudio: false, hasFiles: true, hasUrls: false }\n * ```\n */\nexport function axAnalyzeChatPromptRequirements(\n  chatPrompt: any[]\n): MediaRequirements {\n  let hasImages = false;\n  let hasAudio = false;\n  let hasFiles = false;\n  let hasUrls = false;\n\n  for (const message of chatPrompt) {\n    if (message.role === 'user' && Array.isArray(message.content)) {\n      for (const part of message.content) {\n        switch (part.type) {\n          case 'image':\n            hasImages = true;\n            break;\n          case 'audio':\n            hasAudio = true;\n            break;\n          case 'file':\n            hasFiles = true;\n            break;\n          case 'url':\n            hasUrls = true;\n            break;\n        }\n      }\n    }\n  }\n\n  return { hasImages, hasAudio, hasFiles, hasUrls };\n}\n\n// Note: axSelectOptimalProvider is now available in capabilities.ts for more advanced provider selection\n", "import type { AxModelConfig } from '../types.js';\n\nexport enum AxAIRekaModel {\n  RekaCore = 'reka-core',\n  RekaFlash = 'reka-flash',\n  RekaEdge = 'reka-edge',\n}\n\nexport type AxAIRekaConfig = Omit<AxModelConfig, 'topK'> & {\n  model: AxAIRekaModel;\n  stop?: readonly string[];\n  useSearchEngine?: boolean;\n};\n\nexport type AxAIRekaUsage = {\n  input_tokens: number;\n  output_tokens: number;\n};\n\nexport type AxAIRekaChatRequest = {\n  model: string;\n  messages: (\n    | {\n        role: 'user';\n        content:\n          | string\n          | {\n              type: 'text';\n              text: string;\n            }[];\n      }\n    | {\n        role: 'assistant';\n        content:\n          | string\n          | {\n              type: 'text';\n              text: string;\n            }[];\n      }\n  )[];\n  usage?: AxAIRekaUsage;\n  response_format?: { type: string };\n  max_tokens?: number;\n  temperature?: number;\n  top_p?: number;\n  top_k?: number;\n  stream?: boolean;\n  stop?: readonly string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  use_search_engine?: boolean;\n};\n\nexport type AxAIRekaChatResponse = {\n  id: string;\n  model: string;\n  responses: {\n    message: {\n      content:\n        | string\n        | {\n            type: 'text';\n            text: string;\n          };\n    };\n    finish_reason: 'stop' | 'length' | 'context';\n  }[];\n  usage?: AxAIRekaUsage;\n};\n\nexport type AxAIRekaChatResponseDelta = {\n  id: string;\n  model: string;\n  responses: {\n    chunk: AxAIRekaChatResponse['responses'][0]['message'];\n    finish_reason: AxAIRekaChatResponse['responses'][0]['finish_reason'];\n  }[];\n  usage?: AxAIRekaUsage;\n};\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIRekaModel } from './types.js';\n/**\n * OpenAI: Model information\n */\nexport const axModelInfoReka: AxModelInfo[] = [\n  {\n    name: AxAIRekaModel.RekaCore,\n    currency: 'usd',\n    promptTokenCostPer1M: 3,\n    completionTokenCostPer1M: 15,\n  },\n  {\n    name: AxAIRekaModel.RekaFlash,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.8,\n    completionTokenCostPer1M: 2,\n  },\n  {\n    name: AxAIRekaModel.RekaEdge,\n    currency: 'usd',\n    promptTokenCostPer1M: 0.4,\n    completionTokenCostPer1M: 1,\n  },\n];\n", "import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxChatResponseResult,\n  AxInternalChatRequest,\n  AxModelConfig,\n  AxModelInfo,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoReka } from './info.js';\nimport {\n  type AxAIRekaChatRequest,\n  type AxAIRekaChatResponse,\n  type AxAIRekaChatResponseDelta,\n  type AxAIRekaConfig,\n  AxAIRekaModel,\n} from './types.js';\n\nexport const axAIRekaDefaultConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIRekaBestConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    ...axAIRekaDefaultConfig(),\n    model: AxAIRekaModel.RekaCore,\n  });\n\nexport const axAIRekaCreativeConfig = (): AxAIRekaConfig =>\n  structuredClone({\n    model: AxAIRekaModel.RekaCore,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport const axAIRekaFastConfig = (): AxAIRekaConfig => ({\n  ...axAIRekaDefaultConfig(),\n  model: AxAIRekaModel.RekaFlash,\n});\n\nexport interface AxAIRekaArgs<TModelKey> {\n  name: 'reka';\n  apiKey: string;\n  apiURL?: string;\n  config?: Readonly<Partial<AxAIRekaConfig>>;\n  options?: Readonly<AxAIServiceOptions & { streamingUsage?: boolean }>;\n  modelInfo?: Readonly<AxModelInfo[]>;\n  models?: AxAIInputModelList<AxAIRekaModel, undefined, TModelKey>;\n}\n\nclass AxAIRekaImpl\n  implements\n    AxAIServiceImpl<\n      AxAIRekaModel,\n      undefined,\n      AxAIRekaChatRequest,\n      unknown,\n      AxAIRekaChatResponse,\n      AxAIRekaChatResponseDelta,\n      unknown\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n\n  constructor(private config: AxAIRekaConfig) {}\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      topP: config.topP,\n      n: config.n,\n      stream: config.stream,\n    };\n  }\n\n  createChatReq = (\n    req: Readonly<AxInternalChatRequest<AxAIRekaModel>>\n  ): [AxAPI, AxAIRekaChatRequest] => {\n    const model = req.model;\n\n    if (!req.chatPrompt || req.chatPrompt.length === 0) {\n      throw new Error('Chat prompt is empty');\n    }\n\n    const apiConfig = {\n      name: '/chat/completions',\n    };\n\n    const messages = createMessages(req);\n\n    const frequencyPenalty =\n      req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty;\n\n    const stream = req.modelConfig?.stream ?? this.config.stream;\n\n    const reqValue: AxAIRekaChatRequest = {\n      model,\n      messages,\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      top_k: req.modelConfig?.n ?? this.config.n,\n      top_p: req.modelConfig?.topP ?? this.config.topP ?? 1,\n      stop: req.modelConfig?.stopSequences ?? this.config.stop,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      ...(frequencyPenalty ? { frequency_penalty: frequencyPenalty } : {}),\n      ...(stream ? { stream: true } : {}),\n    };\n\n    return [apiConfig, reqValue];\n  };\n\n  createChatResp = (resp: Readonly<AxAIRekaChatResponse>): AxChatResponse => {\n    const { id, usage, responses } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined;\n\n    const results = responses.map((res, index) => {\n      const finishReason = mapFinishReason(res.finish_reason);\n      let content: string;\n      if (typeof res.message.content === 'string') {\n        content = res.message.content;\n      } else {\n        content = res.message.content.text;\n      }\n\n      return {\n        index,\n        id: `${id}`,\n        content,\n        finishReason,\n      };\n    });\n\n    return { results, remoteId: id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIRekaChatResponseDelta>\n  ): AxChatResponse => {\n    const { id, usage, responses } = resp;\n\n    this.tokensUsed = usage\n      ? {\n          promptTokens: usage.input_tokens,\n          completionTokens: usage.output_tokens,\n          totalTokens: usage.input_tokens + usage.output_tokens,\n        }\n      : undefined;\n\n    const results = responses.map((res, index) => {\n      const finishReason = mapFinishReason(res.finish_reason);\n      let content: string;\n      if (typeof res.chunk.content === 'string') {\n        content = res.chunk.content;\n      } else {\n        content = res.chunk.content.text;\n      }\n\n      return {\n        index,\n        id: `${id}`,\n        content,\n        finishReason,\n      };\n    });\n\n    return { results };\n  };\n}\n\nconst mapFinishReason = (\n  finishReason: AxAIRekaChatResponse['responses'][0]['finish_reason']\n): AxChatResponseResult['finishReason'] => {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop' as const;\n    case 'context':\n      return 'length' as const;\n    case 'length':\n      return 'length' as const;\n  }\n};\n\nfunction createMessages(\n  req: Readonly<AxChatRequest>\n): AxAIRekaChatRequest['messages'] {\n  return req.chatPrompt.map((msg) => {\n    switch (msg.role) {\n      case 'system':\n        return { role: 'user' as const, content: msg.content };\n\n      case 'user':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'user' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  throw new Error('Image type not supported');\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            }),\n          };\n        }\n        return { role: 'user' as const, content: msg.content };\n\n      case 'assistant':\n        if (Array.isArray(msg.content)) {\n          return {\n            role: 'assistant' as const,\n            content: msg.content.map((c) => {\n              switch (c.type) {\n                case 'text':\n                  return { type: 'text' as const, text: c.text };\n                case 'image': {\n                  throw new Error('Image type not supported');\n                }\n                default:\n                  throw new Error('Invalid content type');\n              }\n            }),\n          };\n        }\n        if (!msg.content) {\n          throw new Error('Assistant content is empty');\n        }\n        return { role: 'user' as const, content: msg.content };\n      default:\n        throw new Error('Invalid role');\n    }\n  });\n}\n\nexport class AxAIReka<TModelKey> extends AxBaseAI<\n  AxAIRekaModel,\n  undefined,\n  AxAIRekaChatRequest,\n  unknown,\n  AxAIRekaChatResponse,\n  AxAIRekaChatResponseDelta,\n  unknown,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    apiURL,\n    modelInfo = axModelInfoReka,\n    models,\n  }: Readonly<Omit<AxAIRekaArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Reka API key not set');\n    }\n    const Config = {\n      ...axAIRekaDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIRekaImpl(Config);\n\n    super(aiImpl, {\n      name: 'Reka',\n      apiURL: apiURL ? apiURL : 'https://api.reka.ai/v1/chat',\n      headers: async () => ({ 'X-Api-Key': apiKey }),\n      modelInfo,\n      defaults: {\n        model: Config.model,\n      },\n      options,\n      supportFor: {\n        functions: true,\n        streaming: true,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      },\n      models,\n    });\n  }\n}\n", "import type {\n  AxAIService,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n} from './types.js';\nimport {\n  axProcessContentForProvider,\n  type ProcessingOptions,\n} from './processor.js';\nimport {\n  axSelectOptimalProvider,\n  axAnalyzeRequestRequirements,\n} from './capabilities.js';\nimport { AxMediaNotSupportedError } from '../util/apicall.js';\n\n/**\n * Services for converting unsupported content types to text or optimized formats\n */\nexport interface AxContentProcessingServices {\n  /** Service to convert images to text descriptions */\n  imageToText?: (imageData: string) => Promise<string>;\n  /** Service to convert audio to text transcriptions */\n  audioToText?: (audioData: string, format?: string) => Promise<string>;\n  /** Service to extract text from files */\n  fileToText?: (fileData: string, mimeType: string) => Promise<string>;\n  /** Service to fetch and extract text from URLs */\n  urlToText?: (url: string) => Promise<string>;\n  /** Service to optimize images for size/quality */\n  imageOptimization?: (\n    imageData: string,\n    options: OptimizationOptions\n  ) => Promise<string>;\n}\n\n/**\n * Options for image optimization processing\n */\nexport interface OptimizationOptions {\n  /** Image quality (0-100) */\n  quality?: number;\n  /** Maximum file size in bytes */\n  maxSize?: number;\n  /** Target image format */\n  format?: 'jpeg' | 'png' | 'webp';\n}\n\n/**\n * Configuration for multi-provider routing with fallback capabilities\n */\nexport interface AxMultiProviderConfig {\n  /** Provider hierarchy for routing */\n  providers: {\n    /** Primary provider to try first */\n    primary: AxAIService;\n    /** Alternative providers for fallback */\n    alternatives: AxAIService[];\n  };\n  /** Routing behavior configuration */\n  routing: {\n    /** Order of preferences when selecting providers */\n    preferenceOrder: ('capability' | 'cost' | 'speed' | 'quality')[];\n    /** Capability matching requirements */\n    capability: {\n      /** Only use providers with full capability support */\n      requireExactMatch: boolean;\n      /** Allow providers that require content processing fallbacks */\n      allowDegradation: boolean;\n    };\n  };\n  /** Content processing services for unsupported media types */\n  processing: AxContentProcessingServices;\n}\n\n/**\n * Result of the routing process including provider selection and processing information\n */\nexport interface AxRoutingResult {\n  /** The selected AI service provider */\n  provider: AxAIService;\n  /** List of content processing steps that were applied */\n  processingApplied: string[];\n  /** List of capability degradations that occurred */\n  degradations: string[];\n  /** Non-critical warnings about the routing decision */\n  warnings: string[];\n}\n\n/**\n * Multi-provider router that automatically selects optimal AI providers and handles content processing.\n *\n * The router analyzes requests to determine capability requirements, scores available providers,\n * and automatically handles content transformation for unsupported media types. It provides\n * graceful degradation and fallback mechanisms for robust multi-modal AI applications.\n *\n * @example\n * ```typescript\n * const router = new AxProviderRouter({\n *   providers: {\n *     primary: openaiProvider,\n *     alternatives: [geminiProvider, cohereProvider]\n *   },\n *   routing: {\n *     preferenceOrder: ['capability', 'quality'],\n *     capability: {\n *       requireExactMatch: false,\n *       allowDegradation: true\n *     }\n *   },\n *   processing: {\n *     imageToText: async (data) => await visionService.describe(data),\n *     audioToText: async (data) => await speechService.transcribe(data)\n *   }\n * });\n *\n * const result = await router.chat(multiModalRequest);\n * console.log(`Used: ${result.routing.provider.getName()}`);\n * ```\n */\nexport class AxProviderRouter {\n  private providers: AxAIService[];\n  private processingServices: AxContentProcessingServices;\n  private config: AxMultiProviderConfig['routing'];\n\n  /**\n   * Creates a new provider router with the specified configuration.\n   *\n   * @param config - Router configuration including providers, routing preferences, and processing services\n   */\n  constructor(config: AxMultiProviderConfig) {\n    this.providers = [\n      config.providers.primary,\n      ...config.providers.alternatives,\n    ];\n    this.processingServices = config.processing;\n    this.config = config.routing;\n  }\n\n  /**\n   * Routes a chat request to the most appropriate provider with automatic content processing.\n   *\n   * This method analyzes the request, selects the optimal provider, preprocesses content\n   * for compatibility, and executes the request with fallback support.\n   *\n   * @param request - The chat request to process\n   * @param options - Extended options including fallback providers and routing preferences\n   * @param options.fallbackProviders - Additional providers to try if primary selection fails\n   * @param options.processingOptions - Content processing options and conversion services\n   * @param options.routingOptions - Provider selection and routing behavior options\n   * @param options.routingOptions.requireExactMatch - Only use providers with full capability support\n   * @param options.routingOptions.allowDegradation - Allow content processing for unsupported types\n   * @param options.routingOptions.maxRetries - Maximum number of fallback providers to try\n   * @returns Promise resolving to the AI response and routing information\n   * @throws AxMediaNotSupportedError when no suitable provider can handle the request\n   *\n   * @example\n   * ```typescript\n   * const result = await router.chat(\n   *   { chatPrompt: [{ role: 'user', content: [{ type: 'image', image: '...' }] }] },\n   *   {\n   *     processingOptions: { fallbackBehavior: 'degrade' },\n   *     routingOptions: { allowDegradation: true }\n   *   }\n   * );\n   *\n   * console.log(`Provider: ${result.routing.provider.getName()}`);\n   * console.log(`Processing applied: ${result.routing.processingApplied}`);\n   * ```\n   */\n  async chat(\n    request: AxChatRequest,\n    options: AxAIServiceOptions & {\n      fallbackProviders?: AxAIService[];\n      processingOptions?: ProcessingOptions;\n      routingOptions?: {\n        requireExactMatch?: boolean;\n        allowDegradation?: boolean;\n        maxRetries?: number;\n      };\n    } = {}\n  ): Promise<{\n    response: AxChatResponse | ReadableStream<AxChatResponse>;\n    routing: AxRoutingResult;\n  }> {\n    const routingResult = await this.selectProviderWithDegradation(\n      request,\n      options.routingOptions || {}\n    );\n\n    const processedRequest = await this.preprocessRequest(\n      request,\n      routingResult.provider,\n      options.processingOptions\n    );\n\n    try {\n      const response = await routingResult.provider.chat(\n        processedRequest,\n        options\n      );\n\n      return {\n        response,\n        routing: routingResult,\n      };\n    } catch (error) {\n      if (\n        error instanceof AxMediaNotSupportedError &&\n        options.fallbackProviders?.length\n      ) {\n        // Try fallback providers\n        return await this.tryFallbackProviders(\n          request,\n          options.fallbackProviders,\n          options\n        );\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Preprocesses request content for the target provider\n   */\n  private async preprocessRequest(\n    request: AxChatRequest,\n    provider: AxAIService,\n    processingOptions?: ProcessingOptions\n  ): Promise<AxChatRequest> {\n    const enhancedOptions: ProcessingOptions = {\n      ...processingOptions,\n      fallbackBehavior: processingOptions?.fallbackBehavior || 'degrade',\n      imageToText:\n        processingOptions?.imageToText || this.processingServices.imageToText,\n      audioToText:\n        processingOptions?.audioToText || this.processingServices.audioToText,\n      fileToText:\n        processingOptions?.fileToText || this.processingServices.fileToText,\n      urlToText:\n        processingOptions?.urlToText || this.processingServices.urlToText,\n    };\n\n    const processedChatPrompt = [];\n\n    for (const message of request.chatPrompt) {\n      if (message.role === 'user' && Array.isArray(message.content)) {\n        const processedContent = await axProcessContentForProvider(\n          message.content,\n          provider,\n          enhancedOptions\n        );\n\n        // Convert processed content back to string format if it's all text\n        const allText = processedContent.every((item) => item.type === 'text');\n        if (allText && processedContent.length === 1) {\n          processedChatPrompt.push({\n            ...message,\n            content: processedContent[0].text,\n          });\n        } else {\n          // Keep as array format\n          processedChatPrompt.push({\n            ...message,\n            content: processedContent.map((item) => ({\n              type: 'text' as const,\n              text: item.text,\n            })),\n          });\n        }\n      } else {\n        processedChatPrompt.push(message);\n      }\n    }\n\n    return {\n      ...request,\n      chatPrompt: processedChatPrompt,\n    };\n  }\n\n  /**\n   * Selects provider with graceful degradation\n   */\n  private async selectProviderWithDegradation(\n    request: AxChatRequest,\n    options: {\n      requireExactMatch?: boolean;\n      allowDegradation?: boolean;\n      maxRetries?: number;\n    }\n  ): Promise<AxRoutingResult> {\n    const requirements = axAnalyzeRequestRequirements(request);\n    const processingApplied: string[] = [];\n    const degradations: string[] = [];\n    const warnings: string[] = [];\n\n    try {\n      const provider = axSelectOptimalProvider(request, this.providers, {\n        requireExactMatch:\n          options.requireExactMatch ?? this.config.capability.requireExactMatch,\n        allowDegradation:\n          options.allowDegradation ?? this.config.capability.allowDegradation,\n      });\n\n      const features = provider.getFeatures();\n\n      // Check what degradations will be applied\n      if (requirements.hasImages && !features.media.images.supported) {\n        degradations.push('Images will be converted to text descriptions');\n        processingApplied.push('Image-to-text conversion');\n      }\n\n      if (requirements.hasAudio && !features.media.audio.supported) {\n        degradations.push('Audio will be transcribed to text');\n        processingApplied.push('Audio-to-text transcription');\n      }\n\n      if (requirements.hasFiles && !features.media.files.supported) {\n        degradations.push('File content will be extracted to text');\n        processingApplied.push('File-to-text extraction');\n      }\n\n      if (requirements.hasUrls && !features.media.urls.supported) {\n        degradations.push('URL content will be pre-fetched');\n        processingApplied.push('URL content fetching');\n      }\n\n      if (requirements.requiresStreaming && !features.streaming) {\n        warnings.push('Streaming not supported - will use non-streaming mode');\n      }\n\n      if (requirements.requiresCaching && !features.caching.supported) {\n        warnings.push('Content caching not supported');\n      }\n\n      return {\n        provider,\n        processingApplied,\n        degradations,\n        warnings,\n      };\n    } catch (error) {\n      throw new Error(\n        `Provider selection failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  }\n\n  /**\n   * Tries fallback providers when primary provider fails\n   */\n  private async tryFallbackProviders(\n    request: AxChatRequest,\n    fallbackProviders: AxAIService[],\n    options: AxAIServiceOptions\n  ): Promise<{\n    response: AxChatResponse | ReadableStream<AxChatResponse>;\n    routing: AxRoutingResult;\n  }> {\n    for (const fallbackProvider of fallbackProviders) {\n      try {\n        const routingResult: AxRoutingResult = {\n          provider: fallbackProvider,\n          processingApplied: ['Fallback provider selection'],\n          degradations: [\n            'Using fallback provider due to primary provider failure',\n          ],\n          warnings: [],\n        };\n\n        const processedRequest = await this.preprocessRequest(\n          request,\n          fallbackProvider,\n          { fallbackBehavior: 'degrade' }\n        );\n\n        const response = await fallbackProvider.chat(processedRequest, options);\n\n        return {\n          response,\n          routing: routingResult,\n        };\n      } catch (_fallbackError) {}\n    }\n\n    throw new Error('All fallback providers failed');\n  }\n\n  /**\n   * Gets routing recommendation without executing the request.\n   *\n   * Analyzes the request and returns routing information including which provider\n   * would be selected, what processing would be applied, and any degradations or warnings.\n   *\n   * @param request - The chat request to analyze\n   * @returns Promise resolving to routing result with provider selection and processing info\n   *\n   * @example\n   * ```typescript\n   * const recommendation = await router.getRoutingRecommendation(request);\n   * console.log(`Would use: ${recommendation.provider.getName()}`);\n   * console.log(`Degradations: ${recommendation.degradations.join(', ')}`);\n   * ```\n   */\n  async getRoutingRecommendation(\n    request: AxChatRequest\n  ): Promise<AxRoutingResult> {\n    return await this.selectProviderWithDegradation(request, {});\n  }\n\n  /**\n   * Validates whether the configured providers can handle a specific request.\n   *\n   * Performs pre-flight validation to check if the request can be successfully\n   * processed by available providers, identifies potential issues, and provides\n   * recommendations for improving compatibility.\n   *\n   * @param request - The chat request to validate\n   * @returns Promise resolving to validation result with handling capability and recommendations\n   *\n   * @example\n   * ```typescript\n   * const validation = await router.validateRequest(request);\n   * if (!validation.canHandle) {\n   *   console.log('Issues:', validation.issues);\n   *   console.log('Recommendations:', validation.recommendations);\n   * }\n   * ```\n   */\n  async validateRequest(request: AxChatRequest): Promise<{\n    canHandle: boolean;\n    issues: string[];\n    recommendations: string[];\n  }> {\n    const requirements = axAnalyzeRequestRequirements(request);\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n\n    try {\n      const routingResult = await this.selectProviderWithDegradation(\n        request,\n        {}\n      );\n\n      if (routingResult.degradations.length > 0) {\n        issues.push(...routingResult.degradations);\n        recommendations.push(\n          'Consider using a provider that natively supports all media types'\n        );\n      }\n\n      if (routingResult.warnings.length > 0) {\n        issues.push(...routingResult.warnings);\n      }\n\n      // Check if we have processing services for required degradations\n      if (\n        requirements.hasImages &&\n        this.processingServices.imageToText === undefined\n      ) {\n        const hasImageProvider = this.providers.some(\n          (p) => p.getFeatures().media.images.supported\n        );\n        if (!hasImageProvider) {\n          issues.push(\n            'No image processing service available and no providers support images'\n          );\n          recommendations.push(\n            'Add imageToText processing service or use image-capable provider'\n          );\n        }\n      }\n\n      if (\n        requirements.hasAudio &&\n        this.processingServices.audioToText === undefined\n      ) {\n        const hasAudioProvider = this.providers.some(\n          (p) => p.getFeatures().media.audio.supported\n        );\n        if (!hasAudioProvider) {\n          issues.push(\n            'No audio processing service available and no providers support audio'\n          );\n          recommendations.push(\n            'Add audioToText processing service or use audio-capable provider'\n          );\n        }\n      }\n\n      return {\n        canHandle: issues.length === 0 || routingResult.degradations.length > 0,\n        issues,\n        recommendations,\n      };\n    } catch (error) {\n      return {\n        canHandle: false,\n        issues: [\n          `Cannot route request: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        ],\n        recommendations: [\n          'Add more providers or processing services to handle this request',\n        ],\n      };\n    }\n  }\n\n  /**\n   * Gets detailed statistics about the router's provider capabilities.\n   *\n   * Returns information about available providers, their supported capabilities,\n   * and routing recommendations for analysis and debugging purposes.\n   *\n   * @returns Object containing provider statistics and capability matrix\n   *\n   * @example\n   * ```typescript\n   * const stats = router.getRoutingStats();\n   * console.log(`Total providers: ${stats.totalProviders}`);\n   * console.log('Capabilities:');\n   * for (const [capability, providers] of Object.entries(stats.capabilityMatrix)) {\n   *   console.log(`  ${capability}: ${providers.join(', ')}`);\n   * }\n   * ```\n   */\n  getRoutingStats(): {\n    totalProviders: number;\n    capabilityMatrix: {\n      [capability: string]: string[];\n    };\n    recommendedProvider: string;\n  } {\n    const capabilityMatrix: { [capability: string]: string[] } = {};\n\n    // Build capability matrix\n    for (const provider of this.providers) {\n      const features = provider.getFeatures();\n      const name = provider.getName();\n\n      if (features.functions) {\n        capabilityMatrix.Functions = capabilityMatrix.Functions || [];\n        capabilityMatrix.Functions.push(name);\n      }\n\n      if (features.streaming) {\n        capabilityMatrix.Streaming = capabilityMatrix.Streaming || [];\n        capabilityMatrix.Streaming.push(name);\n      }\n\n      if (features.media.images.supported) {\n        capabilityMatrix.Images = capabilityMatrix.Images || [];\n        capabilityMatrix.Images.push(name);\n      }\n\n      if (features.media.audio.supported) {\n        capabilityMatrix.Audio = capabilityMatrix.Audio || [];\n        capabilityMatrix.Audio.push(name);\n      }\n\n      if (features.media.files.supported) {\n        capabilityMatrix.Files = capabilityMatrix.Files || [];\n        capabilityMatrix.Files.push(name);\n      }\n\n      if (features.media.urls.supported) {\n        capabilityMatrix.URLs = capabilityMatrix.URLs || [];\n        capabilityMatrix.URLs.push(name);\n      }\n\n      if (features.caching.supported) {\n        capabilityMatrix.Caching = capabilityMatrix.Caching || [];\n        capabilityMatrix.Caching.push(name);\n      }\n    }\n\n    return {\n      totalProviders: this.providers.length,\n      capabilityMatrix,\n      recommendedProvider: this.providers[0]?.getName() || 'None',\n    };\n  }\n}\n", "import type { AxModelInfo } from '../types.js';\n\nexport const axModelInfoTogether: AxModelInfo[] = [];\n", "import { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type { AxAIOpenAIConfig } from '../openai/chat_types.js';\n\nimport { axModelInfoTogether } from './info.js';\n\ntype TogetherAIConfig = AxAIOpenAIConfig<string, unknown>;\n\nexport const axAITogetherDefaultConfig = (): TogetherAIConfig =>\n  structuredClone({\n    // cspell:disable-next-line\n    model: 'mistralai/Mixtral-8x7B-Instruct-v0.1',\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport type AxAITogetherArgs<TModelKey> = AxAIOpenAIArgs<\n  'together',\n  string,\n  unknown,\n  TModelKey\n>;\n\nexport class AxAITogether<TModelKey> extends AxAIOpenAIBase<\n  string,\n  unknown,\n  TModelKey\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAITogetherArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Together API key not set');\n    }\n    const Config = {\n      ...axAITogetherDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoTogether, ...(modelInfo ?? [])];\n\n    const supportFor = {\n      functions: true,\n      streaming: true,\n      hasThinkingBudget: false,\n      hasShowThoughts: false,\n      media: {\n        images: {\n          supported: false,\n          formats: [],\n        },\n        audio: {\n          supported: false,\n          formats: [],\n        },\n        files: {\n          supported: false,\n          formats: [],\n          uploadMethod: 'none' as const,\n        },\n        urls: {\n          supported: false,\n          webSearch: false,\n          contextFetching: false,\n        },\n      },\n      caching: {\n        supported: false,\n        types: [],\n      },\n      thinking: false,\n      multiTurn: true,\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.together.xyz/v1',\n      modelInfo,\n      models,\n      supportFor,\n    });\n\n    super.setName('Together');\n  }\n}\n", "import type { AxChatRequest, AxChatResponseResult } from './types.js';\n\ntype AxChatRequestMessage = AxChatRequest['chatPrompt'][number];\n\n/**\n * Validates a chat request message item to ensure it meets the required criteria\n * @param item - The chat request message to validate\n * @throws {Error} When validation fails with a descriptive error message\n */\nexport function axValidateChatRequestMessage(item: AxChatRequestMessage): void {\n  const value = (v: unknown) => JSON.stringify(v, null, 2);\n\n  if (!item) {\n    throw new Error(\n      `Chat request message item cannot be null or undefined, received: ${value(item)}`\n    );\n  }\n\n  const role = (item as { role?: string })?.role;\n  if (!role) {\n    throw new Error(\n      `Chat request message must have a role, received: ${value(role)}`\n    );\n  }\n\n  switch (role) {\n    case 'system': {\n      const systemItem = item as { role: 'system'; content: string };\n      if (!systemItem.content || systemItem.content.trim() === '') {\n        throw new Error(\n          `System message content cannot be empty or whitespace-only, received: ${value(systemItem.content)}`\n        );\n      }\n      break;\n    }\n\n    case 'user': {\n      const userItem = item as { role: 'user'; content: string | object[] };\n      if (!userItem.content) {\n        throw new Error(\n          `User message content cannot be undefined, received: ${value(userItem.content)}`\n        );\n      }\n\n      if (typeof userItem.content === 'string') {\n        if (userItem.content.trim() === '') {\n          throw new Error(\n            `User message content cannot be empty or whitespace-only, received: ${value(userItem.content)}`\n          );\n        }\n      } else if (Array.isArray(userItem.content)) {\n        if (userItem.content.length === 0) {\n          throw new Error(\n            `User message content array cannot be empty, received: ${value(userItem.content)}`\n          );\n        }\n\n        for (let index = 0; index < userItem.content.length; index++) {\n          const contentItem = userItem.content[index];\n          if (!contentItem || typeof contentItem !== 'object') {\n            throw new Error(\n              `User message content item at index ${index} must be an object, received: ${value(contentItem)}`\n            );\n          }\n\n          const contentType = (contentItem as { type?: string })?.type;\n          if (!contentType) {\n            throw new Error(\n              `User message content item at index ${index} must have a type, received: ${value(contentType)}`\n            );\n          }\n\n          switch (contentType) {\n            case 'text': {\n              const textItem = contentItem as { type: 'text'; text: string };\n              if (!textItem.text || textItem.text.trim() === '') {\n                throw new Error(\n                  `User message text content at index ${index} cannot be empty or whitespace-only, received: ${value(textItem.text)}`\n                );\n              }\n              break;\n            }\n            case 'image': {\n              const imageItem = contentItem as {\n                type: 'image';\n                image: string;\n                mimeType: string;\n              };\n              if (!imageItem.image || imageItem.image.trim() === '') {\n                throw new Error(\n                  `User message image content at index ${index} cannot be empty, received: ${value(imageItem.image)}`\n                );\n              }\n              if (!imageItem.mimeType || imageItem.mimeType.trim() === '') {\n                throw new Error(\n                  `User message image content at index ${index} must have a mimeType, received: ${value(imageItem.mimeType)}`\n                );\n              }\n              break;\n            }\n            case 'audio': {\n              const audioItem = contentItem as { type: 'audio'; data: string };\n              if (!audioItem.data || audioItem.data.trim() === '') {\n                throw new Error(\n                  `User message audio content at index ${index} cannot be empty, received: ${value(audioItem.data)}`\n                );\n              }\n              break;\n            }\n            default:\n              throw new Error(\n                `User message content item at index ${index} has unsupported type: ${value(contentType)}`\n              );\n          }\n        }\n      } else {\n        throw new Error(\n          `User message content must be a string or array of content objects, received: ${value(userItem.content)}`\n        );\n      }\n      break;\n    }\n\n    case 'assistant': {\n      const assistantItem = item as {\n        role: 'assistant';\n        content?: string;\n        functionCalls?: object[];\n      };\n      // Assistant messages can have empty content if they have function calls\n      if (!assistantItem.content && !assistantItem.functionCalls) {\n        throw new Error(\n          `Assistant message must have either content or function calls, received content: ${value(assistantItem.content)}, functionCalls: ${value(assistantItem.functionCalls)}`\n        );\n      }\n\n      if (assistantItem.content && typeof assistantItem.content !== 'string') {\n        throw new Error(\n          `Assistant message content must be a string, received: ${value(assistantItem.content)}`\n        );\n      }\n\n      if (\n        assistantItem.functionCalls &&\n        !Array.isArray(assistantItem.functionCalls)\n      ) {\n        throw new Error(\n          `Assistant message function calls must be an array, received: ${value(assistantItem.functionCalls)}`\n        );\n      }\n      break;\n    }\n\n    case 'function': {\n      const functionItem = item as {\n        role: 'function';\n        functionId: string;\n        result: string;\n      };\n      if (!functionItem.functionId || functionItem.functionId.trim() === '') {\n        throw new Error(\n          `Function message must have a non-empty functionId, received: ${value(functionItem.functionId)}`\n        );\n      }\n\n      if (functionItem.result === undefined || functionItem.result === null) {\n        throw new Error(\n          `Function message must have a result, received: ${value(functionItem.result)}`\n        );\n      }\n\n      if (typeof functionItem.result !== 'string') {\n        throw new Error(\n          `Function message result must be a string, received: ${value(functionItem.result)}`\n        );\n      }\n      break;\n    }\n\n    default:\n      throw new Error(`Unsupported message role: ${value(role)}`);\n  }\n}\n\n/**\n * Validates a chat response result to ensure it meets the required criteria\n * @param results - The chat response results to validate (single result or array)\n * @throws {Error} When validation fails with a descriptive error message\n */\nexport function axValidateChatResponseResult(\n  results: Readonly<AxChatResponseResult[]> | Readonly<AxChatResponseResult>\n): void {\n  const value = (v: unknown) => JSON.stringify(v, null, 2);\n  const resultsArray = Array.isArray(results) ? results : [results];\n\n  if (resultsArray.length === 0) {\n    throw new Error(\n      `Chat response results cannot be empty, received: ${value(resultsArray)}`\n    );\n  }\n\n  for (let arrayIndex = 0; arrayIndex < resultsArray.length; arrayIndex++) {\n    const result = resultsArray[arrayIndex];\n    if (!result) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} cannot be null or undefined, received: ${value(result)}`\n      );\n    }\n\n    // Validate index\n    if (typeof result.index !== 'number') {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have a numeric index, received: ${value(result.index)}`\n      );\n    }\n\n    if (result.index < 0) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have a non-negative index, received: ${value(result.index)}`\n      );\n    }\n\n    // Validate that at least one meaningful field is present\n    if (\n      !result.content &&\n      !result.thought &&\n      !result.functionCalls &&\n      !result.finishReason\n    ) {\n      throw new Error(\n        `Chat response result at index ${arrayIndex} must have at least one of: content, thought, functionCalls, or finishReason, received: ${value({ content: result.content, thought: result.thought, functionCalls: result.functionCalls, finishReason: result.finishReason })}`\n      );\n    }\n\n    // Validate content if present\n    if (result.content !== undefined && typeof result.content !== 'string') {\n      throw new Error(\n        `Chat response result content at index ${arrayIndex} must be a string, received: ${value(result.content)}`\n      );\n    }\n\n    // Validate thought if present\n    if (result.thought !== undefined && typeof result.thought !== 'string') {\n      throw new Error(\n        `Chat response result thought at index ${arrayIndex} must be a string, received: ${value(result.thought)}`\n      );\n    }\n\n    // Validate name if present\n    if (result.name !== undefined) {\n      if (typeof result.name !== 'string') {\n        throw new Error(\n          `Chat response result name at index ${arrayIndex} must be a string, received: ${value(result.name)}`\n        );\n      }\n      if (result.name.trim() === '') {\n        throw new Error(\n          `Chat response result name at index ${arrayIndex} cannot be empty or whitespace-only, received: ${value(result.name)}`\n        );\n      }\n    }\n\n    // Validate annotations if present\n    if (result.annotations !== undefined) {\n      if (!Array.isArray(result.annotations)) {\n        throw new Error(\n          `Chat response result annotations at index ${arrayIndex} must be an array, received: ${value(result.annotations)}`\n        );\n      }\n      for (let i = 0; i < result.annotations.length; i++) {\n        const annotation = result.annotations[i];\n        if (!annotation || typeof annotation !== 'object') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must be an object, received: ${value(annotation)}`\n          );\n        }\n        if (annotation.type !== 'url_citation') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must have type 'url_citation', received: ${value(annotation.type)}`\n          );\n        }\n        if (\n          !annotation.url_citation ||\n          typeof annotation.url_citation !== 'object'\n        ) {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] must have a valid url_citation object, received: ${value(annotation.url_citation)}`\n          );\n        }\n        if (typeof annotation.url_citation.url !== 'string') {\n          throw new Error(\n            `Chat response result annotation at index ${arrayIndex}[${i}] url_citation.url must be a string, received: ${value(annotation.url_citation.url)}`\n          );\n        }\n      }\n    }\n\n    // Validate id if present\n    if (result.id !== undefined) {\n      if (typeof result.id !== 'string') {\n        throw new Error(\n          `Chat response result id at index ${arrayIndex} must be a string, received: ${value(result.id)}`\n        );\n      }\n      if (result.id.trim() === '') {\n        throw new Error(\n          `Chat response result id at index ${arrayIndex} cannot be empty or whitespace-only, received: ${value(result.id)}`\n        );\n      }\n    }\n\n    // Validate functionCalls if present\n    if (result.functionCalls !== undefined) {\n      if (!Array.isArray(result.functionCalls)) {\n        throw new Error(\n          `Chat response result functionCalls at index ${arrayIndex} must be an array, received: ${value(result.functionCalls)}`\n        );\n      }\n\n      for (\n        let callIndex = 0;\n        callIndex < result.functionCalls.length;\n        callIndex++\n      ) {\n        const functionCall = result.functionCalls[callIndex];\n        if (!functionCall) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} cannot be null or undefined, received: ${value(functionCall)}`\n          );\n        }\n\n        if (\n          !functionCall.id ||\n          typeof functionCall.id !== 'string' ||\n          functionCall.id.trim() === ''\n        ) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a non-empty string id, received: ${value(functionCall.id)}`\n          );\n        }\n\n        if (functionCall.type !== 'function') {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have type 'function', received: ${value(functionCall.type)}`\n          );\n        }\n\n        if (!functionCall.function) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a function object, received: ${value(functionCall.function)}`\n          );\n        }\n\n        if (\n          !functionCall.function.name ||\n          typeof functionCall.function.name !== 'string' ||\n          functionCall.function.name.trim() === ''\n        ) {\n          throw new Error(\n            `Function call at index ${callIndex} in result ${arrayIndex} must have a non-empty function name, received: ${value(functionCall.function.name)}`\n          );\n        }\n\n        if (functionCall.function.params !== undefined) {\n          if (\n            typeof functionCall.function.params !== 'string' &&\n            typeof functionCall.function.params !== 'object'\n          ) {\n            throw new Error(\n              `Function call params at index ${callIndex} in result ${arrayIndex} must be a string or object, received: ${value(functionCall.function.params)}`\n            );\n          }\n        }\n      }\n    }\n\n    // Validate finishReason if present\n    if (result.finishReason !== undefined) {\n      const validFinishReasons = [\n        'stop',\n        'length',\n        'function_call',\n        'content_filter',\n        'error',\n      ];\n      if (!validFinishReasons.includes(result.finishReason)) {\n        throw new Error(\n          `Chat response result finishReason at index ${arrayIndex} must be one of: ${validFinishReasons.join(', ')}, received: ${value(result.finishReason)}`\n        );\n      }\n    }\n  }\n}\n", "import type { AxModelConfig } from '../types.js';\n\n/**\n * WebLLM: Models for text generation\n * Based on WebLLM's supported models\n */\nexport enum AxAIWebLLMModel {\n  // Llama 3.1 series\n  Llama31_8B_Instruct = 'Llama-3.1-8B-Instruct-q4f32_1-MLC',\n  Llama31_70B_Instruct = 'Llama-3.1-70B-Instruct-q4f16_1-MLC',\n\n  // Llama 3.2 series\n  Llama32_1B_Instruct = 'Llama-3.2-1B-Instruct-q4f32_1-MLC',\n  Llama32_3B_Instruct = 'Llama-3.2-3B-Instruct-q4f32_1-MLC',\n\n  // Mistral series\n  Mistral7B_Instruct = 'Mistral-7B-Instruct-v0.3-q4f32_1-MLC',\n\n  // Phi series\n  Phi35_Mini_Instruct = 'Phi-3.5-mini-instruct-q4f32_1-MLC',\n\n  // Gemma series\n  Gemma2_2B_Instruct = 'gemma-2-2b-it-q4f32_1-MLC',\n  Gemma2_9B_Instruct = 'gemma-2-9b-it-q4f32_1-MLC',\n\n  // Qwen series\n  Qwen2_5_0_5B_Instruct = 'Qwen2.5-0.5B-Instruct-q4f32_1-MLC',\n  Qwen2_5_1_5B_Instruct = 'Qwen2.5-1.5B-Instruct-q4f32_1-MLC',\n  Qwen2_5_3B_Instruct = 'Qwen2.5-3B-Instruct-q4f32_1-MLC',\n  Qwen2_5_7B_Instruct = 'Qwen2.5-7B-Instruct-q4f32_1-MLC',\n}\n\n/**\n * WebLLM: Model options for text generation\n */\nexport type AxAIWebLLMConfig = AxModelConfig & {\n  model: AxAIWebLLMModel;\n  logitBias?: Record<number, number>;\n  logProbs?: boolean;\n  topLogprobs?: number;\n};\n\n/**\n * WebLLM: Chat request structure\n * Based on OpenAI-compatible API from WebLLM\n */\nexport type AxAIWebLLMChatRequest = {\n  model: AxAIWebLLMModel;\n  messages: Array<{\n    role: 'system' | 'user' | 'assistant' | 'function';\n    content?: string;\n    name?: string;\n    function_call?: {\n      name: string;\n      arguments: string;\n    };\n  }>;\n  temperature?: number;\n  top_p?: number;\n  max_tokens?: number;\n  stream?: boolean;\n  stop?: string | string[];\n  presence_penalty?: number;\n  frequency_penalty?: number;\n  logit_bias?: Record<number, number>;\n  logprobs?: boolean;\n  top_logprobs?: number;\n  n?: number;\n  tools?: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string;\n      parameters: object;\n    };\n  }>;\n  tool_choice?:\n    | 'none'\n    | 'auto'\n    | { type: 'function'; function: { name: string } };\n};\n\n/**\n * WebLLM: Chat response structure\n */\nexport type AxAIWebLLMChatResponse = {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: AxAIWebLLMModel;\n  choices: Array<{\n    index: number;\n    message: {\n      role: 'assistant';\n      content?: string;\n      tool_calls?: Array<{\n        id: string;\n        type: 'function';\n        function: {\n          name: string;\n          arguments: string;\n        };\n      }>;\n    };\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter';\n    logprobs?: {\n      content: Array<{\n        token: string;\n        logprob: number;\n        bytes: number[];\n        top_logprobs: Array<{\n          token: string;\n          logprob: number;\n          bytes: number[];\n        }>;\n      }>;\n    };\n  }>;\n  usage: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n};\n\n/**\n * WebLLM: Streaming chat response structure\n */\nexport type AxAIWebLLMChatResponseDelta = {\n  id: string;\n  object: 'chat.completion.chunk';\n  created: number;\n  model: AxAIWebLLMModel;\n  choices: Array<{\n    index: number;\n    delta: {\n      role?: 'assistant';\n      content?: string;\n      tool_calls?: Array<{\n        index: number;\n        id?: string;\n        type?: 'function';\n        function?: {\n          name?: string;\n          arguments?: string;\n        };\n      }>;\n    };\n    finish_reason?: 'stop' | 'length' | 'tool_calls' | 'content_filter';\n    logprobs?: {\n      content: Array<{\n        token: string;\n        logprob: number;\n        bytes: number[];\n        top_logprobs: Array<{\n          token: string;\n          logprob: number;\n          bytes: number[];\n        }>;\n      }>;\n    };\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n};\n\n/**\n * WebLLM doesn't support embeddings natively\n * This is a placeholder for consistency with the framework\n */\nexport type AxAIWebLLMEmbedModel = never;\nexport type AxAIWebLLMEmbedRequest = never;\nexport type AxAIWebLLMEmbedResponse = never;\n", "import type { AxModelInfo } from '../types.js';\n\nimport { AxAIWebLLMModel } from './types.js';\n\n/**\n * WebLLM model information\n * Note: WebLLM runs models locally in the browser, so there are no API costs\n * However, we include context window and capability information\n */\nexport const axModelInfoWebLLM: AxModelInfo[] = [\n  // Llama 3.1 series\n  {\n    name: AxAIWebLLMModel.Llama31_8B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0, // Local inference - no cost\n    completionTokenCostPer1M: 0, // Local inference - no cost\n    contextWindow: 128000,\n    maxTokens: 4096,\n  },\n  {\n    name: AxAIWebLLMModel.Llama31_70B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 4096,\n    isExpensive: true, // Large model - requires significant compute\n  },\n\n  // Llama 3.2 series\n  {\n    name: AxAIWebLLMModel.Llama32_1B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Llama32_3B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 2048,\n  },\n\n  // Mistral series\n  {\n    name: AxAIWebLLMModel.Mistral7B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 4096,\n  },\n\n  // Phi series\n  {\n    name: AxAIWebLLMModel.Phi35_Mini_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 128000,\n    maxTokens: 4096,\n  },\n\n  // Gemma series\n  {\n    name: AxAIWebLLMModel.Gemma2_2B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 8192,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Gemma2_9B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 8192,\n    maxTokens: 2048,\n  },\n\n  // Qwen series\n  {\n    name: AxAIWebLLMModel.Qwen2_5_0_5B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Qwen2_5_1_5B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Qwen2_5_3B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 2048,\n  },\n  {\n    name: AxAIWebLLMModel.Qwen2_5_7B_Instruct,\n    currency: 'usd',\n    promptTokenCostPer1M: 0,\n    completionTokenCostPer1M: 0,\n    contextWindow: 32768,\n    maxTokens: 4096,\n  },\n];\n", "import type { AxAPI } from '../../util/apicall.js';\nimport {\n  AxBaseAI,\n  axBaseAIDefaultConfig,\n  axBaseAIDefaultCreativeConfig,\n} from '../base.js';\nimport type {\n  AxAIInputModelList,\n  AxAIServiceImpl,\n  AxAIServiceOptions,\n  AxChatResponse,\n  AxEmbedResponse,\n  AxInternalChatRequest,\n  AxInternalEmbedRequest,\n  AxModelConfig,\n  AxTokenUsage,\n} from '../types.js';\n\nimport { axModelInfoWebLLM } from './info.js';\nimport {\n  type AxAIWebLLMChatRequest,\n  type AxAIWebLLMChatResponse,\n  type AxAIWebLLMChatResponseDelta,\n  type AxAIWebLLMConfig,\n  type AxAIWebLLMEmbedModel,\n  type AxAIWebLLMEmbedRequest,\n  type AxAIWebLLMEmbedResponse,\n  AxAIWebLLMModel,\n} from './types.js';\n\nexport const axAIWebLLMDefaultConfig = (): AxAIWebLLMConfig =>\n  structuredClone({\n    model: AxAIWebLLMModel.Llama32_3B_Instruct,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIWebLLMCreativeConfig = (): AxAIWebLLMConfig =>\n  structuredClone({\n    model: AxAIWebLLMModel.Llama32_3B_Instruct,\n    ...axBaseAIDefaultCreativeConfig(),\n  });\n\nexport interface AxAIWebLLMArgs<TModelKey> {\n  name: 'webllm';\n  engine: any; // WebLLM MLCEngine instance\n  config?: Readonly<Partial<AxAIWebLLMConfig>>;\n  options?: Readonly<AxAIServiceOptions>;\n  models?: AxAIInputModelList<AxAIWebLLMModel, AxAIWebLLMEmbedModel, TModelKey>;\n}\n\nclass AxAIWebLLMImpl\n  implements\n    AxAIServiceImpl<\n      AxAIWebLLMModel,\n      AxAIWebLLMEmbedModel,\n      AxAIWebLLMChatRequest,\n      AxAIWebLLMEmbedRequest,\n      AxAIWebLLMChatResponse,\n      AxAIWebLLMChatResponseDelta,\n      AxAIWebLLMEmbedResponse\n    >\n{\n  private tokensUsed: AxTokenUsage | undefined;\n  public engine: any; // Make engine public so we can access it in localCall\n\n  constructor(\n    private config: AxAIWebLLMConfig,\n    engine: any // WebLLM MLCEngine instance\n  ) {\n    this.engine = engine;\n  }\n\n  getTokenUsage(): AxTokenUsage | undefined {\n    return this.tokensUsed;\n  }\n\n  getModelConfig(): AxModelConfig {\n    const { config } = this;\n    return {\n      maxTokens: config.maxTokens,\n      temperature: config.temperature,\n      topP: config.topP,\n      topK: config.topK,\n      presencePenalty: config.presencePenalty,\n      frequencyPenalty: config.frequencyPenalty,\n      stopSequences: config.stopSequences,\n      endSequences: config.endSequences,\n      stream: config.stream,\n      n: config.n,\n    } as AxModelConfig;\n  }\n\n  createChatReq(\n    req: Readonly<AxInternalChatRequest<AxAIWebLLMModel>>\n  ): [AxAPI, AxAIWebLLMChatRequest] {\n    const model = req.model;\n\n    // Convert Ax chat format to WebLLM format\n    const messages = req.chatPrompt.map((msg) => {\n      if (msg.role === 'function') {\n        return {\n          role: 'function' as const,\n          name: msg.functionId,\n          content:\n            typeof msg.result === 'string'\n              ? msg.result\n              : JSON.stringify(msg.result),\n        };\n      }\n\n      let content = '';\n      if (typeof msg.content === 'string') {\n        content = msg.content;\n      } else if (Array.isArray(msg.content)) {\n        // Handle multi-modal content by extracting text\n        content = msg.content\n          .filter((item) => item.type === 'text')\n          .map((item) => item.text)\n          .join('\\n');\n      }\n\n      const baseMsg = {\n        role: msg.role,\n        content,\n      };\n\n      // Add function calls for assistant messages\n      if (msg.role === 'assistant' && msg.functionCalls?.length) {\n        return {\n          ...baseMsg,\n          tool_calls: msg.functionCalls.map((fc) => ({\n            id: fc.id,\n            type: 'function' as const,\n            function: {\n              name: fc.function.name,\n              arguments:\n                typeof fc.function.params === 'string'\n                  ? fc.function.params\n                  : JSON.stringify(fc.function.params || {}),\n            },\n          })),\n        };\n      }\n\n      return baseMsg;\n    });\n\n    // Convert functions to tools\n    const tools = req.functions?.map((fn) => ({\n      type: 'function' as const,\n      function: {\n        name: fn.name,\n        description: fn.description,\n        parameters: fn.parameters || { type: 'object', properties: {} },\n      },\n    }));\n\n    const apiConfig = {\n      name: '/chat/completions', // WebLLM uses OpenAI-compatible endpoint\n      localCall: async <TRequest, TResponse>(\n        data: TRequest,\n        stream?: boolean\n      ): Promise<TResponse | ReadableStream<TResponse>> => {\n        try {\n          // Use WebLLM engine's chat.completions.create method\n          const response = await this.engine.chat.completions.create({\n            ...data,\n            stream: stream || false,\n          });\n\n          if (stream) {\n            // Return a ReadableStream for streaming responses\n            return new ReadableStream({\n              async start(controller) {\n                try {\n                  for await (const chunk of response) {\n                    controller.enqueue(chunk);\n                  }\n                  controller.close();\n                } catch (error) {\n                  controller.error(error);\n                }\n              },\n            }) as TResponse | ReadableStream<TResponse>;\n          }\n          return response as TResponse | ReadableStream<TResponse>;\n        } catch (error) {\n          throw new Error(`WebLLM API error: ${error}`);\n        }\n      },\n    };\n\n    const reqValue: AxAIWebLLMChatRequest = {\n      model,\n      messages,\n      ...(tools?.length ? { tools } : {}),\n      max_tokens: req.modelConfig?.maxTokens ?? this.config.maxTokens,\n      temperature: req.modelConfig?.temperature ?? this.config.temperature,\n      top_p: req.modelConfig?.topP ?? this.config.topP,\n      presence_penalty:\n        req.modelConfig?.presencePenalty ?? this.config.presencePenalty,\n      frequency_penalty:\n        req.modelConfig?.frequencyPenalty ?? this.config.frequencyPenalty,\n      stop: req.modelConfig?.stopSequences ?? this.config.stopSequences,\n      stream: req.modelConfig?.stream ?? this.config.stream,\n      n: req.modelConfig?.n ?? this.config.n,\n    };\n\n    return [apiConfig, reqValue];\n  }\n\n  createEmbedReq = (\n    _req: Readonly<AxInternalEmbedRequest<AxAIWebLLMEmbedModel>>\n  ): [AxAPI, AxAIWebLLMEmbedRequest] => {\n    throw new Error('WebLLM does not support embeddings');\n  };\n\n  createChatResp = (resp: Readonly<AxAIWebLLMChatResponse>): AxChatResponse => {\n    this.tokensUsed = {\n      promptTokens: resp.usage?.prompt_tokens ?? 0,\n      completionTokens: resp.usage?.completion_tokens ?? 0,\n      totalTokens: resp.usage?.total_tokens ?? 0,\n    };\n\n    const results = resp.choices.map((choice, index) => {\n      let finishReason: AxChatResponse['results'][0]['finishReason'] = 'stop';\n      switch (choice.finish_reason) {\n        case 'stop':\n          finishReason = 'stop';\n          break;\n        case 'length':\n          finishReason = 'length';\n          break;\n        case 'tool_calls':\n          finishReason = 'function_call';\n          break;\n        case 'content_filter':\n          finishReason = 'content_filter';\n          break;\n        default:\n          finishReason = 'stop';\n          break;\n      }\n\n      const functionCalls = choice.message.tool_calls?.map((toolCall) => ({\n        id: toolCall.id,\n        type: 'function' as const,\n        function: {\n          name: toolCall.function.name,\n          params: toolCall.function.arguments,\n        },\n      }));\n\n      return {\n        index,\n        id: resp.id,\n        content: choice.message.content || '',\n        functionCalls,\n        finishReason,\n      };\n    });\n\n    return { results, remoteId: resp.id };\n  };\n\n  createChatStreamResp = (\n    resp: Readonly<AxAIWebLLMChatResponseDelta>,\n    state: object\n  ): AxChatResponse => {\n    const ss = state as {\n      content?: string;\n      toolCalls?: Array<{\n        id?: string;\n        type?: 'function';\n        function?: { name?: string; arguments?: string };\n      }>;\n    };\n\n    // Accumulate streaming content\n    const choice = resp.choices[0];\n    if (!choice) {\n      throw new Error('No choice in WebLLM stream response');\n    }\n\n    if (choice.delta.content) {\n      ss.content = (ss.content || '') + choice.delta.content;\n    }\n\n    // Handle tool calls in streaming\n    if (choice.delta.tool_calls) {\n      if (!ss.toolCalls) {\n        ss.toolCalls = [];\n      }\n\n      for (const deltaToolCall of choice.delta.tool_calls) {\n        const existingCall = ss.toolCalls[deltaToolCall.index];\n        if (existingCall) {\n          if (deltaToolCall.function?.arguments) {\n            existingCall.function!.arguments =\n              (existingCall.function?.arguments || '') +\n              deltaToolCall.function.arguments;\n          }\n        } else {\n          ss.toolCalls[deltaToolCall.index] = {\n            id: deltaToolCall.id,\n            type: deltaToolCall.type,\n            function: {\n              name: deltaToolCall.function?.name,\n              arguments: deltaToolCall.function?.arguments || '',\n            },\n          };\n        }\n      }\n    }\n\n    // Update token usage if available\n    if (resp.usage) {\n      this.tokensUsed = {\n        promptTokens: resp.usage.prompt_tokens,\n        completionTokens: resp.usage.completion_tokens,\n        totalTokens: resp.usage.total_tokens,\n      };\n    }\n\n    let finishReason: AxChatResponse['results'][0]['finishReason'] | undefined;\n    if (choice.finish_reason) {\n      switch (choice.finish_reason) {\n        case 'stop':\n          finishReason = 'stop';\n          break;\n        case 'length':\n          finishReason = 'length';\n          break;\n        case 'tool_calls':\n          finishReason = 'function_call';\n          break;\n        case 'content_filter':\n          finishReason = 'content_filter';\n          break;\n        default:\n          finishReason = 'stop';\n          break;\n      }\n    }\n\n    const functionCalls = ss.toolCalls?.map((toolCall) => ({\n      id: toolCall.id || '',\n      type: 'function' as const,\n      function: {\n        name: toolCall.function?.name || '',\n        params: toolCall.function?.arguments || '',\n      },\n    }));\n\n    const results = [\n      {\n        index: 0,\n        id: resp.id,\n        content: ss.content || '',\n        functionCalls,\n        finishReason,\n      },\n    ];\n\n    return { results, remoteId: resp.id };\n  };\n\n  createEmbedResp(_resp: Readonly<AxAIWebLLMEmbedResponse>): AxEmbedResponse {\n    throw new Error('WebLLM does not support embeddings');\n  }\n}\n\nexport class AxAIWebLLM<TModelKey> extends AxBaseAI<\n  AxAIWebLLMModel,\n  AxAIWebLLMEmbedModel,\n  AxAIWebLLMChatRequest,\n  AxAIWebLLMEmbedRequest,\n  AxAIWebLLMChatResponse,\n  AxAIWebLLMChatResponseDelta,\n  AxAIWebLLMEmbedResponse,\n  TModelKey\n> {\n  constructor({\n    engine,\n    config,\n    options,\n    models,\n  }: Readonly<Omit<AxAIWebLLMArgs<TModelKey>, 'name'>>) {\n    if (!engine) {\n      throw new Error('WebLLM engine instance is required');\n    }\n\n    const Config = {\n      ...axAIWebLLMDefaultConfig(),\n      ...config,\n    };\n\n    const aiImpl = new AxAIWebLLMImpl(Config, engine);\n\n    super(aiImpl, {\n      name: 'WebLLM',\n      apiURL: undefined, // No URL needed for local inference\n      headers: async () => ({}), // No headers needed\n      modelInfo: axModelInfoWebLLM,\n      defaults: { model: Config.model },\n      supportFor: (_model: AxAIWebLLMModel) => ({\n        functions: true, // WebLLM supports function calling\n        streaming: true, // WebLLM supports streaming\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      }),\n      options,\n      models,\n    });\n  }\n}\n", "// cspell:ignore grok\n\nexport enum AxAIGrokModel {\n  Grok3 = 'grok-3',\n  Grok3Mini = 'grok-3-mini',\n  Grok3Fast = 'grok-3-fast',\n  Grok3MiniFast = 'grok-3-mini-fast',\n}\n\nexport enum AxAIGrokEmbedModels {\n  GrokEmbedSmall = 'grok-embed-small', // Placeholder, update if actual models are known\n}\n", "// cspell:ignore grok\n\nimport type { AxModelInfo } from '../types.js';\n\nimport { AxAIGrokModel } from './types.js';\n\nexport const axModelInfoGrok: AxModelInfo[] = [\n  {\n    name: AxAIGrokModel.Grok3,\n    currency: 'USD',\n    promptTokenCostPer1M: 3.0,\n    completionTokenCostPer1M: 15.0,\n  },\n  {\n    name: AxAIGrokModel.Grok3Mini,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.3,\n    completionTokenCostPer1M: 0.5,\n    hasThinkingBudget: true,\n  },\n  {\n    name: AxAIGrokModel.Grok3Fast,\n    currency: 'USD',\n    promptTokenCostPer1M: 5.0,\n    completionTokenCostPer1M: 25.0,\n  },\n  {\n    name: AxAIGrokModel.Grok3MiniFast,\n    currency: 'USD',\n    promptTokenCostPer1M: 0.6,\n    completionTokenCostPer1M: 4.0,\n    hasThinkingBudget: true,\n  },\n];\n", "import { getModelInfo } from '../../dsp/modelinfo.js';\nimport { axBaseAIDefaultConfig } from '../base.js';\nimport { type AxAIOpenAIArgs, AxAIOpenAIBase } from '../openai/api.js';\nimport type {\n  AxAIOpenAIChatRequest,\n  AxAIOpenAIConfig,\n} from '../openai/chat_types.js';\nimport type { AxAIServiceOptions, AxModelInfo } from '../types.js';\nimport { axModelInfoGrok } from './info.js';\nimport { type AxAIGrokEmbedModels, AxAIGrokModel } from './types.js';\n\nexport const axAIGrokDefaultConfig = (): AxAIOpenAIConfig<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels\n> =>\n  structuredClone({\n    model: AxAIGrokModel.Grok3Mini,\n    ...axBaseAIDefaultConfig(),\n  });\n\nexport const axAIGrokBestConfig = (): AxAIOpenAIConfig<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels\n> =>\n  structuredClone({\n    ...axAIGrokDefaultConfig(),\n    model: AxAIGrokModel.Grok3,\n  });\n\nexport interface AxAIGrokSearchSource {\n  type: 'web' | 'x' | 'news' | 'rss';\n  country?: string; // ISO alpha-2 code for web and news\n  excludedWebsites?: string[]; // Max 5 websites for web and news\n  allowedWebsites?: string[]; // Max 5 websites for web only\n  safeSearch?: boolean; // For web and news, default true\n  xHandles?: string[]; // For X source\n  links?: string[]; // For RSS source, max 1 link\n}\n\nexport interface AxAIGrokOptionsTools {\n  searchParameters?: {\n    mode?: 'auto' | 'on' | 'off';\n    returnCitations?: boolean;\n    fromDate?: string; // ISO8601 format YYYY-MM-DD\n    toDate?: string; // ISO8601 format YYYY-MM-DD\n    maxSearchResults?: number; // Default 20\n    sources?: AxAIGrokSearchSource[];\n  };\n}\n\nexport type AxAIGrokChatRequest = AxAIOpenAIChatRequest<AxAIGrokModel> & {\n  search_parameters?: {\n    mode?: 'auto' | 'on' | 'off';\n    return_citations?: boolean;\n    from_date?: string;\n    to_date?: string;\n    max_search_results?: number;\n    sources?: AxAIGrokSearchSource[];\n  };\n};\n\nexport type AxAIGrokArgs<TModelKey> = AxAIOpenAIArgs<\n  'grok',\n  AxAIGrokModel,\n  AxAIGrokEmbedModels,\n  TModelKey,\n  AxAIGrokChatRequest\n> & {\n  options?: Readonly<AxAIServiceOptions & AxAIGrokOptionsTools> & {\n    tokensPerMinute?: number;\n  };\n  modelInfo?: AxModelInfo[];\n};\n\nexport class AxAIGrok<TModelKey> extends AxAIOpenAIBase<\n  AxAIGrokModel,\n  AxAIGrokEmbedModels,\n  TModelKey,\n  AxAIGrokChatRequest\n> {\n  constructor({\n    apiKey,\n    config,\n    options,\n    models,\n    modelInfo,\n  }: Readonly<Omit<AxAIGrokArgs<TModelKey>, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Grok API key not set');\n    }\n\n    const Config = {\n      ...axAIGrokDefaultConfig(),\n      ...config,\n    };\n\n    modelInfo = [...axModelInfoGrok, ...(modelInfo ?? [])];\n\n    const supportFor = (model: AxAIGrokModel) => {\n      const mi = getModelInfo<AxAIGrokModel, AxAIGrokEmbedModels, TModelKey>({\n        model,\n        modelInfo,\n        models,\n      });\n      return {\n        functions: true,\n        streaming: true,\n        hasThinkingBudget: mi?.hasThinkingBudget ?? false,\n        hasShowThoughts: mi?.hasShowThoughts ?? false,\n        media: {\n          images: {\n            supported: false,\n            formats: [],\n          },\n          audio: {\n            supported: false,\n            formats: [],\n          },\n          files: {\n            supported: false,\n            formats: [],\n            uploadMethod: 'none' as const,\n          },\n          urls: {\n            supported: false,\n            webSearch: false,\n            contextFetching: false,\n          },\n        },\n        caching: {\n          supported: false,\n          types: [],\n        },\n        thinking: false,\n        multiTurn: true,\n      };\n    };\n\n    // Chat request updater to add Grok's search parameters\n    const chatReqUpdater = (req: AxAIGrokChatRequest): AxAIGrokChatRequest => {\n      if (options?.searchParameters) {\n        const searchParams = options.searchParameters;\n        return {\n          ...req,\n          search_parameters: {\n            mode: searchParams.mode,\n            return_citations: searchParams.returnCitations,\n            from_date: searchParams.fromDate,\n            to_date: searchParams.toDate,\n            max_search_results: searchParams.maxSearchResults,\n            sources: searchParams.sources?.map((source) => ({\n              type: source.type,\n              country: source.country,\n              excluded_websites: source.excludedWebsites,\n              allowed_websites: source.allowedWebsites,\n              safe_search: source.safeSearch,\n              x_handles: source.xHandles,\n              links: source.links,\n            })),\n          },\n        };\n      }\n      return req;\n    };\n\n    super({\n      apiKey,\n      config: Config,\n      options,\n      apiURL: 'https://api.x.ai/v1',\n      modelInfo,\n      models,\n      supportFor,\n      chatReqUpdater,\n    });\n\n    super.setName('Grok');\n  }\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport { AxAIAnthropic, type AxAIAnthropicArgs } from './anthropic/api.js';\nimport type { AxAIAnthropicModel } from './anthropic/types.js';\nimport {\n  AxAIAzureOpenAI,\n  type AxAIAzureOpenAIArgs,\n} from './azure-openai/api.js';\nimport type { AxAIFeatures } from './base.js';\nimport { AxAICohere, type AxAICohereArgs } from './cohere/api.js';\nimport type { AxAICohereEmbedModel, AxAICohereModel } from './cohere/types.js';\nimport { AxAIDeepSeek, type AxAIDeepSeekArgs } from './deepseek/api.js';\nimport type { AxAIDeepSeekModel } from './deepseek/types.js';\nimport {\n  AxAIGoogleGemini,\n  type AxAIGoogleGeminiArgs,\n} from './google-gemini/api.js';\nimport type {\n  AxAIGoogleGeminiEmbedModel,\n  AxAIGoogleGeminiModel,\n} from './google-gemini/types.js';\nimport { AxAIGroq, type AxAIGroqArgs } from './groq/api.js';\nimport type { AxAIGroqModel } from './groq/types.js';\nimport {\n  AxAIHuggingFace,\n  type AxAIHuggingFaceArgs,\n} from './huggingface/api.js';\nimport type { AxAIHuggingFaceModel } from './huggingface/types.js';\nimport { AxAIMistral, type AxAIMistralArgs } from './mistral/api.js';\nimport type { AxAIMistralModel } from './mistral/types.js';\nimport { AxAIOllama, type AxAIOllamaArgs } from './ollama/api.js';\nimport { AxAIOpenAI, type AxAIOpenAIArgs } from './openai/api.js';\nimport type {\n  AxAIOpenAIEmbedModel,\n  AxAIOpenAIModel,\n} from './openai/chat_types.js';\nimport {\n  AxAIOpenAIResponses,\n  type AxAIOpenAIResponsesArgs,\n} from './openai/responses_api_base.js';\nimport type { AxAIOpenAIResponsesModel } from './openai/responses_types.js';\nimport { AxAIReka, type AxAIRekaArgs } from './reka/api.js';\nimport { AxAITogether, type AxAITogetherArgs } from './together/api.js';\nimport type {\n  AxAIModelList,\n  AxAIService,\n  AxAIServiceMetrics,\n  AxAIServiceOptions,\n  AxChatRequest,\n  AxChatResponse,\n  AxEmbedRequest,\n  AxEmbedResponse,\n  AxLoggerFunction,\n} from './types.js';\nimport { AxAIWebLLM, type AxAIWebLLMArgs } from './webllm/api.js';\nimport type { AxAIWebLLMModel } from './webllm/types.js';\nimport { AxAIGrok, type AxAIGrokArgs } from './x-grok/api.js';\nimport type { AxAIGrokModel } from './x-grok/types.js';\n\nexport type AxAIArgs<TModelKey> =\n  | AxAIOpenAIArgs<'openai', AxAIOpenAIModel, AxAIOpenAIEmbedModel, TModelKey>\n  | AxAIOpenAIResponsesArgs<\n      'openai-responses',\n      AxAIOpenAIResponsesModel,\n      AxAIOpenAIEmbedModel,\n      TModelKey\n    >\n  | AxAIAzureOpenAIArgs<TModelKey>\n  | AxAITogetherArgs<TModelKey>\n  | AxAIAnthropicArgs<TModelKey>\n  | AxAIGroqArgs<TModelKey>\n  | AxAIGoogleGeminiArgs<TModelKey>\n  | AxAICohereArgs<TModelKey>\n  | AxAIHuggingFaceArgs<TModelKey>\n  | AxAIMistralArgs<TModelKey>\n  | AxAIDeepSeekArgs<TModelKey>\n  | AxAIOllamaArgs<TModelKey>\n  | AxAIRekaArgs<TModelKey>\n  | AxAIGrokArgs<TModelKey>\n  | AxAIWebLLMArgs<TModelKey>;\n\nexport type AxAIModels =\n  | AxAIOpenAIModel\n  | AxAIAnthropicModel\n  | AxAIGroqModel\n  | AxAIGoogleGeminiModel\n  | AxAICohereModel\n  | AxAIHuggingFaceModel\n  | AxAIMistralModel\n  | AxAIDeepSeekModel\n  | AxAIGrokModel\n  | AxAIWebLLMModel;\n\nexport type AxAIEmbedModels =\n  | AxAIOpenAIEmbedModel\n  | AxAIGoogleGeminiEmbedModel\n  | AxAICohereEmbedModel;\n\n// Helper to extract both model keys and enum values from model configurations\ntype ExtractModelKeysAndValues<T> = T extends readonly {\n  key: infer K;\n  model: infer M;\n}[]\n  ? K | M\n  : never;\n\n// Helper to infer TModelKey from args - now includes both keys and enum values\ntype InferTModelKey<T> = T extends { models: infer M }\n  ? ExtractModelKeysAndValues<M>\n  : string;\n\n/**\n * Factory function for creating AxAI instances with type safety.\n * This is the recommended way to create AxAI instances instead of using the constructor.\n *\n * @param options - Configuration options for the AI service\n * @returns A properly typed AxAI instance\n *\n * @example\n * ```typescript\n * const ai = ai({\n *   name: 'openai',\n *   apiKey: process.env.OPENAI_APIKEY!\n * });\n * ```\n */\nexport function ai<const T extends AxAIArgs<any>>(\n  options: T\n): AxAI<InferTModelKey<T>> {\n  return AxAI.create(options);\n}\n\nexport class AxAI<TModelKey = string>\n  implements AxAIService<any, any, TModelKey>\n{\n  private ai: AxAIService<any, any, TModelKey>;\n\n  // Static factory method for automatic type inference\n  static create<const T extends AxAIArgs<any>>(\n    options: T\n  ): AxAI<InferTModelKey<T>> {\n    return new AxAI(options) as any;\n  }\n\n  /**\n   * @deprecated Use `AxAI.create()` or `ai()` function instead for better type safety.\n   * This constructor will be removed in v15.0.0.\n   *\n   * Migration timeline:\n   * - v13.0.24+: Deprecation warnings (current)\n   * - v14.0.0: Runtime console warnings\n   * - v15.0.0: Complete removal\n   *\n   * @example\n   * ```typescript\n   * // Instead of: new AxAI({ name: 'openai', apiKey: '...' })\n   * // Use: AxAI.create({ name: 'openai', apiKey: '...' })\n   * // Or: ai({ name: 'openai', apiKey: '...' })\n   * ```\n   */\n  constructor(options: Readonly<AxAIArgs<TModelKey>>) {\n    switch (options.name) {\n      case 'openai':\n        this.ai = new AxAIOpenAI<TModelKey>(options);\n        break;\n      case 'openai-responses':\n        this.ai = new AxAIOpenAIResponses<TModelKey>(options);\n        break;\n      case 'azure-openai':\n        this.ai = new AxAIAzureOpenAI<TModelKey>(options);\n        break;\n      case 'grok':\n        this.ai = new AxAIGrok<TModelKey>(options);\n        break;\n      case 'huggingface':\n        this.ai = new AxAIHuggingFace<TModelKey>(options);\n        break;\n      case 'groq':\n        this.ai = new AxAIGroq<TModelKey>(options);\n        break;\n      case 'together':\n        this.ai = new AxAITogether<TModelKey>(options);\n        break;\n      case 'cohere':\n        this.ai = new AxAICohere<TModelKey>(options);\n        break;\n      case 'google-gemini':\n        this.ai = new AxAIGoogleGemini<TModelKey>(options);\n        break;\n      case 'anthropic':\n        this.ai = new AxAIAnthropic<TModelKey>(options);\n        break;\n      case 'mistral':\n        this.ai = new AxAIMistral<TModelKey>(options);\n        break;\n      case 'deepseek':\n        this.ai = new AxAIDeepSeek<TModelKey>(options);\n        break;\n      case 'ollama':\n        this.ai = new AxAIOllama<TModelKey>(options);\n        break;\n      case 'reka':\n        this.ai = new AxAIReka<TModelKey>(options);\n        break;\n      case 'webllm':\n        this.ai = new AxAIWebLLM<TModelKey>(options);\n        break;\n      default:\n        throw new Error('Unknown AI');\n    }\n  }\n\n  getName(): string {\n    return this.ai.getName();\n  }\n\n  getId(): string {\n    return this.ai.getId();\n  }\n\n  getFeatures(model?: string): AxAIFeatures {\n    return this.ai.getFeatures(model);\n  }\n\n  getModelList() {\n    return this.ai.getModelList() as AxAIModelList<TModelKey> | undefined;\n  }\n\n  getLastUsedChatModel() {\n    return this.ai.getLastUsedChatModel();\n  }\n\n  getLastUsedEmbedModel() {\n    return this.ai.getLastUsedEmbedModel();\n  }\n\n  getLastUsedModelConfig() {\n    return this.ai.getLastUsedModelConfig();\n  }\n\n  getMetrics(): AxAIServiceMetrics {\n    return this.ai.getMetrics();\n  }\n\n  async chat(\n    req: Readonly<AxChatRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxChatResponse | ReadableStream<AxChatResponse>> {\n    return await this.ai.chat(req, options);\n  }\n\n  async embed(\n    req: Readonly<AxEmbedRequest<TModelKey>>,\n    options?: Readonly<AxAIServiceOptions>\n  ): Promise<AxEmbedResponse> {\n    return await this.ai.embed(req, options);\n  }\n\n  setOptions(options: Readonly<AxAIServiceOptions>): void {\n    this.ai.setOptions(options);\n  }\n\n  getOptions(): Readonly<AxAIServiceOptions> {\n    return this.ai.getOptions();\n  }\n\n  getLogger(): AxLoggerFunction {\n    return this.ai.getLogger();\n  }\n}\n", "import { type Span, SpanKind, type Tracer } from '@opentelemetry/api';\n\nimport { axSpanAttributes } from '../trace/trace.js';\n\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport interface AxDBBaseArgs {\n  fetch?: typeof fetch;\n  tracer?: Tracer;\n}\n\nexport interface AxDBBaseOpOptions {\n  span?: Span;\n}\n\nexport class AxDBBase implements AxDBService {\n  protected name: string;\n  protected fetch?: typeof fetch;\n  private tracer?: Tracer;\n\n  _upsert?: (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>;\n\n  _batchUpsert?: (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBUpsertResponse>;\n\n  _query?: (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBBaseOpOptions>\n  ) => Promise<AxDBQueryResponse>;\n\n  constructor({\n    name,\n    fetch,\n    tracer,\n  }: Readonly<AxDBBaseArgs & { name: string }>) {\n    this.name = name;\n    this.fetch = fetch;\n    this.tracer = tracer;\n  }\n\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._upsert) {\n      throw new Error('upsert() not implemented');\n    }\n\n    if (!this.tracer) {\n      return await this._upsert(req, update);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._upsert!(req, update, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n\n  async batchUpsert(\n    req: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    if (!this._batchUpsert) {\n      throw new Error('batchUpsert() not implemented');\n    }\n    if (req.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    if (!req[0]) {\n      throw new Error('Batch request is invalid first element is undefined');\n    }\n\n    if (!this.tracer) {\n      return await this._batchUpsert(req, update);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Batch Upsert Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req[0].table,\n          [axSpanAttributes.DB_NAMESPACE]: req[0].namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: update ? 'update' : 'insert',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._batchUpsert!(req, update, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    if (!this._query) {\n      throw new Error('query() not implemented');\n    }\n    if (!this.tracer) {\n      return await this._query(req);\n    }\n\n    return await this.tracer.startActiveSpan(\n      'DB Query Request',\n      {\n        kind: SpanKind.SERVER,\n        attributes: {\n          [axSpanAttributes.DB_SYSTEM]: this.name,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'upsert',\n          [axSpanAttributes.DB_TABLE]: req.table,\n          [axSpanAttributes.DB_NAMESPACE]: req.namespace,\n          [axSpanAttributes.DB_OPERATION_NAME]: 'query',\n        },\n      },\n      async (span) => {\n        try {\n          return await this._query!(req, { span });\n        } finally {\n          span.end();\n        }\n      }\n    );\n  }\n}\n", "import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nconst baseURL = 'https://api.cloudflare.com/client/v4/accounts/';\n\nexport type AxDBCloudflareOpOptions = AxDBBaseOpOptions;\n\ntype AxCloudflareUpsertResponse = {\n  success: boolean;\n  errors?: { message: string }[];\n  result: { ids: string[] };\n};\n\ntype AxCloudflareQueryResponse = {\n  success: boolean;\n  errors?: { message: string }[];\n  result: {\n    matches: {\n      id: string;\n      score: number;\n      values: number[];\n      metadata: object;\n    }[];\n  };\n};\n\nexport interface AxDBCloudflareArgs extends AxDBBaseArgs {\n  name: 'cloudflare';\n  apiKey: string;\n  accountId: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Cloudflare: DB Service\n */\nexport class AxDBCloudflare extends AxDBBase {\n  private apiKey: string;\n  private accountId: string;\n\n  constructor({\n    apiKey,\n    accountId,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBCloudflareArgs, 'name'>>) {\n    if (!apiKey || !accountId) {\n      throw new Error('Cloudflare credentials not set');\n    }\n    super({ name: 'Cloudflare', fetch, tracer });\n    this.apiKey = apiKey;\n    this.accountId = accountId;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    _update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }\n    )) as AxCloudflareUpsertResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare upsert failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.result.ids,\n    };\n  };\n\n  override batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update');\n    }\n    if (batchReq.length < 1) {\n      throw new Error('Batch request is empty');\n    }\n    if (!batchReq[0] || !batchReq[0].table) {\n      throw new Error('Table name is empty');\n    }\n    const table = batchReq[0].table;\n\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${table}/upsert`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map((req) => ({\n        id: req.id,\n        values: req.values,\n        namespace: req.namespace,\n        metadata: req.metadata,\n      }))\n    )) as AxCloudflareUpsertResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare batch upsert failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.result.ids,\n    };\n  };\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBCloudflareOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const res = (await apiCall(\n      {\n        url: new URL(\n          `${this.accountId}/vectorize/indexes/${req.table}/query`,\n          baseURL\n        ),\n        headers: {\n          'X-Auth-Key': this.apiKey,\n        },\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        vector: req.values,\n        topK: req.limit || 10,\n        returnValues: true,\n      }\n    )) as AxCloudflareQueryResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Cloudflare query failed: ${res.errors.map(({ message }) => message).join(', ')}`\n      );\n    }\n\n    const matches = res.result.matches.map(\n      ({ id, score, values, metadata }) => ({\n        id,\n        score,\n        values,\n        metadata,\n      })\n    );\n    return { matches } as AxDBQueryResponse;\n  };\n}\n", "import { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBMemoryOpOptions = AxDBBaseOpOptions;\n\nexport interface AxDBMemoryArgs extends AxDBBaseArgs {\n  name: 'memory';\n}\n\nexport type AxDBState = Record<string, Record<string, AxDBUpsertRequest>>;\n\n/**\n * MemoryDB: DB Service\n */\nexport class AxDBMemory extends AxDBBase {\n  private state: AxDBState;\n\n  constructor({ tracer }: Readonly<Omit<AxDBMemoryArgs, 'name'>> = {}) {\n    super({ name: 'Memory', tracer });\n    this.state = {};\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (!this.state[req.table]) {\n      this.state[req.table] = {\n        [req.id]: req,\n      };\n    } else {\n      const obj = this.state[req.table];\n      if (!obj) {\n        throw new Error(`Table not found: ${req.table}`);\n      }\n      obj[req.id] = req;\n    }\n\n    return { ids: [req.id] };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const ids: string[] = [];\n    for (const req of batchReq) {\n      const res = await this.upsert(req, update);\n      ids.push(...res.ids);\n    }\n\n    return { ids };\n  };\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options?: Readonly<AxDBMemoryOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    const table = this.state[req.table];\n    if (!table) {\n      return { matches: [] };\n    }\n\n    const matches: AxDBQueryResponse['matches'] = [];\n\n    Object.entries(table).forEach(([id, data]) => {\n      if (req.values && data.values) {\n        const score = distance(req.values, data.values);\n        matches.push({ id: id, score: score, metadata: data.metadata });\n      }\n    });\n\n    matches.sort((a, b) => a.score - b.score);\n    if (req.limit) {\n      matches.length = req.limit;\n    }\n\n    return { matches };\n  };\n\n  public getDB = () => {\n    return structuredClone(this.state);\n  };\n\n  public setDB = (state: AxDBState) => {\n    this.state = structuredClone(state);\n  };\n\n  public clearDB = () => {\n    this.state = {};\n  };\n}\n\nconst distance = (a: readonly number[], b: readonly number[]): number => {\n  if (a.length !== b.length) {\n    throw new Error('Vectors must be of the same length.');\n  }\n\n  let dotProduct = 0;\n  let normA = 0;\n  let normB = 0;\n  let zeroVectorA = true;\n  let zeroVectorB = true;\n\n  const vectorA = new Float64Array(a);\n  const vectorB = new Float64Array(b);\n\n  for (let i = 0; i < vectorA.length; i++) {\n    dotProduct += vectorA[i]! * vectorB[i]!;\n    normA += vectorA[i]! * vectorA[i]!;\n    normB += vectorB[i]! * vectorB[i]!;\n    if (vectorA[i] !== 0) zeroVectorA = false;\n    if (vectorB[i] !== 0) zeroVectorB = false;\n  }\n\n  if (zeroVectorA || zeroVectorB) {\n    return 1; // Return maximum distance if one vector is zero\n  }\n\n  const sqrtNormA = Math.sqrt(normA);\n  const sqrtNormB = Math.sqrt(normB);\n  const similarity = dotProduct / (sqrtNormA * sqrtNormB);\n  return 1 - similarity; // Returning distance as 1 - cosine similarity.\n};\n", "import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBPineconeOpOptions = AxDBBaseOpOptions;\n\ntype AxPineconeQueryRequest = {\n  namespace?: string;\n  topK: number;\n  filter?: Record<string, string>;\n  includeValues: boolean;\n  includeMetadata: boolean;\n  vector: readonly number[];\n  id?: string;\n};\n\ntype AxPineconeQueryResponse = {\n  matches: {\n    id: string;\n    score: number;\n    values: number[];\n    metadata?: Record<string, string>;\n  }[];\n};\n\nconst createPineconeQueryRequest = (\n  req: Readonly<AxDBQueryRequest>\n): AxPineconeQueryRequest => {\n  const pineconeQueryRequest: AxPineconeQueryRequest = {\n    namespace: req.namespace,\n    topK: req.limit || 10,\n    filter: {},\n    includeValues: true,\n    includeMetadata: true,\n    vector: req.values ?? [],\n    id: req.id,\n  };\n\n  return pineconeQueryRequest;\n};\n\nexport interface AxDBPineconeArgs extends AxDBBaseArgs {\n  name: 'pinecone';\n  apiKey: string;\n  host: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Pinecone: DB Service\n */\nexport class AxDBPinecone extends AxDBBase {\n  private apiKey: string;\n  private apiURL: string;\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBPineconeArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Pinecone API key not set');\n    }\n    super({ name: 'Pinecone', fetch, tracer });\n    this.apiKey = apiKey;\n    this.apiURL = host;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    await this._batchUpsert([req], update, options);\n    return { ids: [req.id] };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    _update?: boolean,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/vectors/upsert',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      batchReq.map(({ id, values = [], metadata }) => ({\n        id,\n        values,\n        metadata,\n      }))\n    );\n\n    return { ids: batchReq.map(({ id }) => id) };\n  };\n\n  override query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBPineconeOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    if (req.text) {\n      throw new Error('Pinecone does not support text');\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/query',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      createPineconeQueryRequest(req)\n    )) as AxPineconeQueryResponse;\n\n    const matches = res.matches.map(({ id, score, values, metadata }) => ({\n      id,\n      score,\n      metadata,\n      values,\n    }));\n\n    return { matches };\n  };\n}\n", "import { apiCall } from '../util/apicall.js';\n\nimport { AxDBBase, type AxDBBaseArgs, type AxDBBaseOpOptions } from './base.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\n\nexport type AxDBWeaviateOpOptions = AxDBBaseOpOptions;\n\ntype AxWeaviateUpsertResponse = {\n  id: string;\n  result?: { errors?: { error: { message: string }[] } };\n};\n\ntype AxWeaviateQueryResponse = {\n  errors?: { location: string; message: string; path: string }[];\n  data: {\n    Get: {\n      [key: string]: {\n        [key: string]: unknown;\n      }[];\n    };\n  };\n};\n\nexport interface AxDBWeaviateArgs extends AxDBBaseArgs {\n  name: 'weaviate';\n  apiKey: string;\n  host: string;\n  fetch?: typeof fetch;\n}\n\n/**\n * Weaviate: DB Service\n */\nexport class AxDBWeaviate extends AxDBBase {\n  private apiKey: string;\n  private apiURL: string;\n\n  constructor({\n    apiKey,\n    host,\n    fetch,\n    tracer,\n  }: Readonly<Omit<AxDBWeaviateArgs, 'name'>>) {\n    if (!apiKey || apiKey === '') {\n      throw new Error('Weaviate API key not set');\n    }\n    super({ name: 'Weaviate', fetch, tracer });\n    this.apiKey = apiKey;\n    this.apiURL = host;\n  }\n\n  override _upsert = async (\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: `/v1/objects/${req.table}/${req.id}`,\n        put: !!update,\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        id: req.id,\n        class: req.table,\n        tenant: req.namespace,\n        vector: req.values,\n        properties: req.metadata ?? {},\n      }\n    )) as AxWeaviateUpsertResponse;\n\n    if (res?.result?.errors) {\n      throw new Error(\n        `Weaviate upsert failed: ${res.result.errors.error\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: [res.id],\n    };\n  };\n\n  override _batchUpsert = async (\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBUpsertResponse> => {\n    if (update) {\n      throw new Error('Weaviate does not support batch update');\n    }\n    if (batchReq.length === 0) {\n      throw new Error('Batch request is empty');\n    }\n    const objects = batchReq.map((req) => ({\n      id: req.id,\n      class: req.table,\n      tenant: req.namespace,\n      vector: req.values,\n      properties: req.metadata ?? {},\n    }));\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/batch/objects',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      { objects }\n    )) as AxWeaviateUpsertResponse[];\n\n    if (res?.some(({ result }) => result?.errors)) {\n      throw new Error(\n        `Weaviate batch upsert failed: ${res\n          .map(({ result }) =>\n            result?.errors?.error.map(({ message }) => message).join(', ')\n          )\n          .join(', ')}`\n      );\n    }\n\n    return {\n      ids: res.map(({ id }) => id),\n    };\n  };\n\n  override _query = async (\n    req: Readonly<AxDBQueryRequest>,\n    options?: Readonly<AxDBWeaviateOpOptions>\n  ): Promise<AxDBQueryResponse> => {\n    let filter = '';\n\n    if (req.columns && req.columns.length === 0) {\n      throw new Error('Weaviate requires at least one column');\n    }\n\n    if (req.values) {\n      filter = `nearVector: {\n            vector: [${req.values.join(',')}],\n        }`;\n    } else if (req.text) {\n      filter = `nearText: {\n            concepts: ['${req.text}'],\n        }`;\n    } else {\n      throw new Error('Weaviate requires either text or values');\n    }\n\n    const res = (await apiCall(\n      {\n        url: this.apiURL,\n        headers: { Authorization: `Bearer ${this.apiKey}` },\n        name: '/v1/graphql',\n        fetch: this.fetch,\n        span: options?.span,\n      },\n      {\n        query: `{\n          Get {\n            ${req.table} (\n              limit: ${req.limit || 10},\n              ${filter}\n            ) {\n                ${req.columns?.join('\\n')}\n            }\n          }\n        }`,\n      }\n    )) as AxWeaviateQueryResponse;\n\n    if (res.errors) {\n      throw new Error(\n        `Weaviate query failed: ${res.errors\n          .map(({ message }) => message)\n          .join(', ')}`\n      );\n    }\n\n    const resMatches = res.data.Get[req.table];\n\n    if (!resMatches) {\n      return { matches: [] };\n    }\n\n    const matches = resMatches.map((match) => {\n      return {\n        id: match.id as string,\n        score: 1,\n        metadata: match,\n      };\n    });\n    return { matches } as AxDBQueryResponse;\n  };\n}\n", "import { AxDBCloudflare, type AxDBCloudflareArgs } from './cloudflare.js';\nimport { AxDBMemory, type AxDBMemoryArgs } from './memory.js';\nimport { AxDBPinecone, type AxDBPineconeArgs } from './pinecone.js';\nimport type {\n  AxDBQueryRequest,\n  AxDBQueryResponse,\n  AxDBService,\n  AxDBUpsertRequest,\n  AxDBUpsertResponse,\n} from './types.js';\nimport { AxDBWeaviate, type AxDBWeaviateArgs } from './weaviate.js';\n\nexport type AxDBArgs =\n  | AxDBCloudflareArgs\n  | AxDBPineconeArgs\n  | AxDBWeaviateArgs\n  | AxDBMemoryArgs;\n\nexport class AxDB implements AxDBService {\n  private db: AxDBService;\n  constructor(args: Readonly<AxDBArgs>) {\n    switch (args.name) {\n      case 'weaviate':\n        this.db = new AxDBWeaviate(args);\n        break;\n      case 'pinecone':\n        this.db = new AxDBPinecone(args);\n        break;\n      case 'cloudflare':\n        this.db = new AxDBCloudflare(args);\n        break;\n      case 'memory':\n        this.db = new AxDBMemory(args);\n        break;\n      default:\n        throw new Error('Unknown DB');\n    }\n  }\n  async upsert(\n    req: Readonly<AxDBUpsertRequest>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.upsert(req, update);\n  }\n\n  async batchUpsert(\n    batchReq: Readonly<AxDBUpsertRequest[]>,\n    update?: boolean\n  ): Promise<AxDBUpsertResponse> {\n    return await this.db.batchUpsert(batchReq, update);\n  }\n\n  async query(req: Readonly<AxDBQueryRequest>): Promise<AxDBQueryResponse> {\n    return await this.db.query(req);\n  }\n}\n", "import type { AxAIService } from '../ai/types.js';\nimport type { AxDBQueryResponse, AxDBService } from '../db/types.js';\nimport type { AxGen } from '../dsp/generate.js';\n\nexport type AxRewriteIn = { query: string };\nexport type AxRewriteOut = { rewrittenQuery: string };\n\nexport type AxRerankerIn = { query: string; items: string[] };\nexport type AxRerankerOut = { rankedItems: string[] };\n\nexport interface AxDBLoaderOptions {\n  chunker?: (text: string) => string[];\n  rewriter?: AxGen<AxRewriteIn, AxRewriteOut>;\n  reranker?: AxGen<AxRerankerIn, AxRerankerOut>;\n}\n\nexport interface AxDBManagerArgs {\n  ai: AxAIService;\n  db: AxDBService;\n  config?: AxDBLoaderOptions;\n}\n\nexport interface AxDBMatch {\n  score: number;\n  text: string;\n}\n\nconst table = '_internal';\n\nexport class AxDBManager {\n  private ai: AxAIService;\n  private db: AxDBService;\n  private chunker: (text: string) => string[];\n  private rewriter?: AxGen<AxRewriteIn, AxRewriteOut>;\n  private reranker?: AxGen<AxRerankerIn, AxRerankerOut>;\n\n  constructor({ ai, db, config }: Readonly<AxDBManagerArgs>) {\n    this.ai = ai;\n    this.db = db;\n    this.chunker = config?.chunker ?? this.defaultChunker;\n    this.reranker = config?.reranker;\n    this.rewriter = config?.rewriter;\n  }\n\n  private defaultChunker = (text: string): string[] => {\n    // Default chunking by paragraphs\n    return text.split(/\\n\\n+/);\n  };\n\n  insert = async (\n    text: Readonly<string | string[]>,\n    options?: Readonly<{\n      batchSize?: number;\n      maxWordsPerChunk?: number;\n      minWordsPerChunk?: number;\n      abortSignal?: AbortSignal;\n    }>\n  ): Promise<void> => {\n    try {\n      const chunkerInput = Array.isArray(text)\n        ? text.join('\\n\\n')\n        : (text as string);\n\n      // Chunk the text using the specified or default chunking function\n      const initialChunks = this.chunker(chunkerInput).filter(\n        (chunk) => chunk.length > 0\n      );\n\n      const maxWordsPerChunk = options?.maxWordsPerChunk;\n      const minWordsPerChunk = options?.minWordsPerChunk;\n\n      const chunks = processChunks({\n        initialChunks,\n        minWordsPerChunk,\n        maxWordsPerChunk,\n      });\n\n      const bs = options?.batchSize ?? 10;\n\n      // Process chunks in batches of 10\n      for (let i = 0; i < chunks.length; i += bs) {\n        const batch = chunks.slice(i, i + bs);\n\n        // Get embeddings for the whole batch from the AI service in one call\n        const ret = await this.ai.embed(\n          { texts: batch },\n          {\n            abortSignal: options?.abortSignal,\n          }\n        );\n\n        // Prepare batch for bulk upsert\n        const embeddings = ret.embeddings\n          .map((embedding, index) => ({\n            id: `chunk_${Date.now() + index}`, // Unique ID for each chunk, adjusted by index\n            table,\n            values: embedding,\n            metadata: { text: batch[index] ?? '' },\n          }))\n          .filter((v) => v.metadata?.text && v.metadata?.text.length > 0);\n\n        // Batch upsert embeddings\n        await this.db.batchUpsert(embeddings);\n      }\n    } catch (error) {\n      throw new Error(`Error processing text: ${error}`);\n    }\n  };\n\n  query = async (\n    query: Readonly<string | string[] | number | number[]>,\n    {\n      topPercent,\n      abortSignal,\n    }:\n      | Readonly<{ topPercent?: number; abortSignal?: AbortSignal }>\n      | undefined = {}\n  ): Promise<AxDBMatch[][]> => {\n    const texts = Array.isArray(query) ? query : [query];\n\n    if (typeof texts[0] === 'string' && this.rewriter) {\n      for (const [i, text] of texts.entries()) {\n        const { rewrittenQuery } = await this.rewriter.forward(this.ai, {\n          query: text,\n        });\n        texts[i] = rewrittenQuery;\n      }\n    }\n\n    let queries: Promise<AxDBQueryResponse>[];\n\n    if (typeof texts[0] === 'string') {\n      const embedResults = await this.ai.embed(\n        { texts },\n        {\n          abortSignal,\n        }\n      );\n      queries = embedResults.embeddings.map((values) =>\n        this.db.query({ table, values })\n      );\n    } else {\n      queries = texts.map((values) => this.db.query({ table, values }));\n    }\n\n    const queryResults = await Promise.all(queries);\n    const res: AxDBMatch[][] = [];\n\n    for (const { matches } of queryResults) {\n      const m = matches\n        .filter((v) => v.metadata?.text && v.metadata?.text.length > 0)\n        .map(({ score, metadata }) => ({\n          score,\n          text: metadata?.text ?? '',\n        }));\n\n      const tp = topPercent && topPercent > 1 ? topPercent / 100 : topPercent;\n      const resultItems = tp ? getTopInPercent(m, tp) : m;\n\n      if (this.reranker) {\n        const { rankedItems } = await this.reranker.forward(this.ai, {\n          query: texts[0] as string,\n          items: resultItems.map((item) => item.text),\n        });\n\n        const items = rankedItems\n          .map((item) => resultItems.find((r) => r.text === item))\n          .filter((v) => v !== undefined) as AxDBMatch[];\n\n        res.push(items);\n      } else {\n        res.push(resultItems);\n      }\n    }\n\n    return res;\n  };\n}\n\nconst processChunks = ({\n  initialChunks,\n  maxWordsPerChunk = 350,\n  minWordsPerChunk = 250,\n}: Readonly<{\n  initialChunks: readonly string[];\n  maxWordsPerChunk?: number;\n  minWordsPerChunk?: number;\n}>): string[] => {\n  const chunks: string[] = [];\n\n  let currentChunk = '';\n  let currentWordCount = 0;\n\n  initialChunks.forEach((chunk) => {\n    const words = chunk.split(/\\s+/); // Split the chunk into words\n    const wordCount = words.length; // Count words in the current chunk\n\n    if (currentWordCount + wordCount <= maxWordsPerChunk) {\n      // Add to the current chunk if within the max size limit\n      currentChunk += `${chunk}\\n\\n`;\n      currentWordCount += wordCount;\n    } else if (\n      currentWordCount > 0 &&\n      currentWordCount + wordCount <= maxWordsPerChunk * 1.5\n    ) {\n      // If the total word count exceeds the limit but is less than 150% of the maxWordsPerChunk\n      currentChunk += `${chunk}\\n\\n`;\n      currentWordCount += wordCount;\n    } else {\n      // If the current chunk is not empty and adding the new chunk exceeds the adjusted limit\n      if (currentWordCount > minWordsPerChunk) {\n        chunks.push(currentChunk.trim());\n        currentChunk = '';\n        currentWordCount = 0;\n      }\n      // Handle the case where the chunk itself is larger than the limit\n      if (wordCount > maxWordsPerChunk) {\n        const remainingWords = words;\n        while (remainingWords.length > maxWordsPerChunk * 1.5) {\n          const slice = remainingWords.splice(0, maxWordsPerChunk);\n          chunks.push(slice.join(' '));\n        }\n        // Add the last portion if it fits the condition of being within 150% of maxWordsPerChunk\n        if (remainingWords.length > 0) {\n          currentChunk += `${remainingWords.join(' ')}\\n\\n`;\n          currentWordCount += remainingWords.length;\n        }\n      } else {\n        // If the new chunk is smaller than the maximum words per chunk\n        currentChunk = `${chunk}\\n\\n`;\n        currentWordCount = wordCount;\n      }\n    }\n  });\n\n  // Push the last chunk if it exists and meets the minimum words condition\n  if (currentWordCount > minWordsPerChunk || chunks.length === 0) {\n    chunks.push(currentChunk.trim());\n  }\n  return chunks;\n};\n\nconst getTopInPercent = (\n  entries: readonly AxDBMatch[],\n  percent = 0.1\n): AxDBMatch[] => {\n  // Sort entries by score in ascending order\n  const sortedEntries = [...entries].sort((a, b) => a.score - b.score);\n\n  // Calculate the number of entries to take (top 10%)\n  const topTenPercentCount = Math.ceil(sortedEntries.length * percent);\n\n  // Return the top 10% of entries\n  return sortedEntries.slice(0, topTenPercentCount);\n};\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport {\n  type Context,\n  context,\n  type Meter,\n  type Span,\n  SpanKind,\n  trace,\n} from '@opentelemetry/api';\n\nimport { validateAxMessageArray } from '../ai/base.js';\nimport { logResultPickerUsed } from '../ai/debug.js';\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunction,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport { AxMemory } from '../mem/memory.js';\nimport type { AxAIMemory } from '../mem/types.js';\nimport {\n  AxAIRefusalError,\n  AxAIServiceStreamTerminatedError,\n} from '../util/apicall.js';\n\nimport {\n  type AxAssertion,\n  AxAssertionError,\n  type AxStreamingAssertion,\n} from './asserts.js';\nimport {\n  type HandleErrorForGenerateArgs,\n  handleAssertionErrorForGenerate,\n  handleRefusalErrorForGenerate,\n  handleValidationErrorForGenerate,\n  ValidationError,\n} from './errors.js';\nimport type { extractionState } from './extract.js';\nimport type { AxFieldProcessor } from './fieldProcessor.js';\nimport {\n  type AxChatResponseFunctionCall,\n  createFunctionConfig,\n  parseFunctions,\n} from './functions.js';\nimport { axGlobals } from './globals.js';\nimport {\n  type AxGenMetricsInstruments,\n  getOrCreateGenMetricsInstruments,\n  recordErrorCorrectionMetric,\n  recordFieldProcessingMetric,\n  recordFunctionCallingMetric,\n  recordGenerationMetric,\n  recordMultiStepMetric,\n  recordPerformanceMetric,\n  recordSamplesMetric,\n  recordSignatureComplexityMetrics,\n  recordStreamingMetric,\n} from './metrics.js';\nimport {\n  processResponse,\n  processStreamingResponse,\n  shouldContinueSteps,\n} from './processResponse.js';\nimport { AxProgram } from './program.js';\nimport { AxPromptTemplate } from './prompt.js';\nimport { selectFromSamples, selectFromSamplesInMemory } from './samples.js';\nimport type { AxSignature, AxIField } from './sig.js';\nimport type {\n  AsyncGenDeltaOut,\n  AxGenDeltaOut,\n  AxGenOut,\n  AxGenStreamingOut,\n  AxMessage,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n  AxProgrammable,\n  AxProgramStreamingForwardOptionsWithModels,\n  AxResultPickerFunction,\n  AxSetExamplesOptions,\n} from './types.js';\nimport { mergeDeltas } from './util.js';\n\nexport type AxGenerateResult<OUT> = OUT & {\n  thought?: string;\n};\n\nexport interface AxResponseHandlerArgs<T> {\n  ai: Readonly<AxAIService>;\n  model?: string;\n  res: T;\n  mem: AxAIMemory;\n  sessionId?: string;\n  traceId?: string;\n  functions: Readonly<AxFunction[]>;\n  strictMode?: boolean;\n  span?: Span;\n  logger: AxLoggerFunction;\n}\n\nexport interface AxStreamingEvent<T> {\n  event: 'delta' | 'done' | 'error';\n  data: {\n    contentDelta?: string;\n    partialValues?: Partial<T>;\n    error?: string;\n    functions?: AxChatResponseFunctionCall[];\n  };\n}\n\nexport type InternalAxGenState = {\n  index: number;\n  values: Record<string, any>;\n  content: string;\n  functionsExecuted: Set<string>;\n  functionCalls: NonNullable<AxChatResponseResult['functionCalls']>;\n  xstate: extractionState;\n};\n\nexport class AxGen<IN = any, OUT extends AxGenOut = any>\n  extends AxProgram<IN, OUT>\n  implements AxProgrammable<IN, OUT>\n{\n  private asserts: AxAssertion[];\n  private streamingAsserts: AxStreamingAssertion[];\n  private options?: Omit<AxProgramForwardOptions<any>, 'functions'>;\n  private functions?: AxFunction[];\n  private fieldProcessors: AxFieldProcessor[] = [];\n  private streamingFieldProcessors: AxFieldProcessor[] = [];\n  private excludeContentFromTrace = false;\n  private thoughtFieldName: string;\n\n  constructor(\n    signature:\n      | NonNullable<ConstructorParameters<typeof AxSignature>[0]>\n      | AxSignature<any, any>,\n    options?: Readonly<AxProgramForwardOptions<any>>\n  ) {\n    super(signature, {\n      description: options?.description,\n      traceLabel: options?.traceLabel,\n    });\n\n    this.options = options;\n    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought';\n    this.asserts = this.options?.asserts ?? [];\n    this.streamingAsserts = this.options?.streamingAsserts ?? [];\n    this.excludeContentFromTrace = options?.excludeContentFromTrace ?? false;\n    this.usage = [];\n\n    if (options?.functions) {\n      this.functions = parseFunctions(options.functions);\n    }\n  }\n\n  private getSignatureName(): string {\n    return this.signature.getDescription() || 'unknown_signature';\n  }\n\n  private getMetricsInstruments(): AxGenMetricsInstruments | undefined {\n    return getOrCreateGenMetricsInstruments();\n  }\n\n  public updateMeter(meter?: Meter): void {\n    // This now just updates the global singleton, no need to store locally\n    getOrCreateGenMetricsInstruments(meter);\n  }\n\n  private createStates(n: number) {\n    return Array.from({ length: n }, (_, index) => ({\n      index,\n      functionCalls: [],\n      values: {},\n      content: '',\n      functionsExecuted: new Set<string>(),\n      xstate: {\n        extractedFields: [],\n        streamedIndex: {},\n        s: -1,\n      },\n    }));\n  }\n\n  public addAssert = (fn: AxAssertion['fn'], message?: string) => {\n    this.asserts.push({ fn, message });\n  };\n\n  public addStreamingAssert = (\n    fieldName: string,\n    fn: AxStreamingAssertion['fn'],\n    message?: string\n  ) => {\n    this.streamingAsserts.push({ fieldName, fn, message });\n  };\n\n  private addFieldProcessorInternal = (\n    fieldName: string,\n    fn: AxFieldProcessor['process'],\n    streaming = false\n  ) => {\n    const field = this.signature\n      .getOutputFields()\n      .find((f) => f.name === fieldName);\n\n    if (!field) {\n      throw new Error(`addFieldProcessor: field ${fieldName} not found`);\n    }\n\n    if (streaming) {\n      const ft = field.type?.name;\n      const isText = !ft || ft === 'string' || ft === 'code';\n\n      if (!isText) {\n        throw new Error(\n          `addFieldProcessor: field ${fieldName} is must be a text field`\n        );\n      }\n      this.streamingFieldProcessors.push({ field, process: fn });\n    } else {\n      this.fieldProcessors.push({ field, process: fn });\n    }\n  };\n\n  public addStreamingFieldProcessor = (\n    fieldName: string,\n    fn: AxFieldProcessor['process']\n  ) => {\n    this.addFieldProcessorInternal(fieldName, fn, true);\n  };\n\n  public addFieldProcessor = (\n    fieldName: string,\n    fn: AxFieldProcessor['process']\n  ) => {\n    this.addFieldProcessorInternal(fieldName, fn, false);\n  };\n\n  private async forwardSendRequest({\n    ai,\n    mem,\n    options,\n    traceContext,\n    functions,\n    functionCall,\n    stepIndex,\n  }: Readonly<{\n    ai: Readonly<AxAIService>;\n    mem: AxAIMemory;\n    options?: Omit<AxProgramForwardOptions<any>, 'ai' | 'mem'>;\n    traceContext?: Context;\n    functions: AxFunction[];\n    functionCall: AxChatRequest['functionCall'] | undefined;\n    stepIndex?: number;\n  }>) {\n    const {\n      sessionId,\n      model,\n      rateLimiter,\n      stream,\n      thinkingTokenBudget,\n      showThoughts,\n    } = options ?? {};\n\n    // Use selectFromSamplesInMemory to choose the best sample before getting history\n    const selectedIndex = await selectFromSamplesInMemory(mem, sessionId, {\n      resultPicker: options?.resultPicker as\n        | AxResultPickerFunction<OUT>\n        | undefined,\n    });\n\n    const chatPrompt = mem?.history(selectedIndex, sessionId) ?? [];\n\n    if (chatPrompt.length === 0) {\n      throw new Error('No chat prompt found');\n    }\n    const modelConfig = {\n      ...options?.modelConfig,\n      ...(options?.sampleCount ? { n: options.sampleCount } : {}),\n      ...(options?.sampleCount && options?.modelConfig?.temperature === 1\n        ? { temperature: 0.8 }\n        : {}),\n    };\n\n    const debug = this.isDebug(ai, options);\n    const firstStep = stepIndex === 0;\n    const logger = this.getLogger(ai, options);\n\n    const res = await ai.chat(\n      {\n        chatPrompt,\n        functions,\n        functionCall,\n        modelConfig,\n        model,\n      },\n      {\n        sessionId,\n        rateLimiter,\n        stream,\n        debug,\n        // Hide system prompt in debug logging for steps > 0 to reduce noise in multi-step workflows\n        debugHideSystemPrompt: !firstStep,\n        thinkingTokenBudget,\n        showThoughts,\n        traceContext,\n        abortSignal: options?.abortSignal,\n        stepIndex,\n        logger,\n      }\n    );\n\n    return res;\n  }\n\n  private async *forwardCore({\n    ai,\n    mem,\n    options,\n    stepIndex,\n    span,\n    traceContext,\n  }: Readonly<{\n    ai: Readonly<AxAIService>;\n    mem: AxAIMemory;\n    options: Omit<AxProgramForwardOptions<any>, 'ai' | 'mem'>;\n    stepIndex?: number;\n    span?: Span;\n    traceContext?: Context;\n  }>): AsyncGenDeltaOut<OUT> {\n    const { sessionId, functions: functionList } = options ?? {};\n    const definedFunctionCall =\n      options?.functionCall ?? this.options?.functionCall;\n    const strictMode = options?.strictMode ?? false;\n    const model = options.model;\n    const states = this.createStates(options.sampleCount ?? 1);\n    const usage = this.usage;\n    const firstStep = stepIndex === 0;\n    const logger = this.getLogger(ai, options);\n\n    const { functions, functionCall } = createFunctionConfig(\n      functionList,\n      definedFunctionCall,\n      firstStep\n    );\n\n    const res = await this.forwardSendRequest({\n      ai,\n      mem,\n      options,\n      traceContext,\n      functions,\n      functionCall,\n      stepIndex,\n    });\n\n    if (res instanceof ReadableStream) {\n      yield* processStreamingResponse<OUT>({\n        ai,\n        model,\n        res,\n        mem,\n        sessionId,\n        functions,\n        strictMode,\n        span,\n        states,\n        usage,\n        asserts: this.asserts,\n        streamingAsserts: this.streamingAsserts,\n        fieldProcessors: this.fieldProcessors,\n        streamingFieldProcessors: this.streamingFieldProcessors,\n        thoughtFieldName: this.thoughtFieldName,\n        excludeContentFromTrace: this.excludeContentFromTrace,\n        signature: this.signature,\n        logger,\n        functionResultFormatter:\n          options?.functionResultFormatter ??\n          this.options?.functionResultFormatter,\n      });\n    } else {\n      yield* processResponse<OUT>({\n        ai,\n        model,\n        res,\n        mem,\n        sessionId,\n        functions,\n        span,\n        strictMode,\n        states,\n        usage,\n        asserts: this.asserts,\n        fieldProcessors: this.fieldProcessors,\n        thoughtFieldName: this.thoughtFieldName,\n        excludeContentFromTrace: this.excludeContentFromTrace,\n        signature: this.signature,\n        logger,\n        functionResultFormatter:\n          options?.functionResultFormatter ??\n          this.options?.functionResultFormatter,\n      });\n    }\n  }\n\n  private async *_forward2(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    states: InternalAxGenState[],\n    options: Readonly<AxProgramForwardOptions<any>>,\n    span?: Span,\n    traceContext?: Context\n  ): AxGenStreamingOut<OUT> {\n    const stopFunction = (\n      options?.stopFunction ?? this.options?.stopFunction\n    )?.toLowerCase();\n\n    const maxRetries = options.maxRetries ?? this.options?.maxRetries ?? 10;\n    const maxSteps = options.maxSteps ?? this.options?.maxSteps ?? 10;\n\n    const mem = options.mem ?? this.options?.mem ?? new AxMemory();\n\n    let err: ValidationError | AxAssertionError | undefined;\n\n    const promptTemplateClass =\n      this.options?.promptTemplate ?? AxPromptTemplate;\n    const currentPromptTemplateOptions = {\n      functions: options.functions,\n      thoughtFieldName: this.thoughtFieldName,\n    };\n    const promptTemplate = new promptTemplateClass(\n      this.signature,\n      currentPromptTemplateOptions\n    );\n\n    // New logic:\n    let prompt: AxChatRequest['chatPrompt'];\n\n    // Track prompt rendering performance\n    const promptRenderStart = performance.now();\n\n    if (Array.isArray(values)) {\n      // Validate AxMessage array items\n      validateAxMessageArray(values);\n\n      // We'll need to decide how to get the 'individual' IN for demos/examples if needed by render.\n      // For now, assume render will handle the array directly.\n      // The generic type for render might need to be T (from render<T extends ...>)\n      // and T will be inferred as ReadonlyArray<AxMessage>\n      prompt = promptTemplate.render(values as any, {\n        examples: this.examples as any,\n        demos: this.demos as any,\n      });\n    } else {\n      // Ensure `values` here is correctly inferred as IN\n      prompt = promptTemplate.render(values as any, {\n        // Cast if necessary\n        examples: this.examples as any,\n        demos: this.demos as any,\n      });\n    }\n\n    const promptRenderDuration = performance.now() - promptRenderStart;\n\n    // Record prompt render performance metric\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'prompt_render',\n        promptRenderDuration,\n        this.getSignatureName()\n      );\n    }\n\n    // Track memory update performance\n    const memoryUpdateStart = performance.now();\n    mem.addRequest(prompt, options.sessionId);\n    const memoryUpdateDuration = performance.now() - memoryUpdateStart;\n\n    // Record memory update performance metric\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'memory_update',\n        memoryUpdateDuration,\n        this.getSignatureName()\n      );\n    }\n\n    multiStepLoop: for (let n = 0; n < maxSteps; n++) {\n      for (let errCount = 0; errCount < maxRetries; errCount++) {\n        try {\n          const generator = this.forwardCore({\n            options,\n            ai,\n            mem,\n            stepIndex: n,\n            span,\n            traceContext,\n          });\n\n          for await (const result of generator) {\n            if (result !== undefined) {\n              yield {\n                version: errCount,\n                index: result.index,\n                delta: result.delta,\n              };\n            }\n          }\n\n          const shouldContinue = shouldContinueSteps(\n            mem,\n            stopFunction,\n            states,\n            options?.sessionId\n          );\n\n          if (shouldContinue) {\n            // Record multi-step generation metric\n            const metricsInstruments = this.getMetricsInstruments();\n            if (metricsInstruments) {\n              recordMultiStepMetric(\n                metricsInstruments,\n                n + 1,\n                maxSteps,\n                this.getSignatureName()\n              );\n            }\n            continue multiStepLoop;\n          }\n\n          // Record successful completion metrics\n          const metricsInstruments = this.getMetricsInstruments();\n          if (metricsInstruments) {\n            recordMultiStepMetric(\n              metricsInstruments,\n              n + 1,\n              maxSteps,\n              this.getSignatureName()\n            );\n\n            // Count unique functions executed across all states\n            const allFunctionsExecuted = new Set<string>();\n            states.forEach((state) => {\n              state.functionsExecuted.forEach((func) =>\n                allFunctionsExecuted.add(func)\n              );\n            });\n\n            // Record function metrics if functions were used\n            if (allFunctionsExecuted.size > 0) {\n              recordFunctionCallingMetric(\n                metricsInstruments,\n                true,\n                allFunctionsExecuted.size,\n                true,\n                false,\n                this.getSignatureName()\n              );\n            }\n\n            // Record field processing metrics\n            recordFieldProcessingMetric(\n              metricsInstruments,\n              this.fieldProcessors.length,\n              this.streamingFieldProcessors.length,\n              this.getSignatureName()\n            );\n          }\n\n          return;\n        } catch (e) {\n          let errorFields: AxIField[] | undefined;\n          const debug = this.isDebug(ai, options);\n          const logger = this.getLogger(ai, options);\n          const metricsInstruments = this.getMetricsInstruments();\n          const signatureName = this.getSignatureName();\n\n          const args: HandleErrorForGenerateArgs<Error> = {\n            error: e as Error,\n            errCount,\n            logger,\n            metricsInstruments,\n            signatureName,\n            span,\n            debug,\n          };\n\n          span?.recordException(e as Error);\n\n          if (e instanceof ValidationError) {\n            errorFields = handleValidationErrorForGenerate(\n              args as HandleErrorForGenerateArgs<ValidationError>\n            );\n            err = e;\n          } else if (e instanceof AxAssertionError) {\n            errorFields = handleAssertionErrorForGenerate(\n              args as HandleErrorForGenerateArgs<AxAssertionError>\n            );\n            err = e;\n          } else if (e instanceof AxAIRefusalError) {\n            handleRefusalErrorForGenerate(\n              args as HandleErrorForGenerateArgs<AxAIRefusalError>\n            );\n          } else if (e instanceof AxAIServiceStreamTerminatedError) {\n            // Do nothing allow error correction to happen\n          } else {\n            throw enhanceError(e, ai, this.signature);\n          }\n\n          if (errorFields) {\n            mem.addRequest(\n              [\n                {\n                  role: 'user' as const,\n                  content: promptTemplate.renderExtraFields(errorFields),\n                },\n              ],\n              options.sessionId\n            );\n            mem.addTag('error', options.sessionId);\n          }\n        }\n      }\n\n      // Record max retries reached\n      const metricsInstruments = this.getMetricsInstruments();\n      if (metricsInstruments) {\n        recordErrorCorrectionMetric(\n          metricsInstruments,\n          maxRetries,\n          false, // failed\n          maxRetries,\n          this.getSignatureName()\n        );\n      }\n\n      throw enhanceError(\n        new Error(`Unable to fix validation error: ${err?.toString()}`),\n        ai,\n        this.signature\n      );\n    }\n\n    // Record max steps reached\n    if (metricsInstruments) {\n      recordMultiStepMetric(\n        metricsInstruments,\n        maxSteps,\n        maxSteps,\n        this.getSignatureName()\n      );\n    }\n\n    throw enhanceError(\n      new Error(`Max steps reached: ${maxSteps}`),\n      ai,\n      this.signature\n    );\n  }\n\n  public async *_forward1(\n    ai: Readonly<AxAIService>,\n    values: IN | AxMessage<IN>[],\n    options: Readonly<AxProgramForwardOptions<any>>\n  ): AxGenStreamingOut<OUT> {\n    // Track state creation performance\n    const stateCreationStart = performance.now();\n    const states = this.createStates(options.sampleCount ?? 1);\n    const stateCreationDuration = performance.now() - stateCreationStart;\n\n    // Record state creation performance metric\n    const metricsInstruments = this.getMetricsInstruments();\n    if (metricsInstruments) {\n      recordPerformanceMetric(\n        metricsInstruments,\n        'state_creation',\n        stateCreationDuration,\n        this.getSignatureName()\n      );\n    }\n\n    const tracer =\n      options?.tracer ?? this.options?.tracer ?? ai.getOptions().tracer;\n\n    let functions: AxFunction[] | undefined = this.functions;\n\n    if (options?.functions) {\n      functions = parseFunctions(options.functions, this.functions);\n    }\n\n    if (!tracer) {\n      yield* this._forward2(ai, values, states, {\n        ...options,\n        functions,\n      });\n      return;\n    }\n\n    const funcNames = functions?.map((f) => f.name).join(',');\n\n    const attributes = {\n      signature: JSON.stringify(this.signature.toJSON(), null, 2),\n      ...(this.examples\n        ? { examples: JSON.stringify(this.examples, null, 2) }\n        : {}),\n      ...(funcNames ? { provided_functions: funcNames } : {}),\n      ...(options?.model ? { model: options.model } : {}),\n      ...(options?.thinkingTokenBudget\n        ? { thinking_token_budget: options.thinkingTokenBudget }\n        : {}),\n      ...(options?.showThoughts ? { show_thoughts: options.showThoughts } : {}),\n      ...(options?.maxSteps ? { max_steps: options.maxSteps } : {}),\n      ...(options?.maxRetries ? { max_retries: options.maxRetries } : {}),\n    };\n\n    const traceLabel =\n      this.traceLabel && options.traceLabel\n        ? `${this.traceLabel} > ${options.traceLabel}`\n        : (options.traceLabel ?? this.traceLabel);\n    const spanName = traceLabel ? `AxGen > ${traceLabel}` : 'AxGen';\n\n    const span = tracer.startSpan(spanName, {\n      kind: SpanKind.SERVER,\n      attributes,\n    });\n\n    const currentContext = context.active();\n    const traceContext = trace.setSpan(currentContext, span);\n\n    try {\n      if (!this.excludeContentFromTrace) {\n        span.addEvent('input', { content: JSON.stringify(values, null, 2) });\n      }\n\n      yield* this._forward2(\n        ai,\n        values,\n        states,\n        {\n          ...options,\n          functions,\n        },\n        span,\n        traceContext\n      );\n\n      if (!this.excludeContentFromTrace) {\n        const valuesList = states.map((s) => s.values);\n        const values = valuesList.length === 1 ? valuesList[0] : valuesList;\n        span.addEvent('output', {\n          content: JSON.stringify(values, null, 2),\n        });\n      }\n    } finally {\n      span.end();\n    }\n  }\n\n  public async forward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): Promise<OUT> {\n    const startTime = performance.now();\n    const signatureName = this.getSignatureName();\n    const isStreaming = options?.stream ?? false;\n    let success = false;\n    let errorCorrectionAttempts = 0;\n    let functionsEnabled = false;\n    const functionsExecuted = 0;\n    let resultPickerUsed = false;\n\n    try {\n      // Record signature complexity metrics\n      const metricsInstruments = this.getMetricsInstruments();\n      if (metricsInstruments) {\n        recordSignatureComplexityMetrics(\n          metricsInstruments,\n          this.signature.getInputFields().length,\n          this.signature.getOutputFields().length,\n          this.examples?.length ?? 0,\n          this.demos?.length ?? 0,\n          signatureName\n        );\n      }\n\n      // Check if functions are enabled\n      functionsEnabled = !!(options?.functions || this.functions);\n\n      const generator = this._forward1(ai, values, options ?? {});\n\n      let buffer: AxGenDeltaOut<OUT>[] = [];\n      let currentVersion = 0;\n      let deltasEmitted = 0;\n\n      for await (const delta of generator) {\n        if (delta.version !== currentVersion) {\n          buffer = [];\n        }\n        currentVersion = delta.version;\n        buffer = mergeDeltas<OUT>(buffer, delta);\n        deltasEmitted++;\n      }\n\n      // Track error correction attempts from the version count\n      errorCorrectionAttempts = currentVersion;\n\n      // Use result picker to select from multiple samples\n      const resultPickerStart = performance.now();\n      resultPickerUsed = !!options?.resultPicker;\n\n      const selectedIndex = await selectFromSamples(\n        buffer,\n        {\n          resultPicker: options?.resultPicker as\n            | AxResultPickerFunction<OUT>\n            | undefined,\n        },\n        // Pass memory to enable function result selection\n        options?.mem,\n        options?.sessionId\n      );\n\n      const resultPickerLatency = performance.now() - resultPickerStart;\n\n      const selectedResult = buffer[selectedIndex];\n      const result = selectedResult?.delta ?? {};\n      this.trace = { ...values, ...result } as unknown as OUT;\n\n      // Log result picker usage if it was used and debug is enabled\n      if (resultPickerUsed && this.isDebug(ai, options)) {\n        const logger = this.getLogger(ai, options);\n        logResultPickerUsed(\n          buffer.length,\n          selectedIndex,\n          resultPickerLatency,\n          logger\n        );\n      }\n\n      success = true;\n\n      // Record samples metrics\n      if (metricsInstruments) {\n        recordSamplesMetric(\n          metricsInstruments,\n          buffer.length,\n          resultPickerUsed,\n          resultPickerUsed ? resultPickerLatency : undefined,\n          signatureName\n        );\n\n        // Record streaming metrics\n        recordStreamingMetric(\n          metricsInstruments,\n          isStreaming,\n          deltasEmitted,\n          undefined, // finalization latency not applicable here\n          signatureName\n        );\n      }\n\n      return result as unknown as OUT;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const duration = performance.now() - startTime;\n\n      // Record generation metrics\n      const finalMetricsInstruments = this.getMetricsInstruments();\n      if (finalMetricsInstruments) {\n        recordGenerationMetric(\n          finalMetricsInstruments,\n          duration,\n          success,\n          signatureName,\n          ai.getName(),\n          options?.model ? String(options.model) : undefined\n        );\n\n        // Record function calling metrics if functions were used\n        if (functionsEnabled) {\n          recordFunctionCallingMetric(\n            finalMetricsInstruments,\n            functionsEnabled,\n            functionsExecuted,\n            functionsExecuted > 0,\n            false, // function error correction tracking would need more complex logic\n            signatureName\n          );\n        }\n\n        // Record error correction metrics\n        if (errorCorrectionAttempts > 0) {\n          recordErrorCorrectionMetric(\n            finalMetricsInstruments,\n            errorCorrectionAttempts,\n            success,\n            options?.maxRetries ?? 10,\n            signatureName\n          );\n        }\n      }\n    }\n  }\n\n  async *streamingForward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptionsWithModels<T>>\n  ): AxGenStreamingOut<OUT> {\n    // If no result picker, use normal streaming\n    if (!options?.resultPicker) {\n      yield* this._forward1(ai, values, {\n        ...options,\n        stream: true,\n      });\n      return;\n    }\n\n    // For result picker, we need to buffer all results first\n    const generator = this._forward1(ai, values, {\n      ...options,\n      stream: true,\n    });\n\n    let buffer: AxGenDeltaOut<OUT>[] = [];\n    let currentVersion = 0;\n\n    for await (const delta of generator) {\n      if (delta.version !== currentVersion) {\n        buffer = [];\n      }\n      currentVersion = delta.version;\n      buffer = mergeDeltas<OUT>(buffer, delta);\n    }\n\n    // Use result picker to select from samples\n    const selectedIndex = await selectFromSamples(\n      buffer,\n      {\n        resultPicker: options?.resultPicker as\n          | AxResultPickerFunction<OUT>\n          | undefined,\n      },\n      // Pass memory to enable function result selection\n      options?.mem,\n      options?.sessionId\n    );\n\n    // Yield the selected result\n    const selectedResult = buffer[selectedIndex];\n    if (selectedResult) {\n      yield {\n        version: currentVersion,\n        index: selectedIndex,\n        delta: selectedResult.delta,\n      };\n    }\n  }\n\n  public override setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    super.setExamples(examples, options);\n    // No need to update prompt template - all fields can be missing in examples\n  }\n\n  private isDebug(\n    ai: Readonly<AxAIService>,\n    options?: Readonly<AxProgramForwardOptions<any>>\n  ) {\n    return (\n      options?.debug ?? this.options?.debug ?? ai.getOptions().debug ?? false\n    );\n  }\n\n  private getLogger(\n    ai: Readonly<AxAIService>,\n    options?: Readonly<AxProgramForwardOptions<any>>\n  ) {\n    return (\n      options?.logger ??\n      this.options?.logger ??\n      axGlobals.logger ??\n      ai.getLogger()\n    );\n  }\n}\n\nexport type AxGenerateErrorDetails = {\n  model?: string;\n  maxTokens?: number;\n  streaming: boolean;\n  signature: {\n    input: Readonly<AxIField[]>;\n    output: Readonly<AxIField[]>;\n    description?: string;\n  };\n};\n\ntype ErrorOptions = { cause?: Error };\n\nexport class AxGenerateError extends Error {\n  public readonly details: AxGenerateErrorDetails;\n\n  constructor(\n    message: string,\n    details: Readonly<AxGenerateErrorDetails>,\n    options?: ErrorOptions\n  ) {\n    super(message);\n    this.name = 'AxGenerateError';\n    this.details = details;\n    // Set cause property dynamically to avoid TypeScript issues\n    if (options?.cause) {\n      (this as ErrorOptions).cause = options.cause;\n    }\n  }\n}\n\nfunction enhanceError(\n  e: unknown,\n  ai: Readonly<AxAIService>,\n  signature: Readonly<AxSignature>\n): Error {\n  const originalError = e instanceof Error ? e : new Error(String(e));\n  const model = ai.getLastUsedChatModel() as string | undefined;\n  const modelConfig = ai.getLastUsedModelConfig();\n\n  const details = {\n    model: model,\n    maxTokens: modelConfig?.maxTokens,\n    streaming: modelConfig?.stream ?? false,\n    signature: {\n      input: signature.getInputFields(),\n      output: signature.getOutputFields(),\n      description: signature.getDescription(),\n    },\n  };\n\n  // Return custom error with short message and details as object property\n  return new AxGenerateError('Generate failed', details, {\n    cause: originalError,\n  });\n}\n", "// Removed debug imports - logging now handled in base.ts\nimport type {\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunctionResult,\n} from '../ai/types.js';\nimport {\n  axValidateChatRequestMessage,\n  axValidateChatResponseResult,\n} from '../ai/validate.js';\n\nimport type { AxAIMemory, AxMemoryData } from './types.js';\n\nexport class MemoryImpl {\n  private data: AxMemoryData = [];\n\n  addRequest(items: AxChatRequest['chatPrompt'], index: number): void {\n    this.data.push(\n      ...items.map((item) => {\n        const value = structuredClone(item);\n        return {\n          role: item.role,\n          chat: [{ index, value }],\n        };\n      })\n    );\n  }\n\n  addFunctionResults(results: Readonly<AxFunctionResult[]>): void {\n    const chat = results.map(({ index, ...value }) => ({\n      index,\n      value: structuredClone(value),\n    }));\n\n    const lastItem = this.getLast();\n    if (lastItem?.role === 'function') {\n      lastItem.chat.push(...chat);\n    } else {\n      this.data.push({ role: 'function', chat });\n    }\n  }\n\n  addResponse(results: Readonly<AxChatResponseResult[]>): void {\n    const chat = results.map(({ index, ...value }) => ({\n      index,\n      value: structuredClone(value),\n    }));\n\n    this.data.push({ role: 'assistant', chat });\n  }\n\n  updateResult({\n    content,\n    name,\n    functionCalls,\n    index,\n  }: Readonly<AxChatResponseResult & { index: number }>): void {\n    const lastItem = this.data.at(-1);\n\n    if (\n      !lastItem ||\n      lastItem.role !== 'assistant' ||\n      (lastItem.role === 'assistant' && !lastItem.updatable)\n    ) {\n      this.data.push({\n        role: 'assistant',\n        updatable: true,\n        chat: [\n          { index, value: structuredClone({ content, name, functionCalls }) },\n        ],\n      });\n      return;\n    }\n\n    const chat = lastItem.chat.find((v) => v.index === index);\n\n    if (!chat) {\n      lastItem.chat.push({\n        index,\n        value: structuredClone({ content, name, functionCalls }),\n      });\n      return;\n    }\n\n    if (typeof content === 'string' && content.trim() !== '') {\n      (chat.value as { content: string }).content = content;\n    }\n\n    if (typeof name === 'string' && name.trim() !== '') {\n      (chat.value as { name: string }).name = name;\n    }\n\n    if (Array.isArray(functionCalls) && functionCalls.length > 0) {\n      (chat.value as { functionCalls: typeof functionCalls }).functionCalls =\n        functionCalls;\n    }\n  }\n\n  addTag(name: string): void {\n    const lastItem = this.data.at(-1);\n    if (!lastItem) {\n      return;\n    }\n\n    if (!lastItem.tags) {\n      lastItem.tags = [];\n    }\n\n    if (!lastItem.tags.includes(name)) {\n      lastItem.tags.push(name);\n    }\n  }\n\n  rewindToTag(name: string): AxMemoryData {\n    const tagIndex = this.data.findIndex((item) => item.tags?.includes(name));\n    if (tagIndex === -1) {\n      throw new Error(`Tag \"${name}\" not found`);\n    }\n\n    // Remove and return the tagged item and everything after it\n    return this.data.splice(tagIndex);\n  }\n\n  removeByTag(name: string): AxMemoryData {\n    const indices = this.data.reduce<number[]>((acc, item, index) => {\n      if (item.tags?.includes(name)) {\n        acc.push(index);\n      }\n      return acc;\n    }, []);\n\n    if (indices.length === 0) {\n      throw new Error(`No items found with tag \"${name}\"`);\n    }\n\n    return indices\n      .reverse()\n      .map((index) => this.data.splice(index, 1).at(0))\n      .filter((item) => item !== undefined)\n      .reverse();\n  }\n\n  history(index: number): AxChatRequest['chatPrompt'] {\n    const result: AxChatRequest['chatPrompt'] = [];\n\n    for (const { role, chat } of this.data) {\n      let values: unknown;\n\n      if (role === 'function') {\n        values = chat.filter((v) => v.index === index).map((v) => v.value);\n      } else {\n        values = chat.find((v) => v.index === index)?.value;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        result.push(\n          ...values.map(\n            (v) => ({ ...v, role }) as AxChatRequest['chatPrompt'][number]\n          )\n        );\n      } else if (typeof values === 'object' && values !== null) {\n        result.push({ ...values, role } as AxChatRequest['chatPrompt'][number]);\n      }\n      // Skip when values is undefined (no matching index found)\n    }\n    return result;\n  }\n\n  getLast(): AxMemoryData[number] | undefined {\n    return this.data.at(-1);\n  }\n\n  reset(): void {\n    this.data = [];\n  }\n}\n\nexport class AxMemory implements AxAIMemory {\n  private memories = new Map<string, MemoryImpl>();\n  private defaultMemory: MemoryImpl;\n\n  constructor() {\n    this.defaultMemory = new MemoryImpl();\n  }\n\n  private getMemory(sessionId?: string): MemoryImpl {\n    if (!sessionId) {\n      return this.defaultMemory;\n    }\n\n    if (!this.memories.has(sessionId)) {\n      this.memories.set(sessionId, new MemoryImpl());\n    }\n\n    return this.memories.get(sessionId) as MemoryImpl;\n  }\n\n  addRequest(value: AxChatRequest['chatPrompt'], sessionId?: string): void {\n    for (const item of value) {\n      axValidateChatRequestMessage(item);\n    }\n    this.getMemory(sessionId).addRequest(value, 0);\n  }\n\n  addResponse(\n    results: Readonly<AxChatResponseResult[]>,\n    sessionId?: string\n  ): void {\n    axValidateChatResponseResult(results);\n    this.getMemory(sessionId).addResponse(results);\n  }\n\n  addFunctionResults(\n    results: Readonly<AxFunctionResult[]>,\n    sessionId?: string\n  ): void {\n    this.getMemory(sessionId).addFunctionResults(results);\n  }\n\n  updateResult(\n    result: Readonly<AxChatResponseResult & { delta?: string }>,\n    sessionId?: string\n  ): void {\n    this.getMemory(sessionId).updateResult(result);\n  }\n\n  addTag(name: string, sessionId?: string) {\n    this.getMemory(sessionId).addTag(name);\n  }\n\n  rewindToTag(name: string, sessionId?: string) {\n    return this.getMemory(sessionId).rewindToTag(name);\n  }\n\n  history(index: number, sessionId?: string) {\n    return this.getMemory(sessionId).history(index);\n  }\n\n  getLast(sessionId?: string) {\n    return this.getMemory(sessionId).getLast();\n  }\n\n  reset(sessionId?: string): void {\n    if (!sessionId) {\n      this.defaultMemory.reset();\n    } else {\n      this.memories.set(sessionId, new MemoryImpl());\n    }\n  }\n}\n\n// Debug functions removed - logging now handled in base.ts\n", "import type { extractionState } from './extract.js';\n\nexport interface AxAssertion {\n  fn(\n    values: Record<string, unknown>\n  ): Promise<boolean | undefined> | boolean | undefined;\n  message?: string;\n}\n\nexport interface AxStreamingAssertion {\n  fieldName: string;\n  fn(content: string, done?: boolean): boolean | undefined;\n  message?: string;\n}\n\nexport class AxAssertionError extends Error {\n  constructor({\n    message,\n  }: Readonly<{\n    message: string;\n  }>) {\n    super(message);\n    this.name = this.constructor.name;\n  }\n\n  public getFixingInstructions = () => {\n    const extraFields = [];\n    const message = this.message.trim();\n\n    extraFields.push({\n      name: 'error',\n      title: 'Follow these instructions',\n      description: message + (message.endsWith('.') ? '' : '.'),\n    });\n\n    return extraFields;\n  };\n\n  override toString(): string {\n    return `${this.name}: ${this.message}`;\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport const assertAssertions = async (\n  asserts: readonly AxAssertion[],\n  values: Record<string, unknown>\n) => {\n  for (const assert of asserts) {\n    const { fn, message } = assert;\n\n    const res = await fn(values);\n    if (res === undefined) {\n      continue;\n    }\n\n    if (!res) {\n      if (!message) {\n        throw new Error('Assertion Failed: No message provided for assertion');\n      }\n      throw new AxAssertionError({ message });\n    }\n  }\n};\n\nexport const assertStreamingAssertions = async (\n  asserts: readonly AxStreamingAssertion[],\n  xstate: Readonly<extractionState>,\n  content: string,\n  final = false\n) => {\n  if (\n    !xstate.currField ||\n    xstate.s === -1 ||\n    !asserts ||\n    asserts.length === 0\n  ) {\n    return;\n  }\n\n  const fieldAsserts = asserts.filter(\n    (a) => a.fieldName === xstate.currField?.name\n  );\n\n  if (fieldAsserts.length === 0) {\n    return;\n  }\n\n  const currValue = content.substring(xstate.s);\n\n  for (const assert of fieldAsserts) {\n    const { message, fn } = assert;\n\n    const res = await fn(currValue, final);\n    if (res === undefined) {\n      continue;\n    }\n\n    if (!res && message) {\n      throw new AxAssertionError({ message });\n    }\n  }\n};\n", "import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\nimport { axGlobals } from './globals.js';\n\n// Metrics configuration interface\nexport interface AxMetricsConfig {\n  enabled: boolean;\n  enabledCategories: (\n    | 'generation'\n    | 'streaming'\n    | 'functions'\n    | 'errors'\n    | 'performance'\n  )[];\n  maxLabelLength: number;\n  samplingRate: number;\n}\n\n// Default metrics configuration\nexport const axDefaultMetricsConfig: AxMetricsConfig = {\n  enabled: true,\n  enabledCategories: [\n    'generation',\n    'streaming',\n    'functions',\n    'errors',\n    'performance',\n  ],\n  maxLabelLength: 100,\n  samplingRate: 1.0,\n};\n\n// Standardized error categories for consistent error classification\nexport type AxErrorCategory =\n  | 'validation_error'\n  | 'assertion_error'\n  | 'timeout_error'\n  | 'abort_error'\n  | 'network_error'\n  | 'auth_error'\n  | 'rate_limit_error'\n  | 'function_error'\n  | 'parsing_error'\n  | 'unknown_error';\n\nexport interface AxGenMetricsInstruments {\n  // Generation flow metrics\n  generationLatencyHistogram?: Histogram;\n  generationRequestsCounter?: Counter;\n  generationErrorsCounter?: Counter;\n\n  // Multi-step flow metrics\n  multiStepGenerationsCounter?: Counter;\n  stepsPerGenerationHistogram?: Histogram;\n  maxStepsReachedCounter?: Counter;\n\n  // Error correction metrics\n  validationErrorsCounter?: Counter;\n  assertionErrorsCounter?: Counter;\n  errorCorrectionAttemptsHistogram?: Histogram;\n  errorCorrectionSuccessCounter?: Counter;\n  errorCorrectionFailureCounter?: Counter;\n  maxRetriesReachedCounter?: Counter;\n\n  // Function calling metrics\n  functionsEnabledGenerationsCounter?: Counter;\n  functionCallStepsCounter?: Counter;\n  functionsExecutedPerGenerationHistogram?: Histogram;\n  functionErrorCorrectionCounter?: Counter;\n\n  // Field processing metrics\n  fieldProcessorsExecutedCounter?: Counter;\n  streamingFieldProcessorsExecutedCounter?: Counter;\n\n  // Streaming specific metrics\n  streamingGenerationsCounter?: Counter;\n  streamingDeltasEmittedCounter?: Counter;\n  streamingFinalizationLatencyHistogram?: Histogram;\n\n  // Memory and samples metrics\n  samplesGeneratedHistogram?: Histogram;\n  resultPickerUsageCounter?: Counter;\n  resultPickerLatencyHistogram?: Histogram;\n\n  // Signature complexity metrics\n  inputFieldsGauge?: Gauge;\n  outputFieldsGauge?: Gauge;\n  examplesUsedGauge?: Gauge;\n  demosUsedGauge?: Gauge;\n\n  // Performance metrics\n  promptRenderLatencyHistogram?: Histogram;\n  extractionLatencyHistogram?: Histogram;\n  assertionLatencyHistogram?: Histogram;\n\n  // State management\n  stateCreationLatencyHistogram?: Histogram;\n  memoryUpdateLatencyHistogram?: Histogram;\n}\n\n// Singleton instance for metrics instruments\nlet globalGenMetricsInstruments: AxGenMetricsInstruments | undefined;\n\n// Function to get or create metrics instruments (singleton pattern)\nexport const getOrCreateGenMetricsInstruments = (\n  meter?: Meter\n): AxGenMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalGenMetricsInstruments) {\n    return globalGenMetricsInstruments;\n  }\n\n  // Try to use provided meter or fall back to global\n  const activeMeter = meter ?? axGlobals.meter;\n  if (activeMeter) {\n    globalGenMetricsInstruments = createGenMetricsInstruments(activeMeter);\n    return globalGenMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the singleton (useful for testing)\nexport const resetGenMetricsInstruments = (): void => {\n  globalGenMetricsInstruments = undefined;\n};\n\n// Health check for metrics system\nexport const axCheckMetricsHealth = (): {\n  healthy: boolean;\n  issues: string[];\n} => {\n  const issues: string[] = [];\n\n  if (!axGlobals.meter) {\n    issues.push('Global meter not initialized');\n  }\n\n  if (!globalGenMetricsInstruments && axGlobals.meter) {\n    issues.push('Metrics instruments not created despite available meter');\n  }\n\n  return {\n    healthy: issues.length === 0,\n    issues,\n  };\n};\n\nexport const createGenMetricsInstruments = (\n  meter: Meter\n): AxGenMetricsInstruments => {\n  return {\n    // Generation flow metrics\n    // Note: Histogram buckets should be configured at the exporter level\n    // Recommended buckets: [1, 5, 10, 25, 50, 100, 250, 500, 1000, 2500, 5000, 10000] ms\n    generationLatencyHistogram: meter.createHistogram(\n      'ax_gen_generation_duration_ms',\n      {\n        description: 'End-to-end duration of AxGen generation requests',\n        unit: 'ms',\n      }\n    ),\n\n    generationRequestsCounter: meter.createCounter(\n      'ax_gen_generation_requests_total',\n      {\n        description: 'Total number of AxGen generation requests',\n      }\n    ),\n\n    generationErrorsCounter: meter.createCounter(\n      'ax_gen_generation_errors_total',\n      {\n        description: 'Total number of failed AxGen generations',\n      }\n    ),\n\n    // Multi-step flow metrics\n    multiStepGenerationsCounter: meter.createCounter(\n      'ax_gen_multistep_generations_total',\n      {\n        description: 'Total number of generations that required multiple steps',\n      }\n    ),\n\n    stepsPerGenerationHistogram: meter.createHistogram(\n      'ax_gen_steps_per_generation',\n      {\n        description: 'Number of steps taken per generation',\n      }\n    ),\n\n    maxStepsReachedCounter: meter.createCounter(\n      'ax_gen_max_steps_reached_total',\n      {\n        description: 'Total number of generations that hit max steps limit',\n      }\n    ),\n\n    // Error correction metrics\n    validationErrorsCounter: meter.createCounter(\n      'ax_gen_validation_errors_total',\n      {\n        description: 'Total number of validation errors encountered',\n      }\n    ),\n\n    assertionErrorsCounter: meter.createCounter(\n      'ax_gen_assertion_errors_total',\n      {\n        description: 'Total number of assertion errors encountered',\n      }\n    ),\n\n    errorCorrectionAttemptsHistogram: meter.createHistogram(\n      'ax_gen_error_correction_attempts',\n      {\n        description: 'Number of error correction attempts per generation',\n      }\n    ),\n\n    errorCorrectionSuccessCounter: meter.createCounter(\n      'ax_gen_error_correction_success_total',\n      {\n        description: 'Total number of successful error corrections',\n      }\n    ),\n\n    errorCorrectionFailureCounter: meter.createCounter(\n      'ax_gen_error_correction_failure_total',\n      {\n        description: 'Total number of failed error corrections',\n      }\n    ),\n\n    maxRetriesReachedCounter: meter.createCounter(\n      'ax_gen_max_retries_reached_total',\n      {\n        description: 'Total number of generations that hit max retries limit',\n      }\n    ),\n\n    // Function calling metrics\n    functionsEnabledGenerationsCounter: meter.createCounter(\n      'ax_gen_functions_enabled_generations_total',\n      {\n        description: 'Total number of generations with functions enabled',\n      }\n    ),\n\n    functionCallStepsCounter: meter.createCounter(\n      'ax_gen_function_call_steps_total',\n      {\n        description: 'Total number of steps that included function calls',\n      }\n    ),\n\n    functionsExecutedPerGenerationHistogram: meter.createHistogram(\n      'ax_gen_functions_executed_per_generation',\n      {\n        description: 'Number of unique functions executed per generation',\n      }\n    ),\n\n    functionErrorCorrectionCounter: meter.createCounter(\n      'ax_gen_function_error_correction_total',\n      {\n        description: 'Total number of function-related error corrections',\n      }\n    ),\n\n    // Field processing metrics\n    fieldProcessorsExecutedCounter: meter.createCounter(\n      'ax_gen_field_processors_executed_total',\n      {\n        description: 'Total number of field processors executed',\n      }\n    ),\n\n    streamingFieldProcessorsExecutedCounter: meter.createCounter(\n      'ax_gen_streaming_field_processors_executed_total',\n      {\n        description: 'Total number of streaming field processors executed',\n      }\n    ),\n\n    // Streaming specific metrics\n    streamingGenerationsCounter: meter.createCounter(\n      'ax_gen_streaming_generations_total',\n      {\n        description: 'Total number of streaming generations',\n      }\n    ),\n\n    streamingDeltasEmittedCounter: meter.createCounter(\n      'ax_gen_streaming_deltas_emitted_total',\n      {\n        description: 'Total number of streaming deltas emitted',\n      }\n    ),\n\n    streamingFinalizationLatencyHistogram: meter.createHistogram(\n      'ax_gen_streaming_finalization_duration_ms',\n      {\n        description: 'Duration of streaming response finalization',\n        unit: 'ms',\n      }\n    ),\n\n    // Memory and samples metrics\n    samplesGeneratedHistogram: meter.createHistogram(\n      'ax_gen_samples_generated',\n      {\n        description: 'Number of samples generated per request',\n      }\n    ),\n\n    resultPickerUsageCounter: meter.createCounter(\n      'ax_gen_result_picker_usage_total',\n      {\n        description: 'Total number of times result picker was used',\n      }\n    ),\n\n    resultPickerLatencyHistogram: meter.createHistogram(\n      'ax_gen_result_picker_duration_ms',\n      {\n        description: 'Duration of result picker execution',\n        unit: 'ms',\n      }\n    ),\n\n    // Signature complexity metrics\n    inputFieldsGauge: meter.createGauge('ax_gen_input_fields', {\n      description: 'Number of input fields in signature',\n    }),\n\n    outputFieldsGauge: meter.createGauge('ax_gen_output_fields', {\n      description: 'Number of output fields in signature',\n    }),\n\n    examplesUsedGauge: meter.createGauge('ax_gen_examples_used', {\n      description: 'Number of examples used in generation',\n    }),\n\n    demosUsedGauge: meter.createGauge('ax_gen_demos_used', {\n      description: 'Number of demos used in generation',\n    }),\n\n    // Performance metrics\n    promptRenderLatencyHistogram: meter.createHistogram(\n      'ax_gen_prompt_render_duration_ms',\n      {\n        description: 'Duration of prompt template rendering',\n        unit: 'ms',\n      }\n    ),\n\n    extractionLatencyHistogram: meter.createHistogram(\n      'ax_gen_extraction_duration_ms',\n      {\n        description: 'Duration of value extraction from responses',\n        unit: 'ms',\n      }\n    ),\n\n    assertionLatencyHistogram: meter.createHistogram(\n      'ax_gen_assertion_duration_ms',\n      {\n        description: 'Duration of assertion checking',\n        unit: 'ms',\n      }\n    ),\n\n    // State management\n    stateCreationLatencyHistogram: meter.createHistogram(\n      'ax_gen_state_creation_duration_ms',\n      {\n        description: 'Duration of state creation for multiple samples',\n        unit: 'ms',\n      }\n    ),\n\n    memoryUpdateLatencyHistogram: meter.createHistogram(\n      'ax_gen_memory_update_duration_ms',\n      {\n        description: 'Duration of memory updates during generation',\n        unit: 'ms',\n      }\n    ),\n  };\n};\n\n// Global metrics configuration\nlet currentMetricsConfig: AxMetricsConfig = axDefaultMetricsConfig;\n\n// Function to update metrics configuration\nexport const axUpdateMetricsConfig = (\n  config: Readonly<Partial<AxMetricsConfig>>\n): void => {\n  currentMetricsConfig = { ...currentMetricsConfig, ...config };\n};\n\n// Function to get current metrics configuration\nexport const axGetMetricsConfig = (): AxMetricsConfig => {\n  return { ...currentMetricsConfig };\n};\n\n// Utility function to sanitize metric labels\nconst sanitizeLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length based on configuration\n      const maxLength = currentMetricsConfig.maxLabelLength;\n      sanitized[key] =\n        stringValue.length > maxLength\n          ? stringValue.substring(0, maxLength)\n          : stringValue;\n    }\n  }\n  return sanitized;\n};\n\n// Recording functions for generation flow metrics\nexport const recordGenerationMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  duration: number,\n  success: boolean,\n  signatureName?: string,\n  aiService?: string,\n  model?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      success: success.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n      ...(aiService ? { ai_service: aiService } : {}),\n      ...(model ? { model } : {}),\n    });\n\n    if (instruments.generationLatencyHistogram) {\n      instruments.generationLatencyHistogram.record(duration, labels);\n    }\n\n    if (instruments.generationRequestsCounter) {\n      instruments.generationRequestsCounter.add(1, labels);\n    }\n\n    if (!success && instruments.generationErrorsCounter) {\n      instruments.generationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    // Log error but don't propagate to avoid breaking the main flow\n    console.warn('Failed to record generation metric:', error);\n  }\n};\n\n// Recording functions for multi-step metrics\nexport const recordMultiStepMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  stepsUsed: number,\n  maxSteps: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (stepsUsed > 1 && instruments.multiStepGenerationsCounter) {\n      instruments.multiStepGenerationsCounter.add(1, labels);\n    }\n\n    if (instruments.stepsPerGenerationHistogram) {\n      instruments.stepsPerGenerationHistogram.record(stepsUsed, labels);\n    }\n\n    if (stepsUsed >= maxSteps && instruments.maxStepsReachedCounter) {\n      instruments.maxStepsReachedCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record multi-step metric:', error);\n  }\n};\n\n// Recording functions for error correction metrics\nexport const recordValidationErrorMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  errorType: 'validation' | 'assertion',\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      error_type: errorType,\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (errorType === 'validation' && instruments.validationErrorsCounter) {\n      instruments.validationErrorsCounter.add(1, labels);\n    }\n\n    if (errorType === 'assertion' && instruments.assertionErrorsCounter) {\n      instruments.assertionErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record validation error metric:', error);\n  }\n};\n\nexport const recordRefusalErrorMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      error_type: 'refusal',\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    // For now, we'll count refusal errors as validation errors since they trigger retry loops\n    if (instruments.validationErrorsCounter) {\n      instruments.validationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record refusal error metric:', error);\n  }\n};\n\nexport const recordErrorCorrectionMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  attempts: number,\n  success: boolean,\n  maxRetries: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      success: success.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.errorCorrectionAttemptsHistogram) {\n      instruments.errorCorrectionAttemptsHistogram.record(attempts, labels);\n    }\n\n    if (success && instruments.errorCorrectionSuccessCounter) {\n      instruments.errorCorrectionSuccessCounter.add(1, labels);\n    }\n\n    if (!success) {\n      if (instruments.errorCorrectionFailureCounter) {\n        instruments.errorCorrectionFailureCounter.add(1, labels);\n      }\n      if (attempts >= maxRetries && instruments.maxRetriesReachedCounter) {\n        instruments.maxRetriesReachedCounter.add(1, labels);\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to record error correction metric:', error);\n  }\n};\n\n// Recording functions for function calling metrics\nexport const recordFunctionCallingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  functionsEnabled: boolean,\n  functionsExecuted: number,\n  hadFunctionCalls: boolean,\n  functionErrorCorrection = false,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      functions_enabled: functionsEnabled.toString(),\n      had_function_calls: hadFunctionCalls.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (functionsEnabled && instruments.functionsEnabledGenerationsCounter) {\n      instruments.functionsEnabledGenerationsCounter.add(1, labels);\n    }\n\n    if (hadFunctionCalls && instruments.functionCallStepsCounter) {\n      instruments.functionCallStepsCounter.add(1, labels);\n    }\n\n    if (\n      functionsExecuted > 0 &&\n      instruments.functionsExecutedPerGenerationHistogram\n    ) {\n      instruments.functionsExecutedPerGenerationHistogram.record(\n        functionsExecuted,\n        labels\n      );\n    }\n\n    if (functionErrorCorrection && instruments.functionErrorCorrectionCounter) {\n      instruments.functionErrorCorrectionCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record function calling metric:', error);\n  }\n};\n\n// Recording functions for field processing metrics\nexport const recordFieldProcessingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  fieldProcessorsExecuted: number,\n  streamingFieldProcessorsExecuted: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (\n      fieldProcessorsExecuted > 0 &&\n      instruments.fieldProcessorsExecutedCounter\n    ) {\n      instruments.fieldProcessorsExecutedCounter.add(\n        fieldProcessorsExecuted,\n        labels\n      );\n    }\n\n    if (\n      streamingFieldProcessorsExecuted > 0 &&\n      instruments.streamingFieldProcessorsExecutedCounter\n    ) {\n      instruments.streamingFieldProcessorsExecutedCounter.add(\n        streamingFieldProcessorsExecuted,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record field processing metric:', error);\n  }\n};\n\n// Recording functions for streaming metrics\nexport const recordStreamingMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  isStreaming: boolean,\n  deltasEmitted: number,\n  finalizationDuration?: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      is_streaming: isStreaming.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (isStreaming && instruments.streamingGenerationsCounter) {\n      instruments.streamingGenerationsCounter.add(1, labels);\n    }\n\n    if (deltasEmitted > 0 && instruments.streamingDeltasEmittedCounter) {\n      instruments.streamingDeltasEmittedCounter.add(deltasEmitted, labels);\n    }\n\n    if (\n      finalizationDuration &&\n      instruments.streamingFinalizationLatencyHistogram\n    ) {\n      instruments.streamingFinalizationLatencyHistogram.record(\n        finalizationDuration,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record streaming metric:', error);\n  }\n};\n\n// Recording functions for samples metrics\nexport const recordSamplesMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  samplesCount: number,\n  resultPickerUsed: boolean,\n  resultPickerLatency?: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      result_picker_used: resultPickerUsed.toString(),\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.samplesGeneratedHistogram) {\n      instruments.samplesGeneratedHistogram.record(samplesCount, labels);\n    }\n\n    if (resultPickerUsed && instruments.resultPickerUsageCounter) {\n      instruments.resultPickerUsageCounter.add(1, labels);\n    }\n\n    if (resultPickerLatency && instruments.resultPickerLatencyHistogram) {\n      instruments.resultPickerLatencyHistogram.record(\n        resultPickerLatency,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record samples metric:', error);\n  }\n};\n\n// Recording functions for signature complexity metrics\nexport const recordSignatureComplexityMetrics = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  inputFields: number,\n  outputFields: number,\n  examplesCount: number,\n  demosCount: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    if (instruments.inputFieldsGauge) {\n      instruments.inputFieldsGauge.record(inputFields, labels);\n    }\n\n    if (instruments.outputFieldsGauge) {\n      instruments.outputFieldsGauge.record(outputFields, labels);\n    }\n\n    if (instruments.examplesUsedGauge) {\n      instruments.examplesUsedGauge.record(examplesCount, labels);\n    }\n\n    if (instruments.demosUsedGauge) {\n      instruments.demosUsedGauge.record(demosCount, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record signature complexity metrics:', error);\n  }\n};\n\n// Recording functions for performance metrics\nexport const recordPerformanceMetric = (\n  instruments: Readonly<AxGenMetricsInstruments>,\n  metricType:\n    | 'prompt_render'\n    | 'extraction'\n    | 'assertion'\n    | 'state_creation'\n    | 'memory_update',\n  duration: number,\n  signatureName?: string\n): void => {\n  try {\n    const labels = sanitizeLabels({\n      metric_type: metricType,\n      ...(signatureName ? { signature: signatureName } : {}),\n    });\n\n    switch (metricType) {\n      case 'prompt_render':\n        if (instruments.promptRenderLatencyHistogram) {\n          instruments.promptRenderLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'extraction':\n        if (instruments.extractionLatencyHistogram) {\n          instruments.extractionLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'assertion':\n        if (instruments.assertionLatencyHistogram) {\n          instruments.assertionLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'state_creation':\n        if (instruments.stateCreationLatencyHistogram) {\n          instruments.stateCreationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'memory_update':\n        if (instruments.memoryUpdateLatencyHistogram) {\n          instruments.memoryUpdateLatencyHistogram.record(duration, labels);\n        }\n        break;\n    }\n  } catch (error) {\n    console.warn('Failed to record performance metric:', error);\n  }\n};\n", "import type { Span } from '@opentelemetry/api';\nimport {\n  logAssertionError,\n  logRefusalError,\n  logValidationError,\n} from '../ai/debug.js';\nimport type { AxLoggerFunction } from '../ai/types.js';\nimport type { AxAIRefusalError } from '../util/apicall.js';\nimport type { AxAssertionError } from './asserts.js';\nimport type { AxGenMetricsInstruments } from './metrics.js';\nimport {\n  recordRefusalErrorMetric,\n  recordValidationErrorMetric,\n} from './metrics.js';\nimport type { AxField } from './sig.js';\n\nexport class ValidationError extends Error {\n  private fields: AxField[];\n\n  constructor({\n    message,\n    fields,\n  }: Readonly<{\n    message: string;\n    fields: AxField[];\n    value?: string;\n  }>) {\n    super(message);\n    this.fields = fields;\n    this.name = this.constructor.name;\n  }\n\n  public getFixingInstructions = () => {\n    const toFieldType = (type: Readonly<AxField['type']>) => {\n      const baseType = (() => {\n        switch (type?.name) {\n          case 'string':\n            return 'string';\n          case 'number':\n            return 'number';\n          case 'boolean':\n            return 'boolean';\n          case 'date':\n            return 'date (\"YYYY-MM-DD\" format)';\n          case 'datetime':\n            return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n          case 'json':\n            return 'JSON object';\n          case 'class':\n            return 'classification class';\n          case 'code':\n            return 'code';\n          default:\n            return 'string';\n        }\n      })();\n\n      return type?.isArray ? `json array of ${baseType} items` : baseType;\n    };\n\n    return this.fields.map((field) => ({\n      name: 'outputError',\n      title: 'Output Correction Required',\n      description: `The section labeled '${field.title}' does not match the expected format of '${toFieldType(field.type)}'. ${this.message} Please revise your response to ensure it conforms to the specified format.`,\n    }));\n  };\n\n  override toString(): string {\n    const toFieldType = (type: Readonly<AxField['type']>) => {\n      const baseType = (() => {\n        switch (type?.name) {\n          case 'string':\n            return 'string';\n          case 'number':\n            return 'number';\n          case 'boolean':\n            return 'boolean';\n          case 'date':\n            return 'date (\"YYYY-MM-DD\" format)';\n          case 'datetime':\n            return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n          case 'json':\n            return 'JSON object';\n          case 'class':\n            return 'classification class';\n          case 'code':\n            return 'code';\n          default:\n            return 'string';\n        }\n      })();\n\n      return type?.isArray ? `json array of ${baseType} items` : baseType;\n    };\n\n    return [\n      `${this.name}: ${this.message}`,\n      ...this.fields.map(\n        (field) =>\n          `  - ${field.title}: Expected format '${toFieldType(field.type)}'`\n      ),\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport type HandleErrorForGenerateArgs<TError extends Error> = {\n  error: TError;\n  errCount: number;\n  logger: AxLoggerFunction | undefined;\n  metricsInstruments: AxGenMetricsInstruments | undefined;\n  signatureName: string;\n  span: Span | undefined;\n  debug: boolean;\n};\n\n/**\n * Handles validation errors with logging, metrics, and telemetry\n */\nexport const handleValidationErrorForGenerate = ({\n  error,\n  errCount,\n  debug,\n  logger,\n  metricsInstruments,\n  signatureName,\n  span,\n}: HandleErrorForGenerateArgs<ValidationError>) => {\n  const errorFields = error.getFixingInstructions();\n\n  // Log validation error with proper structured logging\n  if (debug && logger) {\n    const fixingInstructions =\n      errorFields?.map((f) => f.title).join(', ') ?? '';\n    logValidationError(error, errCount, fixingInstructions, logger);\n  }\n\n  // Record validation error metric\n  if (metricsInstruments) {\n    recordValidationErrorMetric(\n      metricsInstruments,\n      'validation',\n      signatureName\n    );\n  }\n\n  // Add telemetry event for validation error\n  if (span) {\n    span.addEvent('validation.error', {\n      message: error.toString(),\n      fixing_instructions: errorFields?.map((f) => f.title).join(', ') ?? '',\n    });\n  }\n\n  return errorFields;\n};\n\n/**\n * Handles assertion errors with logging, metrics, and telemetry\n */\nexport const handleAssertionErrorForGenerate = ({\n  error,\n  errCount,\n  debug,\n  logger,\n  metricsInstruments,\n  signatureName,\n  span,\n}: HandleErrorForGenerateArgs<AxAssertionError>) => {\n  const errorFields = error.getFixingInstructions();\n\n  // Log assertion error with proper structured logging\n  if (debug && logger) {\n    const fixingInstructions =\n      errorFields?.map((f) => f.title).join(', ') ?? '';\n    logAssertionError(error, errCount, fixingInstructions, logger);\n  }\n\n  // Record assertion error metric\n  if (metricsInstruments) {\n    recordValidationErrorMetric(metricsInstruments, 'assertion', signatureName);\n  }\n\n  // Add telemetry event for assertion error\n  if (span) {\n    span.addEvent('assertion.error', {\n      message: error.toString(),\n      fixing_instructions: errorFields?.map((f) => f.title).join(', ') ?? '',\n    });\n  }\n\n  return errorFields;\n};\n\n/**\n * Handles refusal errors with logging, metrics, and telemetry\n */\nexport const handleRefusalErrorForGenerate = ({\n  error,\n  errCount,\n  debug,\n  logger,\n  metricsInstruments,\n  signatureName,\n  span,\n}: HandleErrorForGenerateArgs<AxAIRefusalError>) => {\n  // Log refusal error with proper structured logging\n  if (debug && logger) {\n    logRefusalError(error, errCount, logger);\n  }\n\n  // Record refusal error metric\n  if (metricsInstruments) {\n    recordRefusalErrorMetric(metricsInstruments, signatureName);\n  }\n\n  // Add telemetry event for refusal error\n  if (span) {\n    span.addEvent('refusal.error', {\n      message: error.toString(),\n    });\n  }\n};\n", "import type { AxFunctionJSONSchema } from '../ai/types.js';\n\n// Extended type to handle flexible JSON schemas with union types\ntype FlexibleJSONSchema = AxFunctionJSONSchema & {\n  anyOf?: FlexibleJSONSchema[];\n  oneOf?: FlexibleJSONSchema[];\n  allOf?: FlexibleJSONSchema[];\n  properties?: Record<string, FlexibleJSONSchema | undefined>;\n};\n\ninterface ValidationError {\n  path: string;\n  issue: string;\n  fix: string;\n  example?: string;\n}\n\nexport const validateJSONSchema = (\n  schema: Readonly<AxFunctionJSONSchema>\n): void => {\n  const errors: ValidationError[] = [];\n\n  const validateSchemaObject = (\n    schema: Readonly<FlexibleJSONSchema | undefined>,\n    path = ''\n  ): void => {\n    // Skip validation if schema is undefined or null\n    if (!schema || typeof schema !== 'object') {\n      return;\n    }\n\n    const validTypes = [\n      'array',\n      'integer',\n      'number',\n      'string',\n      'boolean',\n      'null',\n      'object',\n    ];\n\n    // Handle schemas with anyOf (union types)\n    if (schema.anyOf && Array.isArray(schema.anyOf)) {\n      if (schema.anyOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'anyOf array is empty',\n          fix: 'Add at least one schema to the anyOf array',\n          example: 'anyOf: [{ type: \"string\" }, { type: \"null\" }]',\n        });\n      }\n      // Validate each schema in anyOf\n      schema.anyOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}anyOf[${index}].`);\n      });\n      return;\n    }\n\n    // Handle schemas with oneOf\n    if (schema.oneOf && Array.isArray(schema.oneOf)) {\n      if (schema.oneOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'oneOf array is empty',\n          fix: 'Add at least one schema to the oneOf array',\n          example: 'oneOf: [{ type: \"string\" }, { type: \"number\" }]',\n        });\n      }\n      schema.oneOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}oneOf[${index}].`);\n      });\n      return;\n    }\n\n    // Handle schemas with allOf\n    if (schema.allOf && Array.isArray(schema.allOf)) {\n      if (schema.allOf.length === 0) {\n        errors.push({\n          path: path || 'root',\n          issue: 'allOf array is empty',\n          fix: 'Add at least one schema to the allOf array',\n          example:\n            'allOf: [{ type: \"object\" }, { properties: { name: { type: \"string\" } } }]',\n        });\n      }\n      schema.allOf.forEach((subSchema: FlexibleJSONSchema, index: number) => {\n        validateSchemaObject(subSchema, `${path}allOf[${index}].`);\n      });\n      return;\n    }\n\n    // Skip validation if no type is specified (might be a reference or other valid schema)\n    if (!schema.type) {\n      return;\n    }\n\n    if (!validTypes.includes(schema.type)) {\n      errors.push({\n        path: path || 'root',\n        issue: `Invalid type '${schema.type}'`,\n        fix: `Change type to one of: ${validTypes.join(', ')}`,\n        example: `{ type: \"string\" } or { type: \"object\" }`,\n      });\n      return;\n    }\n\n    if (schema.type === 'object') {\n      if (schema.properties) {\n        if (\n          typeof schema.properties !== 'object' ||\n          Array.isArray(schema.properties)\n        ) {\n          errors.push({\n            path: path || 'root',\n            issue: 'properties must be an object, not an array or primitive',\n            fix: 'Change properties to be an object with property names as keys',\n            example:\n              'properties: { name: { type: \"string\" }, age: { type: \"number\" } }',\n          });\n        } else {\n          for (const key in schema.properties) {\n            const value = schema.properties[key];\n            // Skip undefined or null properties\n            if (value === undefined || value === null) {\n              continue;\n            }\n            if (typeof value !== 'object') {\n              errors.push({\n                path: `${path}${key}`,\n                issue: `Property schema must be an object, got ${typeof value}`,\n                fix: 'Define the property as a proper schema object',\n                example: `${key}: { type: \"string\", description: \"...\" }`,\n              });\n              continue;\n            }\n            validateSchemaObject(value, `${path}${key}.`);\n          }\n        }\n      }\n\n      if (schema.required) {\n        if (!Array.isArray(schema.required)) {\n          errors.push({\n            path: path || 'root',\n            issue: `'required' must be an array, got ${typeof schema.required}`,\n            fix: 'Change required to be an array of property names',\n            example:\n              'required: [\"name\", \"email\"] instead of required: \"name,email\"',\n          });\n        } else if (schema.required.length === 0) {\n          // This is valid but might be worth noting\n        } else {\n          // Validate that required properties exist in properties\n          if (schema.properties) {\n            for (const requiredProp of schema.required) {\n              if (typeof requiredProp !== 'string') {\n                errors.push({\n                  path: `${path}required`,\n                  issue: `Required property names must be strings, got ${typeof requiredProp}`,\n                  fix: 'Ensure all items in required array are strings',\n                  example:\n                    'required: [\"name\", \"email\"] not required: [123, \"email\"]',\n                });\n              } else if (!(requiredProp in schema.properties)) {\n                errors.push({\n                  path: `${path}required`,\n                  issue: `Required property '${requiredProp}' is not defined in properties`,\n                  fix: `Either add '${requiredProp}' to properties or remove it from required`,\n                  example: `properties: { ${requiredProp}: { type: \"string\" } }`,\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (schema.type === 'array') {\n      if (schema.items) {\n        if (typeof schema.items !== 'object') {\n          errors.push({\n            path: `${path}items`,\n            issue: `Array items schema must be an object, got ${typeof schema.items}`,\n            fix: 'Define items as a proper schema object',\n            example:\n              'items: { type: \"string\" } or items: { type: \"object\", properties: {...} }',\n          });\n        } else {\n          validateSchemaObject(schema.items, `${path}items.`);\n        }\n      }\n    }\n  };\n\n  validateSchemaObject(schema);\n\n  if (errors.length > 0) {\n    const errorMessage = [\n      'JSON Schema validation failed:',\n      '',\n      ...errors.map((error, index) => {\n        const parts = [\n          `${index + 1}. Path: ${error.path}`,\n          `   Issue: ${error.issue}`,\n          `   Fix: ${error.fix}`,\n        ];\n        if (error.example) {\n          parts.push(`   Example: ${error.example}`);\n        }\n        return parts.join('\\n');\n      }),\n      '',\n      'Please fix these issues and try again.',\n    ].join('\\n');\n\n    throw new Error(errorMessage);\n  }\n};\n\n// Example Usage:\n\n/*\nconst validSchema: AxFunctionJSONSchema = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'string' },\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    },\n    optionalField: {\n      anyOf: [\n        { type: 'string' },\n        { type: 'null' }\n      ]\n    }\n  },\n  required: ['id', 'name', 'email']\n};\n\nconst invalidSchema: any = {\n  type: 'object',\n  properties: {\n    id: { type: 'integer' },\n    name: { type: 'string' },\n    email: { type: 'unknownType' }, // Invalid type\n    isActive: { type: 'boolean' },\n    tags: {\n      type: 'array',\n      items: { type: 'string' }\n    }\n  },\n  required: 'id,name,email' // Invalid 'required' field\n};\n\ntry {\n  validateJSONSchema(validSchema);\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n\ntry {\n  validateJSONSchema(invalidSchema);\n} catch (error) {\n  console.error('Schema validation failed:', error.message);\n}\n*/\n", "import { logFunctionError, logFunctionResults } from '../ai/debug.js';\nimport type {\n  AxAIService,\n  AxChatRequest,\n  AxChatResponseResult,\n  AxFunction,\n  AxFunctionResult,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport type { AxMemory } from '../mem/memory.js';\nimport { axGlobals } from './globals.js';\nimport { validateJSONSchema } from './jsonschema.js';\nimport type { AxProgramForwardOptions } from './types.js';\n\nexport class AxFunctionError extends Error {\n  constructor(\n    private fields: {\n      field: string;\n      message: string;\n    }[]\n  ) {\n    super();\n    this.name = this.constructor.name;\n  }\n\n  getFields = () => this.fields;\n\n  override toString(): string {\n    return [\n      `${this.name}: Function validation error`,\n      ...this.fields.map((field) => `  - ${field.field}: ${field.message}`),\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\ntype FunctionFieldErrors = ConstructorParameters<typeof AxFunctionError>[0];\n\nexport class FunctionError extends Error {\n  constructor(\n    private readonly fields: FunctionFieldErrors,\n    private readonly func: Readonly<AxFunction>,\n    private readonly funcId?: string\n  ) {\n    super();\n  }\n\n  getFunctionId = () => this.funcId;\n\n  private getFieldDescription(fieldName: string): string {\n    if (!this.func.parameters?.properties?.[fieldName]) {\n      return '';\n    }\n\n    const fieldSchema = this.func.parameters.properties[fieldName];\n    let description = fieldSchema.description;\n\n    if (fieldSchema.enum?.length) {\n      description += ` Allowed values are: ${fieldSchema.enum.join(', ')}`;\n    }\n\n    return description;\n  }\n\n  public getFixingInstructions = () => {\n    const bulletPoints = this.fields.map((fieldError) => {\n      const schemaDescription =\n        this.getFieldDescription(fieldError.field) || '';\n      return `- \\`${fieldError.field}\\` - ${fieldError.message} (${schemaDescription}).`;\n    });\n\n    return `Errors In Function Arguments: Fix the following invalid arguments to '${this.func.name}'\\n${bulletPoints.join('\\n')}`;\n  };\n\n  override toString(): string {\n    return [\n      `${this.name}: Function execution error in '${this.func.name}'`,\n      ...this.fields.map((field) => {\n        const description = this.getFieldDescription(field.field);\n        return `  - ${field.field}: ${field.message}${description ? ` (${description})` : ''}`;\n      }),\n      this.funcId ? `  Function ID: ${this.funcId}` : '',\n    ].join('\\n');\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')](\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _depth: number,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _options: Record<string, unknown>\n  ) {\n    return this.toString();\n  }\n}\n\nexport type AxChatResponseFunctionCall = {\n  id: string;\n  name: string;\n  args: string;\n};\n\nexport class AxFunctionProcessor {\n  private funcList: Readonly<AxFunction[]> = [];\n\n  constructor(funcList: Readonly<AxFunction[]>) {\n    this.funcList = funcList;\n  }\n\n  private executeFunction = async <MODEL>(\n    fnSpec: Readonly<AxFunction>,\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<AxProgramForwardOptions<MODEL>>\n  ) => {\n    let args: unknown;\n\n    if (typeof func.args === 'string' && func.args.length > 0) {\n      args = JSON.parse(func.args);\n    } else {\n      args = func.args;\n    }\n\n    const opt = options\n      ? {\n          sessionId: options.sessionId,\n          ai: options.ai,\n        }\n      : undefined;\n\n    let res: unknown;\n    if (!fnSpec.parameters) {\n      res =\n        fnSpec.func.length === 1 ? await fnSpec.func(opt) : await fnSpec.func();\n    } else {\n      res =\n        fnSpec.func.length === 2\n          ? await fnSpec.func(args, opt)\n          : await fnSpec.func(args);\n    }\n\n    // Use the formatter from options or fall back to globals\n    const formatter =\n      options?.functionResultFormatter ?? axGlobals.functionResultFormatter;\n    return formatter(res);\n  };\n\n  public execute = async <MODEL>(\n    func: Readonly<AxChatResponseFunctionCall>,\n    options?: Readonly<AxProgramForwardOptions<MODEL>>\n  ) => {\n    const fnSpec = this.funcList.find(\n      (v) => v.name.localeCompare(func.name) === 0\n    );\n    if (!fnSpec) {\n      throw new Error(`Function not found: ${func.name}`);\n    }\n    if (!fnSpec.func) {\n      throw new Error(`No handler for function: ${func.name}`);\n    }\n\n    // execute value function calls\n    try {\n      return await this.executeFunction<MODEL>(fnSpec, func, options);\n    } catch (e) {\n      if (e instanceof AxFunctionError) {\n        throw new FunctionError(e.getFields(), fnSpec, func.id);\n      }\n      throw e;\n    }\n  };\n}\n\nexport type AxInputFunctionType = (\n  | AxFunction\n  | {\n      toFunction: () => AxFunction | AxFunction[];\n    }\n)[];\n\nexport const parseFunctions = (\n  newFuncs: Readonly<AxInputFunctionType>,\n  existingFuncs?: readonly AxFunction[]\n): AxFunction[] => {\n  if (newFuncs.length === 0) {\n    return [...(existingFuncs ?? [])];\n  }\n\n  // biome-ignore lint/complexity/useFlatMap: cannot use flatMap here\n  const functions = newFuncs\n    .map((f) => {\n      if ('toFunction' in f) {\n        return f.toFunction();\n      }\n      return f;\n    })\n    .flat();\n\n  for (const fn of functions.filter((v) => v.parameters)) {\n    if (fn.parameters) {\n      validateJSONSchema(fn.parameters);\n    }\n  }\n\n  return [...(existingFuncs ?? []), ...functions];\n};\n\ntype ProcessFunctionsArgs = {\n  ai: Readonly<AxAIService>;\n  functionList: Readonly<AxFunction[]>;\n  functionCalls: readonly AxChatResponseFunctionCall[];\n  mem: Readonly<AxMemory>;\n  sessionId?: string;\n  traceId?: string;\n  span?: import('@opentelemetry/api').Span;\n  excludeContentFromTrace?: boolean;\n  index: number;\n  functionResultFormatter?: (result: unknown) => string;\n  logger: AxLoggerFunction;\n};\n\nexport const processFunctions = async ({\n  ai,\n  functionList,\n  functionCalls,\n  mem,\n  sessionId,\n  span,\n  excludeContentFromTrace,\n  index,\n  functionResultFormatter,\n  logger,\n}: Readonly<ProcessFunctionsArgs>) => {\n  const funcProc = new AxFunctionProcessor(functionList);\n  const functionsExecuted = new Set<string>();\n\n  // Map each function call to a promise that resolves to the function result or null\n  const promises = functionCalls.map((func) => {\n    if (!func.id) {\n      throw new Error(`Function ${func.name} did not return an ID`);\n    }\n\n    const promise: Promise<AxFunctionResult | undefined> = funcProc\n      .execute(func, { sessionId, ai, functionResultFormatter })\n      .then((functionResult) => {\n        functionsExecuted.add(func.name.toLowerCase());\n\n        // Add telemetry event for successful function call\n        if (span) {\n          const eventData: { name: string; args?: string; result?: string } = {\n            name: func.name,\n          };\n          if (!excludeContentFromTrace) {\n            eventData.args = func.args;\n            eventData.result = functionResult ?? '';\n          }\n          span.addEvent('function.call', eventData);\n        }\n\n        return {\n          result: functionResult ?? '',\n          role: 'function' as const,\n          functionId: func.id,\n          index,\n        };\n      })\n      .catch((e) => {\n        if (!(e instanceof FunctionError)) {\n          throw e;\n        }\n        const result = e.getFixingInstructions();\n\n        // Add telemetry event for function error\n        if (span) {\n          const errorEventData: {\n            name: string;\n            args?: string;\n            message: string;\n            fixing_instructions?: string;\n          } = {\n            name: func.name,\n            message: e.toString(),\n          };\n          if (!excludeContentFromTrace) {\n            errorEventData.args = func.args;\n            errorEventData.fixing_instructions = result;\n          }\n          span.addEvent('function.error', errorEventData);\n        }\n\n        if (ai.getOptions().debug) {\n          logFunctionError(e, index, result, logger);\n        }\n\n        return {\n          functionId: func.id,\n          isError: true,\n          index,\n          result,\n          role: 'function' as const,\n        };\n      });\n\n    return promise;\n  });\n\n  // Wait for all promises to resolve\n  const results = await Promise.all(promises);\n  const functionResults = results.filter((result) => result !== undefined);\n\n  mem.addFunctionResults(functionResults, sessionId);\n\n  // Log successful function results if debug is enabled\n  if (ai.getOptions().debug) {\n    const successfulResults = functionResults.filter(\n      (result) => !result.isError\n    );\n    if (successfulResults.length > 0) {\n      logFunctionResults(successfulResults, logger);\n    }\n  }\n\n  if (functionResults.some((result) => result.isError)) {\n    mem.addTag('error', sessionId);\n  }\n\n  return functionsExecuted;\n};\n\nexport function parseFunctionCalls(\n  ai: Readonly<AxAIService>,\n  functionCalls: Readonly<AxChatResponseResult['functionCalls']>,\n  _values: Record<string, unknown>,\n  model?: string\n): AxChatResponseFunctionCall[] | undefined {\n  if (!functionCalls || functionCalls.length === 0) {\n    return;\n  }\n  if (!ai.getFeatures(model).functions) {\n    throw new Error('Functions are not supported by the AI service');\n  }\n\n  const funcs: AxChatResponseFunctionCall[] = functionCalls.map((f) => ({\n    id: f.id,\n    name: f.function.name,\n    args: f.function.params as string,\n  }));\n\n  // for (const [i, f] of funcs.entries()) {\n  //   values['functionName' + i] = f.name;\n  //   values['functionArguments' + i] =\n  //     typeof f.args === 'object' ? JSON.stringify(f.args) : f.args;\n  // }\n  return funcs;\n}\n\ntype FunctionCall = AxChatRequest['functionCall'] | undefined;\n\n/**\n * Utility function to parse a list of functions into AxFunction array\n */\nexport function createFunctionConfig(\n  functionList?: AxInputFunctionType,\n  definedFunctionCall?: FunctionCall,\n  firstStep?: boolean\n): { functions: AxFunction[]; functionCall: FunctionCall } {\n  const functionCall = definedFunctionCall;\n\n  if (\n    !firstStep &&\n    (functionCall === 'required' || typeof functionCall === 'function')\n  ) {\n    return { functions: [], functionCall: undefined };\n  }\n\n  if (!functionList) {\n    return { functions: [], functionCall: functionCall };\n  }\n\n  // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here\n  const functions = functionList\n    .map((f) => {\n      if ('toFunction' in f) {\n        return f.toFunction();\n      }\n      return f;\n    })\n    .flat();\n\n  return { functions, functionCall };\n}\n", "import dayjs from 'dayjs';\nimport customParseFormat from 'dayjs/plugin/customParseFormat.js';\nimport timezone from 'dayjs/plugin/timezone.js';\nimport utc from 'dayjs/plugin/utc.js';\n\nimport { ValidationError } from './errors.js';\nimport type { AxField } from './sig.js';\n\n// Extend Day.js with required plugins\ndayjs.extend(utc);\ndayjs.extend(timezone);\ndayjs.extend(customParseFormat);\n\nexport function parseLLMFriendlyDate(\n  field: Readonly<AxField>,\n  dateStr: string,\n  required = false\n) {\n  try {\n    return ParseLlmFriendlyDate(dateStr);\n  } catch (err) {\n    if (field.isOptional && !required) {\n      return;\n    }\n    const message = (err as Error).message;\n    throw new ValidationError({ fields: [field], message, value: dateStr });\n  }\n}\n\nfunction ParseLlmFriendlyDate(dateStr: string) {\n  // Validate the date string format\n  if (!dayjs(dateStr, 'YYYY-MM-DD', true).isValid()) {\n    throw new Error(\n      'Invalid date format. Please provide the date in \"YYYY-MM-DD\" format.'\n    );\n  }\n\n  // Parse the date and create a UTC dayjs object at midnight\n  // @ts-ignore - utc method exists after plugin extension\n  const date = dayjs.utc(dateStr, 'YYYY-MM-DD').startOf('day');\n\n  return date.toDate();\n}\n\nexport function parseLLMFriendlyDateTime(\n  field: Readonly<AxField>,\n  dateStr: string,\n  required = false\n) {\n  try {\n    return ParseLlmFriendlyDateTime(dateStr);\n  } catch (err) {\n    if (field.isOptional && !required) {\n      return;\n    }\n    const message = (err as Error).message;\n    throw new ValidationError({ fields: [field], message, value: dateStr });\n  }\n}\n\nfunction ParseLlmFriendlyDateTime(dateTimeStr: string) {\n  // Validate the date and time string format\n  const dateTimeRegex = /^(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}(?::\\d{2})?) (.+)$/;\n  const match = dateTimeStr.match(dateTimeRegex);\n  if (!match) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    );\n  }\n\n  const [, dateTime, timeZone] = match;\n\n  if (!dateTime || !timeZone) {\n    throw new Error(\n      'Invalid date and time format. Please provide the date and time in \"YYYY-MM-DD HH:mm\" or \"YYYY-MM-DD HH:mm:ss\" format, followed by the timezone.'\n    );\n  }\n\n  // Day.js doesn't have a direct equivalent to moment.tz.zone, so we attempt to parse and validate the timezone\n  try {\n    // Determine the format based on whether seconds are included\n    const format =\n      dateTime.includes(':') && dateTime.split(':').length === 3\n        ? 'YYYY-MM-DD HH:mm:ss'\n        : 'YYYY-MM-DD HH:mm';\n\n    // Parse the date and time in the specified time zone\n    // @ts-ignore - tz method exists after plugin extension\n    const date = dayjs.tz(dateTime, format, timeZone);\n\n    // Check if the date and time are valid\n    if (!date.isValid()) {\n      throw new Error(\n        'Invalid date and time values. Please ensure all components are correct.'\n      );\n    }\n\n    // Convert to UTC\n    // @ts-ignore - utc method exists after plugin extension\n    return date.utc().toDate();\n  } catch (_err) {\n    throw new Error(\n      `Unrecognized time zone ${timeZone}. Please provide a valid time zone name, abbreviation, or offset. For example, \"America/New_York\", or \"EST\".`\n    );\n  }\n}\n\nexport const formatDateWithTimezone = (date: Readonly<Date>) => {\n  // @ts-ignore - utc method exists after plugin extension\n  const dayjsDate = dayjs(date).utc();\n  return dayjsDate.format('YYYY-MM-DD HH:mm:ss [UTC]');\n};\n", "/* eslint-disable functional/prefer-immutable-types */\nimport { ColorLog } from '../util/log.js';\n\nimport type { AxField } from './sig.js';\nimport type { AxFieldValue, AxGenDeltaOut, AxProgramUsage } from './types.js';\n\nconst colorLog = new ColorLog();\n\nexport const updateProgressBar = (\n  current: number,\n  total: number,\n  success: number,\n  _elapsedTime: number, // in seconds\n  msg: string,\n  progressBarWidth = 20 // Default width of the progress bar\n): void => {\n  const percentage = ((current / total) * 100).toFixed(1);\n  const filledBarLength = Math.round((progressBarWidth * current) / total);\n  const emptyBarLength = progressBarWidth - filledBarLength;\n  const filledBar = colorLog.blueBright(''.repeat(filledBarLength));\n  const emptyBar = ' '.repeat(emptyBarLength);\n  const successRate = total > 0 ? ((success / total) * 100).toFixed(1) : '0.0';\n\n  // More user-friendly message\n  const friendlyMsg = msg.includes('Running MIPROv2 optimization')\n    ? 'Testing prompt variations'\n    : msg.includes('Tuning Prompt')\n      ? 'Generating training examples'\n      : msg;\n\n  // Use newline instead of carriage return to avoid overwriting structured logs\n  console.log(\n    `  ${friendlyMsg}: ${current}/${total} (${colorLog.yellow(percentage)}%) |${filledBar}${emptyBar}| Success rate: ${colorLog.greenBright(successRate)}%\\n`\n  );\n};\n\nexport const validateValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): void => {\n  const ft = field.type ?? { name: 'string', isArray: false };\n\n  const validateSingleValue = (\n    expectedType: string,\n    val: Readonly<AxFieldValue>\n  ): boolean => {\n    switch (expectedType) {\n      case 'class':\n        return typeof val === 'string';\n      case 'code':\n        return typeof val === 'string';\n      case 'string':\n        return typeof val === 'string';\n      case 'number':\n        return typeof val === 'number';\n      case 'boolean':\n        return typeof val === 'boolean';\n      case 'date':\n        return val instanceof Date || typeof val === 'string';\n      case 'datetime':\n        return val instanceof Date || typeof val === 'string';\n      case 'json':\n        return typeof val === 'object' || typeof val === 'string';\n      default:\n        return false; // Unknown or unsupported type\n    }\n  };\n\n  const validImage = (val: Readonly<AxFieldValue>): boolean => {\n    if (\n      !val ||\n      typeof val !== 'object' ||\n      !('mimeType' in val) ||\n      !('data' in val)\n    ) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'image') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validImage(item)) {\n          msg = 'object ({ mimeType: string; data: string })';\n          break;\n        }\n      }\n    } else if (!validImage(value)) {\n      msg = 'object ({ mimeType: string; data: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  const validAudio = (val: Readonly<AxFieldValue>): boolean => {\n    if (!val || typeof val !== 'object' || !('data' in val)) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'audio') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validAudio(item)) {\n          msg = 'object ({ data: string; format?: string })';\n          break;\n        }\n      }\n    } else if (!validAudio(value)) {\n      msg = 'object ({ data: string; format?: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  const validFile = (val: Readonly<AxFieldValue>): boolean => {\n    if (\n      !val ||\n      typeof val !== 'object' ||\n      !('filename' in val) ||\n      !('mimeType' in val) ||\n      !('data' in val)\n    ) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'file') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validFile(item)) {\n          msg = 'object ({ filename: string; mimeType: string; data: string })';\n          break;\n        }\n      }\n    } else if (!validFile(value)) {\n      msg = 'object ({ filename: string; mimeType: string; data: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  const validUrl = (val: Readonly<AxFieldValue>): boolean => {\n    if (typeof val === 'string') {\n      return true; // Simple URL string\n    }\n    if (!val || typeof val !== 'object' || !('url' in val)) {\n      return false;\n    }\n    return true;\n  };\n\n  if (field.type?.name === 'url') {\n    let msg: string | undefined;\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (!validUrl(item)) {\n          msg =\n            'string or object ({ url: string; title?: string; description?: string })';\n          break;\n        }\n      }\n    } else if (!validUrl(value)) {\n      msg =\n        'string or object ({ url: string; title?: string; description?: string })';\n    }\n\n    if (msg) {\n      throw new Error(\n        `Validation failed: Expected '${field.name}' to be type '${msg}' instead got '${value}'`\n      );\n    }\n    return;\n  }\n\n  let isValid = true;\n\n  if (ft.isArray) {\n    if (!Array.isArray(value)) {\n      isValid = false;\n    } else {\n      for (const item of value) {\n        if (!validateSingleValue(ft.name, item)) {\n          isValid = false;\n          break;\n        }\n      }\n    }\n  } else {\n    isValid = validateSingleValue(ft.name, value);\n  }\n\n  if (!isValid) {\n    const gotType = Array.isArray(value) ? 'array' : typeof value;\n    throw new Error(\n      `Validation failed: Expected '${field.name}' to be a ${field.type?.isArray ? 'an array of ' : ''}${ft.name} instead got '${gotType}' (${JSON.stringify(value)})`\n    );\n  }\n};\n\nexport function mergeProgramUsage(\n  usages: readonly AxProgramUsage[]\n): AxProgramUsage[] {\n  const usageMap: { [key: string]: AxProgramUsage } = {};\n\n  for (const usage of usages) {\n    const key = `${usage.ai}:${usage.model}`;\n\n    if (!usageMap[key]) {\n      usageMap[key] = { ...usage };\n      continue;\n    }\n\n    const currentUsage = usageMap[key];\n    if (currentUsage) {\n      const tokens = currentUsage.tokens ?? {\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n      };\n      tokens.promptTokens += usage?.tokens?.promptTokens ?? 0;\n      tokens.completionTokens += usage?.tokens?.completionTokens ?? 0;\n      tokens.totalTokens += usage?.tokens?.totalTokens ?? 0;\n      currentUsage.tokens = tokens;\n    }\n  }\n\n  return Object.values(usageMap);\n}\n\n/**\n * Parses a markdown list from a string. This is a very forgiving parser that\n * will try to handle anything that looks vaguely like a markdown list.\n */\nexport const parseMarkdownList = (input: string): string[] => {\n  // Handle empty input\n  if (!input.trim()) {\n    return [];\n  }\n\n  const listBullets = new Set(['-', '*', '+']);\n  const numberedListRegex = /^\\d+[\\s]*[.)\\]]\\s*/;\n\n  const lines = input.split('\\n');\n  const list = [];\n\n  for (const line of lines) {\n    const trimmedLine = line.trim();\n    // Skip empty lines\n    if (!trimmedLine) {\n      continue;\n    }\n\n    // Check for bullet points\n    if (trimmedLine[0] && listBullets.has(trimmedLine[0])) {\n      list.push(trimmedLine.slice(1).trim());\n    }\n    // Check for numbered lists (e.g., \"1.\", \"2.\", etc.)\n    else if (numberedListRegex.test(trimmedLine)) {\n      list.push(trimmedLine.replace(numberedListRegex, '').trim());\n    }\n    // If it's not a list item and we haven't collected any items yet, do nothing\n    else if (list.length === 0) {\n      // Skip non-list lines at the beginning\n    }\n    // If we've already started collecting list items, then this non-list line\n    //is an error\n    else {\n      throw new Error('Could not parse markdown list: mixed content detected');\n    }\n  }\n\n  // If we didn't find any list items, throw error\n  if (list.length === 0) {\n    throw new Error('Could not parse markdown list: no valid list items found');\n  }\n\n  return list;\n};\n\nexport function mergeDeltas<OUT>(\n  base: AxGenDeltaOut<OUT>[],\n  currentDelta: AxGenDeltaOut<OUT>\n) {\n  type ValueTypeOfAxGenOut = OUT[keyof OUT];\n\n  const { index, delta, version } = currentDelta;\n\n  // Cast once for mutation  safe because we'll only assign validated keys\n  const target = base.find((b) => b.index === index)?.delta as Record<\n    string,\n    ValueTypeOfAxGenOut\n  >;\n\n  if (!target) {\n    base.push({ index, delta, version });\n    return base;\n  }\n\n  for (const key of Object.keys(delta)) {\n    const baseValue = target[key];\n    const deltaValue = (delta as Record<string, unknown>)[key];\n\n    if (baseValue === undefined && Array.isArray(deltaValue)) {\n      target[key] = [...deltaValue] as ValueTypeOfAxGenOut;\n    } else if (Array.isArray(baseValue) && Array.isArray(deltaValue)) {\n      // Concatenate arrays\n      target[key] = [\n        ...(baseValue as unknown[]),\n        ...deltaValue,\n      ] as ValueTypeOfAxGenOut;\n    } else if (\n      (baseValue === undefined || typeof baseValue === 'string') &&\n      typeof deltaValue === 'string'\n    ) {\n      // Concatenate strings\n      target[key] = `${baseValue ?? ''}${deltaValue}` as ValueTypeOfAxGenOut;\n    } else {\n      // For all other types, overwrite with the new value\n      target[key] = deltaValue as ValueTypeOfAxGenOut;\n    }\n  }\n  return base;\n}\n\nexport class LRUCache<K, V> {\n  private cache = new Map<K, V>();\n  private readonly maxSize: number;\n\n  constructor(maxSize: number) {\n    this.maxSize = maxSize;\n  }\n\n  get(key: K): V | undefined {\n    const value = this.cache.get(key);\n    if (value) {\n      // Refresh position by deleting and re-adding\n      this.cache.delete(key);\n      this.cache.set(key, value);\n    }\n    return value;\n  }\n\n  set(key: K, value: V): void {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.maxSize) {\n      // Remove oldest entry (first item in map)\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n    this.cache.set(key, value);\n  }\n}\n\nconst globalPrefixCache = new LRUCache<string, string[]>(500);\n\n/**\n * Checks if a streaming string matches a prefix, either fully or partially from the end.\n * For streaming content, partial matches are checked from shortest to longest since\n * the content grows at the end and we want to detect partial prefixes as they form.\n * @param content The string to check (potentially streaming)\n * @param prefix The prefix to look for\n * @param startIndex Optional starting index for the search\n * @returns\n *   - index >= 0: Position of full match\n *   - -1: No match found\n *   - -2: Partial match from the end\n *   - -3: String is only whitespace\n */\nexport function matchesContent(\n  content: string,\n  prefix: string,\n  startIndex = 0,\n  prefixCache: LRUCache<string, string[]> = globalPrefixCache\n): number {\n  // Check if string starts with a markdown block with optional language\n  if (/^```[a-zA-Z]*\\s*$/.test(content)) {\n    return -4;\n  }\n\n  // Check if string is only whitespace\n  if (/^[\\s`]*$/.test(content)) {\n    return -3;\n  }\n\n  // First check if the complete prefix exists anywhere after startIndex\n  const exactMatchIndex = content.indexOf(prefix, startIndex);\n\n  if (exactMatchIndex !== -1) {\n    return exactMatchIndex;\n  }\n\n  // Get or create cached prefixes\n  const prefixes =\n    prefixCache.get(prefix) ??\n    Array.from({ length: prefix.length }, (_, i) => prefix.slice(0, i + 1));\n\n  // Set in cache if it wasn't there\n  if (!prefixCache.get(prefix)) {\n    prefixCache.set(prefix, prefixes);\n  }\n\n  // Check for partial matches at the end (for streaming content)\n  // We want to find the longest partial prefix that the content ends with\n  let longestPartialMatch = -1;\n\n  // Start from the longest prefix and work backwards to find the longest match\n  for (let i = prefixes.length - 1; i >= 0; i--) {\n    const partialPrefix = prefixes[i] as string;\n\n    // Check if content ends with this partial prefix\n    if (content.endsWith(partialPrefix)) {\n      longestPartialMatch = i;\n      break; // Found the longest match, no need to continue\n    }\n  }\n\n  // Return -2 for partial match, -1 for no match\n  return longestPartialMatch >= 0 ? -2 : -1;\n}\n\nexport const formatTime = (ms: number): string => {\n  const seconds = Math.floor(ms / 1000);\n  if (seconds < 60) return `${seconds}s`;\n\n  const minutes = Math.floor(seconds / 60);\n  const remainingSeconds = seconds % 60;\n  if (minutes < 60) return `${minutes}m ${remainingSeconds}s`;\n\n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  return `${hours}h ${remainingMinutes}m ${remainingSeconds}s`;\n};\n\nexport const calculateETA = (\n  current: number,\n  total: number,\n  elapsedMs: number\n): string => {\n  if (current === 0) return 'calculating...';\n\n  const msPerItem = elapsedMs / current;\n  const remainingItems = total - current;\n  const etaMs = msPerItem * remainingItems;\n\n  return formatTime(etaMs);\n};\n", "/* eslint-disable @typescript-eslint/naming-convention */\n\nimport { parseLLMFriendlyDate, parseLLMFriendlyDateTime } from './datetime.js';\nimport { ValidationError } from './errors.js';\nimport type { AxField, AxSignature } from './sig.js';\nimport type { AxGenOut, GenDeltaOut } from './types.js';\nimport { matchesContent, parseMarkdownList } from './util.js';\n\nexport const extractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  content: string,\n  strictMode = false\n) => {\n  const xstate = { extractedFields: [], streamedIndex: {}, s: -1 };\n  streamingExtractValues(sig, values, xstate, content, { strictMode });\n  streamingExtractFinalValue(sig, values, xstate, content, strictMode);\n\n  // Filter out internal fields\n  for (const field of sig.getOutputFields()) {\n    if (field.isInternal) {\n      delete values[field.name];\n    }\n  }\n};\n\nexport interface extractionState {\n  prevFields?: { field: AxField; s: number; e: number }[];\n  currField?: AxField;\n  currFieldIndex?: number;\n  inAssumedField?: boolean;\n  extractedFields: AxField[];\n  streamedIndex: Record<string, number>;\n  s: number;\n  inBlock?: boolean;\n}\n\n// Helper function to check for missing required fields\nconst checkMissingRequiredFields = (\n  _xstate: Readonly<extractionState>,\n  values: Record<string, unknown>,\n  outputFields: Readonly<AxField[]>\n) => {\n  const missingFields: AxField[] = [];\n\n  for (const field of outputFields) {\n    if (field && !field.isOptional && values[field.name] === undefined) {\n      missingFields.push(field);\n    }\n  }\n\n  if (missingFields.length > 0) {\n    throw new ValidationError({\n      message: `Required ${missingFields.length === 1 ? 'field' : 'fields'} not found`,\n      fields: missingFields,\n    });\n  }\n};\n\nexport interface StreamingExtractValuesOptions {\n  strictMode?: boolean;\n  skipEarlyFail?: boolean;\n}\n\nexport const streamingExtractValues = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  content: string,\n  { strictMode, skipEarlyFail }: StreamingExtractValuesOptions = {}\n) => {\n  const fields = sig.getOutputFields();\n  let expectedField: AxField | undefined;\n\n  for (const [index, field] of fields.entries()) {\n    // If the field is the current field and it's not assumed, skip it\n    if (index === xstate.currFieldIndex && !xstate.inAssumedField) {\n      continue;\n    }\n\n    // If field is already in values and it's not the current field and it's not assumed, skip it\n    if (\n      field.name in values &&\n      !(index === xstate.currFieldIndex && xstate.inAssumedField)\n    ) {\n      continue;\n    }\n\n    const isFirst = xstate.extractedFields.length === 0;\n    const prefix = `${(isFirst ? '' : '\\n') + field.title}:`;\n\n    let e = matchesContent(content, prefix, xstate.s);\n    let prefixLen = prefix.length;\n\n    switch (e) {\n      case -1:\n        if (skipEarlyFail) {\n          continue;\n        }\n\n        // If there is only one field then we assume the content is streaming to the first field\n        // Note: optimization for single field responses (only in non-strict mode)\n        if (\n          !strictMode &&\n          fields.length === 1 &&\n          xstate.currField === undefined\n        ) {\n          xstate.inAssumedField = true;\n          expectedField = field;\n          prefixLen = 0;\n          e = 0;\n          break;\n        }\n\n        // For multiple fields, we need to be more strategic about when to assign content\n        // without prefixes to a field. We should first scan all fields to see if any\n        // have proper prefixes before assigning content to the first field.\n\n        // If this is the first field we're checking and no field has been extracted yet\n        if (\n          xstate.currField === undefined &&\n          xstate.extractedFields.length === 0\n        ) {\n          // In strict mode, we need proper field prefixes for the first required field\n          if (strictMode && !field.isOptional) {\n            throw new ValidationError({\n              message: 'Expected (Required) field not found',\n              fields: [field],\n            });\n          }\n\n          // For non-strict mode, we need to check if ANY field has a proper prefix\n          // before assigning content to the first field\n          if (!strictMode) {\n            // Look ahead to see if any other field has a proper prefix\n            let foundValidFieldPrefix = false;\n            for (let i = index; i < fields.length; i++) {\n              const futureField = fields[i];\n              if (!futureField) continue;\n\n              const futurePrefix = `${(xstate.extractedFields.length === 0 ? '' : '\\n') + futureField.title}:`;\n              const futureMatch = matchesContent(\n                content,\n                futurePrefix,\n                xstate.s\n              );\n              if (futureMatch >= 0) {\n                foundValidFieldPrefix = true;\n                break;\n              }\n            }\n\n            // If no valid field prefix found anywhere, assign to first field\n            if (!foundValidFieldPrefix) {\n              xstate.inAssumedField = true;\n              expectedField = field;\n              prefixLen = 0;\n              e = 0;\n              break;\n            }\n          }\n        }\n\n        expectedField = field.isOptional ? undefined : field;\n        continue; // Field is not found, continue to the next field\n      case -2:\n        return true; // Partial match at end, skip and gather more content\n      case -3:\n        return true; // String is only whitespace, skip and gather more content\n      case -4:\n        xstate.inBlock = true;\n        return true; // String is only backticks, skip and gather more content\n    }\n    // We found a field!!!\n\n    // If the field we found is not the expected field, throw an error\n    if (expectedField && expectedField.name !== field.name) {\n      throw new ValidationError({\n        message: 'Expected (Required) field not found',\n        fields: [expectedField],\n      });\n    }\n\n    if (xstate.currField !== undefined && xstate.inAssumedField) {\n      // We're transitioning from assumed field to explicit field\n      // We need to preserve the content that was already assigned to the assumed field\n      const assumedFieldContent = content.substring(0, e).trim();\n      if (assumedFieldContent && xstate.currField.name === field.name) {\n        // If the assumed field is the same as the current field, combine the content\n        const parsedValue = validateAndParseFieldValue(\n          xstate.currField,\n          assumedFieldContent\n        );\n        if (parsedValue !== undefined) {\n          values[xstate.currField.name] = parsedValue;\n        }\n      } else if (assumedFieldContent) {\n        // If they're different fields, save the assumed field content\n        const parsedValue = validateAndParseFieldValue(\n          xstate.currField,\n          assumedFieldContent\n        );\n        if (parsedValue !== undefined) {\n          values[xstate.currField.name] = parsedValue;\n        }\n      }\n\n      xstate.inAssumedField = false;\n      xstate.streamedIndex[xstate.currField.name] = 0;\n      xstate.currField = undefined;\n    }\n\n    // Lets wrap up the last field which is still the current field\n    if (xstate.currField) {\n      const val = content.substring(xstate.s, e).trim();\n      const parsedValue = validateAndParseFieldValue(xstate.currField, val);\n      if (parsedValue !== undefined) {\n        values[xstate.currField.name] = parsedValue;\n      }\n      if (xstate.prevFields) {\n        xstate.prevFields?.push({ field: xstate.currField, s: xstate.s, e });\n      } else {\n        xstate.prevFields = [{ field: xstate.currField, s: xstate.s, e }];\n      }\n    }\n\n    // Lets update the state for the new current field\n\n    xstate.s = e + prefixLen;\n    xstate.currField = field;\n    xstate.currFieldIndex = index;\n\n    if (!xstate.extractedFields.includes(field)) {\n      xstate.extractedFields.push(field);\n    }\n\n    if (xstate.streamedIndex[field.name] === undefined) {\n      xstate.streamedIndex[field.name] = 0;\n    }\n  }\n};\n\nexport const streamingExtractFinalValue = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  content: string,\n  strictMode = false\n) => {\n  if (xstate.currField) {\n    const val = content.substring(xstate.s).trim();\n\n    const parsedValue = validateAndParseFieldValue(xstate.currField, val);\n    if (parsedValue !== undefined) {\n      values[xstate.currField.name] = parsedValue;\n    }\n  }\n\n  // In strict mode, if we have content but no fields were extracted and no current field,\n  // this means field prefixes were missing when they should have been present\n  if (strictMode && !xstate.currField && xstate.extractedFields.length === 0) {\n    const trimmedContent = content.trim();\n    if (trimmedContent) {\n      // Find the first required field to report in the error\n      const outputFields = sig.getOutputFields();\n      const firstRequiredField = outputFields.find(\n        (field) => !field.isOptional\n      );\n      if (firstRequiredField) {\n        throw new ValidationError({\n          message: 'Expected field not found',\n          fields: [firstRequiredField],\n        });\n      }\n      // If only optional fields exist, ignore unprefixed content in strict mode\n    }\n  }\n\n  // Check for optional fields that might have been missed by streaming parser\n  parseOptionalFieldsFromFullContent(sig, values, content);\n\n  // Check all previous required fields before processing current field\n  checkMissingRequiredFields(xstate, values, sig.getOutputFields());\n};\n\n// Helper function to parse optional fields from full content that streaming parser might have missed\nconst parseOptionalFieldsFromFullContent = (\n  sig: Readonly<AxSignature>,\n  values: Record<string, unknown>,\n  content: string\n) => {\n  const outputFields = sig.getOutputFields();\n\n  for (const field of outputFields) {\n    // Skip if field is not optional or already found\n    if (!field.isOptional || field.name in values) {\n      continue;\n    }\n\n    // Look for field.title pattern in content\n    const prefix = `${field.title}:`;\n    const fieldIndex = content.indexOf(prefix);\n\n    if (fieldIndex === -1) {\n      continue;\n    }\n\n    // Extract content after the field prefix\n    const startIndex = fieldIndex + prefix.length;\n    let endIndex = content.length;\n\n    // Find the end of this field's content by looking for the next field or end of content\n    for (const otherField of outputFields) {\n      if (otherField.name === field.name) {\n        continue;\n      }\n\n      const otherPrefix = `${otherField.title}:`;\n      const otherFieldIndex = content.indexOf(otherPrefix, startIndex);\n\n      if (otherFieldIndex !== -1 && otherFieldIndex < endIndex) {\n        endIndex = otherFieldIndex;\n      }\n    }\n\n    // Extract and validate the field value\n    const fieldValue = content.substring(startIndex, endIndex).trim();\n\n    if (fieldValue) {\n      try {\n        const parsedValue = validateAndParseFieldValue(field, fieldValue);\n        if (parsedValue !== undefined) {\n          values[field.name] = parsedValue;\n        }\n      } catch {\n        // Ignore validation errors for optional fields in this fallback parser\n      }\n    }\n  }\n};\n\nconst convertValueToType = (\n  field: Readonly<AxField>,\n  val: string,\n  required = false\n) => {\n  switch (field.type?.name) {\n    case 'code':\n      return extractBlock(val);\n\n    case 'string':\n      return val;\n\n    case 'number': {\n      const v = Number(val);\n      if (Number.isNaN(v)) {\n        if (field.isOptional && !required) {\n          return;\n        }\n        throw new Error('Invalid number');\n      }\n      return v;\n    }\n\n    case 'boolean': {\n      if (typeof val === 'boolean') {\n        return val;\n      }\n      const v = val.toLowerCase();\n      if (v === 'true') {\n        return true;\n      }\n      if (v === 'false') {\n        return false;\n      }\n      if (field.isOptional && !required) {\n        return;\n      }\n      throw new Error('Invalid boolean');\n    }\n    case 'date':\n      return parseLLMFriendlyDate(field, val, required);\n\n    case 'datetime':\n      return parseLLMFriendlyDateTime(field, val, required);\n\n    case 'class': {\n      const className = val;\n      if (field.type.options && !field.type.options.includes(className)) {\n        if (field.isOptional) {\n          return;\n        }\n        throw new Error(\n          `Invalid class '${val}', expected one of the following: ${field.type.options.join(', ')}`\n        );\n      }\n      return className as string;\n    }\n\n    default:\n      return val as string; // Unknown type\n  }\n};\n\nexport function* yieldDelta<OUT extends AxGenOut>(\n  content: string,\n  field: Readonly<AxField>,\n  s: number,\n  e: number,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  index: number\n): GenDeltaOut<OUT> {\n  const { name: fieldName, isInternal } = field;\n  const { isArray: fieldIsArray, name: fieldTypeName } = field.type ?? {};\n\n  if (\n    isInternal ||\n    fieldIsArray ||\n    (fieldTypeName && fieldTypeName !== 'string' && fieldTypeName !== 'code')\n  ) {\n    return;\n  }\n\n  const pos = xstate.streamedIndex[fieldName] ?? 0;\n  const isFirstChunk = pos === 0;\n\n  const d1 = content.substring(s + pos, e);\n  if (d1.length === 0) {\n    return;\n  }\n\n  // Remove trailing whitespace, tabs, and newlines\n  let d2 = d1.replace(/\\s+$/, '');\n\n  // If this field is a \"code\" type, remove trailing backticks\n  if (xstate.currField?.type?.name === 'code') {\n    d2 = d2.replace(/\\s*```\\s*$/, '');\n  }\n\n  // Only trim start for the first chunk\n  let d3 = isFirstChunk ? d2.trimStart() : d2;\n\n  if (xstate.currField?.type?.name === 'code') {\n    // Remove any leading triple-backtick fences (with optional language specifier)\n    d3 = d3.replace(/^[ ]*```[a-zA-Z0-9]*\\n\\s*/, '');\n  }\n\n  if (d3.length > 0) {\n    yield { index, delta: { [fieldName]: d3 } as unknown as Partial<OUT> };\n    xstate.streamedIndex[fieldName] = pos + d2.length;\n  }\n}\n\nexport function* streamValues<OUT extends AxGenOut>(\n  sig: Readonly<AxSignature>,\n  content: string,\n  values: Readonly<Record<string, OUT>>,\n  // eslint-disable-next-line functional/prefer-immutable-types\n  xstate: extractionState,\n  index: number\n): GenDeltaOut<OUT> {\n  for (const prevField of xstate.prevFields ?? []) {\n    const { field, s, e } = prevField;\n    yield* yieldDelta<OUT>(content, field, s, e, xstate, index);\n  }\n  xstate.prevFields = undefined;\n\n  if (!xstate.currField || xstate.currField.isInternal) {\n    return;\n  }\n\n  yield* yieldDelta<OUT>(\n    content,\n    xstate.currField,\n    xstate.s,\n    content.length,\n    xstate,\n    index\n  );\n\n  const outputFields = sig.getOutputFields();\n\n  for (const key of Object.keys(values)) {\n    const field = outputFields.find((f) => f.name === key);\n    if (!field || field.isInternal) {\n      continue;\n    }\n\n    const value = values[key];\n\n    if (Array.isArray(value)) {\n      const s = xstate.streamedIndex?.[key] ?? 0;\n      const v = value.slice(s);\n      if (v && v.length > 0) {\n        yield { index, delta: { [key]: v } as unknown as Partial<OUT> };\n        xstate.streamedIndex[key] = s + v.length;\n      }\n      continue;\n    }\n\n    if (!xstate.streamedIndex[key]) {\n      yield { index, delta: { [key]: value } as unknown as Partial<OUT> };\n      xstate.streamedIndex[key] = 1;\n    }\n  }\n}\n\nfunction validateAndParseFieldValue(\n  field: Readonly<AxField>,\n  fieldValue: string | undefined\n): unknown {\n  if (\n    !fieldValue ||\n    fieldValue === '' ||\n    /^(null|undefined)\\s*$/i.test(fieldValue)\n  ) {\n    if (field.isOptional) {\n      return;\n    }\n    throw new ValidationError({\n      message: 'Required field is missing',\n      fields: [field],\n      value: fieldValue,\n    });\n  }\n\n  let value: unknown | undefined;\n\n  if (field.type?.name === 'json') {\n    try {\n      const text = extractBlock(fieldValue);\n      value = JSON.parse(text);\n      return value;\n    } catch (e) {\n      throw new ValidationError({\n        message: `Invalid JSON: ${(e as Error).message}`,\n        fields: [field],\n        value: fieldValue,\n      });\n    }\n  }\n\n  if (field.type?.isArray) {\n    try {\n      try {\n        value = JSON.parse(fieldValue);\n      } catch {\n        // If JSON parsing fails, try markdown parsing\n        value = parseMarkdownList(fieldValue);\n      }\n      if (!Array.isArray(value)) {\n        throw new Error('Expected an array');\n      }\n    } catch (e) {\n      throw new ValidationError({\n        message: `Invalid Array: ${(e as Error).message}`,\n        fields: [field],\n        value: fieldValue,\n      });\n    }\n  }\n\n  try {\n    if (Array.isArray(value)) {\n      for (const [index, item] of value.entries()) {\n        if (item !== undefined) {\n          const v = typeof item === 'string' ? item.trim() : item;\n          value[index] = convertValueToType(field, v, true);\n        }\n      }\n    } else {\n      value = convertValueToType(field, fieldValue);\n    }\n  } catch (e) {\n    throw new ValidationError({\n      message: (e as Error).message,\n      fields: [field],\n      value: fieldValue,\n    });\n  }\n\n  if (typeof value === 'string' && value === '') {\n    return undefined;\n  }\n\n  return value;\n}\n\nexport const extractBlock = (input: string): string => {\n  const markdownBlockPattern = /```([A-Za-z]*)\\n([\\s\\S]*?)\\n```/g;\n  const match = markdownBlockPattern.exec(input);\n  if (!match) {\n    return input;\n  }\n  if (match.length === 3) {\n    return match[2] as string;\n  }\n  if (match.length === 2) {\n    return match[1] as string;\n  }\n  return input;\n};\n", "import type { AxAIMemory } from '../mem/types.js';\n\nimport type { extractionState } from './extract.js';\nimport type { AxField } from './sig.js';\nimport type { AxFieldValue, AxGenOut } from './types.js';\n\nexport type AxFieldProcessorProcess = (\n  value: AxFieldValue,\n  context?: Readonly<{\n    values?: AxGenOut;\n    sessionId?: string;\n    done?: boolean;\n  }>\n) => unknown | Promise<unknown>;\n\nexport type AxStreamingFieldProcessorProcess = (\n  value: string,\n  context?: Readonly<{\n    values?: AxGenOut;\n    sessionId?: string;\n    done?: boolean;\n  }>\n) => unknown | Promise<unknown>;\nexport interface AxFieldProcessor {\n  field: Readonly<AxField>;\n\n  /**\n   * Process the field value and return a new value (or undefined if no update is needed).\n   * The returned value may be merged back into memory.\n   * @param value - The current field value.\n   * @param context - Additional context (e.g. memory and session id).\n   */\n  process: AxFieldProcessorProcess | AxStreamingFieldProcessorProcess;\n}\n\n/**\n * For synchronous responses: iterates over registered field processors,\n * passing in the current values. If a processor returns a new value,\n * that value is merged into memory with a special role ('processor').\n */\nexport async function processFieldProcessors(\n  fieldProcessors: AxFieldProcessor[],\n  values: AxGenOut,\n  mem: AxAIMemory,\n  sessionId?: string\n) {\n  for (const processor of fieldProcessors) {\n    if (values[processor.field.name] === undefined) {\n      continue;\n    }\n\n    const processFn = processor.process as AxFieldProcessorProcess;\n    const result = await processFn(values[processor.field.name], {\n      sessionId,\n      values,\n      done: true,\n    });\n    addToMemory(processor.field, mem, result, sessionId);\n  }\n}\n\n/**\n * For streaming responses: processes each streaming field processor\n * and yields delta updates if they return new values.\n */\nexport async function processStreamingFieldProcessors(\n  fieldProcessors: AxFieldProcessor[],\n  content: string,\n  xstate: Readonly<extractionState>,\n  mem: AxAIMemory,\n  values: AxGenOut,\n  sessionId: string | undefined,\n  done = false\n): Promise<void> {\n  for (const processor of fieldProcessors) {\n    if (xstate.currField?.name !== processor.field.name) {\n      continue;\n    }\n\n    let value = content.substring(xstate.s);\n\n    if (xstate.currField?.type?.name === 'code') {\n      // remove markdown block\n      value = value.replace(/^[ ]*```[a-zA-Z0-9]*\\n\\s*/, '');\n      value = value.replace(/\\s*```\\s*$/, '');\n    }\n    const processFn = processor.process as AxStreamingFieldProcessorProcess;\n    const result = await processFn(value, {\n      sessionId,\n      values,\n      done,\n    });\n\n    addToMemory(xstate.currField, mem, result, sessionId);\n  }\n}\n\nconst addToMemory = (\n  field: Readonly<AxField>,\n  mem: AxAIMemory,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  result: any | any[],\n  sessionId?: string\n) => {\n  if (\n    result === undefined ||\n    (typeof result === 'string' &&\n      (result === '' || /^(null|undefined)\\s*$/i.test(result)))\n  ) {\n    return;\n  }\n\n  const resultText = JSON.stringify(\n    result,\n    (_key, value) => (typeof value === 'bigint' ? Number(value) : value),\n    2\n  );\n\n  const text = getFieldProcessingMessage(field, resultText);\n  mem.addRequest(\n    [{ role: 'user', content: [{ type: 'text', text }] }],\n    sessionId\n  );\n  mem.addTag('processor', sessionId);\n};\n\nfunction getFieldProcessingMessage(\n  field: Readonly<AxField>,\n  resultText: string\n) {\n  const isCodeField = field.type?.name === 'code';\n  const fieldTitle = field.title;\n\n  if (isCodeField) {\n    return `Code in the field \"${fieldTitle}\" was executed. The code execution produced the following output: ${resultText}`;\n  }\n  return `The field \"${fieldTitle}\" was processed. The field contents were transformed into the following output: ${resultText}`;\n}\n", "// ReadableStream is available globally in modern browsers and Node.js 16+\n\nimport type { AxChatResponse, AxModelUsage } from '../ai/types.js';\nimport { mergeFunctionCalls } from '../ai/util.js';\nimport type { AxAIMemory } from '../mem/types.js';\n\nimport {\n  type AxAssertion,\n  type AxStreamingAssertion,\n  assertAssertions,\n  assertStreamingAssertions,\n} from './asserts.js';\nimport {\n  extractValues,\n  streamingExtractFinalValue,\n  streamingExtractValues,\n  streamValues,\n} from './extract.js';\nimport {\n  type AxFieldProcessor,\n  processFieldProcessors,\n  processStreamingFieldProcessors,\n} from './fieldProcessor.js';\nimport { parseFunctionCalls, processFunctions } from './functions.js';\nimport type { AxResponseHandlerArgs, InternalAxGenState } from './generate.js';\nimport type { AxSignature } from './sig.js';\nimport type { AsyncGenDeltaOut, AxGenOut, DeltaOut } from './types.js';\n\ntype ProcessStreamingResponseArgs = Readonly<\n  AxResponseHandlerArgs<ReadableStream<AxChatResponse>>\n> & {\n  states: InternalAxGenState[];\n  usage: AxModelUsage[];\n  asserts: AxAssertion[];\n  streamingAsserts: AxStreamingAssertion[];\n  fieldProcessors: AxFieldProcessor[];\n  streamingFieldProcessors: AxFieldProcessor[];\n  thoughtFieldName: string;\n  signature: AxSignature;\n  excludeContentFromTrace: boolean;\n  functionResultFormatter?: (result: unknown) => string;\n};\n\nexport async function* processStreamingResponse<OUT extends AxGenOut>({\n  res,\n  usage,\n  states,\n  ...args\n}: ProcessStreamingResponseArgs): AsyncGenDeltaOut<OUT> {\n  const skipEarlyFail =\n    (args.ai.getFeatures().functionCot ?? false) &&\n    args.functions !== undefined &&\n    args.functions.length > 0;\n\n  // Each streamed chunk contains a `modelUsage` object, with accumulated token usage data.\n  // We'll only keep track of the latest modelUsage to push at the end.\n  let lastChunkUsage: AxModelUsage | undefined;\n\n  // Handle ReadableStream async iteration for browser compatibility\n  const reader = res.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n\n      if (done) {\n        if (lastChunkUsage) {\n          usage.push(lastChunkUsage);\n        }\n        break;\n      }\n      const v = value;\n      if (v.modelUsage) {\n        lastChunkUsage = v.modelUsage;\n      }\n\n      for (const result of v.results) {\n        if (\n          (!result.content || result.content === '') &&\n          (!result.thought || result.thought === '') &&\n          (!result.functionCalls || result.functionCalls.length === 0)\n        ) {\n          continue;\n        }\n\n        const state = states.find((s) => s.index === result.index);\n        if (!state) {\n          throw new Error(`No state found for result (index: ${result.index})`);\n        }\n\n        yield* ProcessStreamingResponse<OUT>({\n          ...args,\n          result,\n          skipEarlyFail,\n          state,\n        });\n      }\n    }\n  } finally {\n    reader.releaseLock();\n  }\n\n  // Finalize the streams\n  for (const state of states) {\n    yield* finalizeStreamingResponse<OUT>({\n      ...args,\n      state,\n    });\n  }\n}\n\ntype ProcessStreamingResponseArgs2 = Readonly<\n  Omit<\n    ProcessStreamingResponseArgs,\n    | 'res'\n    | 'states'\n    | 'usage'\n    | 'excludeContentFromTrace'\n    | 'ai'\n    | 'model'\n    | 'traceId'\n    | 'functions'\n    | 'span'\n    | 'fieldProcessors'\n  > & {\n    result: AxChatResponse['results'][number];\n    skipEarlyFail: boolean;\n    state: InternalAxGenState;\n  }\n>;\n\nasync function* ProcessStreamingResponse<OUT extends AxGenOut>({\n  result,\n  mem,\n  sessionId,\n  strictMode,\n  skipEarlyFail,\n  state,\n  signature,\n  streamingFieldProcessors,\n  thoughtFieldName,\n  streamingAsserts,\n  asserts,\n}: ProcessStreamingResponseArgs2): AsyncGenDeltaOut<OUT> {\n  if (result.functionCalls && result.functionCalls.length > 0) {\n    mergeFunctionCalls(state.functionCalls, result.functionCalls);\n    mem.updateResult(\n      {\n        name: result.name,\n        content: result.content,\n        functionCalls: state.functionCalls,\n        delta: result.functionCalls?.[0]?.function?.params as string,\n        index: result.index,\n      },\n      sessionId\n    );\n  } else if (result.content && result.content.length > 0) {\n    if (result.thought && result.thought.length > 0) {\n      yield {\n        index: result.index,\n        delta: { [thoughtFieldName]: result.thought } as Partial<OUT>,\n      };\n    }\n\n    state.content += result.content;\n    mem.updateResult(\n      {\n        name: result.name,\n        content: state.content,\n        delta: result.content,\n        index: result.index,\n      },\n      sessionId\n    );\n\n    const skip = streamingExtractValues(\n      signature,\n      state.values,\n      state.xstate,\n      state.content,\n      { strictMode, skipEarlyFail }\n    );\n\n    if (skip) {\n      return;\n    }\n\n    if (streamingAsserts.length !== 0) {\n      await assertStreamingAssertions(\n        streamingAsserts,\n        state.xstate,\n        state.content\n      );\n    }\n\n    if (streamingFieldProcessors.length !== 0) {\n      await processStreamingFieldProcessors(\n        streamingFieldProcessors,\n        state.content,\n        state.xstate,\n        mem,\n        state.values,\n        sessionId\n      );\n    }\n\n    yield* streamValues<OUT>(\n      signature,\n      state.content,\n      state.values as Record<string, OUT>,\n      state.xstate,\n      result.index\n    );\n\n    await assertAssertions(asserts, state.values);\n  } else if (result.thought && result.thought.length > 0) {\n    state.values[thoughtFieldName] =\n      (state.values[thoughtFieldName] ?? '') + result.thought;\n\n    yield {\n      index: result.index,\n      delta: { [thoughtFieldName]: result.thought } as Partial<OUT>,\n    };\n  }\n\n  if (result.finishReason === 'length') {\n    throw new Error(\n      `Max tokens reached before completion\\nContent: ${state.content}`\n    );\n  }\n}\n\ntype FinalizeStreamingResponseArgs = Readonly<\n  Omit<ProcessStreamingResponseArgs, 'res' | 'states' | 'usage'> & {\n    state: InternalAxGenState;\n  }\n>;\n\nexport async function* finalizeStreamingResponse<OUT extends AxGenOut>({\n  state,\n  signature,\n  ai,\n  model,\n  functions,\n  mem,\n  sessionId,\n  traceId,\n  span,\n  strictMode,\n  excludeContentFromTrace,\n  streamingAsserts,\n  asserts,\n  fieldProcessors,\n  streamingFieldProcessors,\n  functionResultFormatter,\n  logger,\n}: FinalizeStreamingResponseArgs) {\n  const funcs = parseFunctionCalls(\n    ai,\n    state.functionCalls,\n    state.values,\n    model\n  );\n  if (funcs) {\n    if (!functions) {\n      throw new Error('Functions are not defined');\n    }\n    const fx = await processFunctions({\n      ai,\n      functionList: functions,\n      functionCalls: funcs,\n      mem,\n      sessionId,\n      traceId,\n      span,\n      index: state.index,\n      excludeContentFromTrace,\n      functionResultFormatter,\n      logger,\n    });\n    state.functionsExecuted = new Set([...state.functionsExecuted, ...fx]);\n  } else {\n    streamingExtractFinalValue(\n      signature,\n      state.values,\n      state.xstate,\n      state.content,\n      strictMode\n    );\n\n    await assertStreamingAssertions(\n      streamingAsserts,\n      state.xstate,\n      state.content,\n      true\n    );\n    await assertAssertions(asserts, state.values);\n\n    if (fieldProcessors.length) {\n      await processFieldProcessors(\n        fieldProcessors,\n        state.values,\n        mem,\n        sessionId\n      );\n    }\n\n    if (streamingFieldProcessors.length !== 0) {\n      await processStreamingFieldProcessors(\n        streamingFieldProcessors,\n        state.content,\n        state.xstate,\n        mem,\n        state.values,\n        sessionId,\n        true\n      );\n    }\n\n    yield* streamValues<OUT>(\n      signature,\n      state.content,\n      state.values as Record<string, OUT>,\n      state.xstate,\n      state.index\n    );\n  }\n}\n\nexport async function* processResponse<OUT>({\n  ai,\n  res,\n  mem,\n  sessionId,\n  traceId,\n  functions,\n  span,\n  strictMode,\n  states,\n  usage,\n  excludeContentFromTrace,\n  asserts,\n  fieldProcessors,\n  thoughtFieldName,\n  signature,\n  functionResultFormatter,\n  logger,\n}: Readonly<AxResponseHandlerArgs<AxChatResponse>> & {\n  states: InternalAxGenState[];\n  usage: AxModelUsage[];\n  excludeContentFromTrace: boolean;\n  asserts: AxAssertion[];\n  fieldProcessors: AxFieldProcessor[];\n  thoughtFieldName: string;\n  signature: AxSignature;\n  functionResultFormatter?: (result: unknown) => string;\n}): AsyncGenDeltaOut<OUT> {\n  const results = res.results ?? [];\n\n  mem.addResponse(results, sessionId);\n\n  for (const result of results) {\n    const state = states[result.index];\n\n    if (!state) {\n      throw new Error(`No state found for result (index: ${result.index})`);\n    }\n\n    if (res.modelUsage) {\n      usage.push(res.modelUsage);\n    }\n\n    if (result.functionCalls?.length) {\n      const funcs = parseFunctionCalls(ai, result.functionCalls, state.values);\n      if (funcs) {\n        if (!functions) {\n          throw new Error('Functions are not defined');\n        }\n\n        const fx = await processFunctions({\n          ai,\n          functionList: functions,\n          functionCalls: funcs,\n          mem,\n          sessionId,\n          traceId,\n          span,\n          excludeContentFromTrace,\n          index: result.index,\n          functionResultFormatter,\n          logger,\n        });\n\n        state.functionsExecuted = new Set([...state.functionsExecuted, ...fx]);\n      }\n    } else if (result.content) {\n      if (result.thought && result.thought.length > 0) {\n        state.values[thoughtFieldName] = result.thought;\n      }\n\n      extractValues(signature, state.values, result.content, strictMode);\n      await assertAssertions(asserts, state.values);\n\n      if (fieldProcessors.length) {\n        await processFieldProcessors(\n          fieldProcessors,\n          state.values,\n          mem,\n          sessionId\n        );\n      }\n    }\n\n    if (result.finishReason === 'length') {\n      throw new Error(\n        `Max tokens reached before completion\\nContent: ${result.content}`\n      );\n    }\n  }\n\n  const values = states.map((s) => s.values);\n\n  // Strip out values whose signature fields have isInternal: true\n  for (const v of values) {\n    for (const field of signature.getOutputFields()) {\n      if (field.isInternal) {\n        delete v[field.name];\n      }\n    }\n  }\n\n  const outputFields = signature.getOutputFields();\n  const deltas: DeltaOut<OUT>[] = values.map((v, index) => {\n    const delta: Record<string, unknown> = {};\n    for (const field of outputFields) {\n      if (field.isInternal) {\n        continue;\n      }\n      delta[field.name] = v[field.name];\n    }\n    // Include thought field if it exists in the values\n    if (v[thoughtFieldName] !== undefined) {\n      delta[thoughtFieldName] = v[thoughtFieldName];\n    }\n    return { index, delta: delta as Partial<OUT> };\n  });\n\n  for (const delta of deltas) {\n    yield delta;\n  }\n}\n\nexport function shouldContinueSteps(\n  mem: AxAIMemory,\n  stopFunction: string | undefined,\n  states: InternalAxGenState[],\n  sessionId?: string\n) {\n  const lastMemItem = mem.getLast(sessionId);\n\n  if (!lastMemItem) {\n    return true;\n  }\n\n  for (const [index, state] of states.entries()) {\n    const stopFunctionExecuted =\n      stopFunction && state.functionsExecuted.has(stopFunction);\n\n    const chat = lastMemItem.chat[index];\n\n    if (!chat) {\n      throw new Error(`No chat message found for result (index: ${index})`);\n    }\n\n    const isFunction = lastMemItem.role === 'function';\n    const isProcessor = lastMemItem.tags\n      ? lastMemItem.tags.some((tag) => tag === 'processor')\n      : false;\n\n    // If any state has stop function executed, return false immediately\n    if (isFunction && stopFunction && stopFunctionExecuted) {\n      return false;\n    }\n\n    // If this state doesn't meet continuation criteria, return false\n    if (!(isFunction || isProcessor)) {\n      return false;\n    }\n  }\n\n  // All states meet continuation criteria\n  return true;\n}\n", "import type { AxTunable, AxUsable } from './types.js';\n\ntype AxInstanceRegistryItem<T extends AxTunable<IN, OUT>, IN, OUT> = T &\n  AxUsable;\n\nexport class AxInstanceRegistry<T extends AxTunable<IN, OUT>, IN, OUT> {\n  private reg: Set<AxInstanceRegistryItem<T, IN, OUT>>; // To track keys for iteration\n\n  constructor() {\n    this.reg = new Set();\n  }\n\n  register(instance: AxInstanceRegistryItem<T, IN, OUT>): void {\n    this.reg.add(instance);\n  }\n\n  *[Symbol.iterator]() {\n    const items = Array.from(this.reg);\n    for (let i = 0; i < items.length; i++) {\n      yield items[i];\n    }\n  }\n}\n", "// Updated type definitions\n\nexport type TypeNotClass =\n  | 'string'\n  | 'number'\n  | 'boolean'\n  | 'json'\n  | 'image'\n  | 'audio'\n  | 'file'\n  | 'url'\n  | 'datetime'\n  | 'date'\n  | 'code';\nexport type Type = TypeNotClass | 'class';\nexport type ParsedIdentifier = string;\nexport type ParsedString = string;\n\nexport type ParsedSignature = {\n  desc?: string;\n  inputs: InputParsedField[];\n  outputs: OutputParsedField[];\n};\n\nexport type InputParsedField = {\n  name: ParsedIdentifier;\n  desc?: string;\n  type?: { name: TypeNotClass; isArray: boolean };\n  isOptional?: boolean;\n};\n\nexport type OutputParsedField = {\n  name: ParsedIdentifier;\n  desc?: string;\n  type?:\n    | { name: TypeNotClass; isArray: boolean; options?: string[] }\n    | { name: 'class'; isArray: boolean; options: string[] };\n  isOptional?: boolean;\n  isInternal?: boolean;\n};\n\nimport { axGlobals } from './globals.js';\n\nclass SignatureValidationError extends Error {\n  constructor(\n    message: string,\n    public readonly position: number,\n    public readonly context: string,\n    public readonly suggestion?: string\n  ) {\n    super(message);\n    this.name = 'SignatureValidationError';\n  }\n}\n\nclass SignatureParser {\n  private input: string;\n  private position: number;\n  private currentFieldName: string | null = null;\n  private currentSection: 'description' | 'inputs' | 'outputs' = 'description';\n\n  constructor(input: string) {\n    this.input = input.trim();\n    this.position = 0;\n\n    if (!this.input) {\n      throw new SignatureValidationError(\n        'Empty signature provided',\n        0,\n        '',\n        'A signature must contain at least input and output fields separated by \"->\". Example: \"userQuery:string -> aiResponse:string\"'\n      );\n    }\n  }\n\n  parse(): ParsedSignature {\n    try {\n      this.skipWhitespace();\n      const optionalDesc = this.parseParsedString();\n      this.skipWhitespace();\n\n      this.currentSection = 'inputs';\n      // Use the specialized input field parser\n      const inputs = this.parseFieldList(\n        this.parseInputField.bind(this),\n        'input'\n      );\n      this.skipWhitespace();\n\n      if (this.position >= this.input.length) {\n        throw new SignatureValidationError(\n          'Incomplete signature: Missing output section',\n          this.position,\n          this.getErrorContext(),\n          'Add \"->\" followed by output fields. Example: \"-> responseText:string\"'\n        );\n      }\n\n      this.expectArrow();\n      this.skipWhitespace();\n\n      if (this.position >= this.input.length) {\n        throw new SignatureValidationError(\n          'Incomplete signature: No output fields specified after \"->\"',\n          this.position,\n          this.getErrorContext(),\n          'Add at least one output field. Example: \"-> responseText:string\"'\n        );\n      }\n\n      this.currentSection = 'outputs';\n      // Use the specialized output field parser\n      const outputs = this.parseFieldList(\n        this.parseOutputField.bind(this),\n        'output'\n      );\n\n      // Check for any remaining content that shouldn't be there\n      this.skipWhitespace();\n      if (this.position < this.input.length) {\n        const remaining = this.input.slice(this.position);\n        throw new SignatureValidationError(\n          `Unexpected content after signature: \"${remaining}\"`,\n          this.position,\n          this.getErrorContext(),\n          'Remove any extra content after the output fields'\n        );\n      }\n\n      // Validate the parsed signature\n      this.validateParsedSignature({\n        desc: optionalDesc?.trim(),\n        inputs,\n        outputs,\n      });\n\n      return {\n        desc: optionalDesc?.trim(),\n        inputs,\n        outputs,\n      };\n    } catch (error) {\n      if (error instanceof SignatureValidationError) {\n        throw error;\n      }\n\n      // Wrap other errors with better context\n      const errorMessage =\n        error instanceof Error ? error.message : 'Unknown error';\n      throw new SignatureValidationError(\n        errorMessage,\n        this.position,\n        this.getErrorContext()\n      );\n    }\n  }\n\n  private validateParsedSignature(signature: Readonly<ParsedSignature>): void {\n    // Check for duplicate field names within inputs\n    const inputNames = new Set<string>();\n    for (const field of signature.inputs) {\n      if (inputNames.has(field.name)) {\n        throw new SignatureValidationError(\n          `Duplicate input field name: \"${field.name}\"`,\n          0,\n          '',\n          'Each field name must be unique within the signature'\n        );\n      }\n      inputNames.add(field.name);\n    }\n\n    // Check for duplicate field names within outputs\n    const outputNames = new Set<string>();\n    for (const field of signature.outputs) {\n      if (outputNames.has(field.name)) {\n        throw new SignatureValidationError(\n          `Duplicate output field name: \"${field.name}\"`,\n          0,\n          '',\n          'Each field name must be unique within the signature'\n        );\n      }\n      outputNames.add(field.name);\n    }\n\n    // Check for field names that appear in both inputs and outputs\n    for (const outputField of signature.outputs) {\n      if (inputNames.has(outputField.name)) {\n        throw new SignatureValidationError(\n          `Field name \"${outputField.name}\" appears in both inputs and outputs`,\n          0,\n          '',\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    // Validate that we have at least one input and one output\n    if (signature.inputs.length === 0) {\n      throw new SignatureValidationError(\n        'Signature must have at least one input field',\n        0,\n        '',\n        'Add an input field before \"->\". Example: \"userInput:string -> ...\"'\n      );\n    }\n\n    if (signature.outputs.length === 0) {\n      throw new SignatureValidationError(\n        'Signature must have at least one output field',\n        0,\n        '',\n        'Add an output field after \"->\". Example: \"... -> responseText:string\"'\n      );\n    }\n  }\n\n  private getErrorContext(): string {\n    const start = Math.max(0, this.position - 25);\n    const end = Math.min(this.input.length, this.position + 25);\n    const before = this.input.slice(start, this.position);\n    const after = this.input.slice(this.position, end);\n    const pointer = `${' '.repeat(before.length)}^`;\n\n    const lines = [\n      `Position ${this.position} in signature:`,\n      `\"${before}${after}\"`,\n      ` ${pointer}`,\n    ];\n\n    return lines.join('\\n');\n  }\n\n  private parseFieldList<T extends InputParsedField | OutputParsedField>(\n    parseFieldFn: () => T,\n    section: 'input' | 'output'\n  ): T[] {\n    const fields: T[] = [];\n    this.skipWhitespace();\n\n    if (this.position >= this.input.length) {\n      throw new SignatureValidationError(\n        `Empty ${section} section: Expected at least one field`,\n        this.position,\n        this.getErrorContext(),\n        `Add a ${section} field. Example: ${section === 'input' ? 'userInput:string' : 'responseText:string'}`\n      );\n    }\n\n    // Parse first field\n    try {\n      fields.push(parseFieldFn());\n    } catch (error) {\n      if (error instanceof SignatureValidationError) {\n        throw error;\n      }\n      throw new SignatureValidationError(\n        `Invalid first ${section} field: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        this.position,\n        this.getErrorContext()\n      );\n    }\n\n    this.skipWhitespace();\n\n    // Parse remaining fields\n    while (this.position < this.input.length) {\n      if (\n        this.input[this.position] === '-' &&\n        this.position + 1 < this.input.length &&\n        this.input[this.position + 1] === '>'\n      ) {\n        break;\n      }\n\n      if (this.match(',')) {\n        this.skipWhitespace();\n        if (this.position >= this.input.length) {\n          throw new SignatureValidationError(\n            `Unexpected end of input after comma in ${section} section`,\n            this.position,\n            this.getErrorContext(),\n            `Add another ${section} field after the comma`\n          );\n        }\n        try {\n          fields.push(parseFieldFn());\n        } catch (error) {\n          if (error instanceof SignatureValidationError) {\n            throw error;\n          }\n          throw new SignatureValidationError(\n            `Invalid ${section} field after comma: ${error instanceof Error ? error.message : 'Unknown error'}`,\n            this.position,\n            this.getErrorContext()\n          );\n        }\n        this.skipWhitespace();\n      } else {\n        break;\n      }\n    }\n\n    return fields;\n  }\n\n  // -------------------------------\n  // Parse input fields (no \"class\" type and no internal flag)\n  // -------------------------------\n  private parseInputField(): InputParsedField {\n    this.skipWhitespace();\n    const name = this.parseParsedIdentifier();\n    this.currentFieldName = name;\n\n    // Validate field name for inputs\n    this.validateFieldName(name, 'input');\n\n    // Only the optional marker is allowed\n    let isOptional: boolean | undefined;\n    while (true) {\n      if (this.match('?')) {\n        isOptional = true;\n        continue;\n      }\n      if (this.match('!')) {\n        throw new SignatureValidationError(\n          `Input field \"${name}\" cannot use the internal marker \"!\"`,\n          this.position - 1,\n          this.getErrorContext(),\n          'Internal markers (!) are only allowed on output fields'\n        );\n      }\n      break;\n    }\n\n    let type: { name: TypeNotClass; isArray: boolean } | undefined;\n    this.skipWhitespace();\n    if (this.match(':')) {\n      this.skipWhitespace();\n      // Disallow the \"class\" type in input fields\n      if (/^class\\b/.test(this.input.slice(this.position))) {\n        throw new SignatureValidationError(\n          `Input field \"${name}\" cannot use the \"class\" type`,\n          this.position,\n          this.getErrorContext(),\n          'Class types are only allowed on output fields. Use \"string\" type for input classifications'\n        );\n      }\n      try {\n        const typeName = this.parseTypeNotClass();\n        const isArray = this.match('[]');\n        type = { name: typeName, isArray };\n\n        // Validate specific type constraints for input fields\n        if ((typeName === 'image' || typeName === 'audio') && isArray) {\n          throw new SignatureValidationError(\n            `Input field \"${name}\": Arrays of ${typeName} are not supported`,\n            this.position,\n            this.getErrorContext(),\n            `Use a single ${typeName} type instead: \"${typeName}\"`\n          );\n        }\n      } catch (error) {\n        if (error instanceof SignatureValidationError) {\n          throw error;\n        }\n        throw new SignatureValidationError(\n          `Input field \"${name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n          this.position,\n          this.getErrorContext()\n        );\n      }\n    }\n\n    this.skipWhitespace();\n    const desc = this.parseParsedString();\n\n    return {\n      name,\n      desc: desc?.trim(),\n      type,\n      isOptional,\n    };\n  }\n\n  // -------------------------------\n  // Parse output fields (supports both \"class\" type and the internal marker)\n  // -------------------------------\n  private parseOutputField(): OutputParsedField {\n    this.skipWhitespace();\n    const name = this.parseParsedIdentifier();\n    this.currentFieldName = name;\n\n    // Validate field name for outputs\n    this.validateFieldName(name, 'output');\n\n    let isOptional = false;\n    let isInternal = false;\n    while (true) {\n      if (this.match('?')) {\n        isOptional = true;\n        continue;\n      }\n      if (this.match('!')) {\n        isInternal = true;\n        continue;\n      }\n      break;\n    }\n\n    let type:\n      | { name: TypeNotClass; isArray: boolean; options?: string[] }\n      | { name: 'class'; isArray: boolean; options: string[] }\n      | undefined;\n    this.skipWhitespace();\n    if (this.match(':')) {\n      this.skipWhitespace();\n      if (this.match('class')) {\n        const isArray = this.match('[]');\n        this.skipWhitespace();\n        const classNamesString = this.parseParsedString();\n        if (!classNamesString) {\n          throw new SignatureValidationError(\n            `Output field \"${name}\": Missing class options after \"class\" type`,\n            this.position,\n            this.getErrorContext(),\n            'Add class names in quotes. Example: class \"positive, negative, neutral\"'\n          );\n        }\n        const options = classNamesString\n          .split(/[,|]/)\n          .map((s) => s.trim())\n          .filter((s) => s.length > 0);\n\n        if (options.length === 0) {\n          throw new SignatureValidationError(\n            `Output field \"${name}\": Empty class list provided`,\n            this.position,\n            this.getErrorContext(),\n            'Provide at least one class option. Example: \"positive, negative\"'\n          );\n        }\n\n        type = { name: 'class', isArray, options };\n      } else {\n        try {\n          const typeName = this.parseTypeNotClass();\n          const isArray = this.match('[]');\n          type = { name: typeName, isArray };\n\n          // Validate specific type constraints\n          if (typeName === 'image' && isArray) {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Arrays of images are not supported`,\n              this.position,\n              this.getErrorContext(),\n              'Use a single image type instead: \"image\"'\n            );\n          }\n\n          if (typeName === 'audio' && isArray) {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Arrays of audio are not supported`,\n              this.position,\n              this.getErrorContext(),\n              'Use a single audio type instead: \"audio\"'\n            );\n          }\n\n          if (typeName === 'image') {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Image type is not supported in output fields`,\n              this.position,\n              this.getErrorContext(),\n              'Image types can only be used in input fields'\n            );\n          }\n\n          if (typeName === 'audio') {\n            throw new SignatureValidationError(\n              `Output field \"${name}\": Audio type is not supported in output fields`,\n              this.position,\n              this.getErrorContext(),\n              'Audio types can only be used in input fields'\n            );\n          }\n        } catch (error) {\n          if (error instanceof SignatureValidationError) {\n            throw error;\n          }\n          throw new SignatureValidationError(\n            `Output field \"${name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n            this.position,\n            this.getErrorContext()\n          );\n        }\n      }\n    }\n\n    this.skipWhitespace();\n    const desc = this.parseParsedString();\n\n    return {\n      name,\n      desc: desc?.trim(),\n      type,\n      isOptional,\n      isInternal,\n    };\n  }\n\n  private validateFieldName(name: string, fieldType: 'input' | 'output'): void {\n    // Check for reserved/generic names that should be more descriptive\n    if (axGlobals.signatureStrict) {\n      const reservedNames = [\n        'text',\n        'object',\n        'image',\n        'string',\n        'number',\n        'boolean',\n        'json',\n        'array',\n        'datetime',\n        'date',\n        'time',\n        'type',\n        'class',\n        'input',\n        'output',\n        'data',\n        'value',\n        'result',\n        'response',\n        'request',\n        'item',\n        'element',\n      ];\n\n      if (reservedNames.includes(name.toLowerCase())) {\n        const suggestions =\n          fieldType === 'input'\n            ? ['userInput', 'questionText', 'documentContent', 'messageText']\n            : ['responseText', 'analysisResult', 'categoryType', 'summaryText'];\n\n        throw new SignatureValidationError(\n          `Field name \"${name}\" is too generic`,\n          this.position,\n          this.getErrorContext(),\n          `Use a more descriptive name. Examples: ${suggestions.join(', ')}`\n        );\n      }\n    }\n\n    // Check naming convention\n    const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;\n    const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/;\n\n    if (!camelCaseRegex.test(name) && !snakeCaseRegex.test(name)) {\n      throw new SignatureValidationError(\n        `Invalid field name \"${name}\"`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must be in camelCase (e.g., \"userInput\") or snake_case (e.g., \"user_input\")'\n      );\n    }\n\n    // Check for minimum length\n    if (name.length < 2) {\n      throw new SignatureValidationError(\n        `Field name \"${name}\" is too short`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must be at least 2 characters long'\n      );\n    }\n\n    // Check for maximum length\n    if (name.length > 50) {\n      throw new SignatureValidationError(\n        `Field name \"${name}\" is too long (${name.length} characters)`,\n        this.position,\n        this.getErrorContext(),\n        'Field names should be 50 characters or less'\n      );\n    }\n  }\n\n  private parseTypeNotClass(): TypeNotClass {\n    const types: TypeNotClass[] = [\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'image',\n      'audio',\n      'file',\n      'url',\n      'datetime',\n      'date',\n      'code',\n    ];\n\n    const foundType = types.find((type) => this.match(type));\n    if (!foundType) {\n      const currentWord =\n        this.input.slice(this.position).match(/^\\w+/)?.[0] || '';\n      const suggestion = this.suggestType(currentWord);\n\n      const baseMessage = `Invalid type \"${currentWord || 'empty'}\"`;\n      const suggestionPart = suggestion\n        ? `. Did you mean \"${suggestion}\"?`\n        : '';\n      const fullMessage = `${baseMessage}${suggestionPart}`;\n\n      throw new SignatureValidationError(\n        fullMessage,\n        this.position,\n        this.getErrorContext(),\n        `Expected one of: ${types.join(', ')}`\n      );\n    }\n    return foundType;\n  }\n\n  private suggestType(input: string): string | null {\n    const suggestions: Record<string, string> = {\n      str: 'string',\n      text: 'string',\n      int: 'number',\n      integer: 'number',\n      float: 'number',\n      double: 'number',\n      bool: 'boolean',\n      object: 'json',\n      dict: 'json',\n      timestamp: 'datetime',\n      time: 'datetime',\n      img: 'image',\n      picture: 'image',\n      sound: 'audio',\n      voice: 'audio',\n      classification: 'class',\n      category: 'class',\n    };\n\n    return suggestions[input.toLowerCase()] || null;\n  }\n\n  private parseParsedIdentifier(): ParsedIdentifier {\n    this.skipWhitespace();\n    const match = /^[a-zA-Z_][a-zA-Z_0-9]*/.exec(\n      this.input.slice(this.position)\n    );\n    if (match) {\n      this.position += match[0].length;\n      return match[0];\n    }\n\n    const invalidMatch = /^\\S+/.exec(this.input.slice(this.position));\n    const invalidId = invalidMatch ? invalidMatch[0] : '';\n\n    if (invalidId === '') {\n      throw new SignatureValidationError(\n        'Expected field name but found end of input',\n        this.position,\n        this.getErrorContext(),\n        'Add a field name. Field names must start with a letter or underscore'\n      );\n    }\n\n    if (/^\\d/.test(invalidId)) {\n      throw new SignatureValidationError(\n        `Invalid field name \"${invalidId}\" - cannot start with a number`,\n        this.position,\n        this.getErrorContext(),\n        'Field names must start with a letter or underscore. Example: \"userInput\" or \"_internal\"'\n      );\n    }\n\n    throw new SignatureValidationError(\n      `Invalid field name \"${invalidId}\"`,\n      this.position,\n      this.getErrorContext(),\n      'Field names must start with a letter or underscore and contain only letters, numbers, or underscores'\n    );\n  }\n\n  private parseParsedString(): string | undefined {\n    const quoteChars = [\"'\", '\"'];\n    for (const quoteChar of quoteChars) {\n      if (this.match(quoteChar)) {\n        let content = '';\n        let escaped = false;\n        const startPos = this.position - 1;\n\n        while (this.position < this.input.length) {\n          const char = this.input[this.position];\n          this.position++;\n          if (escaped) {\n            content += char;\n            escaped = false;\n          } else if (char === '\\\\') {\n            escaped = true;\n          } else if (char === quoteChar) {\n            return content;\n          } else {\n            content += char;\n          }\n        }\n\n        const partialString = this.input.slice(\n          startPos,\n          Math.min(this.position, startPos + 20)\n        );\n        throw new SignatureValidationError(\n          `Unterminated string starting at position ${startPos}`,\n          startPos,\n          this.getErrorContext(),\n          `Add closing ${quoteChar} to complete the string: ${partialString}${quoteChar}`\n        );\n      }\n    }\n    return undefined;\n  }\n\n  private skipWhitespace() {\n    const match = /^[\\s\\t\\r\\n]+/.exec(this.input.slice(this.position));\n    if (match) {\n      this.position += match[0].length;\n    }\n  }\n\n  private match(strOrRegex: string | RegExp): boolean {\n    let match: RegExpExecArray | null;\n    if (typeof strOrRegex === 'string') {\n      if (this.input.startsWith(strOrRegex, this.position)) {\n        this.position += strOrRegex.length;\n        return true;\n      }\n    } else {\n      match = strOrRegex.exec(this.input.slice(this.position));\n      if (match) {\n        this.position += match[0].length;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private expectArrow() {\n    if (!this.match('->')) {\n      const found = this.input.slice(this.position, this.position + 10);\n      const suggestion = found.includes('>')\n        ? 'Use \"->\" (dash followed by greater-than)'\n        : found.includes('-')\n          ? 'Add \">\" after the dash'\n          : 'Add \"->\" to separate input and output fields';\n\n      throw new SignatureValidationError(\n        `Expected \"->\" but found \"${found}...\"`,\n        this.position,\n        this.getErrorContext(),\n        suggestion\n      );\n    }\n  }\n}\n\nexport function parseSignature(input: string): ParsedSignature {\n  const parser = new SignatureParser(input);\n  return parser.parse();\n}\n", "import type { AxFunctionJSONSchema } from '../ai/types.js';\nimport { createHash } from '../util/crypto.js';\n\nimport { axGlobals } from './globals.js';\nimport {\n  type InputParsedField,\n  type OutputParsedField,\n  type ParsedSignature,\n  parseSignature,\n} from './parser.js';\nimport type { ParseSignature } from './types.js';\n// Interface for programmatically defining field types\nexport interface AxFieldType {\n  readonly type:\n    | 'string'\n    | 'number'\n    | 'boolean'\n    | 'json'\n    | 'image'\n    | 'audio'\n    | 'file'\n    | 'url'\n    | 'date'\n    | 'datetime'\n    | 'class'\n    | 'code';\n  readonly isArray?: boolean;\n  readonly options?: readonly string[];\n  readonly description?: string;\n  readonly isOptional?: boolean;\n  readonly isInternal?: boolean;\n}\n\n// Improved SignatureBuilder class for fluent API with better type inference\nexport class AxSignatureBuilder<\n  _TInput extends Record<string, any> = {},\n  _TOutput extends Record<string, any> = {},\n> {\n  private inputFields: AxField[] = [];\n  private outputFields: AxField[] = [];\n  private desc?: string;\n\n  /**\n   * Add an input field to the signature\n   * @param name - Field name\n   * @param fieldInfo - Field type created with f.string(), f.number(), etc.\n   * @param prepend - If true, adds field to the beginning of input fields\n   */\n  public input<\n    K extends string,\n    T extends AxFluentFieldInfo<any, any, any, any> | AxFluentFieldType,\n  >(\n    name: K,\n    fieldInfo: T,\n    prepend = false\n  ): AxSignatureBuilder<_TInput & Record<K, InferFluentType<T>>, _TOutput> {\n    const field: AxField = {\n      name,\n      type: {\n        name: fieldInfo.type,\n        isArray: fieldInfo.isArray,\n        options: fieldInfo.options ? [...fieldInfo.options] : undefined,\n      },\n      description: fieldInfo.description,\n      isOptional: fieldInfo.isOptional,\n      isInternal: fieldInfo.isInternal,\n    };\n\n    if (prepend) {\n      this.inputFields.unshift(field);\n    } else {\n      this.inputFields.push(field);\n    }\n\n    return this as any;\n  }\n\n  /**\n   * Add an output field to the signature\n   * @param name - Field name\n   * @param fieldInfo - Field type created with f.string(), f.number(), etc.\n   * @param prepend - If true, adds field to the beginning of output fields\n   */\n  public output<\n    K extends string,\n    T extends AxFluentFieldInfo<any, any, any, any> | AxFluentFieldType,\n  >(\n    name: K,\n    fieldInfo: T,\n    prepend = false\n  ): AxSignatureBuilder<_TInput, _TOutput & Record<K, InferFluentType<T>>> {\n    const field: AxField = {\n      name,\n      type: {\n        name: fieldInfo.type,\n        isArray: fieldInfo.isArray,\n        options: fieldInfo.options ? [...fieldInfo.options] : undefined,\n      },\n      description: fieldInfo.description,\n      isOptional: fieldInfo.isOptional,\n      isInternal: fieldInfo.isInternal,\n    };\n\n    if (prepend) {\n      this.outputFields.unshift(field);\n    } else {\n      this.outputFields.push(field);\n    }\n\n    return this as any;\n  }\n\n  /**\n   * Set the description for the signature\n   * @param description - Description text\n   */\n  public description(\n    description: string\n  ): AxSignatureBuilder<_TInput, _TOutput> {\n    this.desc = description;\n    return this;\n  }\n\n  /**\n   * Build the final AxSignature instance\n   */\n  public build(): AxSignature<_TInput, _TOutput> {\n    const config: AxSignatureConfig = {\n      description: this.desc,\n      inputs: this.inputFields,\n      outputs: this.outputFields,\n    };\n\n    return new AxSignature(config) as AxSignature<_TInput, _TOutput>;\n  }\n}\n\n// Fluent field type builder for method chaining\nexport class AxFluentFieldType implements AxFieldType {\n  readonly type: AxFieldType['type'];\n  readonly isArray?: boolean;\n  readonly options?: readonly string[];\n  readonly description?: string;\n  readonly isOptional?: boolean;\n  readonly isInternal?: boolean;\n\n  constructor(fieldType: AxFieldType) {\n    this.type = fieldType.type;\n    this.isArray = fieldType.isArray;\n    this.options = fieldType.options;\n    this.description = fieldType.description;\n    this.isOptional = fieldType.isOptional;\n    this.isInternal = fieldType.isInternal;\n  }\n\n  optional(): AxFluentFieldType {\n    return new AxFluentFieldType({\n      ...this,\n      isOptional: true,\n    });\n  }\n\n  array(): AxFluentFieldType {\n    return new AxFluentFieldType({\n      ...this,\n      isArray: true,\n    });\n  }\n\n  internal(): AxFluentFieldType {\n    return new AxFluentFieldType({\n      ...this,\n      isInternal: true,\n    });\n  }\n}\n\n// Improved helper functions for creating strongly-typed field info\nexport const f = Object.assign(\n  (): AxSignatureBuilder => new AxSignatureBuilder(),\n  {\n    string: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'string' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    number: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'number' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    boolean: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'boolean' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    json: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'json' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    datetime: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'datetime' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    date: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'date' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    class: <const TOptions extends readonly string[]>(\n      options: TOptions,\n      desc?: string\n    ): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'class' as const,\n        isArray: false as const,\n        options,\n        description: desc,\n      }),\n\n    image: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'image' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    audio: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'audio' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    file: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'file' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    url: (desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'url' as const,\n        isArray: false as const,\n        description: desc,\n      }),\n\n    code: (language?: string, desc?: string): AxFluentFieldType =>\n      new AxFluentFieldType({\n        type: 'code' as const,\n        isArray: false as const,\n        description: desc || language,\n      }),\n\n    // Enhanced helper functions for fluent chaining\n    array: <T extends AxFluentFieldInfo<any, any, any, any>>(\n      baseType: T\n    ): AxFluentFieldInfo<T['type'], true, T['options'], T['isOptional']> => ({\n      ...baseType,\n      isArray: true as const,\n    }),\n\n    optional: <T extends AxFluentFieldInfo<any, any, any, any>>(\n      baseType: T\n    ): AxFluentFieldInfo<T['type'], T['isArray'], T['options'], true> => ({\n      ...baseType,\n      isOptional: true as const,\n    }),\n\n    internal: <T extends AxFluentFieldInfo<any, any, any, any>>(\n      baseType: T\n    ): T & { readonly isInternal: true } => ({\n      ...baseType,\n      isInternal: true as const,\n    }),\n\n    // Legacy helper functions for backward compatibility with AxFieldType\n    legacyArray: <T extends AxFieldType>(\n      baseType: T\n    ): T & { readonly isArray: true } => ({\n      ...baseType,\n      isArray: true,\n    }),\n\n    legacyOptional: <T extends AxFieldType>(\n      baseType: T\n    ): T & { readonly isOptional: true } => ({\n      ...baseType,\n      isOptional: true,\n    }),\n\n    legacyInternal: <T extends AxFieldType>(\n      baseType: T\n    ): T & { readonly isInternal: true } => ({\n      ...baseType,\n      isInternal: true,\n    }),\n  }\n);\n\n// Backward compatibility alias (legacy API)\nexport const createFieldType = f;\n\nexport interface AxField {\n  name: string;\n  title?: string;\n  description?: string;\n  type?: {\n    name:\n      | 'string'\n      | 'number'\n      | 'boolean'\n      | 'json'\n      | 'image'\n      | 'audio'\n      | 'file'\n      | 'url'\n      | 'date'\n      | 'datetime'\n      | 'class'\n      | 'code';\n    isArray?: boolean;\n    options?: string[];\n  };\n  isOptional?: boolean;\n  isInternal?: boolean;\n}\n\nexport type AxIField = Omit<AxField, 'title'> & { title: string };\n\n// Helper type to map AxFieldType or AxFluentFieldType to TypeScript types for type-safe field additions\ntype InferFieldValueType<T> = T extends AxFieldType | AxFluentFieldType\n  ? T['type'] extends 'string'\n    ? T['isArray'] extends true\n      ? string[]\n      : string\n    : T['type'] extends 'number'\n      ? T['isArray'] extends true\n        ? number[]\n        : number\n      : T['type'] extends 'boolean'\n        ? T['isArray'] extends true\n          ? boolean[]\n          : boolean\n        : T['type'] extends 'json'\n          ? T['isArray'] extends true\n            ? any[]\n            : any\n          : T['type'] extends 'date'\n            ? T['isArray'] extends true\n              ? Date[]\n              : Date\n            : T['type'] extends 'datetime'\n              ? T['isArray'] extends true\n                ? Date[]\n                : Date\n              : T['type'] extends 'image'\n                ? T['isArray'] extends true\n                  ? { mimeType: string; data: string }[]\n                  : { mimeType: string; data: string }\n                : T['type'] extends 'audio'\n                  ? T['isArray'] extends true\n                    ? { format?: 'wav'; data: string }[]\n                    : { format?: 'wav'; data: string }\n                  : T['type'] extends 'file'\n                    ? T['isArray'] extends true\n                      ? { mimeType: string; data: string }[]\n                      : { mimeType: string; data: string }\n                    : T['type'] extends 'url'\n                      ? T['isArray'] extends true\n                        ? string[]\n                        : string\n                      : T['type'] extends 'code'\n                        ? T['isArray'] extends true\n                          ? string[]\n                          : string\n                        : T['type'] extends 'class'\n                          ? T['options'] extends readonly (infer U)[]\n                            ? T['isArray'] extends true\n                              ? U[]\n                              : U\n                            : T['isArray'] extends true\n                              ? string[]\n                              : string\n                          : any\n  : any;\n\n// Improved fluent field type that preserves exact type information for better inference\nexport interface AxFluentFieldInfo<\n  TType extends AxFieldType['type'] = AxFieldType['type'],\n  TIsArray extends boolean = false,\n  TOptions extends readonly string[] = readonly string[],\n  TIsOptional extends boolean = false,\n> {\n  readonly type: TType;\n  readonly isArray?: TIsArray;\n  readonly options?: TOptions;\n  readonly description?: string;\n  readonly isOptional?: TIsOptional;\n  readonly isInternal?: boolean;\n}\n\n// Helper type to infer TypeScript type from fluent field info\ntype InferFluentType<\n  T extends AxFluentFieldInfo<any, any, any, any> | AxFluentFieldType,\n> = T['type'] extends 'string'\n  ? T['isArray'] extends true\n    ? string[]\n    : string\n  : T['type'] extends 'number'\n    ? T['isArray'] extends true\n      ? number[]\n      : number\n    : T['type'] extends 'boolean'\n      ? T['isArray'] extends true\n        ? boolean[]\n        : boolean\n      : T['type'] extends 'json'\n        ? T['isArray'] extends true\n          ? any[]\n          : any\n        : T['type'] extends 'date'\n          ? T['isArray'] extends true\n            ? Date[]\n            : Date\n          : T['type'] extends 'datetime'\n            ? T['isArray'] extends true\n              ? Date[]\n              : Date\n            : T['type'] extends 'image'\n              ? T['isArray'] extends true\n                ? { mimeType: string; data: string }[]\n                : { mimeType: string; data: string }\n              : T['type'] extends 'audio'\n                ? T['isArray'] extends true\n                  ? { format?: 'wav'; data: string }[]\n                  : { format?: 'wav'; data: string }\n                : T['type'] extends 'file'\n                  ? T['isArray'] extends true\n                    ? { mimeType: string; data: string }[]\n                    : { mimeType: string; data: string }\n                  : T['type'] extends 'url'\n                    ? T['isArray'] extends true\n                      ? string[]\n                      : string\n                    : T['type'] extends 'code'\n                      ? T['isArray'] extends true\n                        ? string[]\n                        : string\n                      : T['type'] extends 'class'\n                        ? T['options'] extends readonly (infer U)[]\n                          ? T['isArray'] extends true\n                            ? U[]\n                            : U\n                          : T['isArray'] extends true\n                            ? string[]\n                            : string\n                        : any;\n\n// Helper function to convert AxFieldType to AxField\nfunction convertFieldTypeToAxField(\n  fieldType: AxFieldType\n): Omit<AxField, 'name'> {\n  return {\n    type: {\n      name: fieldType.type,\n      isArray: fieldType.isArray,\n      options: fieldType.options ? [...fieldType.options] : undefined,\n    },\n    description: fieldType.description,\n    isOptional: fieldType.isOptional,\n    isInternal: fieldType.isInternal,\n  };\n}\n\nclass AxSignatureValidationError extends Error {\n  constructor(\n    message: string,\n    public readonly fieldName?: string,\n    public readonly suggestion?: string\n  ) {\n    super(message);\n    this.name = 'AxSignatureValidationError';\n  }\n}\n\nexport interface AxSignatureConfig {\n  description?: string;\n  inputs: readonly AxField[];\n  outputs: readonly AxField[];\n}\n\nexport class AxSignature<\n  _TInput extends Record<string, any> = Record<string, any>,\n  _TOutput extends Record<string, any> = Record<string, any>,\n> {\n  private description?: string;\n  private inputFields: AxIField[];\n  private outputFields: AxIField[];\n\n  private sigHash: string;\n  private sigString: string;\n\n  // Validation caching - stores hash when validation last passed\n  private validatedAtHash?: string;\n\n  /**\n   * @deprecated Use `AxSignature.create()` for better type safety instead of the constructor.\n   * This constructor will be removed in v15.0.0.\n   *\n   * Migration timeline:\n   * - v13.0.24+: Deprecation warnings (current)\n   * - v14.0.0: Runtime console warnings\n   * - v15.0.0: Complete removal\n   *\n   * @example\n   * ```typescript\n   * // Instead of: new AxSignature('userInput:string -> responseText:string')\n   * // Use: AxSignature.create('userInput:string -> responseText:string')\n   * ```\n   */\n  constructor(signature?: Readonly<AxSignature | string | AxSignatureConfig>) {\n    if (!signature) {\n      this.inputFields = [];\n      this.outputFields = [];\n      this.sigHash = '';\n      this.sigString = '';\n      return;\n    }\n\n    if (typeof signature === 'string') {\n      let sig: ParsedSignature;\n      try {\n        sig = parseSignature(signature);\n      } catch (e) {\n        if (e instanceof Error) {\n          // Preserve the suggestion if it's a SignatureValidationError\n          const suggestion =\n            'suggestion' in e &&\n            typeof (e as { suggestion: unknown }).suggestion === 'string'\n              ? (e as { suggestion: string }).suggestion\n              : 'Please check the signature format. Example: \"userInput:string -> responseText:string\"';\n          throw new AxSignatureValidationError(\n            `Invalid Signature: ${e.message}`,\n            undefined,\n            suggestion\n          );\n        }\n        throw new AxSignatureValidationError(\n          `Invalid Signature: ${signature}`,\n          undefined,\n          'Please check the signature format. Example: \"userInput:string -> responseText:string\"'\n        );\n      }\n      this.description = sig.desc;\n      this.inputFields = sig.inputs.map((v) => this.parseParsedField(v));\n      this.outputFields = sig.outputs.map((v) => this.parseParsedField(v));\n      [this.sigHash, this.sigString] = this.updateHash();\n    } else if (signature instanceof AxSignature) {\n      this.description = signature.getDescription();\n      this.inputFields = structuredClone(\n        signature.getInputFields()\n      ) as AxIField[];\n      this.outputFields = structuredClone(\n        signature.getOutputFields()\n      ) as AxIField[];\n      this.sigHash = signature.hash();\n      this.sigString = signature.toString();\n      // Copy validation state if the source signature was validated\n      if (signature.validatedAtHash === this.sigHash) {\n        this.validatedAtHash = this.sigHash;\n      }\n    } else if (typeof signature === 'object' && signature !== null) {\n      // Handle AxSignatureConfig object\n      if (!('inputs' in signature) || !('outputs' in signature)) {\n        throw new AxSignatureValidationError(\n          'Invalid signature object: missing inputs or outputs',\n          undefined,\n          'Signature object must have \"inputs\" and \"outputs\" arrays. Example: { inputs: [...], outputs: [...] }'\n        );\n      }\n\n      if (\n        !Array.isArray(signature.inputs) ||\n        !Array.isArray(signature.outputs)\n      ) {\n        throw new AxSignatureValidationError(\n          'Invalid signature object: inputs and outputs must be arrays',\n          undefined,\n          'Both \"inputs\" and \"outputs\" must be arrays of AxField objects'\n        );\n      }\n\n      try {\n        this.description = signature.description;\n        this.inputFields = signature.inputs.map((v) => this.parseField(v));\n        this.outputFields = signature.outputs.map((v) => this.parseField(v));\n        [this.sigHash, this.sigString] = this.updateHash();\n      } catch (error) {\n        if (error instanceof AxSignatureValidationError) {\n          throw error;\n        }\n        throw new AxSignatureValidationError(\n          `Failed to create signature from object: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          undefined,\n          'Check that all fields in inputs and outputs arrays are valid AxField objects'\n        );\n      }\n    } else {\n      throw new AxSignatureValidationError(\n        'Invalid signature argument type',\n        undefined,\n        'Signature must be a string, another AxSignature instance, or an object with inputs and outputs arrays'\n      );\n    }\n  }\n\n  /**\n   * Static factory method for type inference.\n   * Creates a typed AxSignature instance from a signature string.\n   */\n  public static create<const T extends string>(\n    signature: T\n  ): AxSignature<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n    return new AxSignature(signature) as AxSignature<\n      ParseSignature<T>['inputs'],\n      ParseSignature<T>['outputs']\n    >;\n  }\n\n  private parseParsedField = (\n    field: Readonly<InputParsedField | OutputParsedField>\n  ): AxIField => {\n    if (!field.name || field.name.length === 0) {\n      throw new AxSignatureValidationError(\n        'Field name is required',\n        field.name,\n        'Every field must have a descriptive name. Example: \"userInput\", \"responseText\"'\n      );\n    }\n\n    const title = this.toTitle(field.name);\n    return {\n      name: field.name,\n      title,\n      description: 'desc' in field ? field.desc : undefined,\n      type: field.type ?? { name: 'string', isArray: false },\n      ...('isInternal' in field ? { isInternal: field.isInternal } : {}),\n      ...('isOptional' in field ? { isOptional: field.isOptional } : {}),\n    };\n  };\n\n  private parseField = (field: Readonly<AxField>): AxIField => {\n    const title =\n      !field.title || field.title.length === 0\n        ? this.toTitle(field.name)\n        : field.title;\n\n    if (field.type && (!field.type.name || field.type.name.length === 0)) {\n      throw new AxSignatureValidationError(\n        'Field type name is required',\n        field.name,\n        'Specify a valid type. Available types: string, number, boolean, json, image, audio, file, url, date, datetime, class, code'\n      );\n    }\n\n    return { ...field, title };\n  };\n\n  public setDescription = (desc: string) => {\n    if (typeof desc !== 'string') {\n      throw new AxSignatureValidationError(\n        'Description must be a string',\n        undefined,\n        'Provide a string description for the signature'\n      );\n    }\n    this.description = desc;\n    this.invalidateValidationCache();\n    this.updateHashLight();\n  };\n\n  public addInputField = (field: Readonly<AxField>) => {\n    try {\n      const parsedField = this.parseField(field);\n      validateField(parsedField, 'input');\n\n      // Check for duplicate input field names\n      for (const existingField of this.inputFields) {\n        if (existingField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Duplicate input field name: \"${parsedField.name}\"`,\n            parsedField.name,\n            'Each field name must be unique within the signature'\n          );\n        }\n      }\n\n      // Check if field name conflicts with existing output fields\n      for (const outputField of this.outputFields) {\n        if (outputField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n            parsedField.name,\n            'Use different names for input and output fields to avoid confusion'\n          );\n        }\n      }\n\n      this.inputFields.push(parsedField);\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to add input field \"${field.name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n        field.name\n      );\n    }\n  };\n\n  public addOutputField = (field: Readonly<AxField>) => {\n    try {\n      const parsedField = this.parseField(field);\n      validateField(parsedField, 'output');\n\n      // Check for duplicate output field names\n      for (const existingField of this.outputFields) {\n        if (existingField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Duplicate output field name: \"${parsedField.name}\"`,\n            parsedField.name,\n            'Each field name must be unique within the signature'\n          );\n        }\n      }\n\n      // Check if field name conflicts with existing input fields\n      for (const inputField of this.inputFields) {\n        if (inputField.name === parsedField.name) {\n          throw new AxSignatureValidationError(\n            `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n            parsedField.name,\n            'Use different names for input and output fields to avoid confusion'\n          );\n        }\n      }\n\n      this.outputFields.push(parsedField);\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to add output field \"${field.name}\": ${error instanceof Error ? error.message : 'Unknown error'}`,\n        field.name\n      );\n    }\n  };\n\n  public setInputFields = (fields: readonly AxField[]) => {\n    if (!Array.isArray(fields)) {\n      throw new AxSignatureValidationError(\n        'Input fields must be an array',\n        undefined,\n        'Provide an array of field objects'\n      );\n    }\n\n    try {\n      const parsedFields = fields.map((v) => {\n        const parsed = this.parseField(v);\n        validateField(parsed, 'input');\n        return parsed;\n      });\n      this.inputFields = parsedFields;\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to set input fields: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  public setOutputFields = (fields: readonly AxField[]) => {\n    if (!Array.isArray(fields)) {\n      throw new AxSignatureValidationError(\n        'Output fields must be an array',\n        undefined,\n        'Provide an array of field objects'\n      );\n    }\n\n    try {\n      const parsedFields = fields.map((v) => {\n        const parsed = this.parseField(v);\n        validateField(parsed, 'output');\n        return parsed;\n      });\n      this.outputFields = parsedFields;\n      this.invalidateValidationCache();\n      this.updateHashLight();\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Failed to set output fields: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  public getInputFields = (): Readonly<AxIField[]> => this.inputFields;\n  public getOutputFields = (): Readonly<AxIField[]> => this.outputFields;\n  public getDescription = () => this.description;\n\n  // Type-safe field addition methods that return new signature instances\n  public appendInputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<_TInput & Record<K, InferFieldValueType<T>>, _TOutput> => {\n    const newSig = new AxSignature(this);\n    newSig.addInputField({\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    });\n    return newSig as AxSignature<\n      _TInput & Record<K, InferFieldValueType<T>>,\n      _TOutput\n    >;\n  };\n\n  public prependInputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<Record<K, InferFieldValueType<T>> & _TInput, _TOutput> => {\n    const newSig = new AxSignature(this);\n    const fieldToAdd = {\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    };\n\n    // Validate the field before adding\n    const parsedField = newSig.parseField(fieldToAdd);\n    validateField(parsedField, 'input');\n\n    // Check for duplicate field names\n    for (const existingField of newSig.inputFields) {\n      if (existingField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Duplicate input field name: \"${parsedField.name}\"`,\n          parsedField.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n    }\n\n    // Check if field name conflicts with existing output fields\n    for (const outputField of newSig.outputFields) {\n      if (outputField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n          parsedField.name,\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    // Prepend to the beginning of input fields array\n    newSig.inputFields.unshift(parsedField);\n    newSig.invalidateValidationCache();\n    newSig.updateHashLight();\n\n    return newSig as AxSignature<\n      Record<K, InferFieldValueType<T>> & _TInput,\n      _TOutput\n    >;\n  };\n\n  public appendOutputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<_TInput, _TOutput & Record<K, InferFieldValueType<T>>> => {\n    const newSig = new AxSignature(this);\n    newSig.addOutputField({\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    });\n    return newSig as AxSignature<\n      _TInput,\n      _TOutput & Record<K, InferFieldValueType<T>>\n    >;\n  };\n\n  public prependOutputField = <K extends string, T extends AxFieldType>(\n    name: K,\n    fieldType: T\n  ): AxSignature<_TInput, Record<K, InferFieldValueType<T>> & _TOutput> => {\n    const newSig = new AxSignature(this);\n    const fieldToAdd = {\n      name,\n      ...convertFieldTypeToAxField(fieldType),\n    };\n\n    // Validate the field before adding\n    const parsedField = newSig.parseField(fieldToAdd);\n    validateField(parsedField, 'output');\n\n    // Check for duplicate field names\n    for (const existingField of newSig.outputFields) {\n      if (existingField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Duplicate output field name: \"${parsedField.name}\"`,\n          parsedField.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n    }\n\n    // Check if field name conflicts with existing input fields\n    for (const inputField of newSig.inputFields) {\n      if (inputField.name === parsedField.name) {\n        throw new AxSignatureValidationError(\n          `Field name \"${parsedField.name}\" appears in both inputs and outputs`,\n          parsedField.name,\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    // Prepend to the beginning of output fields array\n    newSig.outputFields.unshift(parsedField);\n    newSig.invalidateValidationCache();\n    newSig.updateHashLight();\n\n    return newSig as AxSignature<\n      _TInput,\n      Record<K, InferFieldValueType<T>> & _TOutput\n    >;\n  };\n\n  private invalidateValidationCache = (): void => {\n    this.validatedAtHash = undefined;\n  };\n\n  private toTitle = (name: string) => {\n    let result = name.replace(/_/g, ' ');\n    result = result.replace(/([A-Z]|[0-9]+)/g, ' $1').trim();\n    return result.charAt(0).toUpperCase() + result.slice(1);\n  };\n\n  public toJSONSchema = (): AxFunctionJSONSchema => {\n    const properties: Record<string, unknown> = {};\n    const required: Array<string> = [];\n\n    for (const f of this.inputFields) {\n      const type = f.type ? f.type.name : 'string';\n      if (f.type?.isArray) {\n        properties[f.name] = {\n          description: f.description,\n          type: 'array' as const,\n          items: {\n            type: type,\n            description: f.description,\n          },\n        };\n      } else {\n        properties[f.name] = {\n          description: f.description,\n          type: type,\n        };\n      }\n\n      if (!f.isOptional) {\n        required.push(f.name);\n      }\n    }\n\n    const schema = {\n      type: 'object',\n      properties: properties,\n      required: required,\n    };\n\n    return schema as AxFunctionJSONSchema;\n  };\n\n  private updateHashLight = (): [string, string] => {\n    try {\n      // Light validation - only validate individual fields, not full signature consistency\n      this.getInputFields().forEach((field) => {\n        validateField(field, 'input');\n      });\n      this.getOutputFields().forEach((field) => {\n        validateField(field, 'output');\n      });\n\n      this.sigHash = createHash('sha256')\n        .update(JSON.stringify(this.inputFields))\n        .update(JSON.stringify(this.outputFields))\n        .digest('hex');\n\n      this.sigString = renderSignature(\n        this.description,\n        this.inputFields,\n        this.outputFields\n      );\n\n      return [this.sigHash, this.sigString];\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Signature validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  private updateHash = (): [string, string] => {\n    try {\n      this.getInputFields().forEach((field) => {\n        validateField(field, 'input');\n      });\n      this.getOutputFields().forEach((field) => {\n        validateField(field, 'output');\n      });\n\n      this.validateSignatureConsistency();\n\n      this.sigHash = createHash('sha256')\n        .update(this.description ?? '')\n        .update(JSON.stringify(this.inputFields))\n        .update(JSON.stringify(this.outputFields))\n        .digest('hex');\n\n      this.sigString = renderSignature(\n        this.description,\n        this.inputFields,\n        this.outputFields\n      );\n\n      return [this.sigHash, this.sigString];\n    } catch (error) {\n      if (error instanceof AxSignatureValidationError) {\n        throw error;\n      }\n      throw new AxSignatureValidationError(\n        `Signature validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      );\n    }\n  };\n\n  private validateSignatureConsistency(): void {\n    const inputNames = new Set<string>();\n    for (const field of this.inputFields) {\n      if (inputNames.has(field.name)) {\n        throw new AxSignatureValidationError(\n          `Duplicate input field name: \"${field.name}\"`,\n          field.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n      inputNames.add(field.name);\n    }\n\n    const outputNames = new Set<string>();\n    for (const field of this.outputFields) {\n      if (outputNames.has(field.name)) {\n        throw new AxSignatureValidationError(\n          `Duplicate output field name: \"${field.name}\"`,\n          field.name,\n          'Each field name must be unique within the signature'\n        );\n      }\n      outputNames.add(field.name);\n    }\n\n    for (const outputField of this.outputFields) {\n      if (inputNames.has(outputField.name)) {\n        throw new AxSignatureValidationError(\n          `Field name \"${outputField.name}\" appears in both inputs and outputs`,\n          outputField.name,\n          'Use different names for input and output fields to avoid confusion'\n        );\n      }\n    }\n\n    if (this.inputFields.length === 0) {\n      throw new AxSignatureValidationError(\n        'Signature must have at least one input field',\n        undefined,\n        'Add an input field. Example: \"userInput:string -> ...\"'\n      );\n    }\n\n    if (this.outputFields.length === 0) {\n      throw new AxSignatureValidationError(\n        'Signature must have at least one output field',\n        undefined,\n        'Add an output field. Example: \"... -> responseText:string\"'\n      );\n    }\n  }\n\n  public validate = (): boolean => {\n    // Check if already validated at current hash\n    if (this.validatedAtHash === this.sigHash) {\n      return true;\n    }\n\n    try {\n      // Perform full validation\n      this.updateHash();\n\n      // Cache validation success\n      this.validatedAtHash = this.sigHash;\n\n      return true;\n    } catch (error) {\n      // Clear validation cache on failure\n      this.validatedAtHash = undefined;\n      throw error;\n    }\n  };\n\n  public hash = () => this.sigHash;\n\n  public toString = () => this.sigString;\n\n  public toJSON = () => {\n    return {\n      id: this.hash(),\n      description: this.description,\n      inputFields: this.inputFields,\n      outputFields: this.outputFields,\n    };\n  };\n}\n\nfunction renderField(field: Readonly<AxField>): string {\n  let result = field.name;\n  if (field.isOptional) {\n    result += '?';\n  }\n  if (field.isInternal) {\n    result += '!';\n  }\n  if (field.type) {\n    result += `:${field.type.name}`;\n    if (field.type.isArray) {\n      result += '[]';\n    }\n    if (field.type.name === 'class' && field.type.options) {\n      result += ` \"${field.type.options.join(' | ')}\"`;\n    }\n  }\n  if (field.description && field.type?.name !== 'class') {\n    result += ` \"${field.description}\"`;\n  }\n  return result;\n}\n\nfunction renderSignature(\n  description: string | undefined,\n  inputFields: readonly AxField[],\n  outputFields: readonly AxField[]\n): string {\n  const descriptionPart = description ? `\"${description}\" ` : '';\n\n  const inputFieldsRendered = inputFields.map(renderField).join(', ');\n\n  const outputFieldsRendered = outputFields.map(renderField).join(', ');\n\n  return `${descriptionPart}${inputFieldsRendered} -> ${outputFieldsRendered}`;\n}\n\nfunction isValidCase(inputString: string): boolean {\n  const camelCaseRegex = /^[a-z][a-zA-Z0-9]*$/;\n  const snakeCaseRegex = /^[a-z]+(_[a-z0-9]+)*$/;\n\n  return camelCaseRegex.test(inputString) || snakeCaseRegex.test(inputString);\n}\n\nfunction validateField(\n  field: Readonly<AxField>,\n  context: 'input' | 'output'\n): void {\n  if (!field.name || field.name.length === 0) {\n    throw new AxSignatureValidationError(\n      'Field name cannot be blank',\n      field.name,\n      'Every field must have a descriptive name'\n    );\n  }\n\n  if (!isValidCase(field.name)) {\n    throw new AxSignatureValidationError(\n      `Invalid field name '${field.name}' - must be camelCase or snake_case`,\n      field.name,\n      'Use camelCase (e.g., \"userInput\") or snake_case (e.g., \"user_input\")'\n    );\n  }\n\n  if (axGlobals.signatureStrict) {\n    const reservedNames = [\n      'text',\n      'object',\n      'image',\n      'string',\n      'number',\n      'boolean',\n      'json',\n      'array',\n      'datetime',\n      'date',\n      'time',\n      'type',\n      'class',\n      'input',\n      'output',\n      'data',\n      'value',\n      'result',\n      'response',\n      'request',\n      'item',\n      'element',\n    ];\n\n    if (reservedNames.includes(field.name.toLowerCase())) {\n      const suggestions =\n        context === 'input'\n          ? [\n              'userInput',\n              'questionText',\n              'documentContent',\n              'messageText',\n              'queryString',\n            ]\n          : [\n              'responseText',\n              'analysisResult',\n              'categoryType',\n              'summaryText',\n              'outputData',\n            ];\n\n      throw new AxSignatureValidationError(\n        `Field name '${field.name}' is too generic`,\n        field.name,\n        `Use a more descriptive name. Examples for ${context} fields: ${suggestions.join(', ')}`\n      );\n    }\n  }\n\n  if (field.name.length < 2) {\n    throw new AxSignatureValidationError(\n      `Field name '${field.name}' is too short`,\n      field.name,\n      'Field names must be at least 2 characters long'\n    );\n  }\n\n  if (field.name.length > 50) {\n    throw new AxSignatureValidationError(\n      `Field name '${field.name}' is too long (${field.name.length} characters)`,\n      field.name,\n      'Field names should be 50 characters or less'\n    );\n  }\n\n  if (field.type) {\n    validateFieldType(field, context);\n  }\n}\n\nfunction validateFieldType(\n  field: Readonly<AxField>,\n  context: 'input' | 'output'\n): void {\n  if (!field.type) return;\n\n  const { type } = field;\n\n  if (\n    type.name === 'image' ||\n    type.name === 'audio' ||\n    type.name === 'file' ||\n    type.name === 'url'\n  ) {\n    if (context === 'output') {\n      throw new AxSignatureValidationError(\n        `${type.name} type is not supported in output fields`,\n        field.name,\n        `${type.name} types can only be used in input fields`\n      );\n    }\n\n    if (type.isArray && (type.name === 'image' || type.name === 'audio')) {\n      throw new AxSignatureValidationError(\n        `Arrays of ${type.name} are not supported`,\n        field.name,\n        `Use a single ${type.name} type instead`\n      );\n    }\n  }\n\n  if (type.name === 'class') {\n    if (context === 'input') {\n      throw new AxSignatureValidationError(\n        'Class type is not supported in input fields',\n        field.name,\n        'Class types are only allowed on output fields. Use \"string\" type for input classifications'\n      );\n    }\n\n    if (!type.options || type.options.length === 0) {\n      throw new AxSignatureValidationError(\n        'Class type requires options',\n        field.name,\n        'Provide class options. Example: class \"positive, negative, neutral\"'\n      );\n    }\n\n    for (const option of type.options) {\n      if (!option || option.trim().length === 0) {\n        throw new AxSignatureValidationError(\n          'Empty class option found',\n          field.name,\n          'All class options must be non-empty strings'\n        );\n      }\n\n      const trimmedOption = option.trim();\n      if (trimmedOption.includes(',') || trimmedOption.includes('|')) {\n        throw new AxSignatureValidationError(\n          `Invalid class option \"${trimmedOption}\"`,\n          field.name,\n          'Class options cannot contain commas (,) or pipes (|) as they are used to separate options'\n        );\n      }\n    }\n\n    const uniqueOptions = new Set(\n      type.options.map((opt) => opt.trim().toLowerCase())\n    );\n    if (uniqueOptions.size !== type.options.length) {\n      throw new AxSignatureValidationError(\n        'Duplicate class options found',\n        field.name,\n        'Each class option must be unique (case-insensitive)'\n      );\n    }\n  }\n\n  if (type.name === 'code' && type.isArray) {\n    throw new AxSignatureValidationError(\n      'Arrays of code are not commonly supported',\n      field.name,\n      'Consider using a single code field or an array of strings instead'\n    );\n  }\n\n  if (field.isInternal && context === 'input') {\n    throw new AxSignatureValidationError(\n      'Internal marker (!) is not allowed on input fields',\n      field.name,\n      'Internal markers are only allowed on output fields'\n    );\n  }\n}\n", "import { AxInstanceRegistry } from './registry.js';\nimport { AxSignature } from './sig.js';\nimport type {\n  AxFieldValue,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramOptions,\n  AxProgramTrace,\n  AxProgramUsage,\n  AxSetExamplesOptions,\n  AxTunable,\n  AxUsable,\n} from './types.js';\n\nimport { mergeProgramUsage, validateValue } from './util.js';\n\nexport class AxProgram<IN, OUT> implements AxUsable {\n  protected signature: AxSignature;\n  protected sigHash: string;\n\n  protected examples?: OUT[];\n  protected examplesOptions?: AxSetExamplesOptions;\n  protected demos?: OUT[];\n  protected trace?: OUT;\n  protected usage: AxProgramUsage[] = [];\n  protected traceLabel?: string;\n\n  private key: { id: string; custom?: boolean };\n  private children: AxInstanceRegistry<Readonly<AxTunable<IN, OUT>>, IN, OUT>;\n\n  constructor(\n    signature: ConstructorParameters<typeof AxSignature>[0],\n    options?: Readonly<AxProgramOptions>\n  ) {\n    this.signature = new AxSignature(signature);\n\n    if (options?.description) {\n      this.signature.setDescription(options.description);\n    }\n\n    if (options?.traceLabel) {\n      this.traceLabel = options.traceLabel;\n    }\n\n    // Only validate if signature is provided\n    if (signature) {\n      this.signature.validate();\n    }\n\n    this.sigHash = this.signature?.hash();\n    this.children = new AxInstanceRegistry();\n    this.key = { id: this.signature.hash() };\n  }\n\n  public getSignature(): AxSignature {\n    return new AxSignature(this.signature);\n  }\n\n  public setSignature(\n    signature: ConstructorParameters<typeof AxSignature>[0]\n  ): void {\n    this.signature = new AxSignature(signature);\n\n    // Validate the new signature if it's provided\n    if (signature) {\n      this.signature.validate();\n    }\n\n    // Update the signature hash and key\n    this.updateSignatureHash();\n  }\n\n  // HACK make setInstruction an alias for setDescription\n  public setInstruction(instruction: string) {\n    this.setDescription(instruction)\n  }\n\n  public setDescription(description: string) {\n    this.signature.setDescription(description);\n    this.updateSignatureHash();\n  }\n\n  private updateSignatureHash() {\n    this.sigHash = this.signature.hash();\n    this.key = { id: this.signature.hash() };\n  }\n\n  public register(prog: Readonly<AxTunable<IN, OUT> & AxUsable>) {\n    if (this.key) {\n      prog.setParentId(this.key.id);\n    }\n    this.children.register(prog);\n  }\n\n  public setId(id: string) {\n    this.key = { id, custom: true };\n    for (const child of Array.from(this.children)) {\n      child?.setParentId(id);\n    }\n  }\n\n  public setParentId(parentId: string) {\n    if (!this.key.custom) {\n      this.key.id = [parentId, this.key.id].join('/');\n    }\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    this._setExamples(examples, options);\n\n    if (!('programId' in examples)) {\n      return;\n    }\n\n    for (const child of Array.from(this.children)) {\n      child?.setExamples(examples, options);\n    }\n  }\n\n  private _setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    let traces: Record<string, AxFieldValue>[] = [];\n\n    if ('programId' in examples && examples.programId === this.key.id) {\n      traces = examples.traces as any;\n    }\n\n    if (Array.isArray(examples)) {\n      traces = examples as any;\n    }\n\n    if (traces) {\n      this.examplesOptions = options;\n      const sig = this.signature;\n      const fields = [...sig.getInputFields(), ...sig.getOutputFields()];\n\n      this.examples = traces.map((e) => {\n        const res: Record<string, AxFieldValue> = {};\n        for (const f of fields) {\n          const value = e[f.name];\n          if (value !== undefined) {\n            // Only validate the type of fields that are actually set\n            // Allow any field to be missing regardless of whether it's required\n            validateValue(f, value);\n            res[f.name] = value;\n          }\n        }\n        return res;\n      }) as OUT[];\n    }\n  }\n\n  public getTraces(): AxProgramTrace<IN, OUT>[] {\n    let traces: AxProgramTrace<IN, OUT>[] = [];\n\n    if (this.trace) {\n      traces.push({ trace: this.trace as OUT & IN, programId: this.key.id });\n    }\n\n    for (const child of Array.from(this.children)) {\n      const Traces = child?.getTraces();\n      traces = [...traces, ...(Traces ?? [])];\n    }\n    return traces;\n  }\n\n  public getUsage(): AxProgramUsage[] {\n    let usage: AxProgramUsage[] = [...(this.usage ?? [])];\n\n    for (const child of Array.from(this.children)) {\n      const cu = child?.getUsage();\n      usage = [...usage, ...(cu ?? [])];\n    }\n    return mergeProgramUsage(usage);\n  }\n\n  public resetUsage() {\n    this.usage = [];\n    for (const child of Array.from(this.children)) {\n      child?.resetUsage();\n    }\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]) {\n    // Check if this program has children and if its programId is not found in demos\n    const hasChildren = Array.from(this.children).length > 0;\n    const hasMatchingDemo = demos.some(\n      (demo) => demo.programId === this.key.id\n    );\n\n    if (hasChildren && !hasMatchingDemo) {\n      throw new Error(\n        `Program with id '${this.key.id}' has children but no matching programId found in demos`\n      );\n    }\n\n    // biome-ignore lint/complexity/useFlatMap: it can't\n    this.demos = demos\n      .filter((v) => v.programId === this.key.id)\n      .map((v) => v.traces)\n      .flat();\n\n    for (const child of Array.from(this.children)) {\n      child?.setDemos(demos);\n    }\n  }\n}\n", "import type { AxChatRequest } from '../ai/types.js';\n\nimport { formatDateWithTimezone } from './datetime.js';\nimport type { AxInputFunctionType } from './functions.js';\nimport type { AxField, AxIField, AxSignature } from './sig.js';\nimport type { AxFieldValue, AxMessage } from './types.js';\nimport { validateValue } from './util.js';\n\ntype Writeable<T> = { -readonly [P in keyof T]: T[P] };\n\n// Define options type for AxPromptTemplate constructor\nexport interface AxPromptTemplateOptions {\n  functions?: Readonly<AxInputFunctionType>;\n  thoughtFieldName?: string;\n}\ntype AxChatRequestChatPrompt = Writeable<AxChatRequest['chatPrompt'][0]>;\n\ntype ChatRequestUserMessage = Exclude<\n  Extract<AxChatRequestChatPrompt, { role: 'user' }>['content'],\n  string\n>;\n\nconst functionCallInstructions = `\n## Function Call Instructions\n- Complete the task, using the functions defined earlier in this prompt. \n- Output fields should only be generated after all functions have been called.\n- Use the function results to generate the output fields.`;\n\nconst formattingRules = `\n## Strict Output Formatting Rules\n- Output must strictly follow the defined plain-text \\`field name: value\\` field format.\n- Output field, values must strictly adhere to the specified output field formatting rules.\n- No formatting rules should override these **Strict Output Formatting Rules**\n- Do not add any text before or after the output fields, just the field name and value.\n- Do not use code blocks.`;\n\nexport type AxFieldTemplateFn = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n) => ChatRequestUserMessage;\n\nexport class AxPromptTemplate {\n  private sig: Readonly<AxSignature>;\n  private fieldTemplates?: Record<string, AxFieldTemplateFn>;\n  private task: { type: 'text'; text: string };\n  private readonly thoughtFieldName: string;\n  private readonly functions?: Readonly<AxInputFunctionType>;\n\n  constructor(\n    sig: Readonly<AxSignature>,\n    options?: Readonly<AxPromptTemplateOptions>,\n    fieldTemplates?: Record<string, AxFieldTemplateFn>\n  ) {\n    this.sig = sig;\n    this.fieldTemplates = fieldTemplates;\n    this.thoughtFieldName = options?.thoughtFieldName ?? 'thought';\n    this.functions = options?.functions;\n\n    const task = [];\n\n    const inArgs = renderDescFields(this.sig.getInputFields());\n    const outArgs = renderDescFields(this.sig.getOutputFields());\n    task.push(\n      `You will be provided with the following fields: ${inArgs}. Your task is to generate new fields: ${outArgs}.`\n    );\n\n    // biome-ignore lint/complexity/useFlatMap: you cannot use flatMap here\n    const funcs = this.functions\n      ?.map((f) => ('toFunction' in f ? f.toFunction() : f))\n      ?.flat();\n\n    const funcList = funcs\n      ?.map((fn) => `- \\`${fn.name}\\`: ${formatDescription(fn.description)}`)\n      .join('\\n');\n\n    if (funcList && funcList.length > 0) {\n      task.push(`## Available Functions\\n${funcList}`);\n    }\n\n    const inputFields = renderInputFields(this.sig.getInputFields());\n    task.push(`## Input Fields\\n${inputFields}`);\n\n    const outputFields = renderOutputFields(this.sig.getOutputFields());\n    task.push(`## Output Fields\\n${outputFields}`);\n\n    if (funcList && funcList.length > 0) {\n      task.push(functionCallInstructions.trim());\n    }\n\n    task.push(formattingRules.trim());\n\n    const desc = this.sig.getDescription();\n    if (desc) {\n      const text = formatDescription(desc);\n      task.push(text);\n    }\n\n    this.task = {\n      type: 'text' as const,\n      text: task.join('\\n\\n'),\n    };\n  }\n\n  private renderSingleValueUserContent = <T = any>(\n    values: T,\n    renderedExamples: ChatRequestUserMessage,\n    examplesInSystemPrompt: boolean\n  ): string | ChatRequestUserMessage => {\n    const completion = this.renderInputFields(values);\n    const promptList: ChatRequestUserMessage = examplesInSystemPrompt\n      ? completion\n      : [...renderedExamples, ...completion];\n\n    const prompt = promptList.filter((v) => v !== undefined);\n\n    return prompt.every((v) => v.type === 'text')\n      ? prompt.map((v) => v.text).join('\\n')\n      : prompt.reduce(combineConsecutiveStrings('\\n'), []);\n  };\n\n  public render = <T = any>(\n    values: T | ReadonlyArray<AxMessage<T>>, // Allow T or array of AxMessages\n    {\n      examples,\n      demos,\n    }: Readonly<{\n      skipSystemPrompt?: boolean;\n      examples?: Record<string, AxFieldValue>[]; // Keep as is, examples are specific structures\n      demos?: Record<string, AxFieldValue>[]; // Keep as is\n    }>\n  ): Extract<\n    AxChatRequest['chatPrompt'][number],\n    { role: 'user' | 'system' | 'assistant' }\n  >[] => {\n    const renderedExamples = this.renderExamples([...(examples || []), ...(demos || [])]);\n\n    // Check if demos and examples are all text type\n    const examplesInSystemPrompt = renderedExamples.every((v) => v.type === 'text');\n\n    let systemContent = this.task.text;\n\n    if (examplesInSystemPrompt) {\n      const combinedItems = [\n        { type: 'text' as const, text: systemContent },\n        ...((renderedExamples.length) > 0\n          ? [{ type: 'text' as const, text: '\\n\\n## Examples\\n' }]\n          : []),\n        ...renderedExamples,\n      ];\n      combinedItems.reduce(combineConsecutiveStrings(''), []);\n\n      if (combinedItems?.[0]) {\n        systemContent = combinedItems[0].text;\n      }\n    }\n\n    const systemPrompt = {\n      role: 'system' as const,\n      content: systemContent,\n    };\n\n    if (Array.isArray(values)) {\n      const messages: Extract<\n        AxChatRequest['chatPrompt'][number],\n        { role: 'user' } | { role: 'assistant' }\n      >[] = [];\n\n      const history = values as ReadonlyArray<AxMessage<T>>;\n\n      let firstItem = true;\n      for (const message of history) {\n        let content: string | ChatRequestUserMessage;\n\n        if (firstItem) {\n          content = this.renderSingleValueUserContent(\n            message.values,\n            renderedExamples,\n            examplesInSystemPrompt\n          );\n          firstItem = false;\n        } else {\n          content = this.renderSingleValueUserContent(\n            message.values,\n            [],\n            false\n          );\n        }\n\n        if (message.role === 'user') {\n          messages.push({ role: 'user', content });\n          continue;\n        }\n\n        if (message.role !== 'assistant') {\n          throw new Error('Invalid message role');\n        }\n\n        if (typeof content !== 'string') {\n          throw new Error(\n            'Assistant message cannot contain non-text content like images, files,etc'\n          );\n        }\n\n        messages.push({ role: 'assistant', content });\n      }\n\n      return [systemPrompt, ...messages];\n    }\n\n    // values is T - existing logic path\n    const userContent = this.renderSingleValueUserContent(\n      values as T,\n      renderedExamples,\n      examplesInSystemPrompt\n    );\n\n    return [systemPrompt, { role: 'user' as const, content: userContent }];\n  };\n\n  public renderExtraFields = (extraFields: readonly AxIField[]) => {\n    const prompt: ChatRequestUserMessage = [];\n\n    if (!extraFields || extraFields.length === 0) {\n      return prompt;\n    }\n\n    const groupedFields = extraFields.reduce(\n      (acc, field) => {\n        const title = field.title;\n        if (!acc[title]) {\n          acc[title] = [];\n        }\n        acc[title].push(field);\n        return acc;\n      },\n      {} as Record<string, AxIField[]>\n    );\n\n    const formattedGroupedFields = Object.entries(groupedFields)\n      .map(([title, fields]) => {\n        if (fields.length === 1) {\n          const field = fields[0]!;\n          return {\n            title,\n            name: field.name,\n            description: field.description,\n          };\n        }\n        if (fields.length > 1) {\n          const valuesList = fields\n            .map((field) => `- ${field.description}`)\n            .join('\\n');\n          return {\n            title,\n            name: fields[0]!.name,\n            description: valuesList,\n          };\n        }\n      })\n      .filter(Boolean) as AxIField[];\n\n    formattedGroupedFields.forEach((field) => {\n      const fn = this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;\n      prompt.push(...fn(field, field.description));\n    });\n\n    return prompt;\n  };\n\n  private renderExamples = (data: Readonly<Record<string, AxFieldValue>[]>) => {\n    const list: ChatRequestUserMessage = [];\n    const exampleContext = {\n      isExample: true,\n    };\n\n    for (const [index, item] of data.entries()) {\n      const renderedInputItem = this.sig\n        .getInputFields()\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...exampleContext,\n            isInputField: true,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedOutputItem = this.sig\n        .getOutputFields()\n        .map((field) =>\n          this.renderInField(field, item, {\n            ...exampleContext,\n            isInputField: false,\n          })\n        )\n        .filter((v) => v !== undefined)\n        .flat();\n\n      const renderedItem = [...renderedInputItem, ...renderedOutputItem];\n\n      if (\n        index > 0 &&\n        renderedItem.length > 0 &&\n        renderedItem[0]?.type === 'text'\n      ) {\n        list.push({ type: 'text' as const, text: '---\\n\\n' });\n      }\n\n      renderedItem.forEach((v) => {\n        if ('text' in v) {\n          v.text = `${v.text}\\n`;\n        }\n        list.push(v);\n      });\n    }\n\n    return list;\n  };\n\n  private renderInputFields = <T = any>(values: T) => {\n    const renderedItems = this.sig\n      .getInputFields()\n      .map((field) => this.renderInField(field, values as any, undefined))\n      .filter((v) => v !== undefined)\n      .flat();\n\n    renderedItems\n      .filter((v) => v.type === 'text')\n      .forEach((v) => {\n        v.text = `${v.text}\\n`;\n      });\n\n    return renderedItems;\n  };\n\n  private renderInField = (\n    field: Readonly<AxField>,\n    values: Readonly<Record<string, AxFieldValue>>,\n    context?: {\n      isExample?: boolean;\n      strictExamples?: boolean;\n      optionalOutputFields?: string[];\n      isInputField?: boolean;\n    }\n  ) => {\n    const value = values[field.name];\n\n    if (isEmptyValue(field, value, context)) {\n      return;\n    }\n\n    if (field.type) {\n      validateValue(field, value!);\n    }\n\n    const processedValue = processValue(field, value!);\n\n    const textFieldFn: AxFieldTemplateFn =\n      this.fieldTemplates?.[field.name] ?? this.defaultRenderInField;\n\n    return textFieldFn(field, processedValue);\n  };\n\n  private defaultRenderInField = (\n    field: Readonly<AxField>,\n    value: Readonly<AxFieldValue>\n  ): ChatRequestUserMessage => {\n    if (field.type?.name === 'image') {\n      const validateImage = (\n        value: Readonly<AxFieldValue>\n      ): { mimeType: string; data: string } => {\n        if (!value) {\n          throw new Error('Image field value is required.');\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Image field value must be an object.');\n        }\n        if (!('mimeType' in value)) {\n          throw new Error('Image field must have mimeType');\n        }\n        if (!('data' in value)) {\n          throw new Error('Image field must have data');\n        }\n        return value as { mimeType: string; data: string };\n      };\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Image field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            // Cast to unknown[] before map\n            const validated = validateImage(v as AxFieldValue);\n            return {\n              type: 'image',\n              mimeType: validated.mimeType,\n              image: validated.data,\n            };\n          })\n        );\n      } else {\n        const validated = validateImage(value);\n        result.push({\n          type: 'image',\n          mimeType: validated.mimeType,\n          image: validated.data,\n        });\n      }\n      return result;\n    }\n\n    if (field.type?.name === 'audio') {\n      const validateAudio = (\n        value: Readonly<AxFieldValue>\n      ): { format?: 'wav'; data: string } => {\n        if (!value) {\n          throw new Error('Audio field value is required.');\n        }\n\n        if (typeof value !== 'object') {\n          throw new Error('Audio field value must be an object.');\n        }\n        if (!('data' in value)) {\n          throw new Error('Audio field must have data');\n        }\n        return value as { format?: 'wav'; data: string };\n      };\n\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('Audio field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            // Cast to unknown[] before map\n            const validated = validateAudio(v as AxFieldValue);\n            return {\n              type: 'audio',\n              format: validated.format ?? 'wav',\n              data: validated.data,\n            };\n          })\n        );\n      } else {\n        const validated = validateAudio(value);\n        result.push({\n          type: 'audio',\n          format: validated.format ?? 'wav',\n          data: validated.data,\n        });\n      }\n      return result;\n    }\n\n    if (field.type?.name === 'file') {\n      const validateFile = (\n        value: Readonly<AxFieldValue>\n      ): { filename: string; mimeType: string; data: string } => {\n        if (!value) {\n          throw new Error('File field value is required.');\n        }\n        if (typeof value !== 'object') {\n          throw new Error('File field value must be an object.');\n        }\n        if (!('filename' in value)) {\n          throw new Error('File field must have filename');\n        }\n        if (!('mimeType' in value)) {\n          throw new Error('File field must have mimeType');\n        }\n        if (!('data' in value)) {\n          throw new Error('File field must have data');\n        }\n        return value as { filename: string; mimeType: string; data: string };\n      };\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('File field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            const validated = validateFile(v as AxFieldValue);\n            return {\n              type: 'file',\n              filename: validated.filename,\n              mimeType: validated.mimeType,\n              data: validated.data,\n            };\n          })\n        );\n      } else {\n        const validated = validateFile(value);\n        result.push({\n          type: 'file',\n          filename: validated.filename,\n          mimeType: validated.mimeType,\n          data: validated.data,\n        });\n      }\n      return result;\n    }\n\n    if (field.type?.name === 'url') {\n      const validateUrl = (\n        value: Readonly<AxFieldValue>\n      ): { url: string; title?: string; description?: string } => {\n        if (!value) {\n          throw new Error('URL field value is required.');\n        }\n        if (typeof value === 'string') {\n          return { url: value };\n        }\n        if (typeof value !== 'object') {\n          throw new Error('URL field value must be a string or object.');\n        }\n        if (!('url' in value)) {\n          throw new Error('URL field must have url property');\n        }\n        return value as { url: string; title?: string; description?: string };\n      };\n      let result: ChatRequestUserMessage = [\n        { type: 'text', text: `${field.title}: ` as string },\n      ];\n      if (field.type.isArray) {\n        if (!Array.isArray(value)) {\n          throw new Error('URL field value must be an array.');\n        }\n        result = result.concat(\n          (value as unknown[]).map((v) => {\n            const validated = validateUrl(v as AxFieldValue);\n            return {\n              type: 'url',\n              url: validated.url,\n              ...(validated.title ? { title: validated.title } : {}),\n              ...(validated.description\n                ? { description: validated.description }\n                : {}),\n            };\n          })\n        );\n      } else {\n        const validated = validateUrl(value);\n        result.push({\n          type: 'url',\n          url: validated.url,\n          ...(validated.title ? { title: validated.title } : {}),\n          ...(validated.description\n            ? { description: validated.description }\n            : {}),\n        });\n      }\n      return result;\n    }\n\n    const text = [field.title, ': '];\n\n    if (Array.isArray(value)) {\n      text.push('\\n');\n      text.push(value.map((v) => `- ${v}`).join('\\n'));\n    } else {\n      text.push(value as string);\n    }\n    return [{ type: 'text', text: text.join('') }];\n  };\n}\n\nconst renderDescFields = (list: readonly AxField[]) =>\n  list.map((v) => `\\`${v.title}\\``).join(', ');\n\nconst renderInputFields = (fields: readonly AxField[]) => {\n  const rows = fields.map((field) => {\n    const name = field.title;\n    const type = field.type?.name ? toFieldType(field.type) : 'string';\n\n    const requiredMsg = field.isOptional\n      ? `This optional ${type} field may be omitted`\n      : `A ${type} field`;\n\n    const description = field.description\n      ? ` ${formatDescription(field.description)}`\n      : '';\n\n    return `${name}: (${requiredMsg})${description}`.trim();\n  });\n\n  return rows.join('\\n');\n};\n\nconst renderOutputFields = (fields: readonly AxField[]) => {\n  const rows = fields.map((field) => {\n    const name = field.title;\n    const type = field.type?.name ? toFieldType(field.type) : 'string';\n\n    const requiredMsg = field.isOptional\n      ? `Only include this ${type} field if its value is available`\n      : `This ${type} field must be included`;\n\n    let description = '';\n\n    if (field.description && field.description.length > 0) {\n      const value =\n        field.type?.name === 'class'\n          ? field.description\n          : formatDescription(field.description);\n      description = ` ${value}`;\n    }\n\n    if (field.type?.options && field.type.options.length > 0) {\n      if (description.length > 0) {\n        description += '. ';\n      }\n      description += `Allowed values: ${field.type.options.join(', ')}`;\n    }\n\n    return `${name}: (${requiredMsg})${description}`.trim();\n  });\n\n  return rows.join('\\n');\n};\n\nconst processValue = (\n  field: Readonly<AxField>,\n  value: Readonly<AxFieldValue>\n): AxFieldValue => {\n  if (field.type?.name === 'date' && value instanceof Date) {\n    const v = value.toISOString();\n    return v.slice(0, v.indexOf('T'));\n  }\n  if (field.type?.name === 'datetime' && value instanceof Date) {\n    return formatDateWithTimezone(value);\n  }\n  if (field.type?.name === 'image' && typeof value === 'object') {\n    return value;\n  }\n  if (field.type?.name === 'audio' && typeof value === 'object') {\n    return value;\n  }\n  if (field.type?.name === 'file' && typeof value === 'object') {\n    return value;\n  }\n  if (\n    field.type?.name === 'url' &&\n    (typeof value === 'string' || typeof value === 'object')\n  ) {\n    return value;\n  }\n  if (typeof value === 'string') {\n    return value;\n  }\n  return JSON.stringify(value, null, 2);\n};\n\nexport const toFieldType = (type: Readonly<AxField['type']>) => {\n  const baseType = (() => {\n    switch (type?.name) {\n      case 'string':\n        return 'string';\n      case 'number':\n        return 'number';\n      case 'boolean':\n        return 'boolean (true or false)';\n      case 'date':\n        return 'date (\"YYYY-MM-DD\" format)';\n      case 'datetime':\n        return 'date time (\"YYYY-MM-DD HH:mm Timezone\" format)';\n      case 'json':\n        return 'JSON object';\n      case 'class':\n        return 'classification class';\n      case 'code':\n        return 'code';\n      case 'file':\n        return 'file (with filename, mimeType, and data)';\n      case 'url':\n        return 'URL (string or object with url, title, description)';\n      default:\n        return 'string';\n    }\n  })();\n\n  return type?.isArray ? `json array of ${baseType} items` : baseType;\n};\n\nfunction combineConsecutiveStrings(separator: string) {\n  return (acc: ChatRequestUserMessage, current: ChatRequestUserMessage[0]) => {\n    if (current.type === 'text') {\n      const previous = acc.length > 0 ? acc[acc.length - 1] : null;\n      if (previous && previous.type === 'text') {\n        previous.text += separator + current.text;\n      } else {\n        acc.push(current);\n      }\n    } else {\n      acc.push(current);\n    }\n    return acc;\n  };\n}\n\nconst isEmptyValue = (\n  field: Readonly<AxField>,\n  value?: Readonly<AxFieldValue>,\n  context?: {\n    isExample?: boolean;\n    isInputField?: boolean;\n  }\n) => {\n  if (typeof value === 'boolean') {\n    return false;\n  }\n\n  if (\n    !value ||\n    ((Array.isArray(value) || typeof value === 'string') && value.length === 0)\n  ) {\n    // Handle examples case - all fields can be missing in examples\n    if (context?.isExample) {\n      return true;\n    }\n\n    // Handle non-examples case (regular field validation)\n    if (field.isOptional || field.isInternal) {\n      return true;\n    }\n\n    const fieldType = context?.isInputField !== false ? 'input' : 'output';\n    throw new Error(\n      `Value for ${fieldType} field '${field.name}' is required.`\n    );\n  }\n  return false;\n};\n\nfunction formatDescription(str: string) {\n  const value = str.trim();\n  return value.length > 0\n    ? `${value.charAt(0).toUpperCase()}${value.slice(1)}${value.endsWith('.') ? '' : '.'}`\n    : '';\n}\n", "import type { AxAIMemory } from '../mem/types.js';\nimport type {\n  AxGenDeltaOut,\n  AxResultPickerFunction,\n  AxResultPickerFunctionFunctionResults,\n} from './types.js';\n\nexport interface AxSamplePickerOptions<OUT> {\n  resultPicker?: AxResultPickerFunction<OUT>;\n}\n\n/**\n * Checks if there are function calls in memory\n */\nfunction checkForFunctionCalls(mem: AxAIMemory, sessionId?: string): boolean {\n  const history = mem.history(0, sessionId);\n\n  // Check for both function calls and function results\n  const hasFunctionResults = history.some((msg) => msg.role === 'function');\n  const hasFunctionCalls = history.some(\n    (msg) =>\n      msg.role === 'assistant' &&\n      'functionCalls' in msg &&\n      Array.isArray(msg.functionCalls) &&\n      msg.functionCalls.length > 0\n  );\n\n  return hasFunctionCalls && hasFunctionResults;\n}\n\n/**\n * Extracts function execution results from memory\n */\nfunction extractFunctionResults(\n  mem: AxAIMemory,\n  sessionId?: string\n): AxResultPickerFunctionFunctionResults['results'] {\n  const history = mem.history(0, sessionId);\n  const results: {\n    index: number;\n    functionName: string;\n    functionId: string;\n    args: string | object;\n    result: string;\n    isError?: boolean;\n  }[] = [];\n\n  // Find assistant messages with function calls\n  const assistantMessages = history.filter(\n    (msg) =>\n      msg.role === 'assistant' &&\n      'functionCalls' in msg &&\n      Array.isArray(msg.functionCalls) &&\n      msg.functionCalls.length > 0\n  );\n\n  // Find function result messages\n  const functionMessages = history.filter((msg) => msg.role === 'function');\n\n  // Match function calls with their results\n  for (const assistantMsg of assistantMessages) {\n    if ('functionCalls' in assistantMsg && assistantMsg.functionCalls) {\n      for (const funcCall of assistantMsg.functionCalls) {\n        // Find the corresponding function result\n        const funcResult = functionMessages.find(\n          (msg) => 'functionId' in msg && msg.functionId === funcCall.id\n        );\n\n        if (\n          funcResult &&\n          'result' in funcResult &&\n          'functionId' in funcResult\n        ) {\n          results.push({\n            index: results.length, // Use sequential index for function results\n            functionName: funcCall.function.name,\n            functionId: funcCall.id,\n            args: funcCall.function.params || '',\n            result: String(funcResult.result),\n            isError:\n              'isError' in funcResult ? Boolean(funcResult.isError) : false,\n          });\n        }\n      }\n    }\n  }\n  return results;\n}\n\n/**\n * Selects a result from multiple samples using the provided result picker function.\n * If no result picker is provided or only one result exists, returns the first result.\n */\nexport async function selectFromSamples<OUT>(\n  buffer: AxGenDeltaOut<OUT>[],\n  options?: AxSamplePickerOptions<OUT>,\n  mem?: AxAIMemory,\n  sessionId?: string\n): Promise<number> {\n  // If no result picker or only one result, use index 0\n  if (!options?.resultPicker || buffer.length <= 1) {\n    return 0;\n  }\n\n  const resultPicker = options.resultPicker;\n\n  // Check if there are function calls in memory to determine data type\n  const hasFunctionCalls = mem ? checkForFunctionCalls(mem, sessionId) : false;\n\n  if (hasFunctionCalls && mem) {\n    // Extract function execution data from memory\n    const functionResults = extractFunctionResults(mem, sessionId);\n    const selectedIndex = await resultPicker({\n      type: 'function',\n      results: functionResults,\n    });\n\n    // Validate the selected index\n    if (selectedIndex < 0 || selectedIndex >= functionResults.length) {\n      throw new Error(\n        `Result picker returned invalid index: ${selectedIndex}. Must be between 0 and ${functionResults.length - 1}`\n      );\n    }\n\n    return selectedIndex;\n  }\n  // Use field results\n  const fieldResults = buffer.map((b, index) => ({\n    index,\n    sample: b.delta,\n  }));\n\n  const selectedIndex = await resultPicker({\n    type: 'fields',\n    results: fieldResults,\n  });\n\n  // Validate the selected index\n  if (selectedIndex < 0 || selectedIndex >= buffer.length) {\n    throw new Error(\n      `Result picker returned invalid index: ${selectedIndex}. Must be between 0 and ${buffer.length - 1}`\n    );\n  }\n\n  return selectedIndex;\n}\n\n/**\n * Selects a result index from memory using the provided result picker function.\n * If no result picker is provided or only one result exists, returns 0.\n * If the last memory is not from an assistant role, returns 0.\n */\nexport async function selectFromSamplesInMemory<OUT>(\n  mem: AxAIMemory,\n  sessionId?: string,\n  options?: AxSamplePickerOptions<OUT>\n): Promise<number> {\n  const lastMemory = mem?.getLast(sessionId);\n\n  // If no memory or not from assistant role, return 0\n  if (!lastMemory || lastMemory.role !== 'assistant') {\n    return 0;\n  }\n\n  // If only one chat sample, return 0\n  if (lastMemory.chat.length <= 1) {\n    return 0;\n  }\n\n  // Convert memory chat to buffer format for selectFromSamples\n  const buffer = lastMemory.chat.map((chat) => ({\n    version: 0,\n    index: chat.index,\n    delta: chat.value as OUT,\n  }));\n\n  const selectedIndex = await selectFromSamples(\n    buffer,\n    options,\n    mem,\n    sessionId\n  );\n  return selectedIndex;\n}\n", "const trimNonAlphaNum = (str: string) => {\n  return str.replace(/^\\W+|\\W+$/g, '');\n};\n\nconst splitIntoTwo = (\n  str: string,\n  separator: Readonly<RegExp | string>\n): string[] => {\n  const index = str.search(separator);\n  if (index === -1) {\n    return [str]; // No separator found, return the original string as the only part\n  }\n  const matchResult = str.match(separator);\n  if (!matchResult) {\n    throw new Error('Match failed unexpectedly.');\n  }\n  const firstPart = str.substring(0, index);\n  const secondPart = str.substring(index + matchResult[0].length);\n  return [firstPart, secondPart];\n};\n\nconst dedup = (seq: readonly string[]): string[] => {\n  const seen = new Set<string>();\n  const result: string[] = [];\n\n  for (const x of seq) {\n    if (!seen.has(x)) {\n      seen.add(x);\n      result.push(x);\n    }\n  }\n\n  return result;\n};\n\nconst extractIdAndText = (input: string): { id: number; text: string } => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/);\n  if (!match || match.length < 3) {\n    throw new Error(\n      'line must start with a number, a dot and then text. e.g. \"1. hello\"'\n    );\n  }\n\n  const id = Number.parseInt(match[1] as string, 10);\n  const text = (match[2] as string).trim();\n  return { id, text };\n};\n\nconst extractIndexPrefixedText = (input: string): string => {\n  const match = input.match(/^(\\d+)[.,\\s]+(.*)$/);\n  // Check if match is not null and if the second capturing group is present\n  if (match && match[2] !== undefined) {\n    return match[2].trim();\n  }\n  return input;\n};\n\nconst batchArray = <T>(arr: readonly T[], size: number): T[][] => {\n  const chunkedArr: T[][] = [];\n  for (let i = 0; i < arr.length; i += size) {\n    chunkedArr.push(arr.slice(i, i + size));\n  }\n  return chunkedArr;\n};\n\nexport const AxStringUtil = {\n  trimNonAlphaNum,\n  splitIntoTwo,\n  dedup,\n  extractIdAndText,\n  extractIndexPrefixedText,\n  batchArray,\n};\n", "import type { AxAIService } from '../ai/types.js';\nimport { AxGen } from '../dsp/generate.js';\nimport { AxStringUtil } from '../dsp/strutil.js';\nimport type {\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n} from '../dsp/types.js';\n\nimport type { AxRerankerIn, AxRerankerOut } from './manager.js';\n\nexport class AxDefaultResultReranker extends AxGen<\n  AxRerankerIn,\n  AxRerankerOut\n> {\n  constructor(options?: Readonly<AxProgramForwardOptions<string>>) {\n    const signature = `\"You are a re-ranker assistant tasked with evaluating a set of content items in relation to a specific question. Your role involves critically analyzing each content item to determine its relevance to the question and re-ranking them accordingly. This process includes assigning a relevance score from 0 to 10 to each content item based on how well it answers the question, its coverage of the topic, and the reliability of its information. This re-ranked list should start with the content item that is most relevant to the question and end with the least relevant. Output only the list.\"\n    query: string, items: string[] -> rankedItems: string[] \"list of id, 5-words Rationale, relevance score\"`;\n\n    super(signature, options);\n  }\n\n  public override forward = async <T extends Readonly<AxAIService>>(\n    ai: T,\n    input: Readonly<AxRerankerIn>,\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): Promise<AxRerankerOut> => {\n    const { rankedItems } = await super.forward(ai, input, options);\n\n    const sortedIndexes: number[] = rankedItems.map((item) => {\n      const { id: index } = AxStringUtil.extractIdAndText(item);\n      return index;\n    });\n\n    // Ensure all elements are strings and filter out null or undefined\n    const sortedItems = input.items\n      .map((_, index) => {\n        const originalIndex = sortedIndexes[index];\n        return originalIndex !== undefined\n          ? input.items[originalIndex]\n          : undefined;\n      })\n      .filter((item): item is string => item !== undefined);\n\n    return { rankedItems: sortedItems };\n  };\n}\n", "// Dynamic import for Node.js-specific functionality to maintain browser compatibility\n\nexport interface AxApacheTikaArgs {\n  url?: string | URL;\n  fetch?: typeof fetch;\n}\n\nexport interface AxApacheTikaConvertOptions {\n  format?: 'text' | 'html';\n}\n\nexport class AxApacheTika {\n  private tikaUrl: URL;\n  private fetch?: typeof fetch;\n\n  constructor(args?: Readonly<AxApacheTikaArgs>) {\n    const Args = args ?? { url: 'http://localhost:9998/' };\n    this.tikaUrl = new URL('/tika', Args.url);\n    this.fetch = Args.fetch;\n  }\n\n  private async _convert(\n    fileData: ReadableStream | Blob,\n    options?: Readonly<AxApacheTikaConvertOptions>\n  ): Promise<string> {\n    if (!fileData) {\n      throw new Error('Failed to read file data');\n    }\n\n    const acceptValue = options?.format === 'html' ? 'text/html' : 'text/plain';\n\n    try {\n      const fetchOptions: RequestInit = {\n        body: fileData as any,\n        headers: { Accept: acceptValue },\n        method: 'PUT',\n      };\n\n      // Add duplex option only in Node.js environments\n      if (typeof window === 'undefined' && typeof process !== 'undefined') {\n        (fetchOptions as any).duplex = 'half';\n      }\n\n      const res = await (this.fetch ?? fetch)(this.tikaUrl, fetchOptions);\n\n      if (!res.ok) {\n        throw new Error(`Failed to upload file: ${res.statusText}`);\n      }\n\n      const text = await res.text();\n      return text;\n    } catch (error) {\n      throw new Error(`Error converting file: ${error}`);\n    }\n  }\n\n  public async convert(\n    files: Readonly<Blob[] | ReadableStream[]>,\n    options?: Readonly<{ batchSize?: number; format?: 'html' | 'text' }>\n  ): Promise<string[]> {\n    const results: string[] = [];\n    const bs = options?.batchSize ?? 10;\n\n    for (let i = 0; i < files.length; i += bs) {\n      const batch = files.slice(i, i + bs);\n      const uploadPromises = batch.map((files) =>\n        this._convert(files, { format: options?.format })\n      );\n      const batchResults = await Promise.all(uploadPromises);\n      results.push(...batchResults);\n    }\n\n    return results;\n  }\n}\nexport default AxApacheTika;\n", "import type { AxAIService } from '../ai/types.js';\nimport { AxDBMemory, type AxDBState } from '../db/memory.js';\nimport { ColorLog } from '../util/log.js';\n\nconst colorLog = new ColorLog();\n\nexport interface AxSimpleClassifierForwardOptions {\n  cutoff?: number;\n  abortSignal?: AbortSignal;\n}\n\nexport class AxSimpleClassifierClass {\n  private readonly name: string;\n  private readonly context: readonly string[];\n\n  constructor(name: string, context: readonly string[]) {\n    this.name = name;\n    this.context = context;\n  }\n\n  public getName(): string {\n    return this.name;\n  }\n\n  public getContext(): readonly string[] {\n    return this.context;\n  }\n}\n\nexport class AxSimpleClassifier {\n  private readonly ai: AxAIService;\n\n  private db: AxDBMemory;\n  private debug?: boolean;\n\n  public constructor(ai: AxAIService) {\n    this.db = new AxDBMemory();\n    this.ai = ai;\n  }\n\n  public getState(): AxDBState | undefined {\n    return this.db.getDB();\n  }\n\n  public setState(state: AxDBState) {\n    this.db.setDB(state);\n  }\n\n  public setClasses = async (\n    classes: readonly AxSimpleClassifierClass[],\n    options?: Readonly<{ abortSignal?: AbortSignal }>\n  ): Promise<void> => {\n    for (const c of classes) {\n      const ret = await this.ai.embed(\n        { texts: c.getContext() },\n        {\n          abortSignal: options?.abortSignal,\n        }\n      );\n      await this.db.upsert({\n        id: c.getName(),\n        table: 'classes',\n        values: ret.embeddings[0],\n      });\n    }\n  };\n\n  public async forward(\n    text: string,\n    options?: Readonly<AxSimpleClassifierForwardOptions>\n  ): Promise<string> {\n    const { embeddings } = await this.ai.embed(\n      { texts: [text] },\n      {\n        abortSignal: options?.abortSignal,\n      }\n    );\n\n    const matches = await this.db.query({\n      table: 'classes',\n      values: embeddings[0],\n    });\n\n    let m = matches.matches;\n    if (typeof options?.cutoff === 'number') {\n      const { cutoff } = options;\n      m = m.filter((m) => m.score <= cutoff);\n    }\n\n    if (this.debug) {\n      console.log(\n        `${colorLog.whiteBright(`query: ${text}`)}\\n${colorLog.greenBright(\n          JSON.stringify(m.map((m) => `${m.id}, ${m.score}`))\n        )}`\n      );\n    }\n\n    const matchedClass = m.at(0);\n    if (!matchedClass) {\n      return '';\n    }\n\n    return matchedClass.id;\n  }\n\n  public setOptions(options: Readonly<{ debug?: boolean }>): void {\n    if (typeof options.debug === 'boolean') {\n      this.debug = options.debug;\n    }\n  }\n}\n", "export const stopwords = new Set([\n  '0o',\n  '0s',\n  '3a',\n  '3b',\n  '3d',\n  '6b',\n  '6o',\n  'a',\n  'a1',\n  'a2',\n  'a3',\n  'a4',\n  'ab',\n  'able',\n  'about',\n  'above',\n  'abst',\n  'ac',\n  'accordance',\n  'according',\n  'accordingly',\n  'across',\n  'act',\n  'actually',\n  'ad',\n  'added',\n  'adj',\n  'ae',\n  'af',\n  'affected',\n  'affecting',\n  'affects',\n  'after',\n  'afterwards',\n  'ag',\n  'again',\n  'against',\n  'ah',\n  'ain',\n  \"ain't\",\n  'aj',\n  'al',\n  'all',\n  'allow',\n  'allows',\n  'almost',\n  'alone',\n  'along',\n  'already',\n  'also',\n  'although',\n  'always',\n  'am',\n  'among',\n  'amongst',\n  'amoungst',\n  'amount',\n  'an',\n  'and',\n  'announce',\n  'another',\n  'any',\n  'anybody',\n  'anyhow',\n  'anymore',\n  'anyone',\n  'anything',\n  'anyway',\n  'anyways',\n  'anywhere',\n  'ao',\n  'ap',\n  'apart',\n  'apparently',\n  'appear',\n  'appreciate',\n  'appropriate',\n  'approximately',\n  'ar',\n  'are',\n  'aren',\n  'arent',\n  \"aren't\",\n  'arise',\n  'around',\n  'as',\n  \"a's\",\n  'aside',\n  'ask',\n  'asking',\n  'associated',\n  'at',\n  'au',\n  'auth',\n  'av',\n  'available',\n  'aw',\n  'away',\n  'awfully',\n  'ax',\n  'ay',\n  'az',\n  'b',\n  'b1',\n  'b2',\n  'b3',\n  'ba',\n  'back',\n  'bc',\n  'bd',\n  'be',\n  'became',\n  'because',\n  'become',\n  'becomes',\n  'becoming',\n  'been',\n  'before',\n  'beforehand',\n  'begin',\n  'beginning',\n  'beginnings',\n  'begins',\n  'behind',\n  'being',\n  'believe',\n  'below',\n  'beside',\n  'besides',\n  'best',\n  'better',\n  'between',\n  'beyond',\n  'bi',\n  'bill',\n  'biol',\n  'bj',\n  'bk',\n  'bl',\n  'bn',\n  'both',\n  'bottom',\n  'bp',\n  'br',\n  'brief',\n  'briefly',\n  'bs',\n  'bt',\n  'bu',\n  'but',\n  'bx',\n  'by',\n  'c',\n  'c1',\n  'c2',\n  'c3',\n  'ca',\n  'call',\n  'came',\n  'can',\n  'cannot',\n  'cant',\n  \"can't\",\n  'cause',\n  'causes',\n  'cc',\n  'cd',\n  'ce',\n  'certain',\n  'certainly',\n  'cf',\n  'cg',\n  'ch',\n  'changes',\n  'ci',\n  'cit',\n  'cj',\n  'cl',\n  'clearly',\n  'cm',\n  \"c'mon\",\n  'cn',\n  'co',\n  'com',\n  'come',\n  'comes',\n  'con',\n  'concerning',\n  'consequently',\n  'consider',\n  'considering',\n  'contain',\n  'containing',\n  'contains',\n  'corresponding',\n  'could',\n  'couldn',\n  'couldnt',\n  \"couldn't\",\n  'course',\n  'cp',\n  'cq',\n  'cr',\n  'cry',\n  'cs',\n  \"c's\",\n  'ct',\n  'cu',\n  'currently',\n  'cv',\n  'cx',\n  'cy',\n  'cz',\n  'd',\n  'd2',\n  'da',\n  'date',\n  'dc',\n  'dd',\n  'de',\n  'definitely',\n  'describe',\n  'described',\n  'despite',\n  'detail',\n  'df',\n  'di',\n  'did',\n  'didn',\n  \"didn't\",\n  'different',\n  'dj',\n  'dk',\n  'dl',\n  'do',\n  'does',\n  'doesn',\n  \"doesn't\",\n  'doing',\n  'don',\n  'done',\n  \"don't\",\n  'down',\n  'downwards',\n  'dp',\n  'dr',\n  'ds',\n  'dt',\n  'du',\n  'due',\n  'during',\n  'dx',\n  'dy',\n  'e',\n  'e2',\n  'e3',\n  'ea',\n  'each',\n  'ec',\n  'ed',\n  'edu',\n  'ee',\n  'ef',\n  'effect',\n  'eg',\n  'ei',\n  'eight',\n  'eighty',\n  'either',\n  'ej',\n  'el',\n  'eleven',\n  'else',\n  'elsewhere',\n  'em',\n  'empty',\n  'en',\n  'end',\n  'ending',\n  'enough',\n  'entirely',\n  'eo',\n  'ep',\n  'eq',\n  'er',\n  'es',\n  'especially',\n  'est',\n  'et',\n  'et-al',\n  'etc',\n  'eu',\n  'ev',\n  'even',\n  'ever',\n  'every',\n  'everybody',\n  'everyone',\n  'everything',\n  'everywhere',\n  'ex',\n  'exactly',\n  'example',\n  'except',\n  'ey',\n  'f',\n  'f2',\n  'fa',\n  'far',\n  'fc',\n  'few',\n  'ff',\n  'fi',\n  'fifteen',\n  'fifth',\n  'fify',\n  'fill',\n  'find',\n  'fire',\n  'first',\n  'five',\n  'fix',\n  'fj',\n  'fl',\n  'fn',\n  'fo',\n  'followed',\n  'following',\n  'follows',\n  'for',\n  'former',\n  'formerly',\n  'forth',\n  'forty',\n  'found',\n  'four',\n  'fr',\n  'from',\n  'front',\n  'ft',\n  'fu',\n  'full',\n  'further',\n  'furthermore',\n  'fy',\n  'g',\n  'ga',\n  'gave',\n  'ge',\n  'get',\n  'gets',\n  'getting',\n  'gi',\n  'give',\n  'given',\n  'gives',\n  'giving',\n  'gj',\n  'gl',\n  'go',\n  'goes',\n  'going',\n  'gone',\n  'got',\n  'gotten',\n  'gr',\n  'greetings',\n  'gs',\n  'gy',\n  'h',\n  'h2',\n  'h3',\n  'had',\n  'hadn',\n  \"hadn't\",\n  'happens',\n  'hardly',\n  'has',\n  'hasn',\n  'hasnt',\n  \"hasn't\",\n  'have',\n  'haven',\n  \"haven't\",\n  'having',\n  'he',\n  'hed',\n  \"he'd\",\n  \"he'll\",\n  'hello',\n  'help',\n  'hence',\n  'her',\n  'here',\n  'hereafter',\n  'hereby',\n  'herein',\n  'heres',\n  \"here's\",\n  'hereupon',\n  'hers',\n  'herself',\n  'hes',\n  \"he's\",\n  'hh',\n  'hi',\n  'hid',\n  'him',\n  'himself',\n  'his',\n  'hither',\n  'hj',\n  'ho',\n  'home',\n  'hopefully',\n  'how',\n  'howbeit',\n  'however',\n  \"how's\",\n  'hr',\n  'hs',\n  'http',\n  'hu',\n  'hundred',\n  'hy',\n  'i',\n  'i2',\n  'i3',\n  'i4',\n  'i6',\n  'i7',\n  'i8',\n  'ia',\n  'ib',\n  'ibid',\n  'ic',\n  'id',\n  \"i'd\",\n  'ie',\n  'if',\n  'ig',\n  'ignored',\n  'ih',\n  'ii',\n  'ij',\n  'il',\n  \"i'll\",\n  'im',\n  \"i'm\",\n  'immediate',\n  'immediately',\n  'importance',\n  'important',\n  'in',\n  'inasmuch',\n  'inc',\n  'indeed',\n  'index',\n  'indicate',\n  'indicated',\n  'indicates',\n  'information',\n  'inner',\n  'insofar',\n  'instead',\n  'interest',\n  'into',\n  'invention',\n  'inward',\n  'io',\n  'ip',\n  'iq',\n  'ir',\n  'is',\n  'isn',\n  \"isn't\",\n  'it',\n  'itd',\n  \"it'd\",\n  \"it'll\",\n  'its',\n  \"it's\",\n  'itself',\n  'iv',\n  \"i've\",\n  'ix',\n  'iy',\n  'iz',\n  'j',\n  'jj',\n  'jr',\n  'js',\n  'jt',\n  'ju',\n  'just',\n  'k',\n  'ke',\n  'keep',\n  'keeps',\n  'kept',\n  'kg',\n  'kj',\n  'km',\n  'know',\n  'known',\n  'knows',\n  'ko',\n  'l',\n  'l2',\n  'la',\n  'largely',\n  'last',\n  'lately',\n  'later',\n  'latter',\n  'latterly',\n  'lb',\n  'lc',\n  'le',\n  'least',\n  'les',\n  'less',\n  'lest',\n  'let',\n  'lets',\n  \"let's\",\n  'lf',\n  'like',\n  'liked',\n  'likely',\n  'line',\n  'little',\n  'lj',\n  'll',\n  'll',\n  'ln',\n  'lo',\n  'look',\n  'looking',\n  'looks',\n  'los',\n  'lr',\n  'ls',\n  'lt',\n  'ltd',\n  'm',\n  'm2',\n  'ma',\n  'made',\n  'mainly',\n  'make',\n  'makes',\n  'many',\n  'may',\n  'maybe',\n  'me',\n  'mean',\n  'means',\n  'meantime',\n  'meanwhile',\n  'merely',\n  'mg',\n  'might',\n  'mightn',\n  \"mightn't\",\n  'mill',\n  'million',\n  'mine',\n  'miss',\n  'ml',\n  'mn',\n  'mo',\n  'more',\n  'moreover',\n  'most',\n  'mostly',\n  'move',\n  'mr',\n  'mrs',\n  'ms',\n  'mt',\n  'mu',\n  'much',\n  'mug',\n  'must',\n  'mustn',\n  \"mustn't\",\n  'my',\n  'myself',\n  'model',\n  'n',\n  'n2',\n  'na',\n  'name',\n  'namely',\n  'nay',\n  'nc',\n  'nd',\n  'ne',\n  'near',\n  'nearly',\n  'necessarily',\n  'necessary',\n  'need',\n  'needn',\n  \"needn't\",\n  'needs',\n  'neither',\n  'never',\n  'nevertheless',\n  'new',\n  'next',\n  'ng',\n  'ni',\n  'nine',\n  'ninety',\n  'nj',\n  'nl',\n  'nn',\n  'no',\n  'nobody',\n  'non',\n  'none',\n  'nonetheless',\n  'noone',\n  'nor',\n  'normally',\n  'nos',\n  'not',\n  'noted',\n  'nothing',\n  'novel',\n  'now',\n  'nowhere',\n  'nr',\n  'ns',\n  'nt',\n  'ny',\n  'o',\n  'oa',\n  'ob',\n  'obtain',\n  'obtained',\n  'obviously',\n  'oc',\n  'od',\n  'of',\n  'off',\n  'often',\n  'og',\n  'oh',\n  'oi',\n  'oj',\n  'ok',\n  'okay',\n  'ol',\n  'old',\n  'om',\n  'omitted',\n  'on',\n  'once',\n  'one',\n  'ones',\n  'only',\n  'onto',\n  'oo',\n  'op',\n  'oq',\n  'or',\n  'ord',\n  'os',\n  'ot',\n  'other',\n  'others',\n  'otherwise',\n  'ou',\n  'ought',\n  'our',\n  'ours',\n  'ourselves',\n  'out',\n  'outside',\n  'over',\n  'overall',\n  'ow',\n  'owing',\n  'own',\n  'ox',\n  'oz',\n  'p',\n  'p1',\n  'p2',\n  'p3',\n  'page',\n  'pagecount',\n  'pages',\n  'par',\n  'part',\n  'particular',\n  'particularly',\n  'pas',\n  'past',\n  'pc',\n  'pd',\n  'pe',\n  'per',\n  'perhaps',\n  'pf',\n  'ph',\n  'pi',\n  'pj',\n  'pk',\n  'pl',\n  'placed',\n  'please',\n  'plus',\n  'pm',\n  'pn',\n  'po',\n  'poorly',\n  'possible',\n  'possibly',\n  'potentially',\n  'pp',\n  'pq',\n  'pr',\n  'predominantly',\n  'present',\n  'presumably',\n  'previously',\n  'primarily',\n  'probably',\n  'promptly',\n  'proud',\n  'provides',\n  'ps',\n  'pt',\n  'pu',\n  'put',\n  'py',\n  'q',\n  'qj',\n  'qu',\n  'que',\n  'quickly',\n  'quite',\n  'qv',\n  'r',\n  'r2',\n  'ra',\n  'ran',\n  'rather',\n  'rc',\n  'rd',\n  're',\n  'readily',\n  'really',\n  'reasonably',\n  'recent',\n  'recently',\n  'ref',\n  'refs',\n  'regarding',\n  'regardless',\n  'regards',\n  'related',\n  'relatively',\n  'research',\n  'research-articl',\n  'respectively',\n  'resulted',\n  'resulting',\n  'results',\n  'rf',\n  'rh',\n  'ri',\n  'right',\n  'rj',\n  'rl',\n  'rm',\n  'rn',\n  'ro',\n  'rq',\n  'rr',\n  'rs',\n  'rt',\n  'ru',\n  'run',\n  'rv',\n  'ry',\n  's',\n  's2',\n  'sa',\n  'said',\n  'same',\n  'saw',\n  'say',\n  'saying',\n  'says',\n  'sc',\n  'sd',\n  'se',\n  'sec',\n  'second',\n  'secondly',\n  'section',\n  'see',\n  'seeing',\n  'seem',\n  'seemed',\n  'seeming',\n  'seems',\n  'seen',\n  'self',\n  'selves',\n  'sensible',\n  'sent',\n  'serious',\n  'seriously',\n  'seven',\n  'several',\n  'sf',\n  'shall',\n  'shan',\n  \"shan't\",\n  'she',\n  'shed',\n  \"she'd\",\n  \"she'll\",\n  'shes',\n  \"she's\",\n  'should',\n  'shouldn',\n  \"shouldn't\",\n  \"should've\",\n  'show',\n  'showed',\n  'shown',\n  'showns',\n  'shows',\n  'si',\n  'side',\n  'significant',\n  'significantly',\n  'similar',\n  'similarly',\n  'since',\n  'sincere',\n  'six',\n  'sixty',\n  'sj',\n  'sl',\n  'slightly',\n  'sm',\n  'sn',\n  'so',\n  'some',\n  'somebody',\n  'somehow',\n  'someone',\n  'somethan',\n  'something',\n  'sometime',\n  'sometimes',\n  'somewhat',\n  'somewhere',\n  'soon',\n  'sorry',\n  'sp',\n  'specifically',\n  'specified',\n  'specify',\n  'specifying',\n  'sq',\n  'sr',\n  'ss',\n  'st',\n  'still',\n  'stop',\n  'strongly',\n  'sub',\n  'substantially',\n  'successfully',\n  'such',\n  'sufficiently',\n  'suggest',\n  'sup',\n  'sure',\n  'sy',\n  'system',\n  'sz',\n  't',\n  't1',\n  't2',\n  't3',\n  'take',\n  'taken',\n  'taking',\n  'tb',\n  'tc',\n  'td',\n  'te',\n  'tell',\n  'ten',\n  'tends',\n  'tf',\n  'th',\n  'than',\n  'thank',\n  'thanks',\n  'thanx',\n  'that',\n  \"that'll\",\n  'thats',\n  \"that's\",\n  \"that've\",\n  'the',\n  'their',\n  'theirs',\n  'them',\n  'themselves',\n  'then',\n  'thence',\n  'there',\n  'thereafter',\n  'thereby',\n  'thered',\n  'therefore',\n  'therein',\n  \"there'll\",\n  'thereof',\n  'therere',\n  'theres',\n  \"there's\",\n  'thereto',\n  'thereupon',\n  \"there've\",\n  'these',\n  'they',\n  'theyd',\n  \"they'd\",\n  \"they'll\",\n  'theyre',\n  \"they're\",\n  \"they've\",\n  'thickv',\n  'thin',\n  'think',\n  'third',\n  'this',\n  'thorough',\n  'thoroughly',\n  'those',\n  'thou',\n  'though',\n  'thoughh',\n  'thousand',\n  'three',\n  'throug',\n  'through',\n  'throughout',\n  'thru',\n  'thus',\n  'ti',\n  'til',\n  'tip',\n  'tj',\n  'tl',\n  'tm',\n  'tn',\n  'to',\n  'together',\n  'too',\n  'took',\n  'top',\n  'toward',\n  'towards',\n  'tp',\n  'tq',\n  'tr',\n  'tried',\n  'tries',\n  'truly',\n  'try',\n  'trying',\n  'ts',\n  \"t's\",\n  'tt',\n  'tv',\n  'twelve',\n  'twenty',\n  'twice',\n  'two',\n  'tx',\n  'u',\n  'u201d',\n  'ue',\n  'ui',\n  'uj',\n  'uk',\n  'um',\n  'un',\n  'under',\n  'unfortunately',\n  'unless',\n  'unlike',\n  'unlikely',\n  'until',\n  'unto',\n  'uo',\n  'up',\n  'upon',\n  'ups',\n  'ur',\n  'us',\n  'use',\n  'used',\n  'useful',\n  'usefully',\n  'usefulness',\n  'uses',\n  'using',\n  'usually',\n  'ut',\n  'v',\n  'va',\n  'value',\n  'various',\n  'vd',\n  've',\n  've',\n  'very',\n  'via',\n  'viz',\n  'vj',\n  'vo',\n  'vol',\n  'vols',\n  'volumtype',\n  'vq',\n  'vs',\n  'vt',\n  'vu',\n  'w',\n  'wa',\n  'want',\n  'wants',\n  'was',\n  'wasn',\n  'wasnt',\n  \"wasn't\",\n  'way',\n  'we',\n  'wed',\n  \"we'd\",\n  'welcome',\n  'well',\n  \"we'll\",\n  'well-b',\n  'went',\n  'were',\n  \"we're\",\n  'weren',\n  'werent',\n  \"weren't\",\n  \"we've\",\n  'what',\n  'whatever',\n  \"what'll\",\n  'whats',\n  \"what's\",\n  'when',\n  'whence',\n  'whenever',\n  \"when's\",\n  'where',\n  'whereafter',\n  'whereas',\n  'whereby',\n  'wherein',\n  'wheres',\n  \"where's\",\n  'whereupon',\n  'wherever',\n  'whether',\n  'which',\n  'while',\n  'whim',\n  'whither',\n  'who',\n  'whod',\n  'whoever',\n  'whole',\n  \"who'll\",\n  'whom',\n  'whomever',\n  'whos',\n  \"who's\",\n  'whose',\n  'why',\n  \"why's\",\n  'wi',\n  'widely',\n  'will',\n  'willing',\n  'wish',\n  'with',\n  'within',\n  'without',\n  'wo',\n  'won',\n  'wonder',\n  'wont',\n  \"won't\",\n  'words',\n  'world',\n  'would',\n  'wouldn',\n  'wouldnt',\n  \"wouldn't\",\n  'www',\n  'x',\n  'x1',\n  'x2',\n  'x3',\n  'xf',\n  'xi',\n  'xj',\n  'xk',\n  'xl',\n  'xn',\n  'xo',\n  'xs',\n  'xt',\n  'xv',\n  'xx',\n  'y',\n  'y2',\n  'yes',\n  'yet',\n  'yj',\n  'yl',\n  'you',\n  'youd',\n  \"you'd\",\n  \"you'll\",\n  'your',\n  'youre',\n  \"you're\",\n  'yours',\n  'yourself',\n  'yourselves',\n  \"you've\",\n  'yr',\n  'ys',\n  'yt',\n  'z',\n  'zero',\n  'zi',\n  'zz',\n  'task',\n]);\n", "import { stopwords } from './stopwords.js';\n\n/**\n * Filters out tokens based on a set of exclusion tokens.\n *\n * @param tokens The array of tokens to filter.\n * @param exclusions A set containing tokens to exclude.\n * @returns An array of filtered tokens.\n */\nfunction filterTokens(\n  tokens: readonly string[],\n  exclusions: ReadonlySet<string>\n): string[] {\n  return tokens.filter((token) => !exclusions.has(token));\n}\n\n/**\n * Counts the occurrences of each token in an array of tokens.\n *\n * This function supports the preprocessing step for NLP tasks like text similarity\n * and classification by transforming text into a bag-of-words model, facilitating\n * the comparison of different texts based on their content.\n *\n * @param tokens An array of string tokens.\n * @returns A Counter object mapping each token to its count.\n */\nfunction countTokens(tokens: readonly string[]): Record<string, number> {\n  const counter: Record<string, number> = {};\n  for (const token of tokens) {\n    counter[token] = (counter[token] || 0) + 1;\n  }\n  return counter;\n}\n\n/**\n * Normalizes text by lowercasing, removing punctuation, and squashing multiple spaces.\n *\n * This normalization is crucial in NLP for reducing the complexity of the text data,\n * minimizing the variance between words that should be considered the same for analysis\n * purposes (e.g., \"Dog!\" and \"dog\" are treated as the same word).\n *\n * @param s A string to be normalized.\n * @returns A normalized string.\n */\nfunction normalizeText(s: string): string {\n  let normalized = s.normalize('NFD');\n  normalized = normalized.replace(/\\b(a|an|the)\\b/g, ' ');\n  normalized = normalized.split(/\\s+/).join(' ');\n  normalized = normalized.replace(/[!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~]/g, '');\n  return normalized.toLowerCase();\n}\n\n/**\n * Calculates the Exact Match (EM) score between a prediction and ground truth.\n *\n * The EM score is a strict metric used in machine learning to assess if the predicted\n * answer matches the ground truth exactly, commonly used in tasks like question answering.\n *\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @returns A number (1.0 for exact match, 0.0 otherwise).\n */\nfunction emScore(prediction: string, groundTruth: string): number {\n  return normalizeText(prediction) === normalizeText(groundTruth) ? 1.0 : 0.0;\n}\n\n/**\n * Calculates the F1 score between a prediction and ground truth.\n *\n * The F1 score is a harmonic mean of precision and recall, widely used in NLP to measure\n * a model's accuracy in considering both false positives and false negatives, offering a\n * balance for evaluating classification models.\n *\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @returns The F1 score as a number.\n */\nfunction f1Score(prediction: string, groundTruth: string): number {\n  const predictionTokens = normalizeText(prediction).split(' ');\n  const groundTruthTokens = normalizeText(groundTruth).split(' ');\n\n  // Calculate the intersection of common tokens between prediction and ground truth\n  const predictionCounts = countTokens(predictionTokens);\n  const groundTruthCounts = countTokens(groundTruthTokens);\n\n  let numSame = 0;\n  for (const token in predictionCounts) {\n    const v1 = predictionCounts[token] ?? 0;\n    const v2 = groundTruthCounts[token] ?? 0;\n    numSame += Math.min(v1, v2);\n  }\n  if (numSame === 0) {\n    return 0;\n  }\n\n  const precision = numSame / predictionTokens.length;\n  const recall = numSame / groundTruthTokens.length;\n  return (2 * precision * recall) / (precision + recall);\n}\n\n/**\n * Calculates a novel F1 score, taking into account a history of interaction and excluding stopwords.\n *\n * This metric extends the F1 score by considering contextual relevance and filtering out common words\n * that might skew the assessment of the prediction's quality, especially in conversational models or\n * when historical context is relevant.\n *\n * @param history The historical context or preceding interactions.\n * @param prediction The predicted text.\n * @param groundTruth The actual correct text.\n * @param returnRecall Optionally return the recall score instead of F1.\n * @returns The novel F1 or recall score as a number.\n */\nfunction novelF1ScoreOptimized(\n  history: string,\n  prediction: string,\n  groundTruth: string,\n  returnRecall = false\n): number {\n  // Normalize and split the input texts into tokens\n  const historyTokens = normalizeText(history).split(' ');\n  let predictionTokens = normalizeText(prediction).split(' ');\n  let groundTruthTokens = normalizeText(groundTruth).split(' ');\n\n  // Combine stopwords and history tokens for exclusion\n  const exclusions = new Set([...stopwords, ...historyTokens]);\n\n  // Filter prediction and ground truth tokens against the exclusions\n  predictionTokens = filterTokens(predictionTokens, exclusions);\n  groundTruthTokens = filterTokens(groundTruthTokens, exclusions);\n\n  // Proceed with calculating common tokens, precision, recall, and F1 score as previously outlined\n\n  // Placeholder for the calculation logic\n  const numSame = 0; // This should be calculated as before\n  const precision = numSame / predictionTokens.length;\n  const recall = numSame / groundTruthTokens.length;\n  const f1 = (2 * precision * recall) / (precision + recall);\n\n  return returnRecall ? recall : f1;\n}\n\nexport const AxEvalUtil = {\n  emScore,\n  f1Score,\n  novelF1ScoreOptimized,\n};\n", "import type { AxAIService } from '../ai/types.js';\nimport type { AxGen } from './generate.js';\nimport type { AxExample, AxMetricFn } from './optimizer.js';\nimport type { AxGenIn, AxGenOut } from './types.js';\n\nexport type AxEvaluateArgs<IN extends AxGenIn, OUT extends AxGenOut> = {\n  ai: AxAIService;\n  program: Readonly<AxGen<IN, OUT>>;\n  examples: Readonly<AxExample[]>;\n};\n\nexport class AxTestPrompt<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> {\n  private ai: AxAIService;\n  private program: Readonly<AxGen<IN, OUT>>;\n  private examples: Readonly<AxExample[]>;\n\n  constructor({\n    ai,\n    program,\n    examples = [],\n  }: Readonly<AxEvaluateArgs<IN, OUT>>) {\n    if (examples.length === 0) {\n      throw new Error('No examples found');\n    }\n    this.ai = ai;\n    this.program = program;\n    this.examples = examples;\n  }\n\n  public async run(metricFn: AxMetricFn) {\n    const _st = Date.now();\n    const total = this.examples.length;\n    let sumOfScores = 0;\n\n    for (let i = 0; i < total; i++) {\n      const ex = this.examples[i];\n      if (!ex) {\n        throw new Error('Invalid example');\n      }\n\n      try {\n        const res = await this.program.forward(this.ai, ex as IN, {\n          maxRetries: 1,\n        });\n        const score = await metricFn({ prediction: res, example: ex });\n        sumOfScores += score;\n      } catch (error) {\n        console.warn(\n          `Program evaluation failed for example ${i}: ${error instanceof Error ? error.message : 'Unknown error'}`\n        );\n        // Continue with next example - score remains 0 for this example\n      }\n\n      // Setting updateProgressBar's 3rd argument is a count/value that represents progress.\n      // If it specifically needs a 'success count', this might need adjustment.\n      // For now, using sumOfScores, but it might represent total score, not #successes.\n      // If AxMetricFn is always 0 or 1, sumOfScores is equivalent to successCount.\n      // const et = Date.now() - st;\n      // updateProgressBar(i, total, sumOfScores, et, 'Testing Prompt', 30);\n    }\n\n    const averageScore = total > 0 ? sumOfScores / total : 0;\n    console.log(\n      '\\nPerformance: ',\n      sumOfScores,\n      '/',\n      total,\n      'Average Score: ',\n      averageScore,\n      '\\n'\n    );\n  }\n}\n", "import type { AxFieldValue } from './types.js';\n\nexport type AxDataRow = { row: Record<string, AxFieldValue> };\n\nexport class AxHFDataLoader {\n  private rows: AxDataRow[] = [];\n  private baseUrl: string;\n\n  private dataset: string;\n  private split: string;\n  private config: string;\n  private options?: Readonly<{ offset?: number; length?: number }>;\n\n  constructor({\n    dataset,\n    split,\n    config,\n    options,\n  }: Readonly<{\n    dataset: string;\n    split: string;\n    config: string;\n    options?: Readonly<{ offset?: number; length?: number }>;\n  }>) {\n    this.baseUrl = 'https://datasets-server.huggingface.co/rows';\n    this.dataset = dataset;\n    this.split = split;\n    this.config = config;\n    this.options = options;\n  }\n\n  private async fetchDataFromAPI(url: string): Promise<AxDataRow[]> {\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Error fetching data: ${response.statusText}`);\n      }\n      const data = (await response.json()) as { rows: AxDataRow[] };\n      if (!data?.rows) {\n        throw new Error('Invalid data format');\n      }\n      return data.rows;\n    } catch (error) {\n      console.error('Error fetching data from API:', error);\n      throw error;\n    }\n  }\n\n  // https://datasets-server.huggingface.co/rows?dataset=hotpot_qa&config=distractor&split=train&offset=0&length=100\n\n  public async loadData() {\n    const offset = this.options?.offset ?? 0;\n    const length = this.options?.length ?? 100;\n    const ds = encodeURIComponent(this.dataset);\n\n    const url = `${this.baseUrl}?dataset=${ds}&config=${this.config}&split=${this.split}&offset=${offset}&length=${length}`;\n\n    console.log('Downloading data from API.');\n    this.rows = (await this.fetchDataFromAPI(url)) as AxDataRow[];\n    return this.rows;\n  }\n\n  public setData(rows: AxDataRow[]) {\n    this.rows = rows;\n  }\n\n  public getData() {\n    return this.rows;\n  }\n\n  public async getRows<T>({\n    count,\n    fields,\n    renameMap,\n  }: Readonly<{\n    count: number;\n    fields: readonly string[];\n    renameMap?: Record<string, string>;\n  }>): Promise<T[]> {\n    if (this.rows.length === 0) {\n      throw new Error('No data loaded, call loadData or setData first.');\n    }\n    const dataRows = this.rows.slice(0, count);\n\n    return dataRows\n      .map((item) => {\n        const result: Record<string, AxFieldValue> = {};\n\n        fields.forEach((field) => {\n          const keys = field.split('.');\n          // Initial value should match the type of the rows, and be indexable by string\n          let value: AxFieldValue | unknown = item.row;\n          for (const key of keys) {\n            // Use type assertion to tell TypeScript that value will always be an object that can be indexed with string keys\n            if (Object.hasOwn(value as Record<string, unknown>, key)) {\n              value = (value as Record<string, unknown>)[key];\n            }\n          }\n          if (!value) {\n            return;\n          }\n          const resultFieldName =\n            renameMap && field in renameMap ? renameMap[field] : field;\n          if (!resultFieldName) {\n            throw new Error(`Invalid field name: ${field}`);\n          }\n          result[resultFieldName] = value as AxFieldValue;\n        });\n\n        return result;\n      })\n      .filter((v) => Object.keys(v).length !== 0) as T[];\n  }\n}\n", "import { ColorLog } from '../util/log.js';\nimport type {\n  AxOptimizerLoggerData,\n  AxOptimizerLoggerFunction,\n} from './optimizerTypes.js';\n\n// Default output function that writes to stdout\nconst defaultOutput = (message: string): void => {\n  console.log(message);\n};\n\n/**\n * Factory function to create a default optimizer logger with color formatting\n */\nexport const axCreateDefaultOptimizerColorLogger = (\n  output: (message: string) => void = defaultOutput\n): AxOptimizerLoggerFunction => {\n  const cl = new ColorLog();\n  const lightDivider = cl.gray(''.repeat(50));\n  const heavyDivider = cl.gray(''.repeat(50));\n\n  return (data: AxOptimizerLoggerData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'OptimizationStart':\n        formattedMessage =\n          `\\n${cl.blueBright(' ')}${cl.whiteBright('Optimization Started')}\\n` +\n          `${lightDivider}\\n` +\n          `  ${cl.white('Optimizer:')} ${cl.cyan(data.value.optimizerType)}\\n` +\n          `  ${cl.white('Examples:')} ${cl.green(data.value.exampleCount.toString())} training, ${cl.green(data.value.validationCount.toString())} validation\\n` +\n          `  ${cl.white('Config:')} ${cl.white(JSON.stringify(data.value.config).slice(0, 80))}${JSON.stringify(data.value.config).length > 80 ? '...' : ''}\\n` +\n          `${heavyDivider}\\n`;\n        break;\n\n      case 'RoundProgress':\n        formattedMessage =\n          `${cl.yellow(' ')}${cl.whiteBright(`Round ${data.value.round}/${data.value.totalRounds}`)}\\n` +\n          `  ${cl.white('Score:')} ${cl.green(data.value.currentScore.toFixed(3))} ${cl.white('(best:')} ${cl.greenBright(data.value.bestScore.toFixed(3))}${cl.white(')')}\\n`;\n        break;\n\n      case 'EarlyStopping':\n        formattedMessage =\n          `\\n${cl.red(' ')}${cl.whiteBright('Early Stopping')}\\n` +\n          `${lightDivider}\\n` +\n          `  ${cl.white('Round:')} ${cl.yellow(data.value.round.toString())}\\n` +\n          `  ${cl.white('Reason:')} ${cl.yellow(data.value.reason)}\\n` +\n          `  ${cl.white('Final Score:')} ${cl.green(data.value.finalScore.toFixed(3))}\\n` +\n          `${heavyDivider}\\n`;\n        break;\n\n      case 'OptimizationComplete':\n        formattedMessage =\n          `\\n${cl.green(' ')}${cl.whiteBright('Optimization Complete')}\\n` +\n          `${lightDivider}\\n` +\n          `  ${cl.white('Best Score:')} ${cl.greenBright(data.value.bestScore.toFixed(3))}\\n` +\n          `  ${cl.white('Best Config:')} ${cl.cyan(JSON.stringify(data.value.bestConfiguration).slice(0, 80))}${JSON.stringify(data.value.bestConfiguration).length > 80 ? '...' : ''}\\n` +\n          `  ${cl.white('Total Calls:')} ${cl.white(data.value.stats.totalCalls?.toString() || 'N/A')}\\n` +\n          `  ${cl.white('Success Rate:')} ${cl.green(`${(((data.value.stats.successfulDemos || 0) / Math.max(data.value.stats.totalCalls || 1, 1)) * 100).toFixed(1)}%`)}\\n` +\n          `${heavyDivider}\\n`;\n        break;\n\n      case 'ConfigurationProposal':\n        formattedMessage =\n          `${cl.magenta(' ')}${cl.whiteBright(`${data.value.type} Proposals`)} ${cl.white(`(${data.value.count})`)}\\n` +\n          `  ${cl.white('Candidates:')} ${cl.white(\n            data.value.proposals\n              .slice(0, 2)\n              .map((p) =>\n                typeof p === 'string'\n                  ? `\"${p.slice(0, 40)}...\"`\n                  : `${JSON.stringify(p).slice(0, 40)}...`\n              )\n              .join(', ')\n          )}\\n`;\n        break;\n\n      case 'BootstrappedDemos':\n        formattedMessage =\n          `${cl.cyan(' ')}${cl.whiteBright('Bootstrapped Demos')} ${cl.white(`(${data.value.count})`)}\\n` +\n          `  ${cl.white('Generated:')} ${cl.green(data.value.count.toString())} demonstration examples\\n`;\n        break;\n\n      case 'BestConfigFound':\n        formattedMessage =\n          `${cl.green(' ')}${cl.whiteBright('Best Configuration Found')}\\n` +\n          `  ${cl.white('Score:')} ${cl.greenBright(data.value.score.toFixed(3))}\\n` +\n          `  ${cl.white('Config:')} ${cl.cyan(JSON.stringify(data.value.config).slice(0, 80))}${JSON.stringify(data.value.config).length > 80 ? '...' : ''}\\n`;\n        break;\n\n      default:\n        formattedMessage =\n          `${cl.red(' ')}${cl.whiteBright('Unknown Event')}\\n` +\n          `  ${cl.white(JSON.stringify(data).slice(0, 100))}${JSON.stringify(data).length > 100 ? '...' : ''}\\n`;\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Factory function to create a text-only optimizer logger (no colors)\n */\nexport const axCreateDefaultOptimizerTextLogger = (\n  output: (message: string) => void = defaultOutput\n): AxOptimizerLoggerFunction => {\n  const divider = ''.repeat(60);\n\n  return (data: AxOptimizerLoggerData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'OptimizationStart':\n        formattedMessage =\n          `[ OPTIMIZATION START: ${data.value.optimizerType} ]\n${divider}\n` +\n          `Config: ${JSON.stringify(data.value.config, null, 2)}\n` +\n          `Examples: ${data.value.exampleCount}, Validation: ${data.value.validationCount}\n` +\n          `${divider}`;\n        break;\n      case 'RoundProgress':\n        formattedMessage =\n          `[ ROUND ${data.value.round}/${data.value.totalRounds} ]\n` +\n          `Current Score: ${data.value.currentScore.toFixed(3)}, Best: ${data.value.bestScore.toFixed(3)}\n` +\n          `Config: ${JSON.stringify(data.value.configuration)}\n` +\n          `${divider}`;\n        break;\n      case 'EarlyStopping':\n        formattedMessage =\n          `[ EARLY STOPPING at Round ${data.value.round} ]\n` +\n          `Reason: ${data.value.reason}\n` +\n          `Final Score: ${data.value.finalScore.toFixed(3)}\n` +\n          `${divider}`;\n        break;\n      case 'OptimizationComplete':\n        formattedMessage =\n          `[ OPTIMIZATION COMPLETE ]\n${divider}\n` +\n          `Best Score: ${data.value.bestScore.toFixed(3)}\n` +\n          `Best Config: ${JSON.stringify(data.value.bestConfiguration)}\n` +\n          `Stats: ${JSON.stringify(data.value.stats, null, 2)}\n` +\n          `${divider}`;\n        break;\n      case 'ConfigurationProposal':\n        formattedMessage =\n          `[ CONFIG PROPOSAL: ${data.value.type} ]\n` +\n          `Count: ${data.value.count}\n` +\n          `Proposals: ${JSON.stringify(data.value.proposals.slice(0, 3), null, 2)} ${data.value.proposals.length > 3 ? '... (truncated)' : ''}\n` +\n          `${divider}`;\n        break;\n      case 'BootstrappedDemos':\n        formattedMessage =\n          `[ BOOTSTRAPPED DEMOS ]\n` +\n          `Count: ${data.value.count}\n` +\n          `Demos: ${JSON.stringify(data.value.demos.slice(0, 2), null, 2)} ${data.value.demos.length > 2 ? '... (truncated)' : ''}\n` +\n          `${divider}`;\n        break;\n      case 'BestConfigFound':\n        formattedMessage =\n          `[ BEST CONFIG FOUND ]\n` +\n          `Score: ${data.value.score.toFixed(3)}\n` +\n          `Config: ${JSON.stringify(data.value.config)}\n` +\n          `${divider}`;\n        break;\n      default:\n        formattedMessage = `[ UNKNOWN OPTIMIZER EVENT ]\n${JSON.stringify(data)}\n${divider}`;\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Default optimizer logger instance with color formatting\n */\nexport const axDefaultOptimizerLogger = axCreateDefaultOptimizerColorLogger();\n", "import type { Counter, Gauge, Histogram, Meter } from '@opentelemetry/api';\n\nimport type { AxAIService, AxLoggerFunction } from '../ai/types.js';\n\nimport { AxGen } from './generate.js';\nimport { axGlobals } from './globals.js';\nimport { axDefaultOptimizerLogger } from './optimizerLogging.js';\nimport type { AxOptimizerLoggerFunction } from './optimizerTypes.js';\nimport type { AxFieldValue, AxGenOut, AxProgramDemos } from './types.js';\n\n// Logger utilities are now exported from ./loggers.js\n\n// Common types used by optimizers\nexport type AxExample = Record<string, AxFieldValue>;\n\nexport type AxMetricFn = <T = any>(\n  arg0: Readonly<{ prediction: T; example: AxExample }>\n) => number | Promise<number>;\n\nexport type AxMetricFnArgs = Parameters<AxMetricFn>[0];\n\n// Multi-objective metric function for Pareto optimization\nexport type AxMultiMetricFn = <T = any>(\n  arg0: Readonly<{ prediction: T; example: AxExample }>\n) => Record<string, number>;\n\n// Progress tracking interface for real-time updates\nexport interface AxOptimizationProgress {\n  round: number;\n  totalRounds: number;\n  currentScore: number;\n  bestScore: number;\n  tokensUsed: number;\n  timeElapsed: number;\n  successfulExamples: number;\n  totalExamples: number;\n  currentConfiguration?: Record<string, unknown>;\n  bestConfiguration?: Record<string, unknown>;\n  convergenceInfo?: {\n    improvement: number;\n    stagnationRounds: number;\n    isConverging: boolean;\n  };\n}\n\n// Cost tracking interface for monitoring resource usage\nexport interface AxCostTracker {\n  trackTokens(count: number, model: string): void;\n  getCurrentCost(): number;\n  getTokenUsage(): Record<string, number>;\n  getTotalTokens(): number;\n  isLimitReached(): boolean;\n  reset(): void;\n}\n\n// Checkpoint interface for saving/loading optimization state\nexport interface AxOptimizationCheckpoint {\n  version: string;\n  timestamp: number;\n  optimizerType: string;\n  optimizerConfig: Record<string, unknown>;\n\n  // Current optimization state\n  currentRound: number;\n  totalRounds: number;\n  bestScore: number;\n  bestConfiguration?: Record<string, unknown>;\n\n  // Historical data\n  scoreHistory: number[];\n  configurationHistory: Record<string, unknown>[];\n\n  // Resource usage\n  stats: AxOptimizationStats;\n\n  // Optimizer-specific state\n  optimizerState: Record<string, unknown>;\n\n  // Examples and validation data\n  examples: readonly AxExample[];\n  validationSet?: readonly AxExample[];\n}\n\n// Simple checkpoint functions - users implement these as needed\nexport type AxCheckpointSaveFn = (\n  checkpoint: Readonly<AxOptimizationCheckpoint>\n) => Promise<string>;\nexport type AxCheckpointLoadFn = (\n  checkpointId: string\n) => Promise<AxOptimizationCheckpoint | null>;\n\n// Cost tracker configuration options\nexport interface AxCostTrackerOptions {\n  // Cost-based limits\n  costPerModel?: Record<string, number>;\n  maxCost?: number;\n\n  // Token-based limits\n  maxTokens?: number;\n}\n\n// Enhanced optimizer arguments - no longer includes program\nexport type AxOptimizerArgs = {\n  studentAI: AxAIService;\n  teacherAI?: AxAIService; // For generating high-quality examples/corrections\n  examples: readonly AxExample[];\n\n  // Python optimizer service\n  optimizerEndpoint?: string; // Python optimizer service URL\n  optimizerTimeout?: number; // Request timeout (default: 30000ms)\n  optimizerRetries?: number; // Retry attempts (default: 3)\n\n  // MiPRO-specific options (flattened from AxMiPROOptimizerOptions)\n  numCandidates?: number;\n  initTemperature?: number;\n  maxBootstrappedDemos?: number;\n  maxLabeledDemos?: number;\n  numTrials?: number;\n  minibatch?: boolean;\n  minibatchSize?: number;\n  minibatchFullEvalSteps?: number;\n  programAwareProposer?: boolean;\n  dataAwareProposer?: boolean;\n  viewDataBatchSize?: number;\n  tipAwareProposer?: boolean;\n  fewshotAwareProposer?: boolean;\n  earlyStoppingTrials?: number;\n  minImprovementThreshold?: number;\n  bayesianOptimization?: boolean;\n  acquisitionFunction?:\n    | 'expected_improvement'\n    | 'upper_confidence_bound'\n    | 'probability_improvement';\n  explorationWeight?: number;\n  sampleCount?: number;\n\n  // Evaluation strategy\n  validationSet?: readonly AxExample[];\n\n  // Quality thresholds\n  minSuccessRate?: number;\n  targetScore?: number;\n\n  // Monitoring & callbacks\n  onProgress?: (progress: Readonly<AxOptimizationProgress>) => void;\n  onEarlyStop?: (reason: string, stats: Readonly<AxOptimizationStats>) => void;\n  costTracker?: AxCostTracker;\n\n  // Checkpointing\n  checkpointSave?: AxCheckpointSaveFn;\n  checkpointLoad?: AxCheckpointLoadFn;\n  checkpointInterval?: number; // Save checkpoint every N rounds\n  resumeFromCheckpoint?: string; // Checkpoint ID to resume from\n\n  // Logging\n  logger?: AxLoggerFunction;\n  verbose?: boolean;\n\n  // Reproducibility\n  seed?: number;\n\n  // Optimizer logging\n  debugOptimizer?: boolean;\n  optimizerLogger?: AxOptimizerLoggerFunction;\n};\n\n// Enhanced optimization statistics\nexport interface AxOptimizationStats {\n  totalCalls: number;\n  successfulDemos: number;\n  estimatedTokenUsage: number;\n  earlyStopped: boolean;\n  earlyStopping?: {\n    bestScoreRound: number;\n    patienceExhausted: boolean;\n    reason: string;\n  };\n  bestScore: number;\n  bestConfiguration?: Record<string, unknown>;\n\n  // Resource usage tracking\n  resourceUsage: {\n    totalTokens: number;\n    totalTime: number;\n    avgLatencyPerEval: number;\n    peakMemoryUsage?: number;\n    costByModel: Record<string, number>;\n  };\n\n  // Quality metrics\n  convergenceInfo: {\n    converged: boolean;\n    finalImprovement: number;\n    stagnationRounds: number;\n    convergenceThreshold: number;\n  };\n\n  // Evaluation breakdown\n  evaluationBreakdown?: {\n    trainingScore: number;\n    validationScore: number;\n    crossValidationScores?: number[];\n    standardDeviation?: number;\n  };\n}\n\n// Optimizer metrics configuration interface\nexport interface AxOptimizerMetricsConfig {\n  enabled: boolean;\n  enabledCategories: (\n    | 'optimization'\n    | 'convergence'\n    | 'resource_usage'\n    | 'teacher_student'\n    | 'checkpointing'\n    | 'pareto'\n  )[];\n  maxLabelLength: number;\n  samplingRate: number;\n}\n\n// Default optimizer metrics configuration\nexport const axDefaultOptimizerMetricsConfig: AxOptimizerMetricsConfig = {\n  enabled: true,\n  enabledCategories: [\n    'optimization',\n    'convergence',\n    'resource_usage',\n    'teacher_student',\n    'checkpointing',\n    'pareto',\n  ],\n  maxLabelLength: 100,\n  samplingRate: 1.0,\n};\n\n// Optimizer metrics instruments interface\nexport interface AxOptimizerMetricsInstruments {\n  // Optimization flow metrics\n  optimizationLatencyHistogram?: Histogram;\n  optimizationRequestsCounter?: Counter;\n  optimizationErrorsCounter?: Counter;\n\n  // Convergence metrics\n  convergenceRoundsHistogram?: Histogram;\n  convergenceScoreGauge?: Gauge;\n  convergenceImprovementGauge?: Gauge;\n  stagnationRoundsGauge?: Gauge;\n  earlyStoppingCounter?: Counter;\n\n  // Resource usage metrics\n  tokenUsageCounter?: Counter;\n  costUsageCounter?: Counter;\n  memoryUsageGauge?: Gauge;\n  optimizationDurationHistogram?: Histogram;\n\n  // Teacher-student metrics\n  teacherStudentUsageCounter?: Counter;\n  teacherStudentLatencyHistogram?: Histogram;\n  teacherStudentScoreImprovementGauge?: Gauge;\n\n  // Checkpointing metrics\n  checkpointSaveCounter?: Counter;\n  checkpointLoadCounter?: Counter;\n  checkpointSaveLatencyHistogram?: Histogram;\n  checkpointLoadLatencyHistogram?: Histogram;\n\n  // Pareto optimization metrics\n  paretoOptimizationsCounter?: Counter;\n  paretoFrontSizeHistogram?: Histogram;\n  paretoHypervolumeGauge?: Gauge;\n  paretoSolutionsGeneratedHistogram?: Histogram;\n\n  // Program complexity metrics\n  programInputFieldsGauge?: Gauge;\n  programOutputFieldsGauge?: Gauge;\n  examplesCountGauge?: Gauge;\n  validationSetSizeGauge?: Gauge;\n\n  // Performance metrics\n  evaluationLatencyHistogram?: Histogram;\n  demoGenerationLatencyHistogram?: Histogram;\n  metricComputationLatencyHistogram?: Histogram;\n\n  // Configuration metrics\n  optimizerTypeGauge?: Gauge;\n  targetScoreGauge?: Gauge;\n  maxRoundsGauge?: Gauge;\n}\n\n// Singleton instance for optimizer metrics instruments\nlet globalOptimizerMetricsInstruments:\n  | AxOptimizerMetricsInstruments\n  | undefined;\n\n// Function to get or create optimizer metrics instruments (singleton pattern)\nexport const getOrCreateOptimizerMetricsInstruments = (\n  meter?: Meter\n): AxOptimizerMetricsInstruments | undefined => {\n  // Return existing instance if available\n  if (globalOptimizerMetricsInstruments) {\n    return globalOptimizerMetricsInstruments;\n  }\n\n  if (meter) {\n    globalOptimizerMetricsInstruments =\n      createOptimizerMetricsInstruments(meter);\n    return globalOptimizerMetricsInstruments;\n  }\n\n  return undefined;\n};\n\n// Function to reset the optimizer metrics singleton (useful for testing)\nexport const resetOptimizerMetricsInstruments = (): void => {\n  globalOptimizerMetricsInstruments = undefined;\n};\n\n// Global optimizer metrics configuration\nlet currentOptimizerMetricsConfig: AxOptimizerMetricsConfig =\n  axDefaultOptimizerMetricsConfig;\n\n// Function to update optimizer metrics configuration\nexport const axUpdateOptimizerMetricsConfig = (\n  config: Readonly<Partial<AxOptimizerMetricsConfig>>\n): void => {\n  currentOptimizerMetricsConfig = {\n    ...currentOptimizerMetricsConfig,\n    ...config,\n  };\n};\n\n// Function to get current optimizer metrics configuration\nexport const axGetOptimizerMetricsConfig = (): AxOptimizerMetricsConfig => {\n  return { ...currentOptimizerMetricsConfig };\n};\n\nexport const createOptimizerMetricsInstruments = (\n  meter: Meter\n): AxOptimizerMetricsInstruments => {\n  return {\n    // Optimization flow metrics\n    optimizationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_optimization_duration_ms',\n      {\n        description: 'End-to-end duration of optimization runs',\n        unit: 'ms',\n      }\n    ),\n\n    optimizationRequestsCounter: meter.createCounter(\n      'ax_optimizer_optimization_requests_total',\n      {\n        description: 'Total number of optimization requests',\n      }\n    ),\n\n    optimizationErrorsCounter: meter.createCounter(\n      'ax_optimizer_optimization_errors_total',\n      {\n        description: 'Total number of failed optimizations',\n      }\n    ),\n\n    // Convergence metrics\n    convergenceRoundsHistogram: meter.createHistogram(\n      'ax_optimizer_convergence_rounds',\n      {\n        description: 'Number of rounds until convergence',\n      }\n    ),\n\n    convergenceScoreGauge: meter.createGauge('ax_optimizer_convergence_score', {\n      description: 'Current best score during optimization',\n    }),\n\n    convergenceImprovementGauge: meter.createGauge(\n      'ax_optimizer_convergence_improvement',\n      {\n        description: 'Improvement in score from baseline',\n      }\n    ),\n\n    stagnationRoundsGauge: meter.createGauge('ax_optimizer_stagnation_rounds', {\n      description: 'Number of rounds without improvement',\n    }),\n\n    earlyStoppingCounter: meter.createCounter(\n      'ax_optimizer_early_stopping_total',\n      {\n        description: 'Total number of early stopping events',\n      }\n    ),\n\n    // Resource usage metrics\n    tokenUsageCounter: meter.createCounter('ax_optimizer_token_usage_total', {\n      description: 'Total tokens used during optimization',\n    }),\n\n    costUsageCounter: meter.createCounter('ax_optimizer_cost_usage_total', {\n      description: 'Total cost incurred during optimization',\n      unit: '$',\n    }),\n\n    memoryUsageGauge: meter.createGauge('ax_optimizer_memory_usage_bytes', {\n      description: 'Peak memory usage during optimization',\n      unit: 'By',\n    }),\n\n    optimizationDurationHistogram: meter.createHistogram(\n      'ax_optimizer_duration_ms',\n      {\n        description: 'Duration of optimization runs',\n        unit: 'ms',\n      }\n    ),\n\n    // Teacher-student metrics\n    teacherStudentUsageCounter: meter.createCounter(\n      'ax_optimizer_teacher_student_usage_total',\n      {\n        description: 'Total number of teacher-student interactions',\n      }\n    ),\n\n    teacherStudentLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_teacher_student_latency_ms',\n      {\n        description: 'Latency of teacher-student interactions',\n        unit: 'ms',\n      }\n    ),\n\n    teacherStudentScoreImprovementGauge: meter.createGauge(\n      'ax_optimizer_teacher_student_score_improvement',\n      {\n        description: 'Score improvement from teacher-student interactions',\n      }\n    ),\n\n    // Checkpointing metrics\n    checkpointSaveCounter: meter.createCounter(\n      'ax_optimizer_checkpoint_save_total',\n      {\n        description: 'Total number of checkpoint saves',\n      }\n    ),\n\n    checkpointLoadCounter: meter.createCounter(\n      'ax_optimizer_checkpoint_load_total',\n      {\n        description: 'Total number of checkpoint loads',\n      }\n    ),\n\n    checkpointSaveLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_checkpoint_save_latency_ms',\n      {\n        description: 'Latency of checkpoint save operations',\n        unit: 'ms',\n      }\n    ),\n\n    checkpointLoadLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_checkpoint_load_latency_ms',\n      {\n        description: 'Latency of checkpoint load operations',\n        unit: 'ms',\n      }\n    ),\n\n    // Pareto optimization metrics\n    paretoOptimizationsCounter: meter.createCounter(\n      'ax_optimizer_pareto_optimizations_total',\n      {\n        description: 'Total number of Pareto optimizations',\n      }\n    ),\n\n    paretoFrontSizeHistogram: meter.createHistogram(\n      'ax_optimizer_pareto_front_size',\n      {\n        description: 'Size of Pareto frontier',\n      }\n    ),\n\n    paretoHypervolumeGauge: meter.createGauge(\n      'ax_optimizer_pareto_hypervolume',\n      {\n        description: 'Hypervolume of Pareto frontier',\n      }\n    ),\n\n    paretoSolutionsGeneratedHistogram: meter.createHistogram(\n      'ax_optimizer_pareto_solutions_generated',\n      {\n        description: 'Number of solutions generated for Pareto optimization',\n      }\n    ),\n\n    // Program complexity metrics\n    programInputFieldsGauge: meter.createGauge(\n      'ax_optimizer_program_input_fields',\n      {\n        description: 'Number of input fields in optimized program',\n      }\n    ),\n\n    programOutputFieldsGauge: meter.createGauge(\n      'ax_optimizer_program_output_fields',\n      {\n        description: 'Number of output fields in optimized program',\n      }\n    ),\n\n    examplesCountGauge: meter.createGauge('ax_optimizer_examples_count', {\n      description: 'Number of training examples used',\n    }),\n\n    validationSetSizeGauge: meter.createGauge(\n      'ax_optimizer_validation_set_size',\n      {\n        description: 'Size of validation set used',\n      }\n    ),\n\n    // Performance metrics\n    evaluationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_evaluation_latency_ms',\n      {\n        description: 'Latency of program evaluations',\n        unit: 'ms',\n      }\n    ),\n\n    demoGenerationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_demo_generation_latency_ms',\n      {\n        description: 'Latency of demo generation',\n        unit: 'ms',\n      }\n    ),\n\n    metricComputationLatencyHistogram: meter.createHistogram(\n      'ax_optimizer_metric_computation_latency_ms',\n      {\n        description: 'Latency of metric computation',\n        unit: 'ms',\n      }\n    ),\n\n    // Configuration metrics\n    optimizerTypeGauge: meter.createGauge('ax_optimizer_type', {\n      description: 'Type of optimizer being used',\n    }),\n\n    targetScoreGauge: meter.createGauge('ax_optimizer_target_score', {\n      description: 'Target score for optimization',\n    }),\n\n    maxRoundsGauge: meter.createGauge('ax_optimizer_max_rounds', {\n      description: 'Maximum rounds for optimization',\n    }),\n  };\n};\n\n// Utility function to sanitize optimizer metric labels\nconst sanitizeOptimizerLabels = (\n  labels: Record<string, unknown>\n): Record<string, string> => {\n  const sanitized: Record<string, string> = {};\n  for (const [key, value] of Object.entries(labels)) {\n    if (value !== undefined && value !== null) {\n      const stringValue = String(value);\n      // Limit label length based on configuration\n      const maxLength = currentOptimizerMetricsConfig.maxLabelLength;\n      sanitized[key] =\n        stringValue.length > maxLength\n          ? stringValue.substring(0, maxLength)\n          : stringValue;\n    }\n  }\n  return sanitized;\n};\n\n// Recording functions for optimization flow metrics\nexport const recordOptimizationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  duration: number,\n  success: boolean,\n  optimizerType: string,\n  programSignature?: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      success: success.toString(),\n      optimizer_type: optimizerType,\n      ...(programSignature ? { program_signature: programSignature } : {}),\n    });\n\n    if (instruments.optimizationLatencyHistogram) {\n      instruments.optimizationLatencyHistogram.record(duration, labels);\n    }\n\n    if (instruments.optimizationRequestsCounter) {\n      instruments.optimizationRequestsCounter.add(1, labels);\n    }\n\n    if (!success && instruments.optimizationErrorsCounter) {\n      instruments.optimizationErrorsCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimization metric:', error);\n  }\n};\n\n// Recording functions for convergence metrics\nexport const recordConvergenceMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  rounds: number,\n  currentScore: number,\n  improvement: number,\n  stagnationRounds: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.convergenceRoundsHistogram) {\n      instruments.convergenceRoundsHistogram.record(rounds, labels);\n    }\n\n    if (instruments.convergenceScoreGauge) {\n      instruments.convergenceScoreGauge.record(currentScore, labels);\n    }\n\n    if (instruments.convergenceImprovementGauge) {\n      instruments.convergenceImprovementGauge.record(improvement, labels);\n    }\n\n    if (instruments.stagnationRoundsGauge) {\n      instruments.stagnationRoundsGauge.record(stagnationRounds, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record convergence metric:', error);\n  }\n};\n\nexport const recordEarlyStoppingMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  reason: string,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      reason,\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.earlyStoppingCounter) {\n      instruments.earlyStoppingCounter.add(1, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record early stopping metric:', error);\n  }\n};\n\n// Recording functions for resource usage metrics\nexport const recordResourceUsageMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  tokensUsed: number,\n  costIncurred: number,\n  optimizerType: string,\n  memoryUsage?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.tokenUsageCounter) {\n      instruments.tokenUsageCounter.add(tokensUsed, labels);\n    }\n\n    if (instruments.costUsageCounter) {\n      instruments.costUsageCounter.add(costIncurred, labels);\n    }\n\n    if (memoryUsage !== undefined && instruments.memoryUsageGauge) {\n      instruments.memoryUsageGauge.record(memoryUsage, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record resource usage metric:', error);\n  }\n};\n\nexport const recordOptimizationDurationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  duration: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.optimizationDurationHistogram) {\n      instruments.optimizationDurationHistogram.record(duration, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimization duration metric:', error);\n  }\n};\n\n// Recording functions for teacher-student metrics\nexport const recordTeacherStudentMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  latency: number,\n  scoreImprovement: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.teacherStudentUsageCounter) {\n      instruments.teacherStudentUsageCounter.add(1, labels);\n    }\n\n    if (instruments.teacherStudentLatencyHistogram) {\n      instruments.teacherStudentLatencyHistogram.record(latency, labels);\n    }\n\n    if (instruments.teacherStudentScoreImprovementGauge) {\n      instruments.teacherStudentScoreImprovementGauge.record(\n        scoreImprovement,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record teacher-student metric:', error);\n  }\n};\n\n// Recording functions for checkpointing metrics\nexport const recordCheckpointMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  operation: 'save' | 'load',\n  latency: number,\n  success: boolean,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      operation,\n      success: success.toString(),\n      optimizer_type: optimizerType,\n    });\n\n    if (operation === 'save') {\n      if (instruments.checkpointSaveCounter) {\n        instruments.checkpointSaveCounter.add(1, labels);\n      }\n      if (instruments.checkpointSaveLatencyHistogram) {\n        instruments.checkpointSaveLatencyHistogram.record(latency, labels);\n      }\n    } else {\n      if (instruments.checkpointLoadCounter) {\n        instruments.checkpointLoadCounter.add(1, labels);\n      }\n      if (instruments.checkpointLoadLatencyHistogram) {\n        instruments.checkpointLoadLatencyHistogram.record(latency, labels);\n      }\n    }\n  } catch (error) {\n    console.warn('Failed to record checkpoint metric:', error);\n  }\n};\n\n// Recording functions for Pareto optimization metrics\nexport const recordParetoMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  frontSize: number,\n  solutionsGenerated: number,\n  optimizerType: string,\n  hypervolume?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.paretoOptimizationsCounter) {\n      instruments.paretoOptimizationsCounter.add(1, labels);\n    }\n\n    if (instruments.paretoFrontSizeHistogram) {\n      instruments.paretoFrontSizeHistogram.record(frontSize, labels);\n    }\n\n    if (hypervolume !== undefined && instruments.paretoHypervolumeGauge) {\n      instruments.paretoHypervolumeGauge.record(hypervolume, labels);\n    }\n\n    if (instruments.paretoSolutionsGeneratedHistogram) {\n      instruments.paretoSolutionsGeneratedHistogram.record(\n        solutionsGenerated,\n        labels\n      );\n    }\n  } catch (error) {\n    console.warn('Failed to record Pareto metric:', error);\n  }\n};\n\n// Recording functions for program complexity metrics\nexport const recordProgramComplexityMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  inputFields: number,\n  outputFields: number,\n  examplesCount: number,\n  validationSetSize: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.programInputFieldsGauge) {\n      instruments.programInputFieldsGauge.record(inputFields, labels);\n    }\n\n    if (instruments.programOutputFieldsGauge) {\n      instruments.programOutputFieldsGauge.record(outputFields, labels);\n    }\n\n    if (instruments.examplesCountGauge) {\n      instruments.examplesCountGauge.record(examplesCount, labels);\n    }\n\n    if (instruments.validationSetSizeGauge) {\n      instruments.validationSetSizeGauge.record(validationSetSize, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record program complexity metric:', error);\n  }\n};\n\n// Recording functions for performance metrics\nexport const recordOptimizerPerformanceMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  metricType: 'evaluation' | 'demo_generation' | 'metric_computation',\n  duration: number,\n  optimizerType: string\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      metric_type: metricType,\n      optimizer_type: optimizerType,\n    });\n\n    switch (metricType) {\n      case 'evaluation':\n        if (instruments.evaluationLatencyHistogram) {\n          instruments.evaluationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'demo_generation':\n        if (instruments.demoGenerationLatencyHistogram) {\n          instruments.demoGenerationLatencyHistogram.record(duration, labels);\n        }\n        break;\n      case 'metric_computation':\n        if (instruments.metricComputationLatencyHistogram) {\n          instruments.metricComputationLatencyHistogram.record(\n            duration,\n            labels\n          );\n        }\n        break;\n    }\n  } catch (error) {\n    console.warn('Failed to record optimizer performance metric:', error);\n  }\n};\n\n// Recording functions for configuration metrics\nexport const recordOptimizerConfigurationMetric = (\n  instruments: Readonly<AxOptimizerMetricsInstruments>,\n  optimizerType: string,\n  targetScore?: number,\n  maxRounds?: number\n): void => {\n  try {\n    const labels = sanitizeOptimizerLabels({\n      optimizer_type: optimizerType,\n    });\n\n    if (instruments.optimizerTypeGauge) {\n      instruments.optimizerTypeGauge.record(1, labels);\n    }\n\n    if (targetScore !== undefined && instruments.targetScoreGauge) {\n      instruments.targetScoreGauge.record(targetScore, labels);\n    }\n\n    if (maxRounds !== undefined && instruments.maxRoundsGauge) {\n      instruments.maxRoundsGauge.record(maxRounds, labels);\n    }\n  } catch (error) {\n    console.warn('Failed to record optimizer configuration metric:', error);\n  }\n};\n\n// Simplified result - no program since it's passed to compile\nexport interface AxOptimizerResult<OUT> {\n  demos?: AxProgramDemos<any, OUT>[];\n  stats: AxOptimizationStats;\n  bestScore: number;\n  finalConfiguration?: Record<string, unknown>;\n\n  // Optimization history for analysis\n  scoreHistory?: number[];\n  configurationHistory?: Record<string, unknown>[];\n}\n\n// Pareto optimization result for multi-objective optimization\nexport interface AxParetoResult<OUT = any> extends AxOptimizerResult<OUT> {\n  paretoFront: ReadonlyArray<{\n    demos: readonly AxProgramDemos<any, OUT>[];\n    scores: Readonly<Record<string, number>>;\n    configuration: Readonly<Record<string, unknown>>;\n    dominatedSolutions: number;\n  }>;\n\n  // Multi-objective specific stats\n  hypervolume?: number;\n  paretoFrontSize: number;\n  convergenceMetrics?: Record<string, number>;\n}\n\n// Compile options that can override constructor arguments\nexport interface AxCompileOptions {\n  // Method-specific options\n  maxIterations?: number;\n  earlyStoppingPatience?: number;\n  verbose?: boolean;\n\n  // Override args for this specific run\n  overrideValidationSet?: readonly AxExample[];\n  overrideTargetScore?: number;\n  overrideCostTracker?: AxCostTracker;\n  overrideTeacherAI?: AxAIService;\n\n  // Progress monitoring overrides\n  overrideOnProgress?: (progress: Readonly<AxOptimizationProgress>) => void;\n  overrideOnEarlyStop?: (\n    reason: string,\n    stats: Readonly<AxOptimizationStats>\n  ) => void;\n\n  // Checkpointing overrides\n  overrideCheckpointSave?: AxCheckpointSaveFn;\n  overrideCheckpointLoad?: AxCheckpointLoadFn;\n  overrideCheckpointInterval?: number;\n  saveCheckpointOnComplete?: boolean;\n}\n\n// Enhanced base optimizer interface\nexport interface AxOptimizer<IN = any, OUT extends AxGenOut = any> {\n  /**\n   * Optimize a program using the provided metric function\n   * @param program The program to optimize (moved from constructor)\n   * @param metricFn Evaluation metric function to assess program performance\n   * @param options Optional configuration options that can override constructor settings\n   * @returns Optimization result containing demos, stats, and configuration\n   */\n  compile(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizerResult<OUT>>;\n\n  /**\n   * Optimize a program with real-time streaming updates\n   * @param program The program to optimize\n   * @param metricFn Evaluation metric function\n   * @param options Optional configuration options\n   * @returns Async iterator yielding optimization progress\n   */\n  compileStream?(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): AsyncIterableIterator<AxOptimizationProgress>;\n\n  /**\n   * Multi-objective optimization using Pareto frontier\n   * @param program The program to optimize\n   * @param metricFn Multi-objective metric function\n   * @param options Optional configuration options\n   * @returns Pareto optimization result\n   */\n  compilePareto?(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>>;\n\n  /**\n   * Get current optimization statistics\n   * @returns Current optimization statistics\n   */\n  getStats(): AxOptimizationStats;\n\n  /**\n   * Cancel ongoing optimization gracefully\n   * @returns Promise that resolves when cancellation is complete\n   */\n  cancel?(): Promise<void>;\n\n  /**\n   * Reset optimizer state for reuse with different programs\n   */\n  reset?(): void;\n\n  /**\n   * Get optimizer-specific configuration\n   * @returns Current optimizer configuration\n   */\n  getConfiguration?(): Record<string, unknown>;\n\n  /**\n   * Update optimizer configuration\n   * @param config New configuration to merge with existing\n   */\n  updateConfiguration?(config: Readonly<Record<string, unknown>>): void;\n\n  /**\n   * Validate that the optimizer can handle the given program\n   * @param program Program to validate\n   * @returns Validation result with any issues found\n   */\n  validateProgram?(program: Readonly<AxGen<IN, OUT>>): {\n    isValid: boolean;\n    issues: string[];\n    suggestions: string[];\n  };\n}\n\n// Specific optimizer options interfaces\n\nexport interface AxBootstrapOptimizerOptions {\n  maxRounds?: number;\n  maxExamples?: number;\n  maxDemos?: number;\n  batchSize?: number;\n  earlyStoppingPatience?: number;\n  teacherAI?: AxAIService;\n  costMonitoring?: boolean;\n  maxTokensPerGeneration?: number;\n  verboseMode?: boolean;\n  debugMode?: boolean;\n\n  // Enhanced options\n  adaptiveBatching?: boolean;\n  dynamicTemperature?: boolean;\n  qualityThreshold?: number;\n  diversityWeight?: number;\n}\n\nexport interface AxMiPROOptimizerOptions {\n  numCandidates?: number;\n  initTemperature?: number;\n  maxBootstrappedDemos?: number;\n  maxLabeledDemos?: number;\n  numTrials?: number;\n  minibatch?: boolean;\n  minibatchSize?: number;\n  minibatchFullEvalSteps?: number;\n  programAwareProposer?: boolean;\n  dataAwareProposer?: boolean;\n  viewDataBatchSize?: number;\n  tipAwareProposer?: boolean;\n  fewshotAwareProposer?: boolean;\n  verbose?: boolean;\n  earlyStoppingTrials?: number;\n  minImprovementThreshold?: number;\n\n  // Enhanced options\n  bayesianOptimization?: boolean;\n  acquisitionFunction?:\n    | 'expected_improvement'\n    | 'upper_confidence_bound'\n    | 'probability_improvement';\n  explorationWeight?: number;\n\n  // New option: number of samples to generate per forward call for self-consistency\n  sampleCount?: number;\n}\n\n// Legacy compile options (for backward compatibility)\nexport interface AxBootstrapCompileOptions extends AxCompileOptions {\n  validationExamples?: readonly AxExample[];\n  maxDemos?: number;\n  teacherProgram?: Readonly<AxGen<any, any>>;\n}\n\nexport interface AxMiPROCompileOptions extends AxCompileOptions {\n  validationExamples?: readonly AxExample[];\n  teacher?: Readonly<AxGen<any, any>>;\n  auto?: 'light' | 'medium' | 'heavy';\n\n  // Enhanced MiPRO options\n  instructionCandidates?: string[];\n  customProposer?: (\n    context: Readonly<{\n      programSummary: string;\n      dataSummary: string;\n      previousInstructions: string[];\n    }>\n  ) => Promise<string[]>;\n}\n\n// Default cost tracker implementation\nexport class AxDefaultCostTracker implements AxCostTracker {\n  private tokenUsage: Record<string, number> = {};\n  private totalTokens = 0;\n\n  // Configuration options\n  private readonly costPerModel: Record<string, number>;\n  private readonly maxCost?: number;\n  private readonly maxTokens?: number;\n\n  constructor(options?: AxCostTrackerOptions) {\n    this.costPerModel = options?.costPerModel ?? {};\n    this.maxCost = options?.maxCost;\n    this.maxTokens = options?.maxTokens;\n  }\n\n  trackTokens(count: number, model: string): void {\n    this.tokenUsage[model] = (this.tokenUsage[model] || 0) + count;\n    this.totalTokens += count;\n  }\n\n  getCurrentCost(): number {\n    // Calculate cost on-demand\n    let totalCost = 0;\n    for (const [model, tokens] of Object.entries(this.tokenUsage)) {\n      const costPer1K = this.costPerModel[model] || 0.001; // Default fallback\n      totalCost += (tokens / 1000) * costPer1K;\n    }\n    return totalCost;\n  }\n\n  getTokenUsage(): Record<string, number> {\n    return { ...this.tokenUsage };\n  }\n\n  getTotalTokens(): number {\n    return this.totalTokens;\n  }\n\n  isLimitReached(): boolean {\n    // Check token limit if configured\n    if (this.maxTokens !== undefined && this.totalTokens >= this.maxTokens) {\n      return true;\n    }\n\n    // Check cost limit if configured (calculate cost on-demand)\n    if (this.maxCost !== undefined) {\n      const currentCost = this.getCurrentCost();\n      if (currentCost >= this.maxCost) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  reset(): void {\n    this.tokenUsage = {};\n    this.totalTokens = 0;\n  }\n}\n\n/**\n * Abstract base class for optimizers that provides common functionality\n * and standardized handling of AxOptimizerArgs\n */\nexport abstract class AxBaseOptimizer<IN = any, OUT extends AxGenOut = any>\n  implements AxOptimizer<IN, OUT>\n{\n  // Common AxOptimizerArgs fields\n  protected readonly studentAI: AxAIService;\n  protected readonly teacherAI?: AxAIService;\n  protected readonly examples: readonly AxExample[];\n  protected readonly validationSet?: readonly AxExample[];\n  protected readonly targetScore?: number;\n  protected readonly minSuccessRate?: number;\n  protected readonly onProgress?: (\n    progress: Readonly<AxOptimizationProgress>\n  ) => void;\n  protected readonly onEarlyStop?: (\n    reason: string,\n    stats: Readonly<AxOptimizationStats>\n  ) => void;\n  protected readonly costTracker?: AxCostTracker;\n  protected readonly seed?: number;\n\n  // Checkpointing fields\n  protected readonly checkpointSave?: AxCheckpointSaveFn;\n  protected readonly checkpointLoad?: AxCheckpointLoadFn;\n  protected readonly checkpointInterval?: number;\n  protected readonly resumeFromCheckpoint?: string;\n\n  // Logging fields\n  protected readonly logger?: AxLoggerFunction;\n  protected readonly verbose?: boolean;\n\n  // Optimizer logging\n  protected readonly debugOptimizer: boolean;\n  protected readonly optimizerLogger?: AxOptimizerLoggerFunction;\n\n  // Checkpoint state\n  private currentRound = 0;\n  private scoreHistory: number[] = [];\n  private configurationHistory: Record<string, unknown>[] = [];\n\n  // Common optimization statistics\n  protected stats: AxOptimizationStats;\n\n  // Metrics instruments\n  protected readonly metricsInstruments?: AxOptimizerMetricsInstruments;\n\n  constructor(args: Readonly<AxOptimizerArgs>) {\n    if (args.examples.length === 0) {\n      throw new Error('No examples found');\n    }\n\n    // Set common fields from AxOptimizerArgs\n    this.studentAI = args.studentAI;\n    this.teacherAI = args.teacherAI;\n    this.examples = args.examples;\n    this.validationSet = args.validationSet;\n    this.targetScore = args.targetScore;\n    this.minSuccessRate = args.minSuccessRate;\n    this.onProgress = args.onProgress;\n    this.onEarlyStop = args.onEarlyStop;\n    this.seed = args.seed;\n\n    // Set up checkpointing\n    this.checkpointSave = args.checkpointSave;\n    this.checkpointLoad = args.checkpointLoad;\n    this.checkpointInterval = args.checkpointInterval ?? 10; // Default: checkpoint every 10 rounds\n    this.resumeFromCheckpoint = args.resumeFromCheckpoint;\n\n    // Set up logging\n    this.logger = args.logger;\n    this.verbose = args.verbose;\n\n    // Set up cost tracker with default if not provided\n    const costTracker = new AxDefaultCostTracker({\n      maxTokens: 1000000,\n    });\n    this.costTracker = args.costTracker ?? costTracker;\n\n    // Initialize metrics instruments\n    this.metricsInstruments = getOrCreateOptimizerMetricsInstruments(\n      axGlobals.meter\n    );\n\n    // Initialize common stats structure\n    this.stats = this.initializeStats();\n\n    // Set up optimizer logging\n    this.debugOptimizer = args.debugOptimizer ?? false;\n    this.optimizerLogger = args.optimizerLogger;\n  }\n\n  /**\n   * Initialize the optimization statistics structure\n   */\n  protected initializeStats(): AxOptimizationStats {\n    return {\n      totalCalls: 0,\n      successfulDemos: 0,\n      estimatedTokenUsage: 0,\n      earlyStopped: false,\n      resourceUsage: {\n        totalTokens: 0,\n        totalTime: 0,\n        avgLatencyPerEval: 0,\n        costByModel: {},\n      },\n      convergenceInfo: {\n        converged: false,\n        finalImprovement: 0,\n        stagnationRounds: 0,\n        convergenceThreshold: 0.01,\n      },\n      bestScore: 0,\n      bestConfiguration: {},\n    };\n  }\n\n  /**\n   * Set up reproducible random seed if provided\n   */\n  protected setupRandomSeed(): void {\n    if (this.seed !== undefined) {\n      // Note: For full reproducibility, we'd need a proper PRNG\n      Math.random = (() => {\n        let seed = this.seed!;\n        return () => {\n          seed = (seed * 9301 + 49297) % 233280;\n          return seed / 233280;\n        };\n      })();\n    }\n  }\n\n  /**\n   * Check if optimization should stop early due to cost limits\n   */\n  protected checkCostLimits(): boolean {\n    return this.costTracker?.isLimitReached() ?? false;\n  }\n\n  /**\n   * Check if target score has been reached\n   */\n  protected checkTargetScore(currentScore: number): boolean {\n    return this.targetScore !== undefined && currentScore >= this.targetScore;\n  }\n\n  /**\n   * Update resource usage statistics\n   */\n  protected updateResourceUsage(startTime: number, tokensUsed = 0): void {\n    this.stats.resourceUsage.totalTime = Date.now() - startTime;\n    this.stats.resourceUsage.totalTokens += tokensUsed;\n\n    if (this.stats.totalCalls > 0) {\n      this.stats.resourceUsage.avgLatencyPerEval =\n        this.stats.resourceUsage.totalTime / this.stats.totalCalls;\n    }\n  }\n\n  /**\n   * Trigger early stopping with appropriate callbacks\n   */\n  protected triggerEarlyStopping(reason: string, bestScoreRound: number): void {\n    this.stats.earlyStopped = true;\n    this.stats.earlyStopping = {\n      bestScoreRound,\n      patienceExhausted: reason.includes('improvement'),\n      reason,\n    };\n\n    // Record early stopping metrics (use a default optimizer type)\n    this.recordEarlyStoppingMetrics(reason, 'unknown');\n\n    if (this.onEarlyStop) {\n      this.onEarlyStop(reason, this.stats);\n    }\n    const optLogger = this.getOptimizerLogger();\n    optLogger?.({\n      name: 'EarlyStopping',\n      value: {\n        reason,\n        finalScore: this.stats.bestScore ?? 0,\n        round: bestScoreRound,\n      },\n    });\n  }\n\n  /**\n   * Get the validation set, with fallback to a split of examples\n   */\n  protected getValidationSet(options?: AxCompileOptions): readonly AxExample[] {\n    return (\n      options?.overrideValidationSet ||\n      this.validationSet ||\n      this.examples.slice(0, Math.floor(this.examples.length * 0.2))\n    );\n  }\n\n  /**\n   * Get the AI service to use for a specific task, preferring teacher when available\n   * @param preferTeacher Whether to prefer teacher AI over student AI\n   * @param options Optional compile options that may override teacher AI\n   * @returns The appropriate AI service to use\n   */\n  protected getAIService(\n    preferTeacher = false,\n    options?: AxCompileOptions\n  ): AxAIService {\n    // Check for override teacher AI first\n    if (preferTeacher && options?.overrideTeacherAI) {\n      return options.overrideTeacherAI;\n    }\n\n    // Then check for configured teacher AI\n    if (preferTeacher && this.teacherAI) {\n      return this.teacherAI;\n    }\n\n    return this.studentAI;\n  }\n\n  /**\n   * Check if teacher AI is available (including overrides)\n   * @param options Optional compile options that may override teacher AI\n   * @returns True if teacher AI is configured or overridden\n   */\n  protected hasTeacherAI(options?: AxCompileOptions): boolean {\n    return (\n      options?.overrideTeacherAI !== undefined || this.teacherAI !== undefined\n    );\n  }\n\n  /**\n   * Get teacher AI if available, otherwise return student AI\n   * @param options Optional compile options that may override teacher AI\n   * @returns Teacher AI if available, otherwise student AI\n   */\n  protected getTeacherOrStudentAI(options?: AxCompileOptions): AxAIService {\n    return options?.overrideTeacherAI || this.teacherAI || this.studentAI;\n  }\n\n  /**\n   * Execute a task with teacher AI if available, otherwise use student AI\n   * @param task Function that takes an AI service and returns a promise\n   * @param preferTeacher Whether to prefer teacher AI (default: true)\n   * @param options Optional compile options that may override teacher AI\n   * @returns Result of the task execution\n   */\n  protected async executeWithTeacher<T>(\n    task: (ai: AxAIService) => Promise<T>,\n    preferTeacher = true,\n    options?: AxCompileOptions\n  ): Promise<T> {\n    const ai = this.getAIService(preferTeacher, options);\n    return await task(ai);\n  }\n\n  /**\n   * Abstract method that must be implemented by concrete optimizers\n   */\n  public abstract compile(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizerResult<OUT>>;\n\n  /**\n   * Optimize a program with real-time streaming updates\n   * @param program The program to optimize\n   * @param metricFn Evaluation metric function\n   * @param options Optional configuration options\n   * @returns Async iterator yielding optimization progress\n   */\n  public async *compileStream(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): AsyncIterableIterator<AxOptimizationProgress> {\n    const startTime = Date.now();\n    const optimizerType = this.constructor.name;\n    const programSignature = program.getSignature().toString();\n\n    this.recordOptimizationStart(optimizerType, programSignature);\n\n    let earlyStopReason: string | undefined;\n\n    const updateProgress = (\n      round: number,\n      score: number,\n      configuration: Record<string, unknown>,\n      optimizerType: string,\n      optimizerConfig: Record<string, unknown>,\n      bestScore: number,\n      bestConfiguration: Record<string, unknown> | undefined,\n      optimizerState: Record<string, unknown> = {},\n      options?: AxCompileOptions\n    ) => {\n      const optLogger = this.getOptimizerLogger(options);\n      optLogger?.({\n        name: 'RoundProgress',\n        value: {\n          round,\n          totalRounds: options?.maxIterations ?? 0,\n          currentScore: score,\n          bestScore,\n          configuration,\n        },\n      });\n      this.updateOptimizationProgress(\n        round,\n        score,\n        configuration,\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        optimizerState,\n        options\n      );\n    };\n\n    const onEarlyStop = (\n      reason: string,\n      _stats: Readonly<AxOptimizationStats>\n    ) => {\n      earlyStopReason = reason;\n      this.triggerEarlyStopping(reason, this.currentRound);\n    };\n\n    const onProgress = (progress: Readonly<AxOptimizationProgress>) => {\n      this.onProgress?.(progress);\n      updateProgress(\n        progress.round,\n        progress.currentScore,\n        progress.currentConfiguration || {},\n        optimizerType,\n        {}, // No optimizerConfig here, it's part of the progress object\n        progress.bestScore,\n        progress.bestConfiguration,\n        progress.convergenceInfo,\n        options\n      );\n    };\n\n    const compileResult = await this.compile(program, metricFn, {\n      ...options,\n      overrideOnProgress: onProgress,\n      overrideOnEarlyStop: onEarlyStop,\n    });\n\n    const duration = Date.now() - startTime;\n    this.recordOptimizationComplete(\n      duration,\n      true,\n      optimizerType,\n      programSignature\n    );\n\n    if (earlyStopReason) {\n      this.getLogger(options)?.({\n        name: 'Notification',\n        id: 'optimization_early_stop',\n        value: `Optimization stopped early due to ${earlyStopReason}`,\n      });\n    }\n\n    return {\n      demos: compileResult.demos,\n      stats: compileResult.stats,\n      bestScore: compileResult.bestScore,\n      finalConfiguration: compileResult.finalConfiguration,\n      scoreHistory: compileResult.scoreHistory,\n      configurationHistory: compileResult.configurationHistory,\n    };\n  }\n\n  /**\n   * Multi-objective optimization using Pareto frontier\n   * Default implementation that leverages the single-objective compile method\n   * @param program The program to optimize\n   * @param metricFn Multi-objective metric function that returns multiple scores\n   * @param options Optional configuration options\n   * @returns Pareto optimization result with frontier of non-dominated solutions\n   */\n  public async compilePareto(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxParetoResult<OUT>> {\n    const _optimizerType = this.constructor.name;\n    const startTime = Date.now();\n\n    // Strategy 1: Generate different weighted combinations of objectives\n    const solutions = await this.generateWeightedSolutions(\n      program,\n      metricFn,\n      options\n    );\n\n    // Strategy 2: Generate constraint-based solutions (optimize one objective while constraining others)\n    const constraintSolutions = await this.generateConstraintSolutions(\n      program,\n      metricFn,\n      options\n    );\n\n    // Combine all solutions\n    const allSolutions = [...solutions, ...constraintSolutions];\n\n    // if (options?.verbose) {\n    //   this.getLogger(options)?.(\n    //     `Generated ${allSolutions.length} candidate solutions`,\n    //     { tags: ['discovery'] }\n    //   );\n    // }\n\n    // Find Pareto frontier\n    const paretoFront = this.findParetoFrontier(allSolutions);\n\n    // Calculate hypervolume if possible\n    const hypervolume = this.calculateHypervolume(paretoFront);\n\n    // if (options?.verbose) {\n    //   this.getLogger(options)?.(\n    //     `Found ${paretoFront.length} non-dominated solutions`,\n    //     { tags: ['discovery'] }\n    //   );\n    //   this.getLogger(options)?.(\n    //     `Hypervolume: ${hypervolume?.toFixed(4) || 'N/A'}`,\n    //     { tags: ['discovery'] }\n    //   );\n    // }\n\n    // Update stats\n    this.updateResourceUsage(startTime);\n    this.stats.convergenceInfo.converged = true;\n\n    // Record Pareto optimization metrics\n    this.recordParetoMetrics(\n      paretoFront.length,\n      allSolutions.length,\n      'base_optimizer',\n      hypervolume\n    );\n\n    // Calculate best score as the maximum across all objectives and solutions\n    const bestScore =\n      paretoFront.length > 0\n        ? Math.max(\n            ...paretoFront.map((sol) => Math.max(...Object.values(sol.scores)))\n          )\n        : 0;\n\n    return {\n      demos: paretoFront.length > 0 ? [...paretoFront[0]!.demos] : undefined,\n      stats: this.stats,\n      bestScore,\n      paretoFront,\n      hypervolume,\n      paretoFrontSize: paretoFront.length,\n      finalConfiguration: {\n        paretoFrontSize: paretoFront.length,\n        hypervolume,\n        strategy: 'weighted_combinations_and_constraints',\n        numSolutions: allSolutions.length,\n      },\n    };\n  }\n\n  /**\n   * Generate solutions using different weighted combinations of objectives\n   */\n  private async generateWeightedSolutions(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<\n    Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  > {\n    const solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }> = [];\n\n    // First, determine the objectives by running the metric on a sample\n    const sampleExample = this.examples[0]!;\n    const samplePrediction = await program.forward(\n      this.getAIService(false, options),\n      sampleExample as IN\n    );\n    const sampleScores = await metricFn({\n      prediction: samplePrediction,\n      example: sampleExample,\n    });\n    const objectives = Object.keys(sampleScores);\n\n    // if (options?.verbose) {\n    //   this.getLogger(options)?.(\n    //     `Detected objectives: ${objectives.join(', ')}`,\n    //     { tags: ['discovery'] }\n    //   );\n    // }\n\n    // Generate different weight combinations\n    const weightCombinations = this.generateWeightCombinations(objectives);\n\n    for (let i = 0; i < weightCombinations.length; i++) {\n      const weights = weightCombinations[i]!;\n\n      // if (options?.verbose) {\n      //   this.getLogger(options)?.(\n      //     `Optimizing with weights: ${JSON.stringify(weights)}`,\n      //     { tags: ['discovery'] }\n      //   );\n      // }\n\n      // Create a weighted single-objective metric\n      const weightedMetric: AxMetricFn = async ({ prediction, example }) => {\n        const scores = await metricFn({ prediction, example });\n        let weightedScore = 0;\n        for (const [objective, score] of Object.entries(scores)) {\n          weightedScore += score * (weights[objective] || 0);\n        }\n        return weightedScore;\n      };\n\n      try {\n        // Use the concrete optimizer's compile method\n        const result = await this.compile(program, weightedMetric, {\n          ...options,\n          verbose: false, // Suppress inner optimization logs\n        });\n\n        // Evaluate the result with the multi-objective metric\n        const scores = await this.evaluateWithMultiObjective(\n          program,\n          result,\n          metricFn\n        );\n\n        solutions.push({\n          scores,\n          demos: result.demos,\n          configuration: {\n            ...result.finalConfiguration,\n            weights,\n            strategy: 'weighted_combination',\n          },\n        });\n      } catch (_error) {\n        // if (options?.verbose) {\n        //   this.getLogger(options)?.(\n        //     `Failed optimization with weights ${JSON.stringify(weights)}: ${error}`,\n        //     { tags: ['warning'] }\n        //   );\n        // }\n      }\n    }\n\n    return solutions;\n  }\n\n  /**\n   * Generate solutions using constraint-based optimization\n   */\n  private async generateConstraintSolutions(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMultiMetricFn,\n    options?: AxCompileOptions\n  ): Promise<\n    Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  > {\n    const solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }> = [];\n\n    // Get objectives from a sample evaluation\n    const sampleExample = this.examples[0]!;\n    const samplePrediction = await program.forward(\n      this.getAIService(false, options),\n      sampleExample as IN\n    );\n    const sampleScores = await metricFn({\n      prediction: samplePrediction,\n      example: sampleExample,\n    });\n    const objectives = Object.keys(sampleScores);\n\n    // For each objective, optimize it while constraining others\n    for (const primaryObjective of objectives) {\n      // if (options?.verbose) {\n      //   this.getLogger(options)?.(\n      //     `Optimizing ${primaryObjective} with constraints on other objectives`,\n      //     { tags: ['discovery'] }\n      //   );\n      // }\n\n      // Create a constraint-based metric\n      const constraintMetric: AxMetricFn = async ({ prediction, example }) => {\n        const scores = await metricFn({ prediction, example });\n\n        // Primary objective score\n        const primaryScore = scores[primaryObjective] || 0;\n\n        // Penalty for violating constraints on other objectives\n        let penalty = 0;\n        for (const [objective, score] of Object.entries(scores)) {\n          if (objective !== primaryObjective) {\n            // Simple constraint: other objectives should be at least 0.3\n            // This is a heuristic - in practice you'd set domain-specific thresholds\n            if (score < 0.3) {\n              penalty += (0.3 - score) * 2; // Penalty factor\n            }\n          }\n        }\n\n        return primaryScore - penalty;\n      };\n\n      try {\n        const result = await this.compile(program, constraintMetric, {\n          ...options,\n          verbose: false,\n        });\n\n        const scores = await this.evaluateWithMultiObjective(\n          program,\n          result,\n          metricFn\n        );\n\n        solutions.push({\n          scores,\n          demos: result.demos,\n          configuration: {\n            ...result.finalConfiguration,\n            primaryObjective,\n            strategy: 'constraint_based',\n          },\n        });\n      } catch (_error) {\n        // if (options?.verbose) {\n        //   this.getLogger(options)?.(\n        //     `Failed constraint optimization for ${primaryObjective}: ${error}`,\n        //     { tags: ['warning'] }\n        //   );\n        // }\n      }\n    }\n\n    return solutions;\n  }\n\n  /**\n   * Generate different weight combinations for objectives\n   */\n  private generateWeightCombinations(\n    objectives: string[]\n  ): Record<string, number>[] {\n    const combinations: Record<string, number>[] = [];\n\n    // Single-objective focus (one objective gets weight 1, others get 0)\n    for (const objective of objectives) {\n      const weights: Record<string, number> = {};\n      for (const obj of objectives) {\n        weights[obj] = obj === objective ? 1 : 0;\n      }\n      combinations.push(weights);\n    }\n\n    // Equal weights\n    const equalWeights: Record<string, number> = {};\n    for (const objective of objectives) {\n      equalWeights[objective] = 1 / objectives.length;\n    }\n    combinations.push(equalWeights);\n\n    // If we have 2 objectives, generate more granular combinations\n    if (objectives.length === 2) {\n      const [obj1, obj2] = objectives;\n      for (let w1 = 0.1; w1 <= 0.9; w1 += 0.2) {\n        const w2 = 1 - w1;\n        combinations.push({ [obj1!]: w1, [obj2!]: w2 });\n      }\n    }\n\n    // If we have 3 objectives, generate some key combinations\n    if (objectives.length === 3) {\n      const [obj1, obj2, obj3] = objectives;\n      combinations.push(\n        { [obj1!]: 0.5, [obj2!]: 0.3, [obj3!]: 0.2 },\n        { [obj1!]: 0.3, [obj2!]: 0.5, [obj3!]: 0.2 },\n        { [obj1!]: 0.2, [obj2!]: 0.3, [obj3!]: 0.5 }\n      );\n    }\n\n    return combinations;\n  }\n\n  /**\n   * Evaluate a single-objective result with multi-objective metrics\n   */\n  private async evaluateWithMultiObjective(\n    program: Readonly<AxGen<IN, OUT>>,\n    result: Readonly<AxOptimizerResult<OUT>>,\n    metricFn: AxMultiMetricFn\n  ): Promise<Record<string, number>> {\n    const testProgram = new AxGen(program.getSignature());\n    if (result.demos) {\n      testProgram.setDemos(result.demos);\n    }\n\n    const predictions = [];\n    for (const ex of this.examples) {\n      const prediction = await testProgram.forward(this.studentAI, ex as IN);\n      predictions.push({ prediction, example: ex });\n    }\n\n    const valSet = this.getValidationSet();\n    const allScores: Record<string, number[]> = {};\n\n    // Evaluate on validation set\n    const evalSet = valSet.slice(0, Math.min(5, valSet.length));\n\n    for (const example of evalSet) {\n      try {\n        const prediction = await testProgram.forward(\n          this.studentAI,\n          example as IN\n        );\n        const scores = await metricFn({ prediction, example });\n\n        // Collect scores for each objective\n        for (const [objective, score] of Object.entries(scores)) {\n          if (!allScores[objective]) {\n            allScores[objective] = [];\n          }\n          allScores[objective]!.push(score);\n        }\n      } catch {}\n    }\n\n    // Calculate average scores for each objective\n    const avgScores: Record<string, number> = {};\n    for (const [objective, scores] of Object.entries(allScores)) {\n      avgScores[objective] =\n        scores.length > 0\n          ? scores.reduce((sum, score) => sum + score, 0) / scores.length\n          : 0;\n    }\n\n    return avgScores;\n  }\n\n  /**\n   * Find the Pareto frontier from a set of solutions\n   */\n  private findParetoFrontier(\n    solutions: Array<{\n      scores: Record<string, number>;\n      demos?: AxProgramDemos<any, OUT>[];\n      configuration: Record<string, unknown>;\n    }>\n  ): Array<{\n    demos: readonly AxProgramDemos<any, OUT>[];\n    scores: Readonly<Record<string, number>>;\n    configuration: Readonly<Record<string, unknown>>;\n    dominatedSolutions: number;\n  }> {\n    const paretoFront: Array<{\n      demos: readonly AxProgramDemos<any, OUT>[];\n      scores: Readonly<Record<string, number>>;\n      configuration: Readonly<Record<string, unknown>>;\n      dominatedSolutions: number;\n    }> = [];\n\n    // For each solution, check if it's dominated by any other solution\n    for (let i = 0; i < solutions.length; i++) {\n      const solutionA = solutions[i]!;\n      let isDominated = false;\n      let dominatedCount = 0;\n\n      for (let j = 0; j < solutions.length; j++) {\n        if (i === j) continue;\n\n        const solutionB = solutions[j]!;\n\n        // Check if B dominates A\n        if (this.dominates(solutionB.scores, solutionA.scores)) {\n          isDominated = true;\n          break;\n        }\n\n        // Count how many solutions A dominates\n        if (this.dominates(solutionA.scores, solutionB.scores)) {\n          dominatedCount++;\n        }\n      }\n\n      // If A is not dominated by any solution, it's on the Pareto frontier\n      if (!isDominated) {\n        paretoFront.push({\n          demos: solutionA.demos || [],\n          scores: solutionA.scores,\n          configuration: solutionA.configuration,\n          dominatedSolutions: dominatedCount,\n        });\n      }\n    }\n\n    return paretoFront;\n  }\n\n  /**\n   * Check if solution A dominates solution B\n   * A dominates B if A is better or equal in all objectives and strictly better in at least one\n   */\n  private dominates(\n    scoresA: Record<string, number>,\n    scoresB: Record<string, number>\n  ): boolean {\n    const objectives = Object.keys(scoresA);\n\n    // Check if A is at least as good as B in all objectives\n    let atLeastAsGood = true;\n    let strictlyBetter = false;\n\n    for (const objective of objectives) {\n      const scoreA = scoresA[objective] || 0;\n      const scoreB = scoresB[objective] || 0;\n\n      if (scoreA < scoreB) {\n        atLeastAsGood = false;\n        break;\n      }\n\n      if (scoreA > scoreB) {\n        strictlyBetter = true;\n      }\n    }\n\n    return atLeastAsGood && strictlyBetter;\n  }\n\n  /**\n   * Calculate hypervolume of the Pareto frontier\n   * Simplified implementation using reference point at origin\n   */\n  private calculateHypervolume(\n    paretoFront: Array<{\n      scores: Readonly<Record<string, number>>;\n    }>\n  ): number | undefined {\n    if (paretoFront.length === 0) return undefined;\n\n    // For simplicity, calculate 2D hypervolume if we have exactly 2 objectives\n    const firstSolution = paretoFront[0]!;\n    const objectives = Object.keys(firstSolution.scores);\n\n    if (objectives.length === 2) {\n      const [obj1, obj2] = objectives;\n      let hypervolume = 0;\n\n      // Sort solutions by first objective (descending)\n      const sortedSolutions = [...paretoFront].sort(\n        (a, b) => (b.scores[obj1!] || 0) - (a.scores[obj1!] || 0)\n      );\n\n      let prevScore2 = 0;\n      for (const solution of sortedSolutions) {\n        const score1 = solution.scores[obj1!] || 0;\n        const score2 = solution.scores[obj2!] || 0;\n\n        // Calculate area contribution\n        hypervolume += score1 * (score2 - prevScore2);\n        prevScore2 = Math.max(prevScore2, score2);\n      }\n\n      return hypervolume;\n    }\n\n    // For higher dimensions, return undefined (would need more complex algorithm)\n    return undefined;\n  }\n\n  /**\n   * Save current optimization state to checkpoint\n   */\n  protected async saveCheckpoint(\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<string | undefined> {\n    const saveFn = options?.overrideCheckpointSave || this.checkpointSave;\n    if (!saveFn) return undefined;\n\n    const startTime = Date.now();\n    let success = false;\n    let checkpointId: string | undefined;\n\n    try {\n      const checkpoint: AxOptimizationCheckpoint = {\n        version: '1.0.0',\n        timestamp: Date.now(),\n        optimizerType,\n        optimizerConfig,\n        currentRound: this.currentRound,\n        totalRounds:\n          this.stats.resourceUsage.totalTime > 0 ? this.currentRound : 0,\n        bestScore,\n        bestConfiguration,\n        scoreHistory: [...this.scoreHistory],\n        configurationHistory: [...this.configurationHistory],\n        stats: { ...this.stats },\n        optimizerState,\n        examples: this.examples,\n        validationSet: this.validationSet,\n      };\n\n      checkpointId = await saveFn(checkpoint);\n      success = true;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const latency = Date.now() - startTime;\n      this.recordCheckpointMetrics('save', latency, success, optimizerType);\n    }\n\n    return checkpointId;\n  }\n\n  /**\n   * Load optimization state from checkpoint\n   */\n  protected async loadCheckpoint(\n    checkpointId: string,\n    options?: AxCompileOptions\n  ): Promise<AxOptimizationCheckpoint | null> {\n    const loadFn = options?.overrideCheckpointLoad || this.checkpointLoad;\n    if (!loadFn) return null;\n\n    const startTime = Date.now();\n    let success = false;\n    let checkpoint: AxOptimizationCheckpoint | null = null;\n\n    try {\n      checkpoint = await loadFn(checkpointId);\n      success = checkpoint !== null;\n    } catch (error) {\n      success = false;\n      throw error;\n    } finally {\n      const latency = Date.now() - startTime;\n      // Use a default optimizer type since we don't know it at load time\n      this.recordCheckpointMetrics('load', latency, success, 'unknown');\n    }\n\n    return checkpoint;\n  }\n\n  /**\n   * Restore optimizer state from checkpoint\n   */\n  protected restoreFromCheckpoint(\n    checkpoint: Readonly<AxOptimizationCheckpoint>\n  ): void {\n    this.currentRound = checkpoint.currentRound;\n    this.scoreHistory = [...checkpoint.scoreHistory];\n    this.configurationHistory = [...checkpoint.configurationHistory];\n    this.stats = { ...checkpoint.stats };\n  }\n\n  /**\n   * Check if checkpoint should be saved\n   */\n  protected shouldSaveCheckpoint(\n    round: number,\n    options?: AxCompileOptions\n  ): boolean {\n    const interval =\n      options?.overrideCheckpointInterval || this.checkpointInterval;\n    return interval !== undefined && round % interval === 0;\n  }\n\n  /**\n   * Update optimization progress and handle checkpointing\n   */\n  protected async updateOptimizationProgress(\n    round: number,\n    score: number,\n    configuration: Record<string, unknown>,\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<void> {\n    this.currentRound = round;\n    this.scoreHistory.push(score);\n    this.configurationHistory.push(configuration);\n\n    // Save checkpoint if needed\n    if (this.shouldSaveCheckpoint(round, options)) {\n      await this.saveCheckpoint(\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        optimizerState,\n        options\n      );\n    }\n    const optLogger = this.getOptimizerLogger(options);\n    optLogger?.({\n      name: 'RoundProgress',\n      value: {\n        round,\n        totalRounds: options?.maxIterations ?? 0,\n        currentScore: score,\n        bestScore,\n        configuration,\n      },\n    });\n  }\n\n  /**\n   * Save final checkpoint on completion\n   */\n  protected async saveFinalCheckpoint(\n    optimizerType: string,\n    optimizerConfig: Record<string, unknown>,\n    bestScore: number,\n    bestConfiguration?: Record<string, unknown>,\n    optimizerState: Record<string, unknown> = {},\n    options?: AxCompileOptions\n  ): Promise<void> {\n    if (options?.saveCheckpointOnComplete !== false) {\n      await this.saveCheckpoint(\n        optimizerType,\n        optimizerConfig,\n        bestScore,\n        bestConfiguration,\n        { ...optimizerState, final: true },\n        options\n      );\n    }\n  }\n\n  /**\n   * Get the logger function with fallback hierarchy:\n   * 1. Explicit logger passed to optimizer\n   * 2. Logger from student AI service\n   * 3. undefined if verbose is false\n   */\n  protected getLogger(\n    options?: AxCompileOptions\n  ): AxLoggerFunction | undefined {\n    // Check if logging should be disabled\n    const isVerbose = this.isLoggingEnabled(options);\n    if (!isVerbose) {\n      return undefined;\n    }\n\n    // Use explicit logger if provided\n    if (this.logger) {\n      return this.logger;\n    }\n\n    // Fall back to student AI logger\n    return this.studentAI.getLogger();\n  }\n\n  /**\n   * Check if logging is enabled based on verbose settings\n   */\n  protected isLoggingEnabled(options?: AxCompileOptions): boolean {\n    // Explicit verbose setting in options takes precedence\n    if (options?.verbose !== undefined) {\n      return options.verbose;\n    }\n\n    // Use optimizer's verbose setting\n    return this.verbose ?? true; // Default to true if not specified\n  }\n\n  /**\n   * Record optimization start metrics\n   */\n  protected recordOptimizationStart(\n    optimizerType: string,\n    programSignature?: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    // Record program complexity metrics\n    if (programSignature) {\n      // Extract field counts from signature (simplified)\n      const inputFields = (programSignature.match(/input:/g) || []).length;\n      const outputFields = (programSignature.match(/output:/g) || []).length;\n\n      recordProgramComplexityMetric(\n        this.metricsInstruments,\n        inputFields,\n        outputFields,\n        this.examples.length,\n        this.getValidationSet().length,\n        optimizerType\n      );\n    }\n\n    // Record configuration metrics\n    recordOptimizerConfigurationMetric(\n      this.metricsInstruments,\n      optimizerType,\n      this.targetScore,\n      undefined // maxRounds would be set by concrete optimizers\n    );\n  }\n\n  /**\n   * Record optimization completion metrics\n   */\n  protected recordOptimizationComplete(\n    duration: number,\n    success: boolean,\n    optimizerType: string,\n    programSignature?: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordOptimizationMetric(\n      this.metricsInstruments,\n      duration,\n      success,\n      optimizerType,\n      programSignature\n    );\n\n    recordOptimizationDurationMetric(\n      this.metricsInstruments,\n      duration,\n      optimizerType\n    );\n\n    // Record resource usage\n    const currentCost = this.costTracker?.getCurrentCost() ?? 0;\n    const totalTokens = this.costTracker?.getTotalTokens() ?? 0;\n    recordResourceUsageMetric(\n      this.metricsInstruments,\n      totalTokens,\n      currentCost,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record convergence metrics\n   */\n  protected recordConvergenceMetrics(\n    rounds: number,\n    currentScore: number,\n    improvement: number,\n    stagnationRounds: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordConvergenceMetric(\n      this.metricsInstruments,\n      rounds,\n      currentScore,\n      improvement,\n      stagnationRounds,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record early stopping metrics\n   */\n  protected recordEarlyStoppingMetrics(\n    reason: string,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordEarlyStoppingMetric(this.metricsInstruments, reason, optimizerType);\n  }\n\n  /**\n   * Record teacher-student interaction metrics\n   */\n  protected recordTeacherStudentMetrics(\n    latency: number,\n    scoreImprovement: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordTeacherStudentMetric(\n      this.metricsInstruments,\n      latency,\n      scoreImprovement,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record checkpoint metrics\n   */\n  protected recordCheckpointMetrics(\n    operation: 'save' | 'load',\n    latency: number,\n    success: boolean,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordCheckpointMetric(\n      this.metricsInstruments,\n      operation,\n      latency,\n      success,\n      optimizerType\n    );\n  }\n\n  /**\n   * Record Pareto optimization metrics\n   */\n  protected recordParetoMetrics(\n    frontSize: number,\n    solutionsGenerated: number,\n    optimizerType: string,\n    hypervolume?: number\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordParetoMetric(\n      this.metricsInstruments,\n      frontSize,\n      solutionsGenerated,\n      optimizerType,\n      hypervolume\n    );\n  }\n\n  /**\n   * Record performance metrics\n   */\n  protected recordPerformanceMetrics(\n    metricType: 'evaluation' | 'demo_generation' | 'metric_computation',\n    duration: number,\n    optimizerType: string\n  ): void {\n    if (!this.metricsInstruments) return;\n\n    recordOptimizerPerformanceMetric(\n      this.metricsInstruments,\n      metricType,\n      duration,\n      optimizerType\n    );\n  }\n\n  // Optimizer logging methods\n  protected isOptimizerLoggingEnabled(options?: AxCompileOptions): boolean {\n    return this.debugOptimizer || (options?.verbose ?? this.verbose ?? false);\n  }\n\n  protected getOptimizerLogger(\n    options?: AxCompileOptions\n  ): AxOptimizerLoggerFunction | undefined {\n    if (!this.isOptimizerLoggingEnabled(options)) return undefined;\n    return (\n      this.optimizerLogger ??\n      axGlobals.optimizerLogger ??\n      axDefaultOptimizerLogger\n    );\n  }\n\n  public getStats(): AxOptimizationStats {\n    return { ...this.stats };\n  }\n\n  public reset(): void {\n    this.stats = this.initializeStats();\n    this.costTracker?.reset();\n    this.currentRound = 0;\n    this.scoreHistory = [];\n    this.configurationHistory = [];\n  }\n}\n", "import type { AxGen } from '../generate.js';\nimport {\n  AxBaseOptimizer,\n  type AxBootstrapCompileOptions,\n  type AxBootstrapOptimizerOptions,\n  type AxMetricFn,\n  type AxOptimizerArgs,\n  type AxOptimizerResult,\n} from '../optimizer.js';\nimport type {\n  AxFieldValue,\n  AxGenOut,\n  AxProgramDemos,\n  AxProgramTrace,\n} from '../types.js';\n\n// Define model config interface\ninterface ModelConfig {\n  temperature: number;\n  max_tokens?: number;\n  [key: string]: number | string | boolean | undefined;\n}\n\nexport class AxBootstrapFewShot<\n  IN = any,\n  OUT extends AxGenOut = any,\n> extends AxBaseOptimizer<IN, OUT> {\n  private maxRounds: number;\n  private maxDemos: number;\n  private maxExamples: number;\n  private batchSize: number;\n  private earlyStoppingPatience: number;\n  private costMonitoring: boolean;\n  private maxTokensPerGeneration: number;\n  private verboseMode: boolean;\n  private debugMode: boolean;\n  private traces: AxProgramTrace<IN, OUT>[] = [];\n\n  constructor(\n    args: Readonly<AxOptimizerArgs & { options?: AxBootstrapOptimizerOptions }>\n  ) {\n    // Call parent constructor\n    super(args);\n\n    const options = args.options || {};\n\n    this.maxRounds = options.maxRounds ?? 3;\n    this.maxDemos = options.maxDemos ?? 4;\n    this.maxExamples = options.maxExamples ?? 16;\n    this.batchSize = options.batchSize ?? 1;\n    this.earlyStoppingPatience = options.earlyStoppingPatience ?? 0;\n    this.costMonitoring = options.costMonitoring ?? false;\n    this.maxTokensPerGeneration = options.maxTokensPerGeneration ?? 0;\n    this.verboseMode = options.verboseMode ?? true;\n    this.debugMode = options.debugMode ?? false;\n\n    // Note: teacherAI from options can be used via compile options overrideTeacherAI\n    // The base class provides methods to access teacher AI with fallbacks\n  }\n\n  private async compileRound(\n    program: Readonly<AxGen<IN, OUT>>,\n    roundIndex: number,\n    metricFn: AxMetricFn,\n    options?: { maxRounds?: number; maxDemos?: number } | undefined\n  ) {\n    const _st = Date.now();\n    const maxDemos = options?.maxDemos ?? this.maxDemos;\n    const aiOpt = {\n      modelConfig: {\n        temperature: 0.7,\n      } as ModelConfig,\n    };\n\n    // Apply token limit if specified\n    if (this.maxTokensPerGeneration > 0) {\n      aiOpt.modelConfig.max_tokens = this.maxTokensPerGeneration;\n    }\n\n    const examples = randomSample(this.examples, this.maxExamples);\n    const previousSuccessCount = this.traces.length;\n\n    // Process examples in batches if batch size > 1\n    for (let i = 0; i < examples.length; i += this.batchSize) {\n      if (i > 0) {\n        aiOpt.modelConfig.temperature = 0.7 + 0.001 * i;\n      }\n\n      const batch = examples.slice(i, i + this.batchSize);\n\n      // Process batch sequentially for now (could be parallelized if AI service supports it)\n      for (const ex of batch) {\n        if (!ex) {\n          continue;\n        }\n\n        // Use remaining examples as demonstration examples (excluding current one)\n        const exList = examples.filter((e) => e !== ex);\n        (program as AxGen<IN, OUT>).setExamples(\n          exList as unknown as readonly (OUT & IN)[]\n        );\n\n        // Use teacher AI if provided, otherwise use student AI\n        const aiService = this.getTeacherOrStudentAI();\n\n        this.stats.totalCalls++;\n        let res: OUT;\n\n        try {\n          // Add maxRetries to forward options\n          const forwardOptions = {\n            ...aiOpt,\n            maxRetries: 1,\n          };\n\n          res = await program.forward(aiService, ex as IN, forwardOptions);\n\n          // Estimate token usage if cost monitoring is enabled\n          if (this.costMonitoring) {\n            // Very rough estimate - replace with actual token counting from your AI service\n            this.stats.estimatedTokenUsage +=\n              JSON.stringify(ex).length / 4 + JSON.stringify(res).length / 4;\n          }\n\n          const score = await metricFn({ prediction: res, example: ex });\n          const success = score >= 0.5; // Assuming a threshold of 0.5 for success\n          if (success) {\n            this.traces = [...this.traces, ...program.getTraces()];\n            this.stats.successfulDemos++;\n          }\n        } catch (error) {\n          // Log the error but continue bootstrap - student model failures are expected during bootstrapping\n          if (this.verboseMode || this.debugMode) {\n            console.warn(\n              `Student model failed during bootstrap: ${error instanceof Error ? error.message : 'Unknown error'}`\n            );\n          }\n          res = {} as OUT;\n        }\n\n        // Remove progress bars - now handled by the optimizer logging system\n\n        if (this.traces.length >= maxDemos) {\n          return;\n        }\n      }\n    }\n\n    // Check if we should early stop based on no improvement\n    if (this.earlyStoppingPatience > 0) {\n      const newSuccessCount = this.traces.length;\n      const improvement = newSuccessCount - previousSuccessCount;\n\n      if (!this.stats.earlyStopping) {\n        this.stats.earlyStopping = {\n          bestScoreRound: improvement > 0 ? roundIndex : 0,\n          patienceExhausted: false,\n          reason: 'No improvement detected',\n        };\n      } else if (improvement > 0) {\n        this.stats.earlyStopping.bestScoreRound = roundIndex;\n      } else if (\n        roundIndex - this.stats.earlyStopping.bestScoreRound >=\n        this.earlyStoppingPatience\n      ) {\n        this.stats.earlyStopping.patienceExhausted = true;\n        this.stats.earlyStopped = true;\n        this.stats.earlyStopping.reason = `No improvement for ${this.earlyStoppingPatience} rounds`;\n\n        return;\n      }\n    }\n  }\n\n  public async compile(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxBootstrapCompileOptions\n  ): Promise<AxOptimizerResult<OUT>> {\n    const maxRounds = options?.maxIterations ?? this.maxRounds;\n    this.traces = [];\n\n    // Reset stats using parent method\n    this.reset();\n\n    for (let i = 0; i < maxRounds; i++) {\n      await this.compileRound(program, i, metricFn, options);\n\n      // Break early if early stopping was triggered\n      if (this.stats.earlyStopped) {\n        break;\n      }\n    }\n\n    if (this.traces.length === 0) {\n      throw new Error(\n        'No demonstrations found. Either provide more examples or improve the existing ones.'\n      );\n    }\n\n    const demos: AxProgramDemos<IN, OUT>[] = groupTracesByKeys(this.traces);\n\n    // Calculate best score from traces\n    let bestScore = 0;\n    if (this.traces.length > 0) {\n      // Simple approximation - in a real implementation you'd track scores properly\n      bestScore =\n        this.stats.successfulDemos / Math.max(1, this.stats.totalCalls);\n    }\n\n    // if (this.verboseMode || this.debugMode) {\n    //   this.getLogger()?.(\n    //     `Bootstrap complete. Generated ${demos.length} demos with ${bestScore.toFixed(3)} success rate`,\n    //     { tags: ['optimizer', 'complete'] }\n    //   );\n    // }\n\n    return {\n      demos,\n      stats: this.stats,\n      bestScore,\n      finalConfiguration: {\n        maxRounds: this.maxRounds,\n        maxDemos: this.maxDemos,\n        batchSize: this.batchSize,\n        successRate: bestScore,\n      },\n    };\n  }\n}\n\nfunction groupTracesByKeys<IN, OUT>(\n  programTraces: readonly AxProgramTrace<IN, OUT>[]\n): AxProgramDemos<IN, OUT>[] {\n  const groupedTraces = new Map<string, Record<string, AxFieldValue>[]>();\n\n  // Group all traces by their keys\n  for (const programTrace of programTraces) {\n    if (groupedTraces.has(programTrace.programId)) {\n      const traces = groupedTraces.get(programTrace.programId);\n      if (traces) {\n        traces.push(programTrace.trace as any);\n      }\n    } else {\n      groupedTraces.set(programTrace.programId, [programTrace.trace as any]);\n    }\n  }\n\n  // Convert the Map into an array of ProgramDemos\n  const programDemosArray: AxProgramDemos<IN, OUT>[] = [];\n  groupedTraces.forEach((traces, programId) => {\n    programDemosArray.push({\n      traces: traces as unknown as (OUT & IN)[],\n      programId,\n    });\n  });\n\n  return programDemosArray;\n}\n\nconst randomSample = <T>(array: readonly T[], n: number): T[] => {\n  // Clone the array to avoid modifying the original array\n  const clonedArray = [...array];\n  // Shuffle the cloned array\n  for (let i = clonedArray.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const caI = clonedArray[i];\n    const caJ = clonedArray[j];\n\n    if (!caI || !caJ) {\n      throw new Error('Invalid array elements');\n    }\n\n    [clonedArray[i], clonedArray[j]] = [caJ, caI];\n  }\n  // Return the first `n` items of the shuffled array\n  return clonedArray.slice(0, n);\n};\n", "import type { AxLoggerFunction } from '../../ai/types.js';\n\n// Python optimizer service API types\nexport interface PythonOptimizationParameter {\n  name: string;\n  type: 'float' | 'int' | 'categorical';\n  low?: number;\n  high?: number;\n  choices?: (string | number | boolean)[];\n  step?: number;\n  log?: boolean;\n}\n\nexport interface PythonOptimizationRequest {\n  study_name?: string;\n  parameters: PythonOptimizationParameter[];\n  objective: {\n    name: string;\n    direction: 'minimize' | 'maximize';\n  };\n  n_trials: number;\n  timeout?: number;\n  sampler?: string;\n  pruner?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface PythonOptimizationJob {\n  job_id: string;\n  study_name: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';\n  created_at: string;\n}\n\nexport interface PythonJobStatus {\n  job_id: string;\n  study_name: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';\n  created_at: string;\n  started_at?: string;\n  completed_at?: string;\n  error?: string;\n  result?: PythonOptimizationResult;\n}\n\nexport interface PythonTrial {\n  number: number;\n  value?: number;\n  params: Record<string, string | number | boolean>;\n  state: string;\n  datetime_start?: string;\n  datetime_complete?: string;\n  duration?: number;\n}\n\nexport interface PythonOptimizationResult {\n  study_name: string;\n  best_trial?: PythonTrial;\n  best_value?: number;\n  best_params?: Record<string, string | number | boolean>;\n  trials: PythonTrial[];\n  n_trials: number;\n  direction: 'minimize' | 'maximize';\n}\n\nexport interface PythonParameterSuggestion {\n  trial_number: number;\n  params: Record<string, string | number | boolean>;\n}\n\nexport interface PythonEvaluationRequest {\n  study_name: string;\n  trial_number: number;\n  value: number;\n  intermediate_values?: Record<number, number>;\n}\n\nexport interface PythonOptimizerClientOptions {\n  endpoint: string;\n  timeout?: number;\n  retryAttempts?: number;\n  retryDelay?: number;\n  logger?: AxLoggerFunction;\n}\n\n/**\n * HTTP client for the Python optimizer service\n */\nexport class PythonOptimizerClient {\n  private endpoint: string;\n  private timeout: number;\n  private retryAttempts: number;\n  private retryDelay: number;\n  private logger?: AxLoggerFunction;\n\n  constructor(options: PythonOptimizerClientOptions) {\n    this.endpoint = options.endpoint.replace(/\\/$/, ''); // Remove trailing slash\n    this.timeout = options.timeout ?? 30000; // 30 seconds default\n    this.retryAttempts = options.retryAttempts ?? 3;\n    this.retryDelay = options.retryDelay ?? 1000; // 1 second\n    this.logger = options.logger;\n  }\n\n  /**\n   * Check if the optimizer service is healthy\n   */\n  async healthCheck(): Promise<boolean> {\n    try {\n      const response = await this.fetchWithRetry('/health', {\n        method: 'GET',\n      });\n      return response.ok;\n    } catch (error) {\n      this.logger?.({\n        name: 'Notification',\n        id: 'health_check_failed',\n        value: `Health check failed: ${error}`,\n      });\n      return false;\n    }\n  }\n\n  /**\n   * Create a new optimization job\n   */\n  async createOptimizationJob(\n    request: PythonOptimizationRequest\n  ): Promise<PythonOptimizationJob> {\n    const response = await this.fetchWithRetry('/optimize', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(request),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to create optimization job: ${error}`);\n    }\n\n    return response.json() as Promise<PythonOptimizationJob>;\n  }\n\n  /**\n   * Get job status and results\n   */\n  async getJobStatus(jobId: string): Promise<PythonJobStatus> {\n    const response = await this.fetchWithRetry(`/jobs/${jobId}`, {\n      method: 'GET',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to get job status: ${error}`);\n    }\n\n    return response.json() as Promise<PythonJobStatus>;\n  }\n\n  /**\n   * Cancel a job\n   */\n  async cancelJob(jobId: string): Promise<void> {\n    const response = await this.fetchWithRetry(`/jobs/${jobId}`, {\n      method: 'DELETE',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to cancel job: ${error}`);\n    }\n  }\n\n  /**\n   * Get parameter suggestions for the next trial\n   */\n  async suggestParameters(\n    studyName: string\n  ): Promise<PythonParameterSuggestion> {\n    const response = await this.fetchWithRetry(\n      `/studies/${studyName}/suggest`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to suggest parameters: ${error}`);\n    }\n\n    return response.json() as Promise<PythonParameterSuggestion>;\n  }\n\n  /**\n   * Report trial evaluation result\n   */\n  async evaluateTrial(request: PythonEvaluationRequest): Promise<void> {\n    const response = await this.fetchWithRetry(\n      `/studies/${request.study_name}/evaluate`,\n      {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(request),\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to evaluate trial: ${error}`);\n    }\n  }\n\n  /**\n   * Get optimization results for a study\n   */\n  async getStudyResults(studyName: string): Promise<PythonOptimizationResult> {\n    const response = await this.fetchWithRetry(\n      `/studies/${studyName}/results`,\n      {\n        method: 'GET',\n      }\n    );\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to get study results: ${error}`);\n    }\n\n    return response.json() as Promise<PythonOptimizationResult>;\n  }\n\n  /**\n   * Delete a study\n   */\n  async deleteStudy(studyName: string): Promise<void> {\n    const response = await this.fetchWithRetry(`/studies/${studyName}`, {\n      method: 'DELETE',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to delete study: ${error}`);\n    }\n  }\n\n  /**\n   * List all studies\n   */\n  async listStudies(): Promise<string[]> {\n    const response = await this.fetchWithRetry('/studies', {\n      method: 'GET',\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Failed to list studies: ${error}`);\n    }\n\n    return response.json() as Promise<string[]>;\n  }\n\n  /**\n   * Wait for job completion with polling\n   */\n  async waitForJobCompletion(\n    jobId: string,\n    pollInterval: number = 2000,\n    maxWaitTime: number = 300000 // 5 minutes default\n  ): Promise<PythonJobStatus> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < maxWaitTime) {\n      const status = await this.getJobStatus(jobId);\n\n      if (['completed', 'failed', 'cancelled'].includes(status.status)) {\n        return status;\n      }\n\n      this.logger?.({\n        name: 'Notification',\n        id: 'job_status',\n        value: `Job ${jobId} status: ${status.status}, waiting...`,\n      });\n      await this.sleep(pollInterval);\n    }\n\n    throw new Error(`Job ${jobId} did not complete within ${maxWaitTime}ms`);\n  }\n\n  /**\n   * Fetch with retry logic\n   */\n  private async fetchWithRetry(\n    path: string,\n    options: RequestInit\n  ): Promise<Response> {\n    const url = `${this.endpoint}${path}`;\n    let lastError: Error | null = null;\n\n    for (let attempt = 0; attempt < this.retryAttempts; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n        const response = await fetch(url, {\n          ...options,\n          signal: controller.signal,\n        });\n\n        clearTimeout(timeoutId);\n        return response;\n      } catch (error) {\n        lastError = error as Error;\n        this.logger?.({\n          name: 'Notification',\n          id: 'retry_attempt',\n          value: `Attempt ${attempt + 1} failed: ${error}`,\n        });\n\n        if (attempt < this.retryAttempts - 1) {\n          await this.sleep(this.retryDelay * Math.pow(2, attempt)); // Exponential backoff\n        }\n      }\n    }\n\n    throw new Error(\n      `Request failed after ${this.retryAttempts} attempts: ${lastError?.message}`\n    );\n  }\n\n  /**\n   * Sleep utility\n   */\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n}\n", "import type { AxAIService } from '../../ai/types.js';\nimport { AxGen } from '../generate.js';\nimport {\n  AxBaseOptimizer,\n  type AxCompileOptions,\n  type AxExample,\n  type AxMetricFn,\n  type AxMiPROCompileOptions,\n  type AxOptimizerArgs,\n  type AxOptimizerResult,\n} from '../optimizer.js';\nimport type {\n  AxGenIn,\n  AxGenOut,\n  AxProgramDemos,\n  AxResultPickerFunction,\n} from '../types.js';\n\nimport { AxBootstrapFewShot } from './bootstrapFewshot.js';\nimport {\n  PythonOptimizerClient,\n  type PythonOptimizerClientOptions,\n} from './pythonOptimizerClient.js';\n\ninterface ConfigType extends Record<string, unknown> {\n  instruction: string;\n  bootstrappedDemos: number;\n  labeledExamples: number;\n}\n\n// Extended result interface to include the optimized AxGen\nexport interface AxMiPROResult<IN extends AxGenIn, OUT extends AxGenOut>\n  extends AxOptimizerResult<OUT> {\n  optimizedGen?: AxGen<IN, OUT>;\n}\n\nexport class AxMiPRO<\n  IN extends AxGenIn = AxGenIn,\n  OUT extends AxGenOut = AxGenOut,\n> extends AxBaseOptimizer<IN, OUT> {\n  // MiPRO-specific options\n  private maxBootstrappedDemos: number;\n  private maxLabeledDemos: number;\n  private numCandidates: number;\n  private initTemperature: number;\n  private numTrials: number;\n  private minibatch: boolean;\n  private minibatchSize: number;\n  private minibatchFullEvalSteps: number;\n  private programAwareProposer: boolean;\n  private dataAwareProposer: boolean;\n  private viewDataBatchSize: number;\n  private tipAwareProposer: boolean;\n  private fewshotAwareProposer: boolean;\n  private earlyStoppingTrials: number;\n  private minImprovementThreshold: number;\n  private bayesianOptimization: boolean;\n  private acquisitionFunction:\n    | 'expected_improvement'\n    | 'upper_confidence_bound'\n    | 'probability_improvement';\n  private explorationWeight: number;\n\n  // Self-consistency / multiple sampling\n  private sampleCount: number;\n\n  // Surrogate model state for Bayesian optimization\n  private miproConfigHistory: { config: ConfigType; score: number }[] = [];\n  private surrogateModel: Map<string, { mean: number; variance: number }> =\n    new Map();\n\n  // Python optimizer integration\n  private pythonClient?: PythonOptimizerClient;\n\n  constructor(args: Readonly<AxOptimizerArgs>) {\n    // Call parent constructor with base args\n    super(args);\n\n    // MiPRO-specific options with proper defaults - now from top-level args\n    this.numCandidates = args.numCandidates ?? 5;\n    this.initTemperature = args.initTemperature ?? 0.7;\n    this.maxBootstrappedDemos = args.maxBootstrappedDemos ?? 3;\n    this.maxLabeledDemos = args.maxLabeledDemos ?? 4;\n    this.numTrials = args.numTrials ?? 30;\n    this.minibatch = args.minibatch ?? true;\n    this.minibatchSize = args.minibatchSize ?? 25;\n    this.minibatchFullEvalSteps = args.minibatchFullEvalSteps ?? 10;\n    this.programAwareProposer = args.programAwareProposer ?? true;\n    this.dataAwareProposer = args.dataAwareProposer ?? true;\n    this.viewDataBatchSize = args.viewDataBatchSize ?? 10;\n    this.tipAwareProposer = args.tipAwareProposer ?? true;\n    this.fewshotAwareProposer = args.fewshotAwareProposer ?? true;\n    this.earlyStoppingTrials = args.earlyStoppingTrials ?? 5;\n    this.minImprovementThreshold = args.minImprovementThreshold ?? 0.01;\n    this.bayesianOptimization = args.bayesianOptimization ?? false;\n    this.acquisitionFunction =\n      args.acquisitionFunction ?? 'expected_improvement';\n    this.explorationWeight = args.explorationWeight ?? 0.1;\n\n    // Self-consistency options\n    this.sampleCount = args.sampleCount ?? 1;\n\n    // Initialize Python client if configured - use top-level args instead of nested options\n    if (args.optimizerEndpoint) {\n      const clientOptions: PythonOptimizerClientOptions = {\n        endpoint: args.optimizerEndpoint,\n        timeout: args.optimizerTimeout ?? 30000,\n        retryAttempts: args.optimizerRetries ?? 3,\n        logger: (msg) => {\n          this.logger?.({\n            name: 'Notification',\n            id: 'python_client',\n            value: typeof msg === 'string' ? msg : JSON.stringify(msg),\n          });\n        },\n      };\n      this.pythonClient = new PythonOptimizerClient(clientOptions);\n    }\n\n    // Update convergence threshold in stats\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  /**\n   * Configures the optimizer for light, medium, or heavy optimization\n   * @param level The optimization level: \"light\", \"medium\", or \"heavy\"\n   */\n  public configureAuto(level: 'light' | 'medium' | 'heavy'): void {\n    switch (level) {\n      case 'light':\n        this.numCandidates = 3;\n        this.numTrials = 10;\n        this.minibatch = true;\n        this.minibatchSize = 20;\n        break;\n      case 'medium':\n        this.numCandidates = 5;\n        this.numTrials = 20;\n        this.minibatch = true;\n        this.minibatchSize = 25;\n        break;\n      case 'heavy':\n        this.numCandidates = 7;\n        this.numTrials = 30;\n        this.minibatch = true;\n        this.minibatchSize = 30;\n        break;\n    }\n  }\n\n  /**\n   * Generates creative tips for instruction generation\n   */\n  private generateTips(): string[] {\n    return [\n      'Be very specific and detailed in your instructions.',\n      'Focus on step-by-step reasoning in your instructions.',\n      'Provide clear constraints and guidelines in your instructions.',\n      'Keep your instructions concise and to the point.',\n      'Emphasize accuracy and precision in your instructions.',\n      'Include examples of good outputs in your instructions.',\n      'Focus on handling edge cases in your instructions.',\n      'Explicitly outline the reasoning process in your instructions.',\n    ];\n  }\n\n  /**\n   * Generates program summary for context-aware instruction generation\n   */\n  private async generateProgramSummary(\n    program: Readonly<AxGen<IN, OUT>>,\n    ai: Readonly<AxAIService>\n  ): Promise<string> {\n    // Extract program structure information\n    const signature = program.getSignature();\n\n    // Create program summary prompt based on paper's Appendix C.5\n    const summaryPrompt = `\nAnalyze this language model program and provide a concise summary of its purpose and structure.\n\nProgram Signature: ${signature}\n\nProvide a 2-3 sentence summary focusing on:\n1. The main task or purpose of this program\n2. The input-output relationship\n3. Any special constraints or requirements\n\nSummary:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [{ role: 'user', content: summaryPrompt }],\n      });\n      if ('results' in response) {\n        return (\n          response.results[0]?.content?.trim() ||\n          'General language model program'\n        );\n      }\n      return 'General language model program';\n    } catch {\n      return 'General language model program';\n    }\n  }\n\n  /**\n   * Generates dataset summary for context-aware instruction generation\n   */\n  private async generateDatasetSummary(\n    examples: readonly AxExample[],\n    ai: Readonly<AxAIService>\n  ): Promise<string> {\n    if (examples.length === 0) return 'No examples available';\n\n    // Sample a few examples for analysis (based on paper's approach)\n    const sampleSize = Math.min(this.viewDataBatchSize, examples.length);\n    const sampledExamples = examples.slice(0, sampleSize);\n\n    // Create dataset summary prompt based on paper's Appendix C.3\n    const exampleTexts = sampledExamples\n      .map((ex, i) => `Example ${i + 1}: ${JSON.stringify(ex)}`)\n      .join('\\n');\n\n    const summaryPrompt = `\nAnalyze this dataset and provide a concise summary of its characteristics.\n\nSample Examples:\n${exampleTexts}\n\nProvide a 2-3 sentence summary focusing on:\n1. The type of data and domain\n2. Common patterns or structures in the examples\n3. Key challenges or requirements for processing this data\n\nDataset Summary:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [{ role: 'user', content: summaryPrompt }],\n      });\n      if ('results' in response) {\n        return response.results[0]?.content?.trim() || 'General dataset';\n      }\n      return 'General dataset';\n    } catch {\n      return 'General dataset';\n    }\n  }\n\n  /**\n   * Enhanced instruction generation using AI with program and data awareness\n   */\n  private async generateInstruction({\n    tip,\n    candidateIndex,\n    ai,\n    programSummary,\n    datasetSummary,\n    previousInstructions = [],\n  }: Readonly<{\n    tip: string | undefined;\n    candidateIndex: number;\n    ai: Readonly<AxAIService>;\n    programSummary?: string;\n    datasetSummary?: string;\n    previousInstructions?: string[];\n  }>): Promise<string> {\n    // Build context-aware instruction generation prompt based on paper\n    let contextInfo = '';\n\n    if (this.programAwareProposer && programSummary) {\n      contextInfo += `\\nProgram Context: ${programSummary}`;\n    }\n\n    if (this.dataAwareProposer && datasetSummary) {\n      contextInfo += `\\nDataset Context: ${datasetSummary}`;\n    }\n\n    if (this.fewshotAwareProposer && previousInstructions.length > 0) {\n      contextInfo += `\\nPrevious Instructions (avoid repeating): ${previousInstructions.slice(-3).join('; ')}`;\n    }\n\n    // Core instruction generation prompt inspired by paper's Appendix C.1\n    const instructionPrompt = `\nGenerate a high-quality instruction for a language model program.\n\n${contextInfo}\n\n${tip ? `Tip: ${tip}` : ''}\n\nRequirements:\n1. Be specific and actionable\n2. Focus on accuracy and clarity\n3. Consider the program's purpose and data characteristics\n4. Make the instruction distinct from previous ones\n5. Keep it concise but comprehensive\n\nGenerate a single, well-crafted instruction:\nInstruction:`;\n\n    try {\n      const response = await ai.chat({\n        chatPrompt: [\n          {\n            role: 'user',\n            content: instructionPrompt,\n          },\n        ],\n      });\n\n      if ('results' in response) {\n        const instruction = response.results[0]?.content?.trim();\n        if (instruction && instruction.length > 10) {\n          return instruction;\n        }\n      }\n    } catch (_error) {\n      // if (this.isLoggingEnabled()) {\n      //   this.getLogger()?.(`Failed to generate AI instruction: ${error}`, {\n      //     tags: ['optimizer', 'warning'],\n      //   });\n      // }\n    }\n\n    // Fallback to enhanced templates if AI generation fails\n    const enhancedTemplates = [\n      'Analyze the input systematically and provide a precise, well-reasoned response.',\n      'Think through this step-by-step, considering all relevant factors before responding.',\n      'Examine the input carefully and generate an accurate, detailed answer.',\n      'Process the information methodically and deliver a clear, comprehensive response.',\n      'Consider the context thoroughly and provide a thoughtful, accurate answer.',\n    ];\n\n    let instruction =\n      enhancedTemplates[candidateIndex % enhancedTemplates.length] ||\n      enhancedTemplates[0]!;\n\n    if (tip) {\n      instruction = `${instruction} ${tip}`;\n    }\n\n    return instruction;\n  }\n\n  /**\n   * Generates instruction candidates using enhanced AI-powered generation\n   * @param options Optional compile options that may override teacher AI\n   * @returns Array of generated instruction candidates\n   */\n  private async proposeInstructionCandidates(\n    _program: Readonly<AxGen<IN, OUT>>,\n    options?: AxCompileOptions\n  ): Promise<string[]> {\n    const instructions: string[] = [];\n    const aiToUse = this.getTeacherOrStudentAI(options);\n\n    // Generate contextual information if enabled\n    let programSummary: string | undefined;\n    let datasetSummary: string | undefined;\n\n    // if (this.programAwareProposer) {\n    //   programSummary = await this.generateProgramSummary(program, aiToUse);\n    //   if (this.isLoggingEnabled(options)) {\n    //     this.getLogger(options)?.(`Program summary: ${programSummary}`, {\n    //       tags: ['optimizer', 'config'],\n    //     });\n    //   }\n    // }\n\n    if (this.dataAwareProposer) {\n      datasetSummary = await this.generateDatasetSummary(\n        this.examples,\n        aiToUse\n      );\n      // if (this.isLoggingEnabled(options)) {\n      //   this.getLogger(options)?.(`Dataset summary: ${datasetSummary}`, {\n      //     tags: ['optimizer', 'config'],\n      //   });\n      // }\n    }\n\n    // Generate creative tips for tip-aware proposing\n    const tips = this.tipAwareProposer ? this.generateTips() : [];\n\n    // Generate instructions for each candidate\n    for (let i = 0; i < this.numCandidates; i++) {\n      const tipIndex = tips.length > 0 ? i % tips.length : -1;\n      const tipToUse = tipIndex >= 0 ? tips[tipIndex] : undefined;\n\n      const instruction = await this.generateInstruction({\n        tip: tipToUse,\n        candidateIndex: i,\n        ai: aiToUse,\n        programSummary,\n        datasetSummary,\n        previousInstructions: instructions, // Pass previous instructions for diversity\n      });\n\n      instructions.push(instruction);\n    }\n\n    return instructions;\n  }\n\n  /**\n   * Bootstraps few-shot examples for the program\n   */\n  private async bootstrapFewShotExamples(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn\n  ): Promise<AxProgramDemos<IN, OUT>[]> {\n    // Initialize the bootstrapper for this program\n    const bootstrapper = new AxBootstrapFewShot<IN, OUT>({\n      studentAI: this.studentAI,\n      examples: this.examples,\n      options: {\n        maxDemos: this.maxBootstrappedDemos,\n        maxRounds: 3,\n        verboseMode: this.isLoggingEnabled(),\n      },\n    });\n\n    const result = await bootstrapper.compile(program, metricFn, {\n      maxDemos: this.maxBootstrappedDemos,\n    });\n\n    return (result.demos || []) as AxProgramDemos<IN, OUT>[];\n  }\n\n  /**\n   * Selects labeled examples directly from the training set\n   */\n  private selectLabeledExamples(): AxExample[] {\n    const selectedExamples: AxExample[] = [];\n\n    // Random sampling from the training set\n    const indices = new Set<number>();\n    while (\n      indices.size < this.maxLabeledDemos &&\n      indices.size < this.examples.length\n    ) {\n      const idx = Math.floor(Math.random() * this.examples.length);\n      if (!indices.has(idx)) {\n        indices.add(idx);\n        const example = this.examples[idx];\n        if (example) {\n          selectedExamples.push(example);\n        }\n      }\n    }\n\n    return selectedExamples;\n  }\n\n  /**\n   * Runs optimization to find the best combination of few-shot examples and instructions\n   */\n  private async runOptimization(\n    program: Readonly<AxGen<IN, OUT>>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[],\n    instructions: readonly string[],\n    validationExamples: readonly AxExample[],\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<{ bestConfig: ConfigType; bestScore: number }> {\n    let bestConfig: ConfigType = {\n      instruction: instructions[0] || '',\n      bootstrappedDemos: Math.min(1, bootstrappedDemos.length),\n      labeledExamples: Math.min(1, labeledExamples.length),\n    };\n    let bestScore = 0;\n    let stagnationRounds = 0;\n    const scoreHistory: number[] = [];\n\n    // Check for checkpoint resume\n    let startRound = 0;\n    if (this.resumeFromCheckpoint) {\n      const checkpoint = await this.loadCheckpoint(\n        this.resumeFromCheckpoint,\n        options\n      );\n      if (checkpoint && checkpoint.optimizerType === 'MiPRO') {\n        this.restoreFromCheckpoint(checkpoint);\n        startRound = checkpoint.currentRound;\n        bestScore = checkpoint.bestScore;\n        bestConfig = (checkpoint.bestConfiguration as ConfigType) || bestConfig;\n        stagnationRounds =\n          checkpoint.stats.convergenceInfo?.stagnationRounds || 0;\n      }\n    }\n\n    // Optimization loop with early stopping and checkpointing\n\n    for (let i = startRound; i < this.numTrials; i++) {\n      let config: ConfigType;\n\n      if (this.bayesianOptimization && this.miproConfigHistory.length > 2) {\n        // Use Bayesian optimization with acquisition function\n        config = await this.selectConfigurationViaBayesianOptimization(\n          instructions,\n          bootstrappedDemos,\n          labeledExamples\n        );\n      } else {\n        // Random or round-robin selection (exploration phase)\n        config = {\n          instruction:\n            instructions[i % instructions.length] || instructions[0] || '',\n          bootstrappedDemos: Math.min(\n            Math.floor(Math.random() * (bootstrappedDemos.length + 1)),\n            this.maxBootstrappedDemos\n          ),\n          labeledExamples: Math.min(\n            Math.floor(Math.random() * (labeledExamples.length + 1)),\n            this.maxLabeledDemos\n          ),\n        };\n      }\n\n      const score = await this.evaluateConfig(\n        program,\n        config,\n        bootstrappedDemos,\n        labeledExamples,\n        validationExamples,\n        metricFn,\n        i + 1 // Pass current trial number for adaptive evaluation\n      );\n\n      // Update surrogate model with observed score\n      this.updateSurrogateModel(config, score);\n\n      scoreHistory.push(score);\n\n      // Check for improvement\n      const improvement = score - bestScore;\n      if (improvement > this.minImprovementThreshold) {\n        bestScore = score;\n        bestConfig = config;\n        stagnationRounds = 0;\n\n        // if (this.isLoggingEnabled(options)) {\n        //   this.getLogger(options)?.(\n        //     `Trial ${i + 1}/${this.numTrials}: New best score ${bestScore.toFixed(3)}`,\n        //     { tags: ['optimizer', 'progress'] }\n        //   );\n        // }\n      } else {\n        stagnationRounds++;\n      }\n\n      // Update optimization progress with checkpointing\n      await this.updateOptimizationProgress(\n        i + 1,\n        score,\n        config,\n        'MiPRO',\n        this.getConfiguration(),\n        bestScore,\n        bestConfig,\n        {\n          stagnationRounds,\n          bootstrappedDemos: bootstrappedDemos.length,\n          labeledExamples: labeledExamples.length,\n          instructions: instructions.length,\n        },\n        options\n      );\n\n      // Progress callback\n      if (this.onProgress) {\n        this.onProgress({\n          round: i + 1,\n          totalRounds: this.numTrials,\n          currentScore: score,\n          bestScore,\n          tokensUsed: this.stats.resourceUsage.totalTokens,\n          timeElapsed: Date.now(),\n          successfulExamples: this.stats.successfulDemos,\n          totalExamples: this.examples.length,\n          currentConfiguration: config,\n          convergenceInfo: {\n            improvement,\n            stagnationRounds,\n            isConverging: stagnationRounds < this.earlyStoppingTrials,\n          },\n        });\n      }\n\n      // Cost tracking check (handles token/time/cost budgets)\n      if (this.checkCostLimits()) {\n        this.triggerEarlyStopping('Cost limit reached', i + 1);\n        break;\n      }\n\n      // Early stopping check\n      if (stagnationRounds >= this.earlyStoppingTrials) {\n        this.triggerEarlyStopping(\n          `No improvement for ${this.earlyStoppingTrials} trials`,\n          i - stagnationRounds + 1\n        );\n        break;\n      }\n\n      // Target score check\n      if (this.checkTargetScore(bestScore)) {\n        this.triggerEarlyStopping(\n          `Target score ${this.targetScore} reached`,\n          i + 1\n        );\n        break;\n      }\n    }\n\n    // Update convergence info\n    this.stats.convergenceInfo.stagnationRounds = stagnationRounds;\n    this.stats.convergenceInfo.finalImprovement =\n      scoreHistory.length > 1 ? bestScore - scoreHistory[0]! : 0;\n    this.stats.convergenceInfo.converged =\n      stagnationRounds < this.earlyStoppingTrials;\n\n    return { bestConfig, bestScore };\n  }\n\n  private async evaluateConfig(\n    program: Readonly<AxGen<IN, OUT>>,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[],\n    validationExamples: readonly AxExample[],\n    metricFn: AxMetricFn,\n    currentTrial = 0\n  ): Promise<number> {\n    const testProgram = new AxGen(program.getSignature());\n    this.applyConfigToProgram(\n      testProgram,\n      config,\n      bootstrappedDemos,\n      labeledExamples\n    );\n\n    let totalScore = 0;\n    let count = 0;\n\n    // Adaptive minibatch size based on paper's approach\n    let evalSize: number;\n    if (this.minibatch) {\n      // Start with smaller batches and increase for more promising configurations\n      const baseSize = Math.min(this.minibatchSize, validationExamples.length);\n\n      // Use full evaluation for top configurations in later trials\n      const isFullEvalTrial = currentTrial % this.minibatchFullEvalSteps === 0;\n      if (isFullEvalTrial || currentTrial > this.numTrials * 0.8) {\n        evalSize = Math.min(validationExamples.length, baseSize * 2);\n      } else {\n        // Stochastic minibatch evaluation\n        evalSize = Math.max(3, Math.min(baseSize, validationExamples.length));\n      }\n    } else {\n      evalSize = validationExamples.length;\n    }\n\n    // Randomly sample evaluation examples for stochastic evaluation\n    const evalIndices = this.shuffleArray([\n      ...Array(validationExamples.length).keys(),\n    ]).slice(0, evalSize);\n    const evalSet = evalIndices.map((i) => validationExamples[i]!);\n\n    for (const example of evalSet) {\n      try {\n        const forwardOptions =\n          this.sampleCount > 1\n            ? {\n                sampleCount: this.sampleCount,\n                resultPicker:\n                  axMajorityVotePicker<OUT>() as AxResultPickerFunction<AxGenOut>,\n                maxRetries: 1,\n              }\n            : { maxRetries: 1 };\n\n        const prediction = await testProgram.forward(\n          this.studentAI,\n          example as IN,\n          forwardOptions\n        );\n        const score = await metricFn({ prediction, example });\n        totalScore += score;\n        count++;\n        this.stats.totalCalls++;\n      } catch (error) {\n        // Log the error but continue optimization - student model failures are expected during optimization\n        if (this.isLoggingEnabled()) {\n          console.warn(\n            `Student model failed during evaluation: ${error instanceof Error ? error.message : 'Unknown error'}`\n          );\n        }\n        // Count failed attempts to track optimization health\n        this.stats.totalCalls++;\n      }\n    }\n\n    return count > 0 ? totalScore / count : 0;\n  }\n\n  /**\n   * Fisher-Yates shuffle for stochastic evaluation\n   */\n  private shuffleArray<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j]!, shuffled[i]!];\n    }\n    return shuffled;\n  }\n\n  private applyConfigToProgram(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    program: any,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): void {\n    // Set instruction if the program supports it\n    if (program.setInstruction) {\n      program.setInstruction(config.instruction);\n    }\n\n    // Set demos if needed\n    if (config.bootstrappedDemos > 0 && program.setDemos) {\n      program.setDemos(bootstrappedDemos.slice(0, config.bootstrappedDemos));\n    }\n\n    // Set examples if needed\n    if (config.labeledExamples > 0 && program.setExamples) {\n      program.setExamples(labeledExamples.slice(0, config.labeledExamples));\n    }\n  }\n\n  /**\n   * The main compile method to run MIPROv2 optimization\n   */\n  public async compile(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    options?: AxCompileOptions\n  ): Promise<AxMiPROResult<IN, OUT>> {\n    const startTime = Date.now();\n\n    // Initialize random seed if provided\n    this.setupRandomSeed();\n\n    // Configure auto settings if provided (cast to access MiPRO-specific options)\n    const miproOptions = options as AxMiPROCompileOptions;\n    if (miproOptions?.auto) {\n      this.configureAuto(miproOptions.auto);\n    }\n\n    // Check if Python optimizer should be used (based on presence of client)\n    if (this.pythonClient) {\n      // Check if Python service is available\n      const isHealthy = await this.pythonClient.healthCheck();\n      if (!isHealthy) {\n        throw new Error(\n          'Python optimizer service is not available or unhealthy'\n        );\n      }\n\n      this.logger?.({\n        name: 'Notification',\n        id: 'mipro_mode',\n        value: 'Using Python optimizer service for MiPRO optimization',\n      });\n\n      return await this.compilePython(program, metricFn, options);\n    }\n\n    // Use validation set from parent class method\n    const validationExamples =\n      this.getValidationSet(options) ||\n      (miproOptions?.validationExamples ??\n        this.examples.slice(0, Math.floor(this.examples.length * 0.2)));\n\n    // if (this.isLoggingEnabled(options)) {\n    //   this.getLogger(options)?.(\n    //     `Starting MIPROv2 optimization with ${this.numTrials} trials`,\n    //     { tags: ['optimizer', 'start'] }\n    //   );\n    //   this.getLogger(options)?.(\n    //     `Using ${this.examples.length} examples for training and ${validationExamples.length} for validation`,\n    //     { tags: ['optimizer', 'config'] }\n    //   );\n    //   if (this.teacherAI) {\n    //     this.getLogger(options)?.(\n    //       'Using separate teacher model for instruction generation',\n    //       { tags: ['optimizer', 'config'] }\n    //     );\n    //   }\n    // }\n\n    // Step 1: Bootstrap few-shot examples\n    let bootstrappedDemos: AxProgramDemos<IN, OUT>[] = [];\n    if (this.maxBootstrappedDemos > 0) {\n      bootstrappedDemos = await this.bootstrapFewShotExamples(\n        program,\n        metricFn\n      );\n\n      // if (this.isLoggingEnabled(options)) {\n      //   this.getLogger(options)?.(\n      //     `Generated ${bootstrappedDemos.length} bootstrapped demonstrations`,\n      //     { tags: ['optimizer', 'result'] }\n      //   );\n      // }\n    }\n\n    // Step 2: Select labeled examples from training set\n    let labeledExamples: AxExample[] = [];\n    if (this.maxLabeledDemos > 0) {\n      labeledExamples = this.selectLabeledExamples();\n\n      // if (this.isLoggingEnabled(options)) {\n      //   this.getLogger(options)?.(\n      //     `Selected ${labeledExamples.length} labeled examples from training set`,\n      //     { tags: ['optimizer', 'result'] }\n      //   );\n      // }\n    }\n\n    // Step 3: Generate instruction candidates\n    const instructions = await this.proposeInstructionCandidates(\n      program,\n      options\n    );\n\n    // if (this.isLoggingEnabled(options)) {\n    //   this.getLogger(options)?.(\n    //     `Generated ${instructions.length} instruction candidates`,\n    //     { tags: ['optimizer', 'result'] }\n    //   );\n    //   if (this.hasTeacherAI(options)) {\n    //     this.getLogger(options)?.(\n    //       'Using teacher AI for instruction generation',\n    //       { tags: ['optimizer', 'config'] }\n    //     );\n    //   }\n    // }\n\n    // Step 4: Run optimization to find the best configuration\n    const { bestConfig, bestScore } = await this.runOptimization(\n      program,\n      bootstrappedDemos,\n      labeledExamples,\n      instructions,\n      validationExamples,\n      metricFn,\n      options\n    );\n\n    // if (this.isLoggingEnabled(options)) {\n    //   this.getLogger(options)?.(\n    //     `Optimization complete. Best score: ${bestScore}`,\n    //     { tags: ['optimizer', 'complete'] }\n    //   );\n    //   this.getLogger(options)?.(\n    //     `Best configuration: ${JSON.stringify(bestConfig)}`,\n    //     { tags: ['optimizer', 'result'] }\n    //   );\n    // }\n\n    // Check if target score was reached\n    if (this.checkTargetScore(bestScore)) {\n      this.triggerEarlyStopping(\n        `Target score ${this.targetScore} reached with score ${bestScore}`,\n        this.numTrials\n      );\n    }\n\n    // Create a new AxGen instance with the optimized configuration\n    let signature: any;\n    if (\n      'getSignature' in program &&\n      typeof program.getSignature === 'function'\n    ) {\n      signature = program.getSignature();\n    } else {\n      // Fallback: create a basic signature\n      signature = 'input -> output';\n    }\n\n    const optimizedGen = new AxGen<IN, OUT>(signature);\n\n    // Apply the best configuration to the new AxGen\n    this.applyConfigToAxGen(\n      optimizedGen,\n      bestConfig,\n      bootstrappedDemos,\n      labeledExamples\n    );\n\n    // Update stats using parent class method\n    this.updateResourceUsage(startTime);\n    this.stats.convergenceInfo.converged = true;\n    this.stats.convergenceInfo.finalImprovement = bestScore;\n\n    // Save final checkpoint\n    await this.saveFinalCheckpoint(\n      'MiPRO',\n      this.getConfiguration(),\n      bestScore,\n      bestConfig,\n      {\n        bootstrappedDemos: bootstrappedDemos.length,\n        labeledExamples: labeledExamples.length,\n        instructions: instructions.length,\n        optimizedGen: !!optimizedGen,\n      },\n      options\n    );\n\n    return {\n      demos: bootstrappedDemos,\n      stats: this.stats,\n      bestScore,\n      optimizedGen,\n      finalConfiguration: {\n        instruction: bestConfig.instruction,\n        bootstrappedDemos: bestConfig.bootstrappedDemos,\n        labeledExamples: bestConfig.labeledExamples,\n        numCandidates: this.numCandidates,\n        numTrials: this.numTrials,\n        sampleCount: this.sampleCount,\n      },\n    };\n  }\n\n  /**\n   * Applies a configuration to an AxGen instance\n   */\n  private applyConfigToAxGen(\n    axgen: Readonly<AxGen<IN, OUT>>,\n    config: Readonly<ConfigType>,\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): void {\n    // Set instruction if the AxGen supports it\n    if (\n      'setInstruction' in axgen &&\n      typeof axgen.setInstruction === 'function'\n    ) {\n      axgen.setInstruction(config.instruction);\n    }\n\n    // Set demos if needed\n    if (config.bootstrappedDemos > 0) {\n      axgen.setDemos(bootstrappedDemos.slice(0, config.bootstrappedDemos));\n    }\n\n    // Set examples if needed\n    if (config.labeledExamples > 0) {\n      axgen.setExamples(\n        labeledExamples.slice(\n          0,\n          config.labeledExamples\n        ) as unknown as readonly (OUT & IN)[]\n      );\n    }\n  }\n\n  /**\n   * Get optimizer-specific configuration\n   * @returns Current optimizer configuration\n   */\n  public getConfiguration(): Record<string, unknown> {\n    return {\n      numCandidates: this.numCandidates,\n      initTemperature: this.initTemperature,\n      maxBootstrappedDemos: this.maxBootstrappedDemos,\n      maxLabeledDemos: this.maxLabeledDemos,\n      numTrials: this.numTrials,\n      minibatch: this.minibatch,\n      minibatchSize: this.minibatchSize,\n      minibatchFullEvalSteps: this.minibatchFullEvalSteps,\n      programAwareProposer: this.programAwareProposer,\n      dataAwareProposer: this.dataAwareProposer,\n      tipAwareProposer: this.tipAwareProposer,\n      fewshotAwareProposer: this.fewshotAwareProposer,\n      earlyStoppingTrials: this.earlyStoppingTrials,\n      minImprovementThreshold: this.minImprovementThreshold,\n      bayesianOptimization: this.bayesianOptimization,\n      acquisitionFunction: this.acquisitionFunction,\n      explorationWeight: this.explorationWeight,\n      sampleCount: this.sampleCount,\n    };\n  }\n\n  /**\n   * Update optimizer configuration\n   * @param config New configuration to merge with existing\n   */\n  public updateConfiguration(config: Readonly<Record<string, unknown>>): void {\n    if (config.numCandidates !== undefined) {\n      this.numCandidates = config.numCandidates as number;\n    }\n    if (config.initTemperature !== undefined) {\n      this.initTemperature = config.initTemperature as number;\n    }\n    if (config.maxBootstrappedDemos !== undefined) {\n      this.maxBootstrappedDemos = config.maxBootstrappedDemos as number;\n    }\n    if (config.maxLabeledDemos !== undefined) {\n      this.maxLabeledDemos = config.maxLabeledDemos as number;\n    }\n    if (config.numTrials !== undefined) {\n      this.numTrials = config.numTrials as number;\n    }\n    if (config.minibatch !== undefined) {\n      this.minibatch = config.minibatch as boolean;\n    }\n    if (config.minibatchSize !== undefined) {\n      this.minibatchSize = config.minibatchSize as number;\n    }\n    if (config.earlyStoppingTrials !== undefined) {\n      this.earlyStoppingTrials = config.earlyStoppingTrials as number;\n    }\n    if (config.minImprovementThreshold !== undefined) {\n      this.minImprovementThreshold = config.minImprovementThreshold as number;\n    }\n    if (config.sampleCount !== undefined) {\n      this.sampleCount = config.sampleCount as number;\n    }\n    // Note: verbose is now handled by the base class and cannot be updated here\n  }\n\n  /**\n   * Reset optimizer state for reuse with different programs\n   */\n  public override reset(): void {\n    super.reset();\n    // Reset surrogate model state\n    this.miproConfigHistory = [];\n    this.surrogateModel.clear();\n    // Update convergence threshold after reset\n    this.stats.convergenceInfo.convergenceThreshold =\n      this.minImprovementThreshold;\n  }\n\n  /**\n   * Validate that the optimizer can handle the given program\n   * @param program Program to validate\n   * @returns Validation result with any issues found\n   */\n  public validateProgram(_program: Readonly<AxGen<IN, OUT>>): {\n    isValid: boolean;\n    issues: string[];\n    suggestions: string[];\n  } {\n    // Start with empty validation result\n    const issues: string[] = [];\n    const suggestions: string[] = [];\n\n    // Add MiPRO-specific validation\n    if (\n      this.examples.length <\n      this.maxBootstrappedDemos + this.maxLabeledDemos\n    ) {\n      issues.push(\n        `Not enough examples: need at least ${\n          this.maxBootstrappedDemos + this.maxLabeledDemos\n        }, got ${this.examples.length}`\n      );\n      suggestions.push(\n        'Reduce maxBootstrappedDemos or maxLabeledDemos, or provide more examples'\n      );\n    }\n\n    // Check if validation set is reasonable for MiPRO\n    const validationSetSize = this.getValidationSet().length;\n    if (validationSetSize < 5) {\n      issues.push('Validation set too small for reliable MiPRO optimization');\n      suggestions.push('Provide more examples or a larger validation set');\n    }\n\n    return {\n      isValid: issues.length === 0,\n      issues,\n      suggestions,\n    };\n  }\n\n  /**\n   * Encodes a configuration into a string key for surrogate model lookup\n   */\n  private encodeConfiguration(config: Readonly<ConfigType>): string {\n    // Create a proper hash of the instruction content, not just length!\n    const instructionHash = this.hashString(config.instruction);\n    return `${instructionHash}_${config.bootstrappedDemos}_${config.labeledExamples}`;\n  }\n\n  /**\n   * Simple string hash function for instruction content\n   */\n  private hashString(str: string): string {\n    let hash = 0;\n    if (str.length === 0) return hash.toString();\n    for (let i = 0; i < str.length; i++) {\n      const char = str.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(16);\n  }\n\n  /**\n   * Updates the surrogate model with a new configuration-score pair\n   */\n  private updateSurrogateModel(\n    config: Readonly<ConfigType>,\n    score: number\n  ): void {\n    this.miproConfigHistory.push({ config: { ...config }, score });\n\n    // Simple Gaussian Process approximation for the surrogate model\n    const key = this.encodeConfiguration(config);\n\n    // Find similar configurations (same instruction length and demo counts)\n    const similarConfigs = this.miproConfigHistory.filter(\n      (entry) => this.encodeConfiguration(entry.config) === key\n    );\n\n    if (similarConfigs.length > 0) {\n      const scores = similarConfigs.map((entry) => entry.score);\n      const mean = scores.reduce((sum, s) => sum + s, 0) / scores.length;\n      const variance =\n        scores.length > 1\n          ? scores.reduce((sum, s) => sum + (s - mean) ** 2, 0) /\n            (scores.length - 1)\n          : 0.1; // Default variance for single observation\n\n      this.surrogateModel.set(key, { mean, variance });\n    }\n  }\n\n  /**\n   * Predicts performance using the surrogate model\n   */\n  private predictPerformance(config: Readonly<ConfigType>): {\n    mean: number;\n    variance: number;\n  } {\n    const key = this.encodeConfiguration(config);\n\n    if (this.surrogateModel.has(key)) {\n      return this.surrogateModel.get(key)!;\n    }\n\n    // For unseen configurations, use prior knowledge\n    if (this.miproConfigHistory.length > 0) {\n      // Find most similar configurations based on demo counts\n      const similarities = this.miproConfigHistory.map((entry) => {\n        const diff =\n          Math.abs(entry.config.bootstrappedDemos - config.bootstrappedDemos) +\n          Math.abs(entry.config.labeledExamples - config.labeledExamples);\n        return { score: entry.score, similarity: 1 / (1 + diff) };\n      });\n\n      // Weighted average based on similarity\n      const totalWeight = similarities.reduce(\n        (sum, s) => sum + s.similarity,\n        0\n      );\n      const weightedMean =\n        similarities.reduce((sum, s) => sum + s.score * s.similarity, 0) /\n        totalWeight;\n\n      return { mean: weightedMean, variance: 0.2 }; // Higher variance for unseen configs\n    }\n\n    // Default prior for completely unknown configurations\n    return { mean: 0.5, variance: 0.3 };\n  }\n\n  /**\n   * Calculates acquisition function value for Bayesian optimization\n   */\n  private calculateAcquisitionValue(config: Readonly<ConfigType>): number {\n    const prediction = this.predictPerformance(config);\n    const { mean, variance } = prediction;\n    const std = Math.sqrt(variance);\n\n    // Current best score\n    const bestScore =\n      this.miproConfigHistory.length > 0\n        ? Math.max(...this.miproConfigHistory.map((entry) => entry.score))\n        : 0;\n\n    switch (this.acquisitionFunction) {\n      case 'expected_improvement': {\n        const improvement = mean - bestScore;\n        if (std === 0) return Math.max(0, improvement);\n\n        const z = improvement / std;\n        const phi = 0.5 * (1 + this.erf(z / Math.sqrt(2))); // CDF of standard normal\n        const pdfValue = Math.exp(-0.5 * z * z) / Math.sqrt(2 * Math.PI); // PDF of standard normal\n\n        return improvement * phi + std * pdfValue;\n      }\n\n      case 'upper_confidence_bound': {\n        return mean + this.explorationWeight * std;\n      }\n\n      case 'probability_improvement': {\n        const improvement = mean - bestScore;\n        if (std === 0) return improvement > 0 ? 1 : 0;\n\n        const z = improvement / std;\n        return 0.5 * (1 + this.erf(z / Math.sqrt(2)));\n      }\n\n      default:\n        return mean;\n    }\n  }\n\n  /**\n   * Error function approximation for acquisition function calculations\n   */\n  private erf(x: number): number {\n    // Abramowitz and Stegun approximation\n    const a1 = 0.254829592;\n    const a2 = -0.284496736;\n    const a3 = 1.421413741;\n    const a4 = -1.453152027;\n    const a5 = 1.061405429;\n    const p = 0.3275911;\n\n    const sign = x >= 0 ? 1 : -1;\n    const absX = Math.abs(x);\n\n    const t = 1.0 / (1.0 + p * absX);\n    const y =\n      1.0 -\n      ((((a5 * t + a4) * t + a3) * t + a2) * t + a1) *\n        t *\n        Math.exp(-absX * absX);\n\n    return sign * y;\n  }\n\n  /**\n   * Selects the next configuration to evaluate using Bayesian optimization\n   */\n  private async selectConfigurationViaBayesianOptimization(\n    instructions: readonly string[],\n    bootstrappedDemos: readonly AxProgramDemos<IN, OUT>[],\n    labeledExamples: readonly AxExample[]\n  ): Promise<ConfigType> {\n    const candidates: Array<{ config: ConfigType; acquisitionValue: number }> =\n      [];\n\n    // Generate candidate configurations\n    const numCandidates = Math.min(20, instructions.length * 3); // Reasonable number of candidates\n\n    for (let i = 0; i < numCandidates; i++) {\n      const config: ConfigType = {\n        instruction:\n          instructions[i % instructions.length] || instructions[0] || '',\n        bootstrappedDemos: Math.min(\n          Math.floor(Math.random() * (bootstrappedDemos.length + 1)),\n          this.maxBootstrappedDemos\n        ),\n        labeledExamples: Math.min(\n          Math.floor(Math.random() * (labeledExamples.length + 1)),\n          this.maxLabeledDemos\n        ),\n      };\n\n      const acquisitionValue = this.calculateAcquisitionValue(config);\n      candidates.push({ config, acquisitionValue });\n    }\n\n    // Sort by acquisition value (higher is better)\n    candidates.sort((a, b) => b.acquisitionValue - a.acquisitionValue);\n\n    // Return the most promising configuration\n    return candidates[0]!.config;\n  }\n\n  /**\n   * Python-based compilation method\n   *\n   * This is a simplified implementation that demonstrates integration\n   * with the Python optimizer service. For now, it focuses on basic\n   * parameter optimization rather than full MiPRO functionality.\n   */\n  private async compilePython(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    _options?: AxCompileOptions\n  ): Promise<AxMiPROResult<IN, OUT>> {\n    if (!this.pythonClient) {\n      throw new Error('Python client not initialized');\n    }\n\n    const studyName = `mipro_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    // Create optimization request - simplified parameter set for now\n    const optimizationRequest = {\n      study_name: studyName,\n      parameters: [\n        {\n          name: 'temperature',\n          type: 'float' as const,\n          low: 0.1,\n          high: 2.0,\n        },\n        {\n          name: 'bootstrappedDemos',\n          type: 'int' as const,\n          low: 0,\n          high: this.maxBootstrappedDemos,\n        },\n      ],\n      objective: {\n        name: 'score',\n        direction: 'maximize' as const,\n      },\n      n_trials: this.numTrials,\n      sampler: 'TPESampler',\n      pruner: this.minibatch ? 'MedianPruner' : undefined,\n    };\n\n    // Create the optimization job\n    const job =\n      await this.pythonClient.createOptimizationJob(optimizationRequest);\n\n    this.logger?.({\n      name: 'Notification',\n      id: 'python_job_started',\n      value: `Started Python optimization job ${job.job_id}`,\n    });\n\n    let bestScore = Number.NEGATIVE_INFINITY;\n    const bestProgram = program;\n    let totalTrials = 0;\n\n    // Run optimization trials\n    for (let trial = 0; trial < this.numTrials; trial++) {\n      try {\n        // Get parameter suggestion from Python service\n        const suggestion = await this.pythonClient.suggestParameters(studyName);\n\n        // Apply the suggested parameters (simplified implementation)\n        const temperature = suggestion.params.temperature as number;\n        const bootstrappedDemos = suggestion.params.bootstrappedDemos as number;\n\n        // Evaluate with the suggested parameters\n        const score = await this.evaluateConfiguration(\n          program,\n          metricFn,\n          { temperature, bootstrappedDemos },\n          this.minibatch\n            ? this.examples.slice(0, this.minibatchSize)\n            : this.examples\n        );\n\n        totalTrials++;\n\n        // Report the result back to Python optimizer\n        await this.pythonClient.evaluateTrial({\n          study_name: studyName,\n          trial_number: suggestion.trial_number,\n          value: score,\n        });\n\n        // Update best result\n        if (score > bestScore) {\n          bestScore = score;\n          // In a full implementation, we'd create an optimized program here\n        }\n\n        this.logger?.({\n          name: 'Notification',\n          id: 'python_trial_result',\n          value: `Trial ${trial + 1}: score=${score.toFixed(3)}, temp=${temperature.toFixed(2)}`,\n        });\n\n        // Report progress\n        this.onProgress?.({\n          round: trial + 1,\n          totalRounds: this.numTrials,\n          currentScore: score,\n          bestScore,\n          tokensUsed: this.stats.estimatedTokenUsage,\n          timeElapsed: Date.now() - Date.now(), // Simplified\n          successfulExamples: totalTrials,\n          totalExamples: this.examples.length,\n        });\n      } catch (error) {\n        this.logger?.({\n          name: 'Notification',\n          id: 'python_trial_error',\n          value: `Trial ${trial + 1} failed: ${error}`,\n        });\n        // Continue with next trial\n      }\n    }\n\n    // Get final results from Python optimizer\n    try {\n      const studyResults = await this.pythonClient.getStudyResults(studyName);\n      this.logger?.({\n        name: 'Notification',\n        id: 'python_results',\n        value: `Python optimization completed with ${studyResults.n_trials} trials`,\n      });\n    } catch (error) {\n      this.logger?.({\n        name: 'Notification',\n        id: 'python_results_error',\n        value: `Failed to get study results: ${error}`,\n      });\n    }\n\n    // Cleanup\n    try {\n      await this.pythonClient.deleteStudy(studyName);\n    } catch (_error) {\n      // Ignore cleanup errors\n    }\n\n    // Update stats\n    this.stats.bestScore = bestScore;\n    this.stats.totalCalls = totalTrials;\n\n    return {\n      bestScore,\n      stats: this.stats,\n      optimizedGen: bestProgram as AxGen<IN, OUT>, // In full implementation, this would be the optimized program\n    };\n  }\n\n  /**\n   * Simplified evaluation method for Python optimization\n   */\n  private async evaluateConfiguration(\n    program: Readonly<AxGen<IN, OUT>>,\n    metricFn: AxMetricFn,\n    _config: { temperature: number; bootstrappedDemos: number },\n    examples: readonly AxExample[]\n  ): Promise<number> {\n    let totalScore = 0;\n    let validResults = 0;\n\n    // Use a subset of examples for efficiency\n    const evaluationExamples = examples.slice(0, Math.min(5, examples.length));\n\n    for (const example of evaluationExamples) {\n      try {\n        // In a full implementation, we'd apply the config to create an optimized program\n        // For now, we just use the original program\n        const prediction = await program.forward(this.studentAI, example as IN);\n        const score = await metricFn({ prediction, example });\n\n        if (typeof score === 'number' && !Number.isNaN(score)) {\n          totalScore += score;\n          validResults++;\n        }\n      } catch (_error) {\n        // Continue with other examples\n      }\n    }\n\n    return validResults > 0 ? totalScore / validResults : 0;\n  }\n}\n\n// ---------------------------------------\n// Helper: Majority-vote result picker for self-consistency\n// ---------------------------------------\nconst axMajorityVotePicker = <\n  OUT extends AxGenOut,\n>(): AxResultPickerFunction<OUT> => {\n  // Return a picker function capturing no external state\n  return async (data) => {\n    // If we have field results, do majority vote on stringified payload\n    if (data.type === 'fields') {\n      const counts: Record<string, { count: number; index: number }> = {};\n      for (const { index, sample } of data.results) {\n        const key = JSON.stringify(sample);\n        if (!counts[key]) {\n          counts[key] = { count: 0, index };\n        }\n        counts[key]!.count += 1;\n      }\n\n      // Select the sample with highest count (ties -> first seen)\n      let bestKey: string | undefined;\n      let bestCount = -1;\n      for (const [k, v] of Object.entries(counts)) {\n        if (v.count > bestCount) {\n          bestCount = v.count;\n          bestKey = k;\n        }\n      }\n      return counts[bestKey!]?.index ?? 0;\n    }\n\n    // For function results, fall back to first sample (could be improved)\n    return data.results[0]?.index ?? 0;\n  };\n};\n", "import { AxGen } from './generate.js';\nimport { AxSignature } from './sig.js';\nimport type { ParseSignature } from './sigtypes.js';\nimport type { AxProgramForwardOptions } from './types.js';\n\n// Function for string-based type-safe signature creation\nexport function s<const T extends string>(\n  signature: T\n): AxSignature<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n  return AxSignature.create(signature);\n}\n\n// Function for string-based type-safe generator creation\nexport function ax<const T extends string>(\n  signature: T,\n  options?: Readonly<AxProgramForwardOptions<any>>\n): AxGen<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n  const typedSignature = AxSignature.create(signature);\n  return new AxGen(typedSignature, options);\n}\n", "/**\n * Analyzes mapping functions to extract state dependencies.\n *\n * This class is crucial for the automatic parallelization feature of AxFlow.\n * It determines which fields in the state object a mapping function accesses,\n * which allows the execution planner to understand dependencies between steps\n * and optimize execution by running independent steps in parallel.\n *\n * The analyzer uses two complementary approaches:\n * 1. Static analysis of the function source code\n * 2. Dynamic proxy-based tracking as a fallback\n *\n * This dual approach ensures robust dependency detection even for complex\n * mapping functions that might use destructuring, computed property access,\n * or other advanced JavaScript patterns.\n */\nexport class AxFlowDependencyAnalyzer {\n  /**\n   * Analyzes a mapping function to determine which state fields it depends on.\n   *\n   * This method is called for every execute step to understand what data\n   * the step needs from the current state. This information is used to:\n   * - Build the dependency graph for parallel execution\n   * - Ensure steps execute in the correct order\n   * - Optimize performance by identifying independent operations\n   *\n   * The analysis process:\n   * 1. First tries static analysis by parsing the function source\n   * 2. Falls back to proxy-based tracking for complex cases\n   * 3. Returns a list of field names that the mapping function accesses\n   *\n   * @param mapping - The mapping function that transforms state to node inputs\n   * @param _nodeName - The name of the node (currently unused but kept for future use)\n   * @returns Array of field names that the mapping function depends on\n   *\n   * @example\n   * ```typescript\n   * // For a mapping like: state => ({ query: state.userInput, context: state.previousResult })\n   * // This would return: ['userInput', 'previousResult']\n   * ```\n   */\n  analyzeMappingDependencies(\n    mapping: (state: any) => any,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _nodeName: string\n  ): string[] {\n    // Handle null/undefined mapping functions\n    if (!mapping || typeof mapping !== 'function') {\n      return [];\n    }\n\n    const dependencies: string[] = [];\n\n    try {\n      // Method 1: Static analysis of function source\n      // This approach parses the function's source code to find property access patterns\n      // It's fast and works for most common cases like state.fieldName\n      const source = mapping.toString();\n      const stateAccessMatches = Array.from(source.matchAll(/state\\.(\\w+)/g));\n      for (const match of stateAccessMatches) {\n        if (match[1] && !dependencies.includes(match[1])) {\n          dependencies.push(match[1]);\n        }\n      }\n\n      // Method 2: Proxy-based tracking (fallback for complex cases)\n      // This approach actually calls the mapping function with a proxy object\n      // that tracks all property access, catching cases that static analysis might miss\n      // Examples: destructuring, computed properties, nested access patterns\n      if (dependencies.length === 0) {\n        try {\n          const tracker = this.createDependencyTracker(dependencies);\n          mapping(tracker);\n        } catch {\n          // Expected - we're just tracking access patterns, not executing the logic\n          // The function may throw errors when called with our proxy, but that's OK\n        }\n      }\n    } catch (error) {\n      // If any error occurs during analysis, return empty dependencies\n      console.debug('Dependency analysis failed:', error);\n    }\n\n    return dependencies;\n  }\n\n  /**\n   * Creates a tracking proxy for dependency analysis.\n   *\n   * This is a public method that creates a proxy to track property access patterns.\n   * It's used for testing and advanced dependency analysis scenarios.\n   *\n   * @param target - The target object to wrap with a proxy\n   * @param accessed - Array to collect accessed property names\n   * @returns Proxy object that tracks property access\n   */\n  createTrackingProxy(target: any, accessed: string[]): any {\n    const self = this;\n    return new Proxy(target, {\n      get(obj, prop) {\n        if (typeof prop === 'string' && !accessed.includes(prop)) {\n          accessed.push(prop);\n        }\n\n        const value = obj[prop];\n\n        // Return nested proxies for objects to track deeper access\n        if (value && typeof value === 'object') {\n          return self.createTrackingProxy(value, accessed);\n        }\n\n        return value;\n      },\n\n      has(obj, prop) {\n        if (typeof prop === 'string' && !accessed.includes(prop)) {\n          accessed.push(prop);\n        }\n        return prop in obj;\n      },\n    });\n  }\n\n  /**\n   * Parses function source code to extract state dependencies using static analysis.\n   *\n   * This method analyzes the source code of a function to find patterns like\n   * `state.fieldName` and extracts the field names as dependencies.\n   *\n   * @param functionSource - The source code of the function to analyze\n   * @returns Array of field names found in the source code\n   */\n  parseStaticDependencies(functionSource: string): string[] {\n    const dependencies: string[] = [];\n\n    try {\n      // Match state.fieldName patterns\n      const stateAccessMatches = Array.from(\n        functionSource.matchAll(/state\\.(\\w+)/g)\n      );\n      for (const match of stateAccessMatches) {\n        if (match[1] && !dependencies.includes(match[1])) {\n          dependencies.push(match[1]);\n        }\n      }\n\n      // Match template literal patterns ${state.fieldName}\n      const templateMatches = Array.from(\n        functionSource.matchAll(/\\$\\{state\\.(\\w+)\\}/g)\n      );\n      for (const match of templateMatches) {\n        if (match[1] && !dependencies.includes(match[1])) {\n          dependencies.push(match[1]);\n        }\n      }\n\n      // Match destructuring patterns\n      const destructureMatches = Array.from(\n        functionSource.matchAll(/\\{\\s*(\\w+)(?:\\s*,\\s*(\\w+))*\\s*\\}\\s*=\\s*state/g)\n      );\n      for (const match of destructureMatches) {\n        for (let i = 1; i < match.length; i++) {\n          if (match[i] && !dependencies.includes(match[i])) {\n            dependencies.push(match[i]);\n          }\n        }\n      }\n    } catch (error) {\n      // If parsing fails, return empty array\n      console.debug('Static dependency parsing failed:', error);\n    }\n\n    return dependencies;\n  }\n\n  /**\n   * Creates a proxy object that tracks property access for dependency analysis.\n   *\n   * This proxy intercepts all property access on the state object and records\n   * which fields are being accessed. It's used as a fallback when static analysis\n   * can't determine dependencies (e.g., for destructuring or computed properties).\n   *\n   * The proxy works by:\n   * 1. Intercepting all property access via the 'get' trap\n   * 2. Recording accessed property names in the dependencies array\n   * 3. Returning nested proxies for chained property access\n   *\n   * This allows detection of complex access patterns like:\n   * - Destructuring: const { field1, field2 } = state\n   * - Computed properties: state[dynamicKey]\n   * - Nested access: state.nested.field\n   *\n   * @param dependencies - Array to collect dependency names (modified in place)\n   * @returns Proxy object that tracks property access\n   */\n  private createDependencyTracker(dependencies: string[]): any {\n    return new Proxy(\n      {},\n      {\n        get(_target, prop) {\n          // Record this property access if it's a string and not already recorded\n          if (typeof prop === 'string' && !dependencies.includes(prop)) {\n            dependencies.push(prop);\n          }\n\n          // Return another proxy for nested access patterns\n          // This allows tracking of chained property access like state.nested.field\n          return new Proxy(\n            {},\n            {\n              get: () => undefined, // Always return undefined for nested access\n            }\n          );\n        },\n      }\n    );\n  }\n}\n", "/**\n * Utility functions for batch processing in parallel operations\n */\n\n/**\n * Processes an array of promises in batches with concurrency control\n *\n * @param items - Array of items to process\n * @param processor - Function that converts item to promise\n * @param batchSize - Number of items to process in each batch (default: unlimited)\n * @returns Promise that resolves to array of results in original order\n */\nexport async function processBatches<T, R>(\n  items: T[],\n  processor: (item: T, index: number) => Promise<R>,\n  batchSize?: number\n): Promise<R[]> {\n  // If no batch size specified, process all at once\n  if (!batchSize || batchSize <= 0 || batchSize >= items.length) {\n    const promises = items.map((item, index) => processor(item, index));\n    return Promise.all(promises);\n  }\n\n  const results: R[] = new Array(items.length);\n\n  // Process items in batches\n  for (let i = 0; i < items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize);\n    const batchPromises = batch.map((item, batchIndex) => {\n      const originalIndex = i + batchIndex;\n      return processor(item, originalIndex).then((result) => ({\n        result,\n        originalIndex,\n      }));\n    });\n\n    const batchResults = await Promise.all(batchPromises);\n\n    // Place results in correct positions\n    for (const { result, originalIndex } of batchResults) {\n      results[originalIndex] = result;\n    }\n  }\n\n  return results;\n}\n\n/**\n * Chunks an array into smaller arrays of specified size\n *\n * @param array - Array to chunk\n * @param chunkSize - Size of each chunk\n * @returns Array of chunks\n */\nexport function chunk<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    return [array];\n  }\n\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    chunks.push(array.slice(i, i + chunkSize));\n  }\n  return chunks;\n}\n", "import { processBatches } from './batchUtil.js';\nimport { AxFlowDependencyAnalyzer } from './dependencyAnalyzer.js';\nimport type {\n  AxFlowExecutionStep,\n  AxFlowParallelGroup,\n  AxFlowStepFunction,\n} from './types.js';\n\n/**\n * Builds and manages the execution plan with automatic parallelization.\n *\n * This class is the core of AxFlow's performance optimization system.\n * It analyzes the dependency relationships between steps and creates\n * an optimized execution plan that maximizes parallelism while ensuring\n * correct execution order.\n *\n * Key responsibilities:\n * 1. **Dependency Analysis**: Tracks what fields each step depends on and produces\n * 2. **Parallel Grouping**: Groups independent steps that can run simultaneously\n * 3. **Execution Optimization**: Creates optimized execution functions that\n *    run parallel groups concurrently\n * 4. **Signature Inference**: Provides data for automatic signature generation\n *\n * The planner works by building a directed acyclic graph (DAG) of dependencies\n * and then creating execution levels where all steps in a level can run in parallel.\n */\nexport class AxFlowExecutionPlanner {\n  private steps: AxFlowExecutionStep[] = [];\n  private parallelGroups: AxFlowParallelGroup[] = [];\n  private readonly analyzer = new AxFlowDependencyAnalyzer();\n  private initialFields: Set<string> = new Set();\n\n  /**\n   * Adds an execution step to the plan for analysis and optimization.\n   *\n   * This method is called for every operation in the flow (execute, map, merge, etc.)\n   * and performs dependency analysis to understand what the step needs and produces.\n   * This information is crucial for building the parallel execution plan.\n   *\n   * The method handles different types of steps:\n   * - **Execute steps**: LLM node operations that depend on specific state fields\n   * - **Map steps**: Transformations that modify the state object\n   * - **Merge steps**: Operations that combine results from branches or parallel operations\n   * - **Other steps**: Generic operations that don't fit other categories\n   *\n   * @param stepFunction - The actual function to execute for this step\n   * @param nodeName - Name of the node (for execute steps)\n   * @param mapping - Function that maps state to node inputs (for execute steps)\n   * @param stepType - Type of step for specialized analysis\n   * @param mapTransform - Transformation function (for map steps)\n   * @param mergeOptions - Options for merge operations (result key, merge function)\n   */\n  addExecutionStep(\n    stepFunction: AxFlowStepFunction,\n    nodeName?: string,\n    mapping?: (state: any) => any,\n    stepType?:\n      | 'execute'\n      | 'map'\n      | 'merge'\n      | 'parallel-map'\n      | 'parallel'\n      | 'derive',\n    mapTransform?: (state: any) => any,\n    mergeOptions?: {\n      resultKey?: string;\n      mergeFunction?: (...args: any[]) => any;\n    },\n    deriveOptions?: {\n      inputFieldName: string;\n      outputFieldName: string;\n      batchSize?: number;\n    }\n  ): void {\n    let dependencies: string[] = [];\n    let produces: string[] = [];\n    let type:\n      | 'execute'\n      | 'map'\n      | 'merge'\n      | 'parallel-map'\n      | 'parallel'\n      | 'derive' = stepType || 'map';\n\n    if (nodeName && mapping) {\n      type = 'execute';\n      dependencies = this.analyzer.analyzeMappingDependencies(\n        mapping,\n        nodeName\n      );\n      // For execute steps, we know the result will be stored as `${nodeName}Result`\n      produces = [`${nodeName}Result`];\n    } else if (type === 'map' && mapTransform) {\n      // Analyze map transformation to determine what fields it produces\n      const mapOutputFields = this.analyzeMapTransformation(mapTransform);\n      produces = mapOutputFields;\n      dependencies = this.getAllProducedFields();\n    } else if (type === 'parallel-map') {\n      // Parallel map operations produce fields from all transforms\n      if (Array.isArray(mapTransform)) {\n        // Multiple transforms - analyze each one\n        const allFields = new Set<string>();\n        for (const transform of mapTransform) {\n          const fields = this.analyzeMapTransformation(transform);\n          fields.forEach((f) => allFields.add(f));\n        }\n        produces = Array.from(allFields);\n      } else if (mapTransform) {\n        // Single transform\n        produces = this.analyzeMapTransformation(mapTransform);\n      } else {\n        // No transform provided, use default\n        produces = ['_parallelMapResult'];\n      }\n      dependencies = this.getAllProducedFields();\n    } else if (type === 'merge') {\n      // Merge operations produce their result key or merge all previous results\n      if (mergeOptions?.resultKey) {\n        produces = [mergeOptions.resultKey];\n      } else {\n        // Branch merge - analyze what fields the branches produce\n        const branchFields = this.analyzeBranchMergeFields();\n        produces = branchFields.length > 0 ? branchFields : ['_mergedResult'];\n      }\n\n      // Check if this is a parallel merge step by looking at the function code\n      const funcCode = stepFunction.toString();\n      if (funcCode.includes('_parallelResults')) {\n        dependencies = ['_parallelResults'];\n      } else {\n        dependencies = this.getAllProducedFields();\n      }\n    } else if (type === 'parallel') {\n      // Parallel operations produce _parallelResults for merge step\n      produces = ['_parallelResults'];\n      dependencies = this.getAllProducedFields();\n    } else if (type === 'derive') {\n      // Derive operations produce the specified output field and depend on the input field\n      if (deriveOptions?.outputFieldName && deriveOptions?.inputFieldName) {\n        produces = [deriveOptions.outputFieldName];\n        // Also analyze the transform function for other dependencies\n        const otherDependencies = mapTransform\n          ? this.analyzer.analyzeMappingDependencies(mapTransform, 'derive')\n          : [];\n        dependencies = [\n          deriveOptions.inputFieldName,\n          ...otherDependencies,\n        ].filter((v, i, a) => a.indexOf(v) === i); // Ensure uniqueness\n      } else {\n        // Fallback if options not provided properly\n        produces = ['_deriveResult'];\n        dependencies = this.getAllProducedFields();\n      }\n    } else if (stepFunction.toString().includes('transform(')) {\n      type = 'map';\n      // Fallback: Map steps are harder to analyze statically, assume they depend on all previous steps\n      dependencies = this.getAllProducedFields();\n      produces = ['_mapResult'];\n    } else if (stepFunction.toString().includes('_parallelResults')) {\n      // This is likely a parallel step that produces _parallelResults\n      produces = ['_parallelResults'];\n      dependencies = this.getAllProducedFields();\n    }\n\n    // Infer initial fields from dependencies\n    // A field is an initial field if it's consumed by a step but not produced by any previous step\n    for (const dep of dependencies) {\n      if (!this.getAllProducedFields().includes(dep)) {\n        this.initialFields.add(dep);\n      }\n    }\n\n    const step: AxFlowExecutionStep = {\n      type,\n      nodeName,\n      dependencies,\n      produces,\n      stepFunction,\n      stepIndex: this.steps.length,\n    };\n\n    this.steps.push(step);\n    // Don't rebuild parallel groups during construction - only after initial fields are set\n    // this.rebuildParallelGroups()\n  }\n\n  /**\n   * Analyzes a step function to determine what fields it produces.\n   *\n   * This method analyzes the step function to understand what new fields\n   * it adds to the state. It uses a mock state approach:\n   * 1. Creates a mock state with sample data\n   * 2. Runs the step function on the mock state\n   * 3. Compares the result to see what fields were added\n   *\n   * @param stepFunction - The step function to analyze\n   * @returns Array of field names that the step function produces\n   */\n  private analyzeStepFunctionProduction(\n    stepFunction: AxFlowStepFunction\n  ): string[] {\n    // For step functions, we should primarily rely on source analysis\n    // since they might contain complex AI operations that we can't mock safely\n    try {\n      const sourceAnalysis = this.analyzeStepFunctionSource(stepFunction);\n      if (\n        sourceAnalysis.length > 0 &&\n        !sourceAnalysis.includes('_stepResult')\n      ) {\n        return sourceAnalysis;\n      }\n    } catch (error) {\n      console.debug('Step function source analysis failed:', error);\n    }\n\n    // Only try dynamic analysis for simple functions\n    try {\n      const mockState = this.createMockState();\n      const originalKeys = Object.keys(mockState);\n\n      // Create a mock context for the step function\n      const mockContext = {\n        mainAi: {\n          getOptions: () => ({ trace: false }),\n          forward: () => Promise.resolve({ text: 'mock' }),\n        } as any,\n        mainOptions: undefined,\n      };\n\n      const result = stepFunction(mockState, mockContext);\n\n      // Handle async functions\n      if (result && typeof result === 'object' && 'then' in result) {\n        // For async functions, we can't easily determine the output\n        // Fall back to analyzing the function source code\n        return this.analyzeStepFunctionSource(stepFunction);\n      }\n\n      if (result && typeof result === 'object' && !Array.isArray(result)) {\n        const newKeys = Object.keys(result);\n        const addedFields = newKeys.filter(\n          (key) => !originalKeys.includes(key)\n        );\n        if (addedFields.length > 0) {\n          return addedFields;\n        }\n      }\n    } catch (error) {\n      // If analysis fails, fall back to source analysis\n      console.debug('Step function dynamic analysis failed:', error);\n    }\n\n    return this.analyzeStepFunctionSource(stepFunction);\n  }\n\n  /**\n   * Analyzes step function source code to determine what fields it produces.\n   *\n   * @param stepFunction - The step function to analyze\n   * @returns Array of field names that the step function produces\n   */\n  private analyzeStepFunctionSource(\n    stepFunction: AxFlowStepFunction\n  ): string[] {\n    try {\n      const source = stepFunction.toString();\n\n      // Look for patterns like: { ...state, fieldName: value }\n      const fieldAssignments = source.match(\n        /\\{\\s*\\.\\.\\.state\\s*,\\s*(\\w+)\\s*:/g\n      );\n      if (fieldAssignments) {\n        const fields = fieldAssignments\n          .map((assignment) => {\n            const match = assignment.match(/(\\w+)\\s*:/);\n            return match ? match[1] : null;\n          })\n          .filter(Boolean);\n\n        if (fields.length > 0) {\n          return fields as string[];\n        }\n      }\n\n      // Look for direct property assignments like: state.fieldName = value\n      const propertyAssignments = source.match(/state\\.(\\w+)\\s*=/g);\n      if (propertyAssignments) {\n        const fields = propertyAssignments\n          .map((assignment) => {\n            const match = assignment.match(/state\\.(\\w+)\\s*=/);\n            return match ? match[1] : null;\n          })\n          .filter(Boolean);\n\n        if (fields.length > 0) {\n          return fields as string[];\n        }\n      }\n    } catch (error) {\n      console.debug('Step function source analysis failed:', error);\n    }\n\n    // Fallback to a generic field name\n    return ['_stepResult'];\n  }\n\n  /**\n   * Analyzes a map transformation function to determine what fields it produces.\n   *\n   * This is a challenging problem because map transformations can produce arbitrary\n   * new fields based on complex logic. The method uses a mock state approach:\n   * 1. Creates a mock state with sample data\n   * 2. Runs the transformation on the mock state\n   * 3. Analyzes the result to see what fields were produced\n   *\n   * This approach works for most common transformation patterns but may miss\n   * edge cases where the transformation behavior depends on specific data values.\n   *\n   * @param mapTransform - The map transformation function to analyze\n   * @returns Array of field names that the transformation produces\n   */\n  private analyzeMapTransformation(\n    mapTransform: (state: any) => any\n  ): string[] {\n    try {\n      // Create a mock state with sample data to analyze the transformation\n      const mockState = this.createMockState();\n      const result = mapTransform(mockState);\n\n      if (result && typeof result === 'object' && !Array.isArray(result)) {\n        return Object.keys(result);\n      }\n    } catch (error) {\n      // If analysis fails, return a generic field name\n      console.debug('Map transformation analysis failed:', error);\n    }\n\n    return ['_mapResult'];\n  }\n\n  /**\n   * Creates a mock state with sample data for transformation analysis.\n   *\n   * This method builds a representative state object that includes:\n   * - Initial fields from the flow input\n   * - Result fields from previous steps with realistic structure\n   * - Sample data that allows transformations to execute\n   *\n   * The mock state is used to run map transformations in a controlled\n   * environment to determine what fields they produce.\n   *\n   * @returns Mock state object with sample data\n   */\n  private createMockState(): any {\n    const mockState: any = {};\n\n    // Add initial fields\n    for (const field of this.initialFields) {\n      mockState[field] = this.createMockValue(field);\n    }\n\n    // Add produced fields from previous steps\n    for (const step of this.steps) {\n      for (const field of step.produces) {\n        if (field.endsWith('Result')) {\n          mockState[field] = {\n            // Add common result field patterns\n            text: 'mockText',\n            value: 'mockValue',\n            result: 'mockResult',\n            data: 'mockData',\n            // Add specific field names that tests might expect\n            processedText: 'mockProcessedText',\n            sentimentValue: 'mockSentiment',\n            confidenceScore: 0.8,\n            isComplex: false,\n            mockValue: 'mockValue',\n            responseText: 'mockResponseText',\n            inputText: 'mockInputText',\n          };\n        } else {\n          mockState[field] = this.createMockValue(field);\n        }\n      }\n    }\n\n    return mockState;\n  }\n\n  /**\n   * Creates appropriate mock values based on field names and patterns.\n   */\n  private createMockValue(fieldName: string): any {\n    // Handle array fields\n    if (\n      fieldName.includes('List') ||\n      fieldName.includes('Array') ||\n      fieldName.endsWith('s')\n    ) {\n      return ['mockItem1', 'mockItem2'];\n    }\n\n    // Handle numeric fields\n    if (\n      fieldName.includes('count') ||\n      fieldName.includes('Count') ||\n      fieldName.includes('index') ||\n      fieldName.includes('Index')\n    ) {\n      return 0;\n    }\n\n    // Handle boolean fields\n    if (\n      fieldName.includes('is') ||\n      fieldName.includes('has') ||\n      fieldName.includes('can')\n    ) {\n      return false;\n    }\n\n    // Default to string\n    return 'mockValue';\n  }\n\n  /**\n   * Analyzes what fields are produced by conditional merge operations.\n   *\n   * Conditional merges are complex because they don't transform data like map operations,\n   * but instead select which branch's results to use based on a condition.\n   * The challenge is determining what fields will be available after the merge\n   * without knowing which branch will be taken at runtime.\n   *\n   * This method uses heuristics to determine the likely output fields:\n   * 1. Look at recent execute steps (likely branch operations)\n   * 2. If found, use their output fields as potential merge results\n   * 3. Fallback to all execute step fields if no recent pattern is found\n   *\n   * The analysis assumes that branches in a conditional merge will produce\n   * similar types of fields, so we can use any branch's fields as representative\n   * of what the merge might produce.\n   *\n   * @returns string[] - Array of field names that the merge operation might produce\n   */\n  private analyzeBranchMergeFields(): string[] {\n    // Look at the last few steps to find execute steps that would be merged\n    // We focus on recent steps because they're more likely to be part of the\n    // current branch structure being merged\n    const recentExecuteSteps = this.steps\n      .slice(-5) // Look at last 5 steps\n      .filter((step) => step.type === 'execute' && step.nodeName)\n      .flatMap((step) => step.produces);\n\n    if (recentExecuteSteps.length > 0) {\n      return recentExecuteSteps;\n    }\n\n    // Fallback: return all execute step fields\n    // This is a broader approach when we can't identify recent branch patterns\n    // It includes all possible fields that could be produced by any node\n    return this.steps\n      .filter((step) => step.type === 'execute' && step.nodeName)\n      .flatMap((step) => step.produces);\n  }\n\n  /**\n   * Sets the initial fields and triggers parallel group rebuilding.\n   *\n   * This method is called once the flow knows what input fields are available.\n   * It triggers the parallel group analysis which determines the optimal\n   * execution strategy for the entire flow.\n   *\n   * @param fields - Array of field names available at the start of execution\n   */\n  setInitialFields(fields: string[]): void {\n    this.initialFields = new Set(fields);\n    this.rebuildParallelGroups();\n  }\n\n  /**\n   * Rebuilds the parallel execution groups based on step dependencies.\n   *\n   * This is the core algorithm that creates the parallel execution plan.\n   * It uses a level-by-level approach:\n   *\n   * 1. **Level 0**: Steps with no dependencies (can run immediately)\n   * 2. **Level 1**: Steps that depend only on Level 0 outputs\n   * 3. **Level N**: Steps that depend on outputs from previous levels\n   *\n   * Steps within the same level can run in parallel because they don't\n   * depend on each other's outputs.\n   *\n   * The algorithm ensures:\n   * - Correct execution order (dependencies are satisfied)\n   * - Maximum parallelism (independent steps run simultaneously)\n   * - Deadlock prevention (circular dependencies are detected)\n   *\n   * Time complexity: O(n) where n is the number of steps\n   * Space complexity: O(n) for tracking processed steps and available fields\n   */\n  private rebuildParallelGroups(): void {\n    this.parallelGroups = [];\n    const processedSteps = new Set<number>();\n    const availableFields = new Set<string>(this.initialFields);\n    let currentLevel = 0;\n\n    while (processedSteps.size < this.steps.length) {\n      const currentLevelSteps: AxFlowExecutionStep[] = [];\n\n      // Find all steps that can run at this level\n      for (const step of this.steps) {\n        if (processedSteps.has(step.stepIndex)) continue;\n\n        // Check if all dependencies are available\n        const canRun =\n          step.dependencies.length === 0 ||\n          step.dependencies.every((dep) => availableFields.has(dep));\n\n        if (canRun) {\n          // Special handling for merge steps - they should run in their own group\n          // to ensure they see the results from the previous parallel step\n          if (step.type === 'merge' && currentLevelSteps.length > 0) {\n            // Don't add merge step to current level if there are already steps\n            // It will be picked up in the next iteration\n            continue;\n          }\n\n          currentLevelSteps.push(step);\n          processedSteps.add(step.stepIndex);\n\n          // If this is a merge step, don't add any more steps to this level\n          if (step.type === 'merge') {\n            break;\n          }\n        }\n      }\n\n      if (currentLevelSteps.length > 0) {\n        // Add all produced fields from this level to available fields\n        for (const step of currentLevelSteps) {\n          step.produces.forEach((field) => availableFields.add(field));\n        }\n\n        this.parallelGroups.push({\n          level: currentLevel,\n          steps: currentLevelSteps,\n        });\n        currentLevel++;\n      } else {\n        // No progress made - try to add steps that haven't been processed yet\n        // This handles cases where dependencies might not be perfectly resolved\n        const remainingSteps = this.steps.filter(\n          (step) => !processedSteps.has(step.stepIndex)\n        );\n\n        if (remainingSteps.length > 0) {\n          // Add the first remaining step to make progress\n          const nextStep = remainingSteps[0];\n          processedSteps.add(nextStep.stepIndex);\n\n          // Add produced fields to available fields\n          nextStep.produces.forEach((field) => availableFields.add(field));\n\n          this.parallelGroups.push({\n            level: currentLevel,\n            steps: [nextStep],\n          });\n          currentLevel++;\n        } else {\n          // No remaining steps, we're done\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Gets all fields produced by previous steps.\n   *\n   * This is used by steps that depend on \"everything produced so far\"\n   * such as map transformations and merge operations.\n   *\n   * @returns Array of all field names produced by previous steps\n   */\n  private getAllProducedFields(): string[] {\n    const fields: string[] = [];\n    for (const step of this.steps) {\n      fields.push(...step.produces);\n    }\n    return fields;\n  }\n\n  /**\n   * Creates optimized execution functions that implement the parallel execution plan.\n   *\n   * This method converts the parallel groups into actual executable functions.\n   * It creates a series of steps where:\n   * - Single-step groups execute directly\n   * - Multi-step groups execute in parallel with batch size control\n   * - Results are properly merged to maintain state consistency\n   *\n   * The optimized execution can significantly improve performance for flows\n   * with independent operations, especially I/O-bound operations like LLM calls.\n   *\n   * Performance benefits:\n   * - Reduces total execution time for independent operations\n   * - Maximizes CPU and I/O utilization\n   * - Maintains correctness through dependency management\n   * - Controls resource usage through batch size limiting\n   *\n   * @param batchSize - Maximum number of concurrent operations (optional)\n   * @returns Array of optimized step functions ready for execution\n   */\n  createOptimizedExecution(batchSize?: number): AxFlowStepFunction[] {\n    const optimizedSteps: AxFlowStepFunction[] = [];\n\n    for (const group of this.parallelGroups) {\n      if (group.steps.length === 1) {\n        // Single step - execute directly\n        const step = group.steps[0];\n        if (step) {\n          optimizedSteps.push(step.stepFunction);\n        }\n      } else if (group.steps.length > 1) {\n        // Multiple steps - execute in parallel with batch size control\n        const parallelStep: AxFlowStepFunction = async (state, context) => {\n          const results = await processBatches(\n            group.steps,\n            async (step) => {\n              return await step.stepFunction(state, context);\n            },\n            batchSize\n          );\n\n          // Check if any step produces _parallelResults (indicates this is a parallel flow)\n          const hasParallelResults = results.some(\n            (result) =>\n              result &&\n              typeof result === 'object' &&\n              '_parallelResults' in result\n          );\n\n          if (hasParallelResults) {\n            // Find the step that produced _parallelResults and return it directly\n            const parallelResult = results.find(\n              (result) =>\n                result &&\n                typeof result === 'object' &&\n                '_parallelResults' in result\n            );\n            if (parallelResult) {\n              // Return the parallel result directly - the merge step will handle cleanup\n              return parallelResult;\n            }\n            return state;\n          }\n\n          // Merge all results for regular parallel execution\n          let mergedState = state;\n          for (const result of results) {\n            mergedState = { ...mergedState, ...result };\n          }\n\n          return mergedState;\n        };\n\n        optimizedSteps.push(parallelStep);\n      }\n    }\n\n    return optimizedSteps;\n  }\n\n  /**\n   * Gets optimized execution steps for the flow.\n   *\n   * This method provides the optimized execution steps that can be used\n   * to execute the flow with maximum parallelism while maintaining\n   * dependency order.\n   *\n   * @returns Array of optimized step functions ready for execution\n   */\n  getOptimizedExecutionSteps(): AxFlowStepFunction[] {\n    // If parallel groups haven't been built yet, build them with empty initial fields\n    if (this.parallelGroups.length === 0 && this.steps.length > 0) {\n      this.rebuildParallelGroups();\n    }\n    return this.createOptimizedExecution();\n  }\n\n  /**\n   * Gets detailed execution plan information for debugging and analysis.\n   *\n   * This method provides comprehensive information about the execution plan,\n   * including step counts, parallel grouping details, and the complete\n   * dependency structure. It's particularly useful for:\n   * - Debugging execution flow issues\n   * - Performance analysis and optimization\n   * - Understanding parallelization effectiveness\n   * - Monitoring execution plan complexity\n   *\n   * @returns Object containing detailed execution plan metrics and data\n   */\n  getExecutionPlan(): {\n    totalSteps: number;\n    parallelGroups: number;\n    maxParallelism: number;\n    steps: AxFlowExecutionStep[];\n    groups: AxFlowParallelGroup[];\n  } {\n    // If parallel groups haven't been built yet, build them with empty initial fields\n    if (this.parallelGroups.length === 0 && this.steps.length > 0) {\n      this.rebuildParallelGroups();\n    }\n\n    return {\n      totalSteps: this.steps.length,\n      parallelGroups: this.parallelGroups.length,\n      maxParallelism:\n        this.steps.length === 0\n          ? 1\n          : Math.max(...this.parallelGroups.map((g) => g.steps.length), 0),\n      steps: this.steps,\n      groups: this.parallelGroups,\n    };\n  }\n}\n", "import { ColorLog } from '../util/log.js';\nimport type { AxFlowState } from './types.js';\n\n/**\n * Data types for different AxFlow logging events\n */\nexport interface AxFlowLoggerData {\n  name: string;\n  timestamp: number;\n  [key: string]: unknown;\n}\n\nexport interface AxFlowStartData extends AxFlowLoggerData {\n  name: 'FlowStart';\n  inputFields: string[];\n  totalSteps: number;\n  parallelGroups: number;\n  maxParallelism: number;\n  autoParallelEnabled: boolean;\n}\n\nexport interface AxFlowStepStartData extends AxFlowLoggerData {\n  name: 'StepStart';\n  stepIndex: number;\n  stepType:\n    | 'execute'\n    | 'map'\n    | 'merge'\n    | 'parallel-map'\n    | 'parallel'\n    | 'derive'\n    | 'branch'\n    | 'feedback'\n    | 'while'\n    | 'other';\n  nodeName?: string;\n  dependencies: string[];\n  produces: string[];\n  state: AxFlowState;\n}\n\nexport interface AxFlowStepCompleteData extends AxFlowLoggerData {\n  name: 'StepComplete';\n  stepIndex: number;\n  stepType:\n    | 'execute'\n    | 'map'\n    | 'merge'\n    | 'parallel-map'\n    | 'parallel'\n    | 'derive'\n    | 'branch'\n    | 'feedback'\n    | 'while'\n    | 'other';\n  nodeName?: string;\n  executionTime: number;\n  state: AxFlowState;\n  newFields?: string[];\n  result?: any;\n}\n\nexport interface AxFlowParallelGroupStartData extends AxFlowLoggerData {\n  name: 'ParallelGroupStart';\n  groupLevel: number;\n  stepsCount: number;\n  stepTypes: string[];\n}\n\nexport interface AxFlowParallelGroupCompleteData extends AxFlowLoggerData {\n  name: 'ParallelGroupComplete';\n  groupLevel: number;\n  stepsCount: number;\n  executionTime: number;\n}\n\nexport interface AxFlowBranchEvaluationData extends AxFlowLoggerData {\n  name: 'BranchEvaluation';\n  branchValue: unknown;\n  hasMatchingBranch: boolean;\n  branchStepsCount: number;\n}\n\nexport interface AxFlowCompleteData extends AxFlowLoggerData {\n  name: 'FlowComplete';\n  totalExecutionTime: number;\n  finalState: AxFlowState;\n  outputFields: string[];\n  stepsExecuted: number;\n}\n\nexport interface AxFlowErrorData extends AxFlowLoggerData {\n  name: 'FlowError';\n  error: string;\n  stepIndex?: number;\n  stepType?: string;\n  nodeName?: string;\n  state?: AxFlowState;\n}\n\nexport type AxFlowLogData =\n  | AxFlowStartData\n  | AxFlowStepStartData\n  | AxFlowStepCompleteData\n  | AxFlowParallelGroupStartData\n  | AxFlowParallelGroupCompleteData\n  | AxFlowBranchEvaluationData\n  | AxFlowCompleteData\n  | AxFlowErrorData;\n\n/**\n * Function type for AxFlow logging\n */\nexport type AxFlowLoggerFunction = (data: AxFlowLogData) => void;\n\n// Default output function that writes to stdout\nconst defaultOutput = (message: string): void => {\n  console.log(message);\n};\n\n/**\n * Formats state object for display, truncating large values\n */\nconst formatState = (state: AxFlowState, hideContent = false): string => {\n  if (hideContent) return '[State hidden]';\n\n  const formatted: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(state)) {\n    if (typeof value === 'string' && value.length > 100) {\n      formatted[key] = `${value.substring(0, 100)}...`;\n    } else if (Array.isArray(value) && value.length > 3) {\n      formatted[key] = [...value.slice(0, 3), `... (${value.length - 3} more)`];\n    } else if (typeof value === 'object' && value !== null) {\n      const objStr = JSON.stringify(value);\n      if (objStr.length > 200) {\n        formatted[key] = `${objStr.substring(0, 200)}...`;\n      } else {\n        formatted[key] = value;\n      }\n    } else {\n      formatted[key] = value;\n    }\n  }\n  return JSON.stringify(formatted, null, 2);\n};\n\n/**\n * Formats execution time for display\n */\nconst formatTime = (ms: number): string => {\n  if (ms < 1000) return `${ms.toFixed(1)}ms`;\n  if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;\n  return `${(ms / 60000).toFixed(2)}min`;\n};\n\n/**\n * Factory function to create a colorized AxFlow logger\n */\nexport const axCreateFlowColorLogger = (\n  output: (message: string) => void = defaultOutput\n): AxFlowLoggerFunction => {\n  const cl = new ColorLog();\n  const divider = cl.gray(`${''.repeat(80)}\\n`);\n  const smallDivider = cl.gray(`${''.repeat(40)}\\n`);\n\n  return (data: AxFlowLogData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'FlowStart':\n        formattedMessage = `\\n${cl.blueBright(' [ AXFLOW START ]')}\\n${divider}`;\n        formattedMessage += `${cl.white('Input Fields:')} ${cl.cyan(data.inputFields.join(', '))}\\n`;\n        formattedMessage += `${cl.white('Total Steps:')} ${cl.yellow(data.totalSteps.toString())}\\n`;\n        formattedMessage += `${cl.white('Parallel Groups:')} ${cl.yellow(data.parallelGroups.toString())}\\n`;\n        formattedMessage += `${cl.white('Max Parallelism:')} ${cl.yellow(data.maxParallelism.toString())}\\n`;\n        formattedMessage += `${cl.white('Auto-Parallel:')} ${data.autoParallelEnabled ? cl.green('enabled') : cl.red('disabled')}\\n`;\n        formattedMessage += divider;\n        break;\n\n      case 'StepStart': {\n        const stepIcon =\n          data.stepType === 'execute'\n            ? ''\n            : data.stepType === 'map'\n              ? ''\n              : data.stepType === 'merge'\n                ? ''\n                : data.stepType === 'parallel'\n                  ? ''\n                  : '';\n        formattedMessage = `${cl.greenBright(`${stepIcon} [ STEP ${data.stepIndex} START ]`)} ${cl.white(`(${data.stepType})`)}`;\n        if (data.nodeName) {\n          formattedMessage += ` ${cl.cyanBright(`Node: ${data.nodeName}`)}`;\n        }\n        formattedMessage += '\\n';\n        if (data.dependencies.length > 0) {\n          formattedMessage += `${cl.white('Dependencies:')} ${cl.gray(data.dependencies.join(', '))}\\n`;\n        }\n        if (data.produces.length > 0) {\n          formattedMessage += `${cl.white('Produces:')} ${cl.cyan(data.produces.join(', '))}\\n`;\n        }\n        formattedMessage += `${cl.white('State:')} ${cl.gray(formatState(data.state, true))}\\n`;\n        formattedMessage += smallDivider;\n        break;\n      }\n\n      case 'StepComplete': {\n        const completeIcon =\n          data.stepType === 'execute'\n            ? ''\n            : data.stepType === 'map'\n              ? ''\n              : data.stepType === 'merge'\n                ? ''\n                : data.stepType === 'parallel'\n                  ? ''\n                  : '';\n        formattedMessage = `${cl.greenBright(`${completeIcon} [ STEP ${data.stepIndex} COMPLETE ]`)} ${cl.white(`(${data.stepType})`)}`;\n        if (data.nodeName) {\n          formattedMessage += ` ${cl.cyanBright(`Node: ${data.nodeName}`)}`;\n        }\n        formattedMessage += ` ${cl.magenta(`in ${formatTime(data.executionTime)}`)}\\n`;\n        if (data.newFields && data.newFields.length > 0) {\n          formattedMessage += `${cl.white('New Fields:')} ${cl.green(data.newFields.join(', '))}\\n`;\n        }\n        if (data.result && data.nodeName) {\n          formattedMessage += `${cl.white('Result:')} ${cl.yellow(JSON.stringify(data.result, null, 2))}\\n`;\n        }\n        formattedMessage += smallDivider;\n        break;\n      }\n\n      case 'ParallelGroupStart':\n        formattedMessage = `${cl.blueBright(' [ PARALLEL GROUP START ]')} ${cl.white(`Level ${data.groupLevel}`)}\\n`;\n        formattedMessage += `${cl.white('Steps:')} ${cl.yellow(data.stepsCount.toString())} ${cl.gray(`(${data.stepTypes.join(', ')})`)}\\n`;\n        formattedMessage += smallDivider;\n        break;\n\n      case 'ParallelGroupComplete':\n        formattedMessage = `${cl.blueBright(' [ PARALLEL GROUP COMPLETE ]')} ${cl.white(`Level ${data.groupLevel}`)}`;\n        formattedMessage += ` ${cl.magenta(`in ${formatTime(data.executionTime)}`)}\\n`;\n        formattedMessage += `${cl.white('Steps Executed:')} ${cl.yellow(data.stepsCount.toString())}\\n`;\n        formattedMessage += smallDivider;\n        break;\n\n      case 'BranchEvaluation':\n        formattedMessage = `${cl.yellow(' [ BRANCH EVALUATION ]')}\\n`;\n        formattedMessage += `${cl.white('Branch Value:')} ${cl.cyan(JSON.stringify(data.branchValue))}\\n`;\n        formattedMessage += `${cl.white('Has Matching Branch:')} ${data.hasMatchingBranch ? cl.green('yes') : cl.red('no')}\\n`;\n        if (data.hasMatchingBranch) {\n          formattedMessage += `${cl.white('Branch Steps:')} ${cl.yellow(data.branchStepsCount.toString())}\\n`;\n        }\n        formattedMessage += smallDivider;\n        break;\n\n      case 'FlowComplete':\n        formattedMessage = `\\n${cl.greenBright(' [ AXFLOW COMPLETE ]')}\\n${divider}`;\n        formattedMessage += `${cl.white('Total Time:')} ${cl.magenta(formatTime(data.totalExecutionTime))}\\n`;\n        formattedMessage += `${cl.white('Steps Executed:')} ${cl.yellow(data.stepsExecuted.toString())}\\n`;\n        formattedMessage += `${cl.white('Output Fields:')} ${cl.green(data.outputFields.join(', '))}\\n`;\n        formattedMessage += `${cl.white('Final State:')} ${cl.gray(formatState(data.finalState, true))}\\n`;\n        formattedMessage += divider;\n        break;\n\n      case 'FlowError':\n        formattedMessage = `\\n${cl.redBright(' [ AXFLOW ERROR ]')}\\n${divider}`;\n        if (data.stepIndex !== undefined) {\n          formattedMessage += `${cl.white('Step:')} ${cl.yellow(data.stepIndex.toString())}`;\n          if (data.stepType)\n            formattedMessage += ` ${cl.gray(`(${data.stepType})`)}`;\n          if (data.nodeName)\n            formattedMessage += ` ${cl.cyan(`Node: ${data.nodeName}`)}`;\n          formattedMessage += '\\n';\n        }\n        formattedMessage += `${cl.white('Error:')} ${cl.red(data.error)}\\n`;\n        if (data.state) {\n          formattedMessage += `${cl.white('State:')} ${cl.gray(formatState(data.state, true))}\\n`;\n        }\n        formattedMessage += divider;\n        break;\n\n      default:\n        formattedMessage = cl.gray(JSON.stringify(data, null, 2));\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Factory function to create a text-only AxFlow logger (no colors)\n */\nexport const axCreateFlowTextLogger = (\n  output: (message: string) => void = defaultOutput\n): AxFlowLoggerFunction => {\n  const divider = '='.repeat(80);\n  const smallDivider = '-'.repeat(40);\n\n  return (data: AxFlowLogData) => {\n    let formattedMessage = '';\n\n    switch (data.name) {\n      case 'FlowStart':\n        formattedMessage = `\\n[ AXFLOW START ]\\n${divider}\\n`;\n        formattedMessage += `Input Fields: ${data.inputFields.join(', ')}\\n`;\n        formattedMessage += `Total Steps: ${data.totalSteps}\\n`;\n        formattedMessage += `Parallel Groups: ${data.parallelGroups}\\n`;\n        formattedMessage += `Max Parallelism: ${data.maxParallelism}\\n`;\n        formattedMessage += `Auto-Parallel: ${data.autoParallelEnabled ? 'enabled' : 'disabled'}\\n`;\n        formattedMessage += `${divider}\\n`;\n        break;\n\n      case 'StepStart':\n        formattedMessage = `[ STEP ${data.stepIndex} START ] (${data.stepType})`;\n        if (data.nodeName) {\n          formattedMessage += ` Node: ${data.nodeName}`;\n        }\n        formattedMessage += '\\n';\n        if (data.dependencies.length > 0) {\n          formattedMessage += `Dependencies: ${data.dependencies.join(', ')}\\n`;\n        }\n        if (data.produces.length > 0) {\n          formattedMessage += `Produces: ${data.produces.join(', ')}\\n`;\n        }\n        formattedMessage += `State: ${formatState(data.state, true)}\\n`;\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'StepComplete':\n        formattedMessage = `[ STEP ${data.stepIndex} COMPLETE ] (${data.stepType})`;\n        if (data.nodeName) {\n          formattedMessage += ` Node: ${data.nodeName}`;\n        }\n        formattedMessage += ` in ${formatTime(data.executionTime)}\\n`;\n        if (data.newFields && data.newFields.length > 0) {\n          formattedMessage += `New Fields: ${data.newFields.join(', ')}\\n`;\n        }\n        if (data.result && data.nodeName) {\n          formattedMessage += `Result: ${JSON.stringify(data.result, null, 2)}\\n`;\n        }\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'ParallelGroupStart':\n        formattedMessage = `[ PARALLEL GROUP START ] Level ${data.groupLevel}\\n`;\n        formattedMessage += `Steps: ${data.stepsCount} (${data.stepTypes.join(', ')})\\n`;\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'ParallelGroupComplete':\n        formattedMessage = `[ PARALLEL GROUP COMPLETE ] Level ${data.groupLevel} in ${formatTime(data.executionTime)}\\n`;\n        formattedMessage += `Steps Executed: ${data.stepsCount}\\n`;\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'BranchEvaluation':\n        formattedMessage = `[ BRANCH EVALUATION ]\\n`;\n        formattedMessage += `Branch Value: ${JSON.stringify(data.branchValue)}\\n`;\n        formattedMessage += `Has Matching Branch: ${data.hasMatchingBranch ? 'yes' : 'no'}\\n`;\n        if (data.hasMatchingBranch) {\n          formattedMessage += `Branch Steps: ${data.branchStepsCount}\\n`;\n        }\n        formattedMessage += `${smallDivider}\\n`;\n        break;\n\n      case 'FlowComplete':\n        formattedMessage = `\\n[ AXFLOW COMPLETE ]\\n${divider}\\n`;\n        formattedMessage += `Total Time: ${formatTime(data.totalExecutionTime)}\\n`;\n        formattedMessage += `Steps Executed: ${data.stepsExecuted}\\n`;\n        formattedMessage += `Output Fields: ${data.outputFields.join(', ')}\\n`;\n        formattedMessage += `Final State: ${formatState(data.finalState, true)}\\n`;\n        formattedMessage += `${divider}\\n`;\n        break;\n\n      case 'FlowError':\n        formattedMessage = `\\n[ AXFLOW ERROR ]\\n${divider}\\n`;\n        if (data.stepIndex !== undefined) {\n          formattedMessage += `Step: ${data.stepIndex}`;\n          if (data.stepType) formattedMessage += ` (${data.stepType})`;\n          if (data.nodeName) formattedMessage += ` Node: ${data.nodeName}`;\n          formattedMessage += '\\n';\n        }\n        formattedMessage += `Error: ${data.error}\\n`;\n        if (data.state) {\n          formattedMessage += `State: ${formatState(data.state, true)}\\n`;\n        }\n        formattedMessage += `${divider}\\n`;\n        break;\n\n      default:\n        formattedMessage = JSON.stringify(data, null, 2);\n    }\n\n    output(formattedMessage);\n  };\n};\n\n/**\n * Default AxFlow logger with colors\n */\nexport const axDefaultFlowLogger: AxFlowLoggerFunction =\n  axCreateFlowColorLogger();\n\n/**\n * Helper function to create a timing wrapper around the logger\n */\nexport const createTimingLogger = (logger: AxFlowLoggerFunction) => {\n  const timingData = new Map<string, number>();\n\n  return {\n    logger,\n    startTiming: (key: string) => {\n      timingData.set(key, Date.now());\n    },\n    endTiming: (key: string): number => {\n      const start = timingData.get(key);\n      if (!start) return 0;\n      const duration = Date.now() - start;\n      timingData.delete(key);\n      return duration;\n    },\n    getCurrentTime: () => Date.now(),\n  };\n};\n", "import type { AxAIService } from '../ai/types.js';\nimport type { AxGen } from '../dsp/generate.js';\nimport type { AxProgram } from '../dsp/program.js';\nimport type {\n  AxFieldValue,\n  AxForwardable,\n  AxGenIn,\n  AxGenOut,\n  AxProgramForwardOptions,\n  AxTunable,\n  AxUsable,\n} from '../dsp/types.js';\nimport type {\n  AddNodeResult,\n  AxFlowDynamicContext,\n  AxFlowState,\n  AxFlowStepFunction,\n  AxFlowSubContext,\n  AxFlowTypedSubContext,\n  GetGenIn,\n  GetGenOut,\n} from './types.js';\n\n/**\n * Implementation of the sub-context for parallel execution\n */\nexport class AxFlowSubContextImpl implements AxFlowSubContext {\n  private readonly steps: AxFlowStepFunction[] = [];\n\n  constructor(\n    private readonly nodeGenerators: Map<\n      string,\n      AxForwardable<AxGenIn, AxGenOut, string> &\n        AxTunable<AxGenIn, AxGenOut> &\n        AxUsable\n    >\n  ) {}\n\n  execute<TAI extends Readonly<AxAIService>>(\n    nodeName: string,\n    mapping: (state: AxFlowState) => Record<string, AxFieldValue>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): this {\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    this.steps.push(async (state, context) => {\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n      const nodeInputs = mapping(state);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      // Handle both AxGen and AxProgram types\n      let result: any;\n      if (\n        'forward' in nodeProgram &&\n        typeof nodeProgram.forward === 'function'\n      ) {\n        result = await nodeProgram.forward(ai, nodeInputs, {\n          ...options,\n          traceLabel,\n        });\n      } else {\n        throw new Error(\n          `Node program for '${nodeName}' does not have a forward method`\n        );\n      }\n\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    });\n\n    return this;\n  }\n\n  map(transform: (state: AxFlowState) => AxFlowState): this {\n    this.steps.push((state) => transform(state));\n    return this;\n  }\n\n  async executeSteps(\n    initialState: AxFlowState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions<string>;\n    }>\n  ): Promise<AxFlowState> {\n    let currentState = initialState;\n\n    for (const step of this.steps) {\n      currentState = await step(currentState, context);\n    }\n\n    return currentState;\n  }\n}\n\n/**\n * Typed implementation of the sub-context for parallel execution with full type safety\n */\n// This class is used by the type system but not directly instantiated in this file\n// NOTE: The `any` here is necessary for the same reason as in the interfaces above\nexport class AxFlowTypedSubContextImpl<\n  TNodes extends Record<string, AxGen<any, any>>,\n  TState extends AxFlowState,\n> implements AxFlowTypedSubContext<TNodes, TState>\n{\n  private readonly steps: AxFlowStepFunction[] = [];\n\n  constructor(\n    private readonly nodeGenerators: Map<\n      string,\n      AxGen<AxGenIn, AxGenOut> | AxProgram<AxGenIn, AxGenOut>\n    >\n  ) {}\n\n  execute<\n    TNodeName extends keyof TNodes & string,\n    TAI extends Readonly<AxAIService>,\n  >(\n    nodeName: TNodeName,\n    mapping: (state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): AxFlowTypedSubContext<\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    this.steps.push(async (state, context) => {\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n      const nodeInputs = mapping(state as TState);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      // Handle both AxGen and AxProgram types\n      let result: any;\n      if (\n        'forward' in nodeProgram &&\n        typeof nodeProgram.forward === 'function'\n      ) {\n        result = await nodeProgram.forward(ai, nodeInputs, {\n          ...options,\n          traceLabel,\n        });\n      } else {\n        throw new Error(\n          `Node program for '${nodeName}' does not have a forward method`\n        );\n      }\n\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    });\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as AxFlowTypedSubContext<\n      TNodes,\n      AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n    >;\n  }\n\n  map<TNewState extends AxFlowState>(\n    transform: (state: TState) => TNewState\n  ): AxFlowTypedSubContext<TNodes, TNewState> {\n    this.steps.push((state) => transform(state as TState));\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as unknown as AxFlowTypedSubContext<TNodes, TNewState>;\n  }\n\n  async executeSteps(\n    initialState: TState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions<string>;\n    }>\n  ): Promise<AxFlowState> {\n    let currentState: AxFlowState = initialState;\n\n    for (const step of this.steps) {\n      currentState = await step(currentState, context);\n    }\n\n    return currentState;\n  }\n}\n", "/* eslint-disable @typescript-eslint/no-explicit-any, functional/prefer-immutable-types */\nimport type { AxAIService } from '../ai/types.js';\nimport type { AxGen } from '../dsp/generate.js';\nimport { AxProgram } from '../dsp/program.js';\nimport type { AxFieldType } from '../dsp/sig.js';\nimport { type AxField, AxSignature, f } from '../dsp/sig.js';\nimport { ax } from '../dsp/template.js';\nimport type {\n  AxGenIn,\n  AxGenOut,\n  AxGenStreamingOut,\n  AxMessage,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n  AxProgrammable,\n  AxProgramStreamingForwardOptionsWithModels,\n  AxProgramTrace,\n  AxProgramUsage,\n  AxSetExamplesOptions,\n} from '../dsp/types.js';\nimport { mergeProgramUsage } from '../dsp/util.js';\nimport { processBatches } from './batchUtil.js';\nimport { AxFlowExecutionPlanner } from './executionPlanner.js';\nimport {\n  type AxFlowLoggerFunction,\n  axCreateFlowColorLogger,\n  createTimingLogger,\n} from './logger.js';\nimport { AxFlowSubContextImpl } from './subContext.js';\nimport type {\n  AddNodeResult,\n  AxFlowAutoParallelConfig,\n  AxFlowable,\n  AxFlowBranchContext,\n  AxFlowDynamicContext,\n  AxFlowExecutionStep,\n  AxFlowNodeDefinition,\n  AxFlowParallelBranch,\n  AxFlowParallelGroup,\n  AxFlowState,\n  AxFlowStepFunction,\n  AxFlowSubContext,\n  AxFlowTypedParallelBranch,\n  AxFlowTypedSubContext,\n  GetGenIn,\n  GetGenOut,\n  InferAxGen,\n} from './types.js';\n\n/**\n * AxFlow - A fluent, chainable API for building and orchestrating complex, stateful AI programs.\n *\n * Now with advanced type-safe chaining where each method call evolves the type information,\n * providing compile-time type safety and superior IntelliSense.\n *\n * @example\n * ```\n * const flow = new AxFlow<{ topic: string }, { finalAnswer: string }>()\n *   .node('summarizer', 'text:string -> summary:string')\n *   .node('critic', 'summary:string -> critique:string')\n *   .execute('summarizer', state => ({ text: `About ${state.topic}` })) // state is { topic: string }\n *   .execute('critic', state => ({ summary: state.summarizerResult.summary })) // state evolves!\n *   .map(state => ({ finalAnswer: state.criticResult.critique })) // fully typed!\n *\n * const result = await flow.forward(ai, { topic: \"AI safety\" })\n * ```\n */\nexport class AxFlow<\n  IN extends Record<string, any>,\n  OUT,\n  // NOTE: The `any` here is necessary because TNodes must accommodate AxProgrammable instances with various input/output types\n  TNodes extends Record<string, AxProgrammable<any, any>> = Record<\n    string,\n    never\n  >, // Node registry for type tracking\n  TState extends AxFlowState = IN, // Current evolving state type\n> implements AxFlowable<IN, OUT>\n{\n  private readonly nodes: Map<string, AxFlowNodeDefinition> = new Map();\n  private readonly flowDefinition: AxFlowStepFunction[] = [];\n  private readonly nodeGenerators: Map<\n    string,\n    AxProgrammable<any, any, unknown>\n  > = new Map();\n  private readonly loopStack: number[] = [];\n  private readonly stepLabels: Map<string, number> = new Map();\n  private branchContext: AxFlowBranchContext | null = null;\n\n  // Automatic parallelization components\n  private readonly autoParallelConfig: AxFlowAutoParallelConfig;\n  private readonly executionPlanner = new AxFlowExecutionPlanner();\n\n  // Program field that gets initialized when something is added to the graph\n  private program?: AxProgram<IN, OUT>;\n\n  // Node-level usage tracking\n  private nodeUsage: Map<string, AxProgramUsage[]> = new Map();\n\n  // Node-level trace tracking\n  private nodeTraces: Map<string, AxProgramTrace<any, any>[]> = new Map();\n\n  // Verbose logging support\n  private readonly flowLogger?: AxFlowLoggerFunction;\n  private readonly timingLogger?: ReturnType<typeof createTimingLogger>;\n\n  /**\n   * Converts a string to camelCase for valid field names\n   */\n  private toCamelCase(str: string): string {\n    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());\n  }\n\n  /**\n   * Executes a list of steps with comprehensive logging\n   */\n  private async executeStepsWithLogging(\n    steps: AxFlowStepFunction[],\n    initialState: AxFlowState,\n    context: Readonly<{\n      mainAi: AxAIService;\n      mainOptions?: AxProgramForwardOptions<string>;\n    }>,\n    _isOptimized: boolean\n  ): Promise<{ finalState: AxFlowState; stepsExecuted: number }> {\n    let state = { ...initialState };\n    let stepsExecuted = 0;\n\n    for (let i = 0; i < steps.length; i++) {\n      const step = steps[i];\n      if (!step) continue;\n\n      // Determine step type and metadata for logging\n      const stepType = this.getStepType(step, i);\n      const stepMetadata = this.getStepMetadata(step, i);\n\n      const previousFields = Object.keys(state);\n\n      // Log step start\n      if (this.flowLogger) {\n        this.flowLogger({\n          name: 'StepStart',\n          timestamp: Date.now(),\n          stepIndex: i,\n          stepType: stepType,\n          nodeName: stepMetadata.nodeName,\n          dependencies: stepMetadata.dependencies,\n          produces: stepMetadata.produces,\n          state: { ...state },\n        });\n      }\n\n      // Execute step with timing\n      const stepStartTime = Date.now();\n      this.timingLogger?.startTiming(`step-${i}`);\n\n      try {\n        const result = await step(state, context);\n        state = result;\n        stepsExecuted++;\n\n        // Calculate execution time\n        const executionTime =\n          this.timingLogger?.endTiming(`step-${i}`) ??\n          Date.now() - stepStartTime;\n\n        // Identify new fields\n        const currentFields = Object.keys(state);\n        const newFields = currentFields.filter(\n          (field) => !previousFields.includes(field)\n        );\n\n        // Extract result for execute steps with node names\n        let nodeResult: any;\n        if (\n          stepType === 'execute' &&\n          stepMetadata.nodeName &&\n          newFields.length > 0\n        ) {\n          // For execute steps, try to find the result field that matches the node name\n          const resultFieldName = `${stepMetadata.nodeName}Result`;\n          nodeResult = state[resultFieldName];\n        }\n\n        // Log step completion\n        if (this.flowLogger) {\n          this.flowLogger({\n            name: 'StepComplete',\n            timestamp: Date.now(),\n            stepIndex: i,\n            stepType: stepType,\n            nodeName: stepMetadata.nodeName,\n            executionTime,\n            state: { ...state },\n            newFields,\n            result: nodeResult,\n          });\n        }\n      } catch (error) {\n        // Log step error\n        if (this.flowLogger) {\n          this.flowLogger({\n            name: 'FlowError',\n            timestamp: Date.now(),\n            error: error instanceof Error ? error.message : String(error),\n            stepIndex: i,\n            stepType: stepType,\n            nodeName: stepMetadata.nodeName,\n            state: { ...state },\n          });\n        }\n        throw error;\n      }\n    }\n\n    return { finalState: state, stepsExecuted };\n  }\n\n  /**\n   * Determines the type of a step function for logging purposes\n   */\n  private getStepType(\n    step: AxFlowStepFunction,\n    _index: number\n  ):\n    | 'execute'\n    | 'map'\n    | 'merge'\n    | 'parallel-map'\n    | 'parallel'\n    | 'derive'\n    | 'branch'\n    | 'feedback'\n    | 'while'\n    | 'other' {\n    const source = step.toString();\n\n    // Check for execute steps (contain nodeName references)\n    if (source.includes('nodeName') || source.includes('nodeProgram')) {\n      return 'execute';\n    }\n\n    // Check for parallel operations\n    if (\n      source.includes('_parallelResults') ||\n      source.includes('processBatches')\n    ) {\n      return 'parallel';\n    }\n\n    // Check for merge operations\n    if (\n      source.includes('branchValue') ||\n      source.includes('branches.get') ||\n      source.includes('mergeFunction')\n    ) {\n      return 'merge';\n    }\n\n    // Check for map operations\n    if (source.includes('transform(') || source.includes('...state,')) {\n      return 'map';\n    }\n\n    // Check for derive operations\n    if (source.includes('inputValue') && source.includes('transformFn')) {\n      return 'derive';\n    }\n\n    // Check for control flow operations\n    if (source.includes('condition(') && source.includes('iterations')) {\n      if (source.includes('while')) {\n        return 'while';\n      }\n      return 'feedback';\n    }\n\n    // Check for branch operations\n    if (source.includes('branchSteps') || source.includes('currentState')) {\n      return 'branch';\n    }\n\n    return 'other';\n  }\n\n  /**\n   * Gets metadata about a step for logging purposes\n   */\n  private getStepMetadata(\n    step: AxFlowStepFunction,\n    index: number\n  ): {\n    nodeName?: string;\n    dependencies: string[];\n    produces: string[];\n  } {\n    // Try to get metadata from execution planner if available\n    const executionPlan = this.executionPlanner.getExecutionPlan();\n    const stepInfo = executionPlan.steps.find((s) => s.stepIndex === index);\n\n    if (stepInfo) {\n      return {\n        nodeName: stepInfo.nodeName,\n        dependencies: stepInfo.dependencies,\n        produces: stepInfo.produces,\n      };\n    }\n\n    // Fallback to source analysis\n    const source = step.toString();\n    const nodeName = this.extractNodeNameFromSource(source);\n\n    return {\n      nodeName,\n      dependencies: [],\n      produces: [],\n    };\n  }\n\n  /**\n   * Extracts node name from step function source code\n   */\n  private extractNodeNameFromSource(source: string): string | undefined {\n    // Look for patterns like 'nodeName' variable references\n    const nodeNameMatch = source.match(/nodeName['\"]?\\s*[=:]\\s*['\"](\\w+)['\"]/);\n    if (nodeNameMatch) {\n      return nodeNameMatch[1];\n    }\n\n    // Look for patterns in node execution\n    const nodeExecMatch = source.match(/nodeProgram\\.get\\(['\"](\\w+)['\"]\\)/);\n    if (nodeExecMatch) {\n      return nodeExecMatch[1];\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Infers the signature of the flow based on the execution plan and node definitions.\n   * This is the core method that determines what input/output fields the flow should have\n   * based on the nodes and operations defined in the flow.\n   *\n   * The inference process follows these steps:\n   * 1. If no nodes are defined, return a default signature\n   * 2. Analyze the execution plan to find all produced and consumed fields\n   * 3. Determine input fields (consumed but not produced by any step)\n   * 4. Determine output fields with special handling for final map/merge operations\n   * 5. If no clear pattern is found, create a comprehensive signature from all nodes\n   *\n   * Special handling for final operations:\n   * - Map operations: Use the fields produced by the map transformation\n   * - Merge operations: Use fields from the merged branches or merge result\n   * - Conditional merges: Analyze what fields the branches actually produce\n   *\n   * @returns AxSignature - The inferred signature for this flow\n   */\n  private inferSignatureFromFlow(): AxSignature {\n    // Get execution plan to identify dependencies and field flow\n    const executionPlan = this.executionPlanner.getExecutionPlan();\n\n    // If no nodes are defined AND no execution steps, return a default signature\n    if (this.nodeGenerators.size === 0 && executionPlan.steps.length === 0) {\n      // Create a default signature for flows without nodes or steps\n      return f()\n        .input('userInput', f.string('User input to the flow'))\n        .output('flowOutput', f.string('Output from the flow'))\n        .build();\n    }\n\n    // This gives us a structured view of what each step consumes and produces\n    const allProducedFields = new Set<string>();\n    const allConsumedFields = new Set<string>();\n\n    // Collect all produced and consumed fields from the execution plan\n    // This helps us understand the data flow through the entire workflow\n    for (const step of executionPlan.steps) {\n      step.produces.forEach((field) => allProducedFields.add(field));\n      step.dependencies.forEach((field) => allConsumedFields.add(field));\n    }\n\n    // Find input fields (consumed but not produced by any step)\n    // These are fields that the flow needs from external input\n    const inputFieldNames = new Set<string>();\n    for (const consumed of Array.from(allConsumedFields)) {\n      if (!allProducedFields.has(consumed)) {\n        inputFieldNames.add(consumed);\n      }\n    }\n\n    // Find output fields (produced but not consumed by subsequent steps)\n    // These are the final results that the flow produces\n    const outputFieldNames = new Set<string>();\n\n    // Special handling for final map/merge operations\n    // When a flow ends with a transformation or merge, we want to use those results\n    // as the output rather than intermediate node results\n    // Note: For derive operations, use standard logic to handle multiple derives properly\n    const lastStep = executionPlan.steps[executionPlan.steps.length - 1];\n    if (lastStep && (lastStep.type === 'map' || lastStep.type === 'merge')) {\n      // If the last step is a map/merge, use its produced fields as outputs\n      lastStep.produces.forEach((field) => {\n        // Skip internal fields like _mapResult, _mergedResult\n        if (!field.startsWith('_')) {\n          outputFieldNames.add(field);\n        }\n      });\n\n      // For conditional merges that produce _mergedResult,\n      // use all fields from previous steps as potential outputs\n      // This handles cases where the merge doesn't transform the data\n      // but just selects which branch's results to use\n      if (\n        lastStep.type === 'merge' &&\n        lastStep.produces.includes('_mergedResult')\n      ) {\n        // Find all node result fields from previous steps\n        for (const step of executionPlan.steps) {\n          if (step.type === 'execute' && step.produces.length > 0) {\n            step.produces.forEach((field) => outputFieldNames.add(field));\n          }\n        }\n      }\n    } else {\n      // Standard logic: fields produced but not consumed by subsequent steps\n      // This finds the \"leaf\" fields that aren't used by any other step\n      for (const produced of Array.from(allProducedFields)) {\n        // Check if this field is consumed by any step\n        let isConsumed = false;\n        for (const step of executionPlan.steps) {\n          if (step.dependencies.includes(produced)) {\n            isConsumed = true;\n            break;\n          }\n        }\n        if (!isConsumed) {\n          // If this is a node result field (ends with \"Result\"), extract the actual output field names\n          if (produced.endsWith('Result')) {\n            const nodeName = produced.replace('Result', '');\n            const nodeGen = this.nodeGenerators.get(nodeName);\n            if (nodeGen) {\n              const sig = nodeGen.getSignature();\n              const outputFields = sig.getOutputFields();\n\n              // Add the actual output field names from the node signature\n              for (const field of outputFields) {\n                outputFieldNames.add(field.name);\n              }\n            } else {\n              // Fallback to the original field name if node not found\n              outputFieldNames.add(produced);\n            }\n          } else {\n            outputFieldNames.add(produced);\n          }\n        }\n      }\n    }\n\n    // If no clear input/output pattern, create a comprehensive signature\n    // This is a fallback that includes all possible fields from all nodes\n    // It's used when the execution plan analysis doesn't give clear results\n    if (inputFieldNames.size === 0 && outputFieldNames.size === 0) {\n      // Extract fields from node signatures\n      const inputFields: AxField[] = [];\n      const outputFields: AxField[] = [];\n\n      // Go through each node and extract its input/output fields\n      for (const [nodeName, nodeGen] of Array.from(this.nodeGenerators)) {\n        const sig = nodeGen.getSignature();\n\n        // Add node's input fields as potential flow inputs\n        // These are prefixed with the node name to avoid conflicts\n        for (const field of sig.getInputFields()) {\n          // Convert to camelCase to avoid validation issues\n          const camelCaseName = this.toCamelCase(`${nodeName}_${field.name}`);\n          inputFields.push({\n            name: camelCaseName,\n            type: field.type,\n            description: field.description,\n            isOptional: field.isOptional,\n            isInternal: field.isInternal,\n          });\n        }\n\n        // Add node's output fields as potential flow outputs\n        // These are also prefixed with the node name\n        for (const field of sig.getOutputFields()) {\n          // Convert to camelCase to avoid validation issues\n          const camelCaseName = this.toCamelCase(`${nodeName}_${field.name}`);\n          outputFields.push({\n            name: camelCaseName,\n            type: field.type,\n            description: field.description,\n            isOptional: field.isOptional,\n            isInternal: field.isInternal,\n          });\n        }\n      }\n\n      // Create signature from collected fields\n      const inferredSignature = new AxSignature();\n\n      // Add input fields or default\n      if (inputFields.length > 0) {\n        inferredSignature.setInputFields(inputFields);\n      } else {\n        inferredSignature.addInputField({\n          name: 'userInput',\n          type: { name: 'string' },\n          description: 'User input to the flow',\n        });\n      }\n\n      // Add output fields or default\n      if (outputFields.length > 0) {\n        inferredSignature.setOutputFields(outputFields);\n      } else {\n        inferredSignature.addOutputField({\n          name: 'flowOutput',\n          type: { name: 'string' },\n          description: 'Output from the flow',\n        });\n      }\n\n      return inferredSignature;\n    }\n\n    // Build signature from identified input/output fields\n    // This is the main path when we have clear input/output patterns\n    const inferredSignature = new AxSignature();\n\n    // Add input fields\n    const inputFields: AxField[] = [];\n    for (const fieldName of Array.from(inputFieldNames)) {\n      inputFields.push({\n        name: fieldName,\n        type: { name: 'string' },\n        description: `Input field: ${fieldName}`,\n      });\n    }\n\n    // Add default input if none found\n    if (inputFields.length === 0) {\n      inputFields.push({\n        name: 'userInput',\n        type: { name: 'string' },\n        description: 'User input to the flow',\n      });\n    }\n\n    // Add output fields\n    const outputFields: AxField[] = [];\n    for (const fieldName of Array.from(outputFieldNames)) {\n      // Skip internal fields that start with underscore\n      if (fieldName.startsWith('_')) {\n        continue;\n      }\n      outputFields.push({\n        name: fieldName,\n        type: { name: 'string' },\n        description: `Output field: ${fieldName}`,\n      });\n    }\n\n    // Add default output if none found\n    if (outputFields.length === 0) {\n      outputFields.push({\n        name: 'flowOutput',\n        type: { name: 'string' },\n        description: 'Output from the flow',\n      });\n    }\n\n    inferredSignature.setInputFields(inputFields);\n    inferredSignature.setOutputFields(outputFields);\n\n    return inferredSignature;\n  }\n\n  constructor(options?: {\n    autoParallel?: boolean;\n    batchSize?: number;\n    logger?: AxFlowLoggerFunction;\n    debug?: boolean;\n  }) {\n    // Initialize configuration with defaults\n    this.autoParallelConfig = {\n      enabled: options?.autoParallel !== false, // Default to true\n      batchSize: options?.batchSize || 10, // Default batch size of 10\n    };\n\n    // Initialize logging based on options\n    if (options?.logger) {\n      // Explicit logger provided\n      this.flowLogger = options.logger;\n    } else if (options?.debug === true) {\n      // Debug mode enabled - use default color logger\n      this.flowLogger = axCreateFlowColorLogger();\n    } else {\n      // No logging\n      this.flowLogger = undefined;\n    }\n\n    this.timingLogger = this.flowLogger\n      ? createTimingLogger(this.flowLogger)\n      : undefined;\n  }\n\n  /**\n   * Static factory method to create a new AxFlow instance with proper type safety\n   * @param options - Optional configuration for the flow\n   * @returns New AxFlow instance with type-safe defaults\n   */\n  public static create<\n    IN extends Record<string, any> = Record<string, never>,\n    OUT = {},\n    TNodes extends Record<string, AxProgrammable<any, any>> = Record<\n      string,\n      never\n    >,\n    TState extends AxFlowState = IN,\n  >(options?: {\n    autoParallel?: boolean;\n    batchSize?: number;\n    logger?: AxFlowLoggerFunction;\n    debug?: boolean;\n  }): AxFlow<IN, OUT, TNodes, TState> {\n    return new AxFlow<IN, OUT, TNodes, TState>(options);\n  }\n\n  /**\n   * Initializes the program field every time something is  added to the graph\n   */\n  private ensureProgram(): void {\n    // Create program with inferred signature\n    const signature = this.inferSignatureFromFlow();\n    this.program = new AxProgram<IN, OUT>(signature);\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ): void {\n    this.ensureProgram();\n    this.program!.setExamples(examples, options);\n  }\n\n  public setId(id: string): void {\n    this.ensureProgram();\n    this.program!.setId(id);\n  }\n\n  public setParentId(parentId: string): void {\n    this.ensureProgram();\n    this.program!.setParentId(parentId);\n  }\n\n  public getTraces(): AxProgramTrace<IN, OUT>[] {\n    // Collect traces from all nodes\n    const allTraces: AxProgramTrace<IN, OUT>[] = [];\n\n    for (const [_nodeName, nodeTraces] of Array.from(this.nodeTraces)) {\n      // Cast the traces to the expected type since they should be compatible\n      allTraces.push(...(nodeTraces as AxProgramTrace<IN, OUT>[]));\n    }\n\n    return allTraces;\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]): void {\n    this.ensureProgram();\n    this.program!.setDemos(demos);\n  }\n\n  public getUsage(): AxProgramUsage[] {\n    // Collect usage from all nodes and merge\n    const allUsage: AxProgramUsage[] = [];\n\n    for (const [_nodeName, nodeUsage] of Array.from(this.nodeUsage)) {\n      allUsage.push(...nodeUsage);\n    }\n\n    return mergeProgramUsage(allUsage);\n  }\n\n  public resetUsage(): void {\n    // Clear node-level usage tracking\n    this.nodeUsage.clear();\n\n    // Also reset usage on all node generators\n    for (const [_nodeName, nodeProgram] of Array.from(this.nodeGenerators)) {\n      if (nodeProgram && 'resetUsage' in nodeProgram) {\n        nodeProgram.resetUsage();\n      }\n    }\n  }\n\n  /**\n   * Resets trace tracking for the flow.\n   * This is called automatically on each forward/streamingForward call.\n   */\n  public resetTraces(): void {\n    // Clear node-level trace tracking\n    this.nodeTraces.clear();\n\n    // Note: Individual node programs don't have resetTraces method,\n    // so we only clear the flow-level trace collection\n  }\n\n  /**\n   * Gets a detailed usage report broken down by node name.\n   * This provides visibility into which nodes are consuming the most tokens.\n   *\n   * @returns Object mapping node names to their usage statistics\n   */\n  public getUsageReport(): Record<string, AxProgramUsage[]> {\n    const report: Record<string, AxProgramUsage[]> = {};\n\n    for (const [nodeName, nodeUsage] of Array.from(this.nodeUsage)) {\n      report[nodeName] = mergeProgramUsage(nodeUsage);\n    }\n\n    return report;\n  }\n\n  /**\n   * Gets a detailed trace report broken down by node name.\n   * This provides visibility into the execution traces for each node.\n   *\n   * @returns Object mapping node names to their trace data\n   */\n  public getTracesReport(): Record<string, AxProgramTrace<any, any>[]> {\n    const report: Record<string, AxProgramTrace<any, any>[]> = {};\n\n    for (const [nodeName, nodeTraces] of Array.from(this.nodeTraces)) {\n      report[nodeName] = nodeTraces;\n    }\n\n    return report;\n  }\n\n  public async *streamingForward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptionsWithModels<T>>\n  ): AxGenStreamingOut<OUT> {\n    // For now, we'll implement streaming by converting the regular forward result\n    // This is a simplified implementation - full streaming would require more work\n    // Note: forward() will handle the resetUsage() call\n    const result = await this.forward(ai, values, options);\n\n    // Yield the final result with correct AxGenDeltaOut structure\n    yield {\n      version: 1,\n      index: 0,\n      delta: result,\n    };\n  }\n\n  /**\n   * Executes the flow with the given AI service and input values.\n   *\n   * This is the main execution method that orchestrates the entire flow execution.\n   * It handles several complex aspects:\n   *\n   * 1. **Dynamic Signature Inference**: If the flow was created with a default signature\n   *    but has nodes defined, it will infer the actual signature from the flow structure.\n   *\n   * 2. **Execution Mode Selection**: Chooses between optimized parallel execution\n   *    (when auto-parallel is enabled) or sequential execution based on configuration.\n   *\n   * 3. **State Management**: Maintains the evolving state object as it flows through\n   *    each step, accumulating results and transformations.\n   *\n   * 4. **Performance Optimization**: Uses the execution planner to identify\n   *    independent operations that can run in parallel, reducing total execution time.\n   *\n   * Execution Flow:\n   * - Initialize state with input values\n   * - Infer signature if needed (based on nodes and current signature)\n   * - Choose execution strategy (parallel vs sequential)\n   * - Execute all steps while maintaining state consistency\n   * - Return final state cast to expected output type\n   *\n   * @param ai - The AI service to use as the default for all steps\n   * @param values - The input values for the flow\n   * @param options - Optional forward options to use as defaults (includes autoParallel override)\n   * @returns Promise that resolves to the final output\n   */\n  public async forward<T extends Readonly<AxAIService>>(\n    ai: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<\n      AxProgramForwardOptionsWithModels<T> & { autoParallel?: boolean }\n    >\n  ): Promise<OUT> {\n    // Start flow timing\n    const flowStartTime = Date.now();\n    this.timingLogger?.startTiming('flow-execution');\n\n    // Initialize state early so it's accessible in catch block\n    let state: AxFlowState = {};\n\n    try {\n      // Reset usage and trace tracking at the start of each forward call\n      this.resetUsage();\n      this.resetTraces();\n\n      // Extract values from input - handle both IN and AxMessage<IN>[] cases\n      let inputValues: IN;\n      if (Array.isArray(values)) {\n        // If values is an array of messages, find the most recent user message\n        const lastUserMessage = values\n          .filter((msg) => msg.role === 'user')\n          .pop();\n        if (!lastUserMessage) {\n          throw new Error('No user message found in values array');\n        }\n        inputValues = lastUserMessage.values;\n      } else {\n        // If values is a single IN object\n        inputValues = values;\n      }\n\n      // Dynamic signature inference - only if using default signature and have nodes\n      // This allows flows to be created with a simple signature and then have it\n      // automatically refined based on the actual nodes and operations defined\n      if (this.nodeGenerators.size > 0) {\n        // Initialize program with inferred signature\n        this.ensureProgram();\n      }\n\n      // Initialize state with input values\n      // This creates the initial state object that will flow through all steps\n      state = { ...inputValues };\n\n      // Log flow start\n      if (this.flowLogger) {\n        const executionPlan = this.getExecutionPlan();\n        this.flowLogger({\n          name: 'FlowStart',\n          timestamp: flowStartTime,\n          inputFields: Object.keys(inputValues),\n          totalSteps: executionPlan.totalSteps,\n          parallelGroups: executionPlan.parallelGroups,\n          maxParallelism: executionPlan.maxParallelism,\n          autoParallelEnabled: executionPlan.autoParallelEnabled,\n        });\n      }\n\n      // Create execution context object\n      // This provides consistent access to AI service and options for all steps\n      const context = {\n        mainAi: ai,\n        mainOptions: options\n          ? {\n              ...options,\n              model: options.model ? String(options.model) : undefined,\n            }\n          : undefined,\n      } as const;\n\n      // Determine execution strategy based on configuration\n      // Auto-parallel can be disabled globally or overridden per execution\n      const useAutoParallel =\n        options?.autoParallel !== false && this.autoParallelConfig.enabled;\n\n      let stepsExecuted = 0;\n      if (useAutoParallel) {\n        // OPTIMIZED PARALLEL EXECUTION PATH\n        // This path uses the execution planner to identify independent operations\n        // and execute them in parallel for better performance\n\n        // Set initial fields for dependency analysis\n        // This tells the planner what fields are available at the start\n        this.executionPlanner.setInitialFields(Object.keys(inputValues));\n\n        // Get optimized execution plan with parallel groups and batch size control\n        const optimizedSteps = this.executionPlanner.createOptimizedExecution(\n          this.autoParallelConfig.batchSize\n        );\n\n        // Execute optimized steps with logging\n        const result = await this.executeStepsWithLogging(\n          optimizedSteps,\n          state,\n          context,\n          true\n        );\n        state = result.finalState;\n        stepsExecuted = result.stepsExecuted;\n      } else {\n        // SEQUENTIAL EXECUTION PATH\n        // This path executes all steps in the order they were defined\n        // It's simpler but potentially slower for independent operations\n\n        // Execute all steps sequentially with logging\n        const result = await this.executeStepsWithLogging(\n          this.flowDefinition,\n          state,\n          context,\n          false\n        );\n        state = result.finalState;\n        stepsExecuted = result.stepsExecuted;\n      }\n\n      // Log flow completion\n      if (this.flowLogger) {\n        const totalExecutionTime =\n          this.timingLogger?.endTiming('flow-execution') ??\n          Date.now() - flowStartTime;\n        this.flowLogger({\n          name: 'FlowComplete',\n          timestamp: Date.now(),\n          totalExecutionTime,\n          finalState: state,\n          outputFields: Object.keys(state),\n          stepsExecuted,\n        });\n      }\n\n      // Return the final state cast to the expected output type\n      // The type system ensures this is safe based on the signature inference\n      return state as any;\n    } catch (error) {\n      // Log flow error\n      if (this.flowLogger) {\n        this.flowLogger({\n          name: 'FlowError',\n          timestamp: Date.now(),\n          error: error instanceof Error ? error.message : String(error),\n          state,\n        });\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Declares a reusable computational node using a signature string.\n   * Returns a new AxFlow type that tracks this node in the TNodes registry.\n   *\n   * @param name - The name of the node\n   * @param signature - Signature string in the same format as AxSignature\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```\n   * flow.node('summarizer', 'text:string -> summary:string')\n   * flow.node('analyzer', 'text:string -> analysis:string, confidence:number', { debug: true })\n   * ```\n   */\n  public node<TName extends string, TSig extends string>(\n    name: TName,\n    signature: TSig\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: InferAxGen<TSig> }, // Add new node to registry\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using an AxSignature instance.\n   * This allows using pre-configured signatures in the flow.\n   *\n   * @param name - The name of the node\n   * @param signature - AxSignature instance to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```\n   * const sig = s('text:string -> summary:string')\n   * flow.node('summarizer', sig, { temperature: 0.1 })\n   * ```\n   */\n  public node<TName extends string>(\n    name: TName,\n    signature: AxSignature\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> }, // Add new node to registry\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using a class that extends AxProgram.\n   * This allows using custom program classes in the flow.\n   *\n   * @param name - The name of the node\n   * @param programClass - Class that extends AxProgram to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   *\n   * @example\n   * ```\n   * class CustomProgram extends AxProgram<{ input: string }, { output: string }> {\n   *   async forward(ai, values) { return { output: values.input.toUpperCase() } }\n   * }\n   * flow.node('custom', CustomProgram)\n   * ```\n   */\n  public node<\n    TName extends string,\n    TProgram extends new () => AxProgrammable<any, any>,\n  >(\n    name: TName,\n    programClass: TProgram\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: InstanceType<TProgram> }, // Add new node to registry with exact type\n    TState // State unchanged\n  >;\n\n  /**\n   * Declares a reusable computational node using an AxProgrammable instance.\n   * This allows using pre-configured AxGen instances or other programmable objects in the flow.\n   *\n   * @param name - The name of the node\n   * @param programInstance - The AxProgrammable instance to use for this node\n   * @returns New AxFlow instance with updated TNodes type\n   */\n  public node<TName extends string, TProgram extends AxProgrammable<any, any>>(\n    name: TName,\n    programInstance: TProgram\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: TProgram }, // Add new node to registry with exact type\n    TState // State unchanged\n  >;\n\n  // Implementation\n  public node<TName extends string>(\n    name: TName,\n    nodeValue:\n      | string\n      | AxSignature\n      | AxProgrammable<any, any>\n      | (new () => AxProgrammable<any, any>)\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: any }, // Using any here as the implementation handles all cases\n    TState\n  > {\n    if (typeof nodeValue === 'string' || nodeValue instanceof AxSignature) {\n      // Using signature string (original behavior)\n      const signature = nodeValue;\n\n      // Validate that signature is provided\n      if (!signature) {\n        throw new Error(\n          `Invalid signature for node '${name}': signature cannot be empty`\n        );\n      }\n\n      // Store node definition (simplified since we're using standard signatures)\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Create and store the AxGen instance for this node with the same arguments as AxGen\n      const nodeGenerator = ax(signature as string);\n      this.nodeGenerators.set(name, nodeGenerator);\n\n      // Register the node with the program after program is initialized\n      this.ensureProgram();\n      this.program!.register(nodeGenerator as any);\n    } else if (typeof nodeValue === 'function') {\n      // Using program class\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Create an instance of the program class and store it directly\n      const programInstance = new nodeValue() as AxProgrammable<any, any>;\n      this.nodeGenerators.set(name, programInstance);\n\n      // Register the node with the program after program is initialized\n      this.ensureProgram();\n      this.program!.register(programInstance as any);\n    } else if (\n      nodeValue &&\n      typeof nodeValue === 'object' &&\n      'forward' in nodeValue\n    ) {\n      // Using existing AxGen instance or AxProgrammable instance\n      this.nodes.set(name, {\n        inputs: {},\n        outputs: {},\n      });\n\n      // Store the existing AxGen instance\n      const nodeGenerator = nodeValue as AxProgrammable<any, any>;\n      this.nodeGenerators.set(name, nodeGenerator);\n\n      // Register the node with the program after program is initialized\n      this.ensureProgram();\n      this.program!.register(nodeGenerator as any);\n    } else {\n      // Invalid argument type\n      throw new Error(\n        `Invalid second argument for node '${name}': expected string, AxSignature, AxProgrammable instance, or constructor function`\n      );\n    }\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    // The runtime value is the same object, but TypeScript can't track the evolving generic types\n    return this as any;\n  }\n\n  /**\n   * Short alias for node() - supports signature strings, AxSignature instances, AxGen instances, and program classes\n   */\n  public n<TName extends string, TSig extends string>(\n    name: TName,\n    signature: TSig\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: InferAxGen<TSig> }, TState>;\n\n  public n<TName extends string>(\n    name: TName,\n    signature: AxSignature\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> },\n    TState\n  >;\n\n  public n<\n    TName extends string,\n    TProgram extends new () => AxProgrammable<any, any>,\n  >(\n    name: TName,\n    programClass: TProgram\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: InstanceType<TProgram> }, TState>;\n\n  public n<TName extends string, TProgram extends AxProgrammable<any, any>>(\n    name: TName,\n    programInstance: TProgram\n  ): AxFlow<IN, OUT, TNodes & { [K in TName]: TProgram }, TState>;\n\n  public n<TName extends string>(\n    name: TName,\n    signatureOrAxGenOrClass:\n      | string\n      | AxSignature\n      | AxProgrammable<any, any>\n      | (new () => AxProgrammable<any, any>)\n  ): any {\n    return this.node(name, signatureOrAxGenOrClass as any);\n  }\n\n  /**\n   * Applies a synchronous transformation to the state object.\n   * Returns a new AxFlow type with the evolved state.\n   *\n   * @param transform - Function that takes the current state and returns a new state\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * flow.map(state => ({ ...state, processedText: state.text.toLowerCase() }))\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transform: (_state: TState) => TNewState\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  /**\n   * Applies an asynchronous transformation to the state object.\n   * Returns a new AxFlow type with the evolved state.\n   *\n   * @param transform - Async function that takes the current state and returns a promise of new state\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * flow.map(async state => ({\n   *   ...state,\n   *   apiResult: await fetchDataFromAPI(state.query)\n   * }))\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transform: (_state: TState) => Promise<TNewState>\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  /**\n   * Applies a transformation to the state object with optional parallel execution.\n   * When parallel is enabled, the transform function should prepare data for parallel processing.\n   * The actual parallel processing happens with the array of transforms provided.\n   *\n   * @param transforms - Array of transformation functions to apply in parallel\n   * @param options - Options including parallel execution configuration\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * // Parallel map with multiple transforms\n   * flow.map([\n   *   state => ({ ...state, result1: processA(state.data) }),\n   *   state => ({ ...state, result2: processB(state.data) }),\n   *   state => ({ ...state, result3: processC(state.data) })\n   * ], { parallel: true })\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => TNewState>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  /**\n   * Applies async transformations to the state object with optional parallel execution.\n   * When parallel is enabled, all async transforms are executed concurrently.\n   *\n   * @param transforms - Array of async transformation functions to apply in parallel\n   * @param options - Options including parallel execution configuration\n   * @returns New AxFlow instance with updated TState type\n   *\n   * @example\n   * ```\n   * // Parallel async map with multiple transforms\n   * flow.map([\n   *   async state => ({ ...state, result1: await apiCall1(state.data) }),\n   *   async state => ({ ...state, result2: await apiCall2(state.data) }),\n   *   async state => ({ ...state, result3: await apiCall3(state.data) })\n   * ], { parallel: true })\n   * ```\n   */\n  public map<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => Promise<TNewState>>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public map<TNewState extends AxFlowState>(\n    transform: (_state: TState) => TNewState | Promise<TNewState>,\n    options?: { parallel?: boolean }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public map<TNewState extends AxFlowState>(\n    transformOrTransforms: any,\n    options?: { parallel?: boolean }\n  ): AxFlow<IN, OUT, TNodes, TNewState> {\n    // Check if parallel processing is requested\n    if (options?.parallel) {\n      // Determine if we have an array of transforms or a single transform\n      const transforms = Array.isArray(transformOrTransforms)\n        ? transformOrTransforms\n        : [transformOrTransforms];\n\n      // Create a parallel map step using the existing parallel infrastructure pattern\n      const parallelMapStep = async (state: AxFlowState) => {\n        // Execute transforms with batch size control\n        const orderedResults = await processBatches(\n          transforms,\n          async (transform, _index) => {\n            // Apply each transform to the state - handle both sync and async transforms\n            const result = transform(state as TState);\n            // If the result is a promise, await it; otherwise return it directly\n            return Promise.resolve(result);\n          },\n          this.autoParallelConfig.batchSize\n        );\n\n        // For parallel map, merge results by taking the last one (most recent state)\n        // or if only one transform, return that result\n        return orderedResults[orderedResults.length - 1];\n      };\n\n      // Add the parallel step to the flow\n      if (this.branchContext?.currentBranchValue !== undefined) {\n        const currentBranch =\n          this.branchContext.branches.get(\n            this.branchContext.currentBranchValue\n          ) || [];\n        currentBranch.push(parallelMapStep);\n        this.branchContext.branches.set(\n          this.branchContext.currentBranchValue,\n          currentBranch\n        );\n      } else {\n        this.flowDefinition.push(parallelMapStep);\n\n        // Register with execution planner as parallel operation\n        if (this.autoParallelConfig.enabled) {\n          this.executionPlanner.addExecutionStep(\n            parallelMapStep,\n            undefined,\n            undefined,\n            'parallel-map'\n          );\n        }\n      }\n    } else {\n      // Regular map operation (supports both sync and async)\n      const step = async (state: AxFlowState) => {\n        // For non-parallel mode, only single transforms are supported\n        if (Array.isArray(transformOrTransforms)) {\n          throw new Error('Array of transforms requires parallel: true option');\n        }\n\n        // Handle both sync and async transforms\n        const result = transformOrTransforms(state as TState);\n        // If the result is a promise, await it; otherwise return it directly\n        return Promise.resolve(result);\n      };\n\n      if (this.branchContext?.currentBranchValue !== undefined) {\n        const currentBranch =\n          this.branchContext.branches.get(\n            this.branchContext.currentBranchValue\n          ) || [];\n        currentBranch.push(step);\n        this.branchContext.branches.set(\n          this.branchContext.currentBranchValue,\n          currentBranch\n        );\n      } else {\n        this.flowDefinition.push(step);\n\n        // Add to execution planner for automatic parallelization\n        if (this.autoParallelConfig.enabled) {\n          this.executionPlanner.addExecutionStep(\n            step,\n            undefined,\n            undefined,\n            'map',\n            transformOrTransforms\n          );\n        }\n      }\n    }\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as unknown as AxFlow<IN, OUT, TNodes, TNewState>;\n  }\n\n  /**\n   * Short alias for map() - supports parallel option and async functions\n   */\n  public m<TNewState extends AxFlowState>(\n    transform: (_state: TState) => TNewState\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transform: (_state: TState) => Promise<TNewState>\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => TNewState>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transforms: Array<(_state: TState) => Promise<TNewState>>,\n    options: { parallel: true }\n  ): AxFlow<IN, OUT, TNodes, TNewState>;\n\n  public m<TNewState extends AxFlowState>(\n    transformOrTransforms:\n      | ((_state: TState) => TNewState | Promise<TNewState>)\n      | Array<(_state: TState) => TNewState | Promise<TNewState>>,\n    options?: { parallel?: boolean }\n  ): AxFlow<IN, OUT, TNodes, TNewState> {\n    return this.map(transformOrTransforms as any, options);\n  }\n\n  /**\n   * Terminal transformation that sets the final output type of the flow.\n   * Use this as the last transformation to get proper type inference for the flow result.\n   *\n   * @param transform - Function that transforms the current state to the final output\n   * @returns A new flow with the output type set to the transform result\n   *\n   * @example\n   * ```typescript\n   * const flow = flow<{ input: string }>()\n   *   .map(state => ({ ...state, processed: true }))\n   *   .returns(state => ({\n   *     result: state.processed ? \"done\" : \"pending\"\n   *   })) // TypeScript now knows the output is { result: string }\n   * ```\n   */\n  public returns<TNewOut extends Record<string, unknown>>(\n    transform: (_state: TState) => TNewOut\n  ): AxFlow<IN, TNewOut, TNodes, TState> {\n    // Add the transformation to the flow definition\n    // Note: We need to ensure the result extends AxFlowState (Record<string, unknown>)\n    const step: AxFlowStepFunction = async (state: AxFlowState) => {\n      const result = transform(state as TState);\n      return Promise.resolve(result as AxFlowState);\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(\n          step,\n          undefined,\n          undefined,\n          'map', // Treat returns as a special map operation\n          transform\n        );\n      }\n    }\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    // Return a new flow with the updated output type\n    return this as unknown as AxFlow<IN, TNewOut, TNodes, TState>;\n  }\n\n  /**\n   * Short alias for returns() - r() is to returns() as m() is to map()\n   *\n   * @param transform - Function that transforms the current state to the final output\n   * @returns A new flow with the output type set to the transform result\n   */\n  public r<TNewOut extends Record<string, unknown>>(\n    transform: (_state: TState) => TNewOut\n  ): AxFlow<IN, TNewOut, TNodes, TState> {\n    return this.returns(transform);\n  }\n\n  /**\n   * Labels a step for later reference (useful for feedback loops).\n   *\n   * @param label - The label to assign to the current step position\n   * @returns this (for chaining, no type change)\n   *\n   * @example\n   * ```typescript\n   * flow.label('retry-point')\n   *   .execute('queryGen', ...)\n   * ```\n   */\n  public label(label: string): this {\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      throw new Error('Cannot create labels inside branch blocks');\n    }\n    this.stepLabels.set(label, this.flowDefinition.length);\n    return this;\n  }\n\n  /**\n   * Short alias for label()\n   */\n  public l(label: string): this {\n    return this.label(label);\n  }\n\n  /**\n   * Executes a previously defined node with full type safety.\n   * The node name must exist in TNodes, and the mapping function is typed based on the node's signature.\n   *\n   * @param nodeName - The name of the node to execute (must exist in TNodes)\n   * @param mapping - Typed function that takes the current state and returns the input for the node\n   * @param dynamicContext - Optional object to override the AI service or options for this specific step\n   * @returns New AxFlow instance with TState augmented with the node's result\n   *\n   * @example\n   * ```typescript\n   * flow.execute('summarizer', state => ({ text: state.originalText }), { ai: cheapAI })\n   * ```\n   */\n  public execute<\n    TNodeName extends keyof TNodes & string,\n    TAI extends Readonly<AxAIService>,\n  >(\n    nodeName: TNodeName,\n    mapping: (_state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    if (!this.nodes.has(nodeName)) {\n      throw new Error(\n        `Node '${nodeName}' not found. Make sure to define it with .node() first.`\n      );\n    }\n\n    const nodeProgram = this.nodeGenerators.get(nodeName);\n    if (!nodeProgram) {\n      throw new Error(`Node program for '${nodeName}' not found.`);\n    }\n\n    const step = async (\n      state: AxFlowState,\n      context: Readonly<{\n        mainAi: AxAIService;\n        mainOptions?: AxProgramForwardOptions<string>;\n      }>\n    ) => {\n      // Determine AI service and options using fallback logic\n      const ai = dynamicContext?.ai ?? context.mainAi;\n      const options = dynamicContext?.options ?? context.mainOptions;\n\n      // Map the state to node inputs (with type safety)\n      const nodeInputs = mapping(state as TState);\n\n      // Create trace label for the node execution\n      const traceLabel = options?.traceLabel\n        ? `Node:${nodeName} (${options.traceLabel})`\n        : `Node:${nodeName}`;\n\n      // Execute the node with updated trace label\n      // Handle both AxGen and AxProgram types\n      let result: any;\n      if (\n        'forward' in nodeProgram &&\n        typeof nodeProgram.forward === 'function'\n      ) {\n        result = await nodeProgram.forward(ai, nodeInputs, {\n          ...options,\n          traceLabel,\n        });\n\n        // Collect usage from the node after execution\n        if (\n          'getUsage' in nodeProgram &&\n          typeof nodeProgram.getUsage === 'function'\n        ) {\n          const nodeUsage = nodeProgram.getUsage();\n          if (nodeUsage && nodeUsage.length > 0) {\n            // Store usage for this node\n            const existingUsage = this.nodeUsage.get(nodeName) || [];\n            this.nodeUsage.set(nodeName, [...existingUsage, ...nodeUsage]);\n          }\n        }\n\n        // Collect traces from the node after execution\n        if (\n          'getTraces' in nodeProgram &&\n          typeof nodeProgram.getTraces === 'function'\n        ) {\n          const nodeTraces = nodeProgram.getTraces();\n          if (nodeTraces && nodeTraces.length > 0) {\n            // Store traces for this node\n            const existingTraces = this.nodeTraces.get(nodeName) || [];\n            this.nodeTraces.set(nodeName, [...existingTraces, ...nodeTraces]);\n          }\n        }\n      } else {\n        throw new Error(\n          `Node program for '${nodeName}' does not have a forward method`\n        );\n      }\n\n      // Merge result back into state under a key like `${nodeName}Result`\n      return {\n        ...state,\n        [`${nodeName}Result`]: result,\n      };\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      // We're inside a branch - add to current branch\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      // Normal execution - add to main flow\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(step, nodeName, mapping);\n      }\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    // NOTE: This type assertion is necessary for the type-level programming pattern\n    return this as AxFlow<\n      IN,\n      OUT,\n      TNodes,\n      AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n    >;\n  }\n\n  /**\n   * Short alias for execute()\n   */\n  public e<\n    TNodeName extends keyof TNodes & string,\n    TAI extends Readonly<AxAIService>,\n  >(\n    nodeName: TNodeName,\n    mapping: (_state: TState) => GetGenIn<TNodes[TNodeName]>,\n    dynamicContext?: AxFlowDynamicContext<TAI>\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    AddNodeResult<TState, TNodeName, GetGenOut<TNodes[TNodeName]>>\n  > {\n    return this.execute(nodeName, mapping, dynamicContext);\n  }\n\n  /**\n   * Starts a conditional branch based on a predicate function.\n   *\n   * @param predicate - Function that takes state and returns a value to branch on\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.branch(state => state.qualityResult.needsMoreInfo)\n   *   .when(true)\n   *     .execute('queryGen', ...)\n   *   .when(false)\n   *     .execute('answer', ...)\n   *   .merge()\n   * ```\n   */\n  public branch(predicate: (_state: TState) => unknown): this {\n    if (this.branchContext) {\n      throw new Error('Nested branches are not supported');\n    }\n\n    this.branchContext = {\n      predicate: (state: AxFlowState) => predicate(state as TState),\n      branches: new Map(),\n      currentBranchValue: undefined,\n    };\n\n    return this;\n  }\n\n  /**\n   * Short alias for branch()\n   */\n  public b(predicate: (_state: TState) => unknown): this {\n    return this.branch(predicate);\n  }\n\n  /**\n   * Defines a branch case for the current branch context.\n   *\n   * @param value - The value to match against the branch predicate result\n   * @returns this (for chaining)\n   */\n  public when(value: unknown): this {\n    if (!this.branchContext) {\n      throw new Error('when() called without matching branch()');\n    }\n\n    this.branchContext.currentBranchValue = value;\n    this.branchContext.branches.set(value, []);\n\n    return this;\n  }\n\n  /**\n   * Short alias for when()\n   */\n  public w(value: unknown): this {\n    return this.when(value);\n  }\n\n  /**\n   * Merges the results of conditional branches into a single execution path.\n   *\n   * This method is called after defining conditional branches with branch() and when() methods.\n   * It creates a merge point where the flow continues with the results from whichever\n   * branch was executed based on the branch condition.\n   *\n   * How conditional merging works:\n   * 1. The branch predicate is evaluated against the current state\n   * 2. The matching branch's steps are executed sequentially\n   * 3. If no branch matches, the state is returned unchanged\n   * 4. The merged result becomes the new state for subsequent steps\n   *\n   * Type safety note:\n   * The TMergedState generic allows for type-level tracking of what fields\n   * will be available after the merge, though runtime behavior depends on\n   * which branch actually executes.\n   *\n   * @returns AxFlow with updated state type reflecting the merged result\n   *\n   * @example\n   * ```typescript\n   * flow\n   *   .branch(state => state.complexity > 0.5)\n   *   .when(true)\n   *     .execute('complexProcessor', state => ({ input: state.text }))\n   *   .when(false)\n   *     .execute('simpleProcessor', state => ({ input: state.text }))\n   *   .merge() // Combines results from either branch\n   * ```\n   */\n  public merge<TMergedState extends AxFlowState = TState>(): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    TMergedState\n  > {\n    if (!this.branchContext) {\n      throw new Error('merge() called without matching branch()');\n    }\n\n    // Capture the branch context before clearing it\n    const branchContext = this.branchContext;\n    this.branchContext = null;\n\n    // Create the merge step that will execute at runtime\n    const mergeStep = async (state: AxFlowState, context: any) => {\n      // Evaluate the branch predicate to determine which branch to execute\n      const branchValue = branchContext.predicate(state);\n      const branchSteps = branchContext.branches.get(branchValue);\n\n      if (!branchSteps) {\n        // No matching branch found - return state unchanged\n        // This can happen if the predicate returns a value that wasn't\n        // defined with a when() clause\n        return state;\n      }\n\n      // Execute all steps in the matched branch sequentially\n      // Each step receives the output of the previous step as input\n      let currentState = state;\n      for (const step of branchSteps) {\n        currentState = await step(currentState, context);\n      }\n\n      return currentState;\n    };\n\n    // Add the merge step to the main flow execution\n    this.flowDefinition.push(mergeStep);\n\n    // Register with execution planner for automatic parallelization\n    // This helps with signature inference and dependency analysis\n    if (this.autoParallelConfig.enabled) {\n      this.executionPlanner.addExecutionStep(\n        mergeStep,\n        undefined,\n        undefined,\n        'merge'\n      );\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    // Type-level cast to update the state type while preserving the runtime object\n    // This allows TypeScript to track what fields should be available after the merge\n    return this as unknown as AxFlow<IN, OUT, TNodes, TMergedState>;\n  }\n\n  /**\n   * Short alias for merge()\n   */\n  public mg<TMergedState extends AxFlowState = TState>(): AxFlow<\n    IN,\n    OUT,\n    TNodes,\n    TMergedState\n  > {\n    return this.merge<TMergedState>();\n  }\n\n  /**\n   * Executes multiple operations in parallel and provides a merge method for combining results.\n   *\n   * This method enables true parallel execution of independent operations, which is particularly\n   * useful for operations like:\n   * - Multiple document retrievals\n   * - Parallel processing of different data sources\n   * - Independent LLM calls that can run simultaneously\n   *\n   * How parallel execution works:\n   * 1. Each branch function receives a sub-context for defining operations\n   * 2. All branches are executed simultaneously using Promise.all()\n   * 3. Results are stored in _parallelResults for the merge operation\n   * 4. The merge function combines the results into a single field\n   *\n   * Performance benefits:\n   * - Reduces total execution time for independent operations\n   * - Maximizes throughput for I/O-bound operations (like LLM calls)\n   * - Maintains type safety through the merge operation\n   *\n   * @param branches - Array of functions that define parallel operations\n   * @returns Object with merge method for combining results\n   *\n   * @example\n   * ```typescript\n   * flow.parallel([\n   *   subFlow => subFlow.execute('retrieve1', state => ({ query: state.query1 })),\n   *   subFlow => subFlow.execute('retrieve2', state => ({ query: state.query2 })),\n   *   subFlow => subFlow.execute('retrieve3', state => ({ query: state.query3 }))\n   * ]).merge('documents', (docs1, docs2, docs3) => [...docs1, ...docs2, ...docs3])\n   * ```\n   */\n  public parallel(\n    branches: (\n      | AxFlowParallelBranch\n      | AxFlowTypedParallelBranch<TNodes, TState>\n    )[]\n  ): {\n    merge<T, TResultKey extends string>(\n      resultKey: TResultKey,\n      mergeFunction: (..._results: unknown[]) => T\n    ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }>;\n  } {\n    // Create the parallel execution step\n    const parallelStep = async (\n      state: AxFlowState,\n      context: Readonly<{\n        mainAi: AxAIService;\n        mainOptions?: AxProgramForwardOptions<string>;\n      }>\n    ) => {\n      // Execute branches with batch size control\n      const results = await processBatches(\n        branches,\n        async (branchFn, _index) => {\n          // Create a sub-context for this branch\n          // This isolates each branch's operations from the others\n          const subContext = new AxFlowSubContextImpl(this.nodeGenerators);\n\n          // Type assertion needed because we support both typed and untyped branch functions\n          // The runtime behavior is the same, but TypeScript needs this for type checking\n          const populatedSubContext = branchFn(\n            subContext as AxFlowSubContext &\n              AxFlowTypedSubContext<TNodes, TState>\n          );\n\n          // Execute the sub-context steps and return the result\n          return await populatedSubContext.executeSteps(state, context);\n        },\n        this.autoParallelConfig.batchSize\n      );\n\n      // Store results in a special field for the merge operation\n      // This is a temporary storage that will be cleaned up by the merge\n      return {\n        ...state,\n        _parallelResults: results,\n      };\n    };\n\n    // Add the parallel step to the main flow execution\n    this.flowDefinition.push(parallelStep);\n\n    // Register with execution planner (marked as 'other' since it's a special case)\n    if (this.autoParallelConfig.enabled) {\n      this.executionPlanner.addExecutionStep(\n        parallelStep,\n        undefined,\n        undefined,\n        'parallel',\n        undefined,\n        undefined\n      );\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    // Return an object with the merge method for combining parallel results\n    return {\n      /**\n       * Merges the results of parallel operations into a single field.\n       *\n       * @param resultKey - Name of the field to store the merged result\n       * @param mergeFunction - Function that combines the parallel results\n       * @returns AxFlow with the merged result added to the state\n       */\n      merge: <T, TResultKey extends string>(\n        resultKey: TResultKey,\n        mergeFunction: (...results: unknown[]) => T\n      ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }> => {\n        // Create the merge step that combines parallel results\n        const parallelMergeStep = (state: AxFlowState) => {\n          const results = state._parallelResults;\n          if (!Array.isArray(results)) {\n            throw new Error('No parallel results found for merge');\n          }\n\n          // Apply the merge function to combine all parallel results\n          const mergedValue = mergeFunction(...results);\n\n          // Create new state with the merged result and clean up temporary storage\n          const newState = { ...state };\n          delete newState._parallelResults; // Properly delete temporary field\n          newState[resultKey] = mergedValue;\n\n          return newState;\n        };\n\n        // Add the merge step to the main flow execution\n        this.flowDefinition.push(parallelMergeStep);\n\n        // Register with execution planner for signature inference\n        if (this.autoParallelConfig.enabled) {\n          this.executionPlanner.addExecutionStep(\n            parallelMergeStep,\n            undefined,\n            undefined,\n            'merge',\n            undefined,\n            { resultKey, mergeFunction }\n          );\n        }\n\n        // Initialize program when flow structure is updated\n        this.ensureProgram();\n\n        // Type-level cast to include the new merged field in the state type\n        return this as AxFlow<\n          IN,\n          OUT,\n          TNodes,\n          TState & { [K in TResultKey]: T }\n        >;\n      },\n    };\n  }\n\n  /**\n   * Short alias for parallel()\n   */\n  public p(\n    branches: (\n      | AxFlowParallelBranch\n      | AxFlowTypedParallelBranch<TNodes, TState>\n    )[]\n  ): {\n    merge<T, TResultKey extends string>(\n      resultKey: TResultKey,\n      mergeFunction: (..._results: unknown[]) => T\n    ): AxFlow<IN, OUT, TNodes, TState & { [K in TResultKey]: T }>;\n  } {\n    return this.parallel(branches);\n  }\n\n  /**\n   * Creates a feedback loop that jumps back to a labeled step if a condition is met.\n   *\n   * @param condition - Function that returns true to trigger the feedback loop\n   * @param targetLabel - The label to jump back to\n   * @param maxIterations - Maximum number of iterations to prevent infinite loops (default: 10)\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.label('retry-point')\n   *   .execute('answer', ...)\n   *   .execute('qualityCheck', ...)\n   *   .feedback(state => state.qualityCheckResult.confidence < 0.7, 'retry-point')\n   * ```\n   */\n  public feedback(\n    condition: (_state: TState) => boolean,\n    targetLabel: string,\n    maxIterations = 10\n  ): this {\n    if (!this.stepLabels.has(targetLabel)) {\n      throw new Error(\n        `Label '${targetLabel}' not found. Make sure to define it with .label() before the feedback point.`\n      );\n    }\n\n    const targetIndex = this.stepLabels.get(targetLabel)!;\n\n    // Capture the current flow definition length before adding the feedback step\n    // This prevents the feedback step from executing itself recursively\n    const feedbackStepIndex = this.flowDefinition.length;\n\n    this.flowDefinition.push(async (state, context) => {\n      let currentState = state;\n      let iterations = 1; // Start at 1 since we've already executed once before reaching feedback\n\n      // Add iteration tracking to state if not present\n      const iterationKey = `_feedback_${targetLabel}_iterations`;\n      if (typeof currentState[iterationKey] !== 'number') {\n        currentState = { ...currentState, [iterationKey]: 1 }; // Initial execution counts as iteration 1\n      }\n\n      // Check if we should loop back (iterations < maxIterations since initial execution counts as 1)\n      while (condition(currentState as TState) && iterations < maxIterations) {\n        iterations++;\n        currentState = { ...currentState, [iterationKey]: iterations };\n\n        // Execute steps from target index to just before the feedback step\n        // Use feedbackStepIndex to avoid including the feedback step itself\n        for (let i = targetIndex; i < feedbackStepIndex; i++) {\n          const step = this.flowDefinition[i];\n          if (step) {\n            currentState = await step(currentState, context);\n          }\n        }\n      }\n\n      return currentState;\n    });\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    return this;\n  }\n\n  /**\n   * Short alias for feedback()\n   */\n  public fb(\n    condition: (_state: TState) => boolean,\n    targetLabel: string,\n    maxIterations = 10\n  ): this {\n    return this.feedback(condition, targetLabel, maxIterations);\n  }\n\n  /**\n   * Marks the beginning of a loop block.\n   *\n   * @param condition - Function that takes the current state and returns a boolean\n   * @param maxIterations - Maximum number of iterations to prevent infinite loops (default: 100)\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * flow.while(state => state.iterations < 3, 10)\n   *   .map(state => ({ ...state, iterations: (state.iterations || 0) + 1 }))\n   *   .endWhile()\n   * ```\n   */\n  public while(\n    condition: (state: TState) => boolean,\n    maxIterations = 100\n  ): this {\n    // Store the condition and mark the start of the loop\n    const loopStartIndex = this.flowDefinition.length;\n    this.loopStack.push(loopStartIndex);\n\n    // Add a placeholder step that will be replaced in endWhile()\n    // We store the condition and maxIterations in the placeholder for later use\n    interface LoopPlaceholder extends AxFlowStepFunction {\n      _condition: (state: TState) => boolean;\n      _maxIterations: number;\n      _isLoopStart: boolean;\n    }\n\n    const placeholderStep: LoopPlaceholder = Object.assign(\n      (state: AxFlowState) => state,\n      {\n        _condition: condition,\n        _maxIterations: maxIterations,\n        _isLoopStart: true,\n      }\n    );\n\n    this.flowDefinition.push(placeholderStep);\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    return this;\n  }\n\n  /**\n   * Short alias for while()\n   */\n  public wh(condition: (_state: TState) => boolean, maxIterations = 100): this {\n    return this.while(condition, maxIterations);\n  }\n\n  /**\n   * Marks the end of a loop block.\n   *\n   * @returns this (for chaining)\n   */\n  public endWhile(): this {\n    if (this.loopStack.length === 0) {\n      throw new Error('endWhile() called without matching while()');\n    }\n\n    const loopStartIndex = this.loopStack.pop()!;\n\n    // Get the condition from the placeholder step\n    const placeholderStep = this.flowDefinition[loopStartIndex];\n    if (!placeholderStep || !('_isLoopStart' in placeholderStep)) {\n      throw new Error('Loop start step not found or invalid');\n    }\n\n    const condition = (\n      placeholderStep as unknown as {\n        _condition: (state: TState) => boolean;\n        _maxIterations: number;\n      }\n    )._condition;\n\n    const maxIterations = (\n      placeholderStep as unknown as {\n        _condition: (state: TState) => boolean;\n        _maxIterations: number;\n      }\n    )._maxIterations;\n\n    // Extract the loop body steps (everything between while and endWhile)\n    const loopBodySteps = this.flowDefinition.splice(loopStartIndex + 1);\n\n    // Replace the placeholder with the actual loop implementation\n    this.flowDefinition[loopStartIndex] = async (state, context) => {\n      let currentState = state;\n      let iterations = 0;\n\n      // Execute the loop while condition is true and within iteration limit\n      while (condition(currentState as TState) && iterations < maxIterations) {\n        iterations++;\n\n        // Execute all steps in the loop body\n        for (const step of loopBodySteps) {\n          currentState = await step(currentState, context);\n        }\n      }\n\n      // Check if we exceeded the maximum iterations\n      if (iterations >= maxIterations && condition(currentState as TState)) {\n        throw new Error(\n          `While loop exceeded maximum iterations (${maxIterations}). Consider increasing maxIterations or ensuring the loop condition eventually becomes false.`\n        );\n      }\n\n      return currentState;\n    };\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    return this;\n  }\n\n  /**\n   * Short alias for endWhile()\n   */\n  public end(): this {\n    return this.endWhile();\n  }\n\n  /**\n   * Derives a new field from an existing field by applying a transform function.\n   *\n   * If the input field contains an array, the transform function is applied to each\n   * array element in parallel with batch size control. If the input field contains\n   * a scalar value, the transform function is applied directly.\n   *\n   * @param outputFieldName - Name of the field to store the result\n   * @param inputFieldName - Name of the existing field to transform\n   * @param transformFn - Function to apply to each element (for arrays) or the value directly (for scalars)\n   * @param options - Options including batch size for parallel processing\n   * @returns this (for chaining)\n   *\n   * @example\n   * ```typescript\n   * // Parallel processing of array items\n   * flow.derive('processedItems', 'items', (item, index) => processItem(item), { batchSize: 5 })\n   *\n   * // Direct transformation of scalar value\n   * flow.derive('upperText', 'text', (text) => text.toUpperCase())\n   * ```\n   */\n  public derive<T>(\n    outputFieldName: string,\n    inputFieldName: string,\n    transformFn: (value: any, index?: number, state?: TState) => T,\n    options?: { batchSize?: number }\n  ): this {\n    const step = async (state: AxFlowState) => {\n      const inputValue = state[inputFieldName];\n\n      if (inputValue === undefined) {\n        throw new Error(`Input field '${inputFieldName}' not found in state`);\n      }\n\n      let result: T | T[];\n\n      if (Array.isArray(inputValue)) {\n        // Array input - use parallel processing with batch control\n        if (this.autoParallelConfig.enabled) {\n          const batchSize =\n            options?.batchSize || this.autoParallelConfig.batchSize;\n          result = await processBatches(\n            inputValue,\n            async (item, index) => {\n              return transformFn(item, index, state as TState);\n            },\n            batchSize\n          );\n        } else {\n          // Sequential processing when parallel is disabled\n          result = inputValue.map((item: any, index: number) =>\n            transformFn(item, index, state as TState)\n          );\n        }\n      } else {\n        // Scalar input - apply transform directly\n        result = transformFn(inputValue, undefined, state as TState);\n      }\n\n      return {\n        ...state,\n        [outputFieldName]: result,\n      };\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      // We're inside a branch - add to current branch\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      // Normal execution - add to main flow\n      this.flowDefinition.push(step);\n\n      // Register with execution planner for signature inference and automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(\n          step,\n          undefined,\n          undefined,\n          'derive',\n          transformFn as any,\n          undefined,\n          {\n            inputFieldName,\n            outputFieldName,\n            batchSize: options?.batchSize,\n          }\n        );\n      }\n    }\n\n    // Initialize program when flow structure is updated\n    this.ensureProgram();\n\n    return this;\n  }\n\n  /**\n   * Gets execution plan information for debugging automatic parallelization\n   *\n   * @returns Object with execution plan details\n   */\n  public getExecutionPlan(): {\n    totalSteps: number;\n    parallelGroups: number;\n    maxParallelism: number;\n    autoParallelEnabled: boolean;\n    steps?: AxFlowExecutionStep[];\n    groups?: AxFlowParallelGroup[];\n  } {\n    const planInfo = this.executionPlanner.getExecutionPlan();\n    return {\n      totalSteps: planInfo.totalSteps,\n      parallelGroups: planInfo.parallelGroups,\n      maxParallelism: planInfo.maxParallelism,\n      autoParallelEnabled: this.autoParallelConfig.enabled,\n      steps: planInfo.steps,\n      groups: planInfo.groups,\n    };\n  }\n\n  public getSignature(): AxSignature {\n    this.ensureProgram();\n    return this.program!.getSignature();\n  }\n\n  /**\n   * Creates a new AxFlow node from an existing signature by extending it with additional fields.\n   *\n   * @param name - The name of the new node\n   * @param baseSignature - The base signature to extend (string or AxSignature)\n   * @param extensions - Object defining how to extend the signature\n   * @returns New AxFlow instance with the extended node\n   *\n   * @example\n   * ```typescript\n   * // Create a chain-of-thought node\n   * flow.nodeExtended('reasoner', 'question:string -> answer:string', {\n   *   prependOutputs: [\n   *     { name: 'reasoning', type: f.internal(f.string('Step-by-step reasoning')) }\n   *   ]\n   * })\n   *\n   * // Create a node with context and confidence\n   * flow.nodeExtended('analyzer', 'input:string -> output:string', {\n   *   appendInputs: [{ name: 'context', type: f.optional(f.string('Context')) }],\n   *   appendOutputs: [{ name: 'confidence', type: f.number('Confidence score') }]\n   * })\n   * ```\n   */\n  public nodeExtended<TName extends string>(\n    name: TName,\n    baseSignature: string | AxSignature,\n    extensions: {\n      prependInputs?: Array<{ name: string; type: AxFieldType }>;\n      appendInputs?: Array<{ name: string; type: AxFieldType }>;\n      prependOutputs?: Array<{ name: string; type: AxFieldType }>;\n      appendOutputs?: Array<{ name: string; type: AxFieldType }>;\n    }\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> },\n    TState\n  > {\n    // Create base signature\n    const sig =\n      typeof baseSignature === 'string'\n        ? AxSignature.create(baseSignature)\n        : baseSignature;\n\n    // Apply extensions in the specified order\n    let extendedSig = sig;\n\n    // Apply prepend inputs first\n    if (extensions.prependInputs) {\n      for (const input of extensions.prependInputs) {\n        extendedSig = extendedSig.prependInputField(input.name, input.type);\n      }\n    }\n\n    // Apply append inputs\n    if (extensions.appendInputs) {\n      for (const input of extensions.appendInputs) {\n        extendedSig = extendedSig.appendInputField(input.name, input.type);\n      }\n    }\n\n    // Apply prepend outputs\n    if (extensions.prependOutputs) {\n      for (const output of extensions.prependOutputs) {\n        extendedSig = extendedSig.prependOutputField(output.name, output.type);\n      }\n    }\n\n    // Apply append outputs\n    if (extensions.appendOutputs) {\n      for (const output of extensions.appendOutputs) {\n        extendedSig = extendedSig.appendOutputField(output.name, output.type);\n      }\n    }\n\n    // Create the node using the extended signature\n    return this.node(name, extendedSig);\n  }\n\n  /**\n   * Short alias for nodeExtended() - creates nodes with extended signatures\n   */\n  public nx<TName extends string>(\n    name: TName,\n    baseSignature: string | AxSignature,\n    extensions: {\n      prependInputs?: Array<{ name: string; type: AxFieldType }>;\n      appendInputs?: Array<{ name: string; type: AxFieldType }>;\n      prependOutputs?: Array<{ name: string; type: AxFieldType }>;\n      appendOutputs?: Array<{ name: string; type: AxFieldType }>;\n    }\n  ): AxFlow<\n    IN,\n    OUT,\n    TNodes & { [K in TName]: AxGen<AxGenIn, AxGenOut> },\n    TState\n  > {\n    return this.nodeExtended(name, baseSignature, extensions);\n  }\n\n  /**\n   * Applies a final transformation to the state object that updates both state and output type.\n   * This is specifically designed for terminal transformations that shape the final output.\n   *\n   * @param transform - Function that takes the current state and returns the final output\n   * @returns New AxFlow instance with updated OUT and TState types\n   *\n   * @example\n   * ```\n   * const result = await flow\n   *   .node('analyzer', 'userQuestion:string -> analysisResult:string')\n   *   .execute('analyzer', state => ({ userQuestion: state.userQuestion }))\n   *   .mapOutput(state => ({\n   *     // Note: Node results are typed as AxFieldValue, so you may need to cast\n   *     finalAnswer: state.analyzerResult.analysisResult as string\n   *   }))\n   *   .forward(ai, { userQuestion: 'test' });\n   *\n   * // result is typed as { finalAnswer: string }\n   * ```\n   */\n  public mapOutput<TOutput>(\n    transform: (_state: TState) => TOutput\n  ): AxFlow<IN, TOutput, TNodes, TOutput & TState> {\n    // Add the transformation as a regular map step\n    const step = async (state: AxFlowState) => {\n      const result = transform(state as TState);\n      return { ...state, ...result };\n    };\n\n    if (this.branchContext?.currentBranchValue !== undefined) {\n      const currentBranch =\n        this.branchContext.branches.get(\n          this.branchContext.currentBranchValue\n        ) || [];\n      currentBranch.push(step);\n      this.branchContext.branches.set(\n        this.branchContext.currentBranchValue,\n        currentBranch\n      );\n    } else {\n      this.flowDefinition.push(step);\n\n      // Add to execution planner for automatic parallelization\n      if (this.autoParallelConfig.enabled) {\n        this.executionPlanner.addExecutionStep(\n          step,\n          undefined,\n          undefined,\n          'map',\n          transform\n        );\n      }\n    }\n\n    // Initialize program when flow structure is updated (only if we have nodes)\n    if (this.nodeGenerators.size > 0) {\n      this.ensureProgram();\n    }\n\n    // Return with updated OUT type\n    return this as unknown as AxFlow<IN, TOutput, TNodes, TOutput & TState>;\n  }\n\n  /**\n   * Short alias for mapOutput()\n   */\n  public mo<TOutput>(\n    transform: (_state: TState) => TOutput\n  ): AxFlow<IN, TOutput, TNodes, TOutput & TState> {\n    return this.mapOutput(transform);\n  }\n}\n\n/**\n * Factory function to create a new AxFlow instance\n * Similar to ai() for AI services, this creates a fluent flow\n *\n * @param options - Optional configuration for the flow\n * @returns New AxFlow instance\n *\n * @example\n * ```typescript\n * // Input type is required - provides type safety throughout the flow\n * const workflow = flow<{ userInput: string }>()\n *   .node('summarizer', 'documentText:string -> summaryText:string')\n *   .execute('summarizer', state => ({ documentText: state.userInput }));\n *\n * // Complex input types work great for multi-field workflows\n * const complexFlow = flow<{ userQuestion: string; context: string }>()\n *   .map(state => ({\n *     ...state,\n *     processedQuestion: state.userQuestion.toUpperCase() // TypeScript knows this exists!\n *   }));\n * ```\n */\n/**\n * Creates a new AxFlow instance with required input type specification.\n *\n * The input type must be specified upfront to enable proper type inference\n * throughout the flow construction and execution.\n *\n * @example\n * ```typescript\n * //  Define input type upfront for better type safety\n * const workflow = flow<{ userInput: string, options?: any }>()\n *   .map(state => ({ ...state, processedInput: state.userInput.toUpperCase() }))\n *   .node('analyzer', 'processedInput:string -> result:string')\n *\n * //  Simple input types work too\n * const simpleFlow = flow<{ documentText: string }>()\n *   .node('summarizer', 'documentText:string -> summary:string')\n * ```\n */\nexport function flow<\n  TInput extends Record<string, any>,\n  TOutput = {},\n>(options?: {\n  autoParallel?: boolean;\n  batchSize?: number;\n  logger?: AxFlowLoggerFunction;\n  debug?: boolean;\n}): AxFlow<TInput, TOutput, {}, TInput> {\n  return AxFlow.create<TInput, TOutput, {}, TInput>(options);\n}\n", "import type { AxFunction } from '../ai/types.js';\n\nexport interface AxDockerContainer {\n  Id: string;\n  Names: string[];\n  Image: string;\n  ImageID: string;\n  Command: string;\n  Created: number;\n  State: {\n    Status: string;\n    Running: boolean;\n    Paused: boolean;\n    Restarting: boolean;\n    OOMKilled: boolean;\n    Dead: boolean;\n    Pid: number;\n    ExitCode: number;\n    Error: string;\n    StartedAt: Date;\n    FinishedAt: Date;\n  };\n  Status: string;\n  Ports: Array<{\n    IP: string;\n    PrivatePort: number;\n    PublicPort: number;\n    Type: string;\n  }>;\n  Labels: { [key: string]: string };\n  SizeRw: number;\n  SizeRootFs: number;\n  HostConfig: {\n    NetworkMode: string;\n  };\n  NetworkSettings: {\n    Networks: {\n      [key: string]: {\n        IPAddress: string;\n        IPPrefixLen: number;\n        Gateway: string;\n        MacAddress: string;\n      };\n    };\n  };\n  Mounts: Array<{\n    Type: string;\n    Source: string;\n    Destination: string;\n    Mode: string;\n    RW: boolean;\n    Propagation: string;\n  }>;\n}\n\nexport class AxDockerSession {\n  private readonly apiUrl: string;\n  private containerId: string | null = null;\n\n  constructor(apiUrl = 'http://localhost:2375') {\n    this.apiUrl = apiUrl;\n  }\n\n  async pullImage(imageName: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/images/create?fromImage=${encodeURIComponent(imageName)}`,\n      {\n        method: 'POST',\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to pull image: ${response.statusText}`);\n    }\n\n    // Wait for the pull to complete\n    await response.text();\n  }\n\n  async createContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string;\n    volumes?: Array<{ hostPath: string; containerPath: string }>;\n    doNotPullImage?: boolean;\n    tag?: string;\n  }>) {\n    const binds = volumes.map((v) => `${v.hostPath}:${v.containerPath}`);\n\n    if (!doNotPullImage) {\n      await this.pullImage(imageName);\n    }\n\n    const containerConfig = {\n      Image: imageName,\n      Tty: true,\n      OpenStdin: false,\n      AttachStdin: false,\n      AttachStdout: false,\n      AttachStderr: false,\n      HostConfig: { Binds: binds },\n      Labels: {} as Record<string, string>,\n    };\n\n    if (tag) {\n      containerConfig.Labels['com.example.tag'] = tag;\n    }\n\n    const response = await this.fetchDockerAPI('/containers/create', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(containerConfig),\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to create container: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as { Id: string };\n    this.containerId = data.Id;\n\n    return data;\n  }\n\n  async findOrCreateContainer({\n    imageName,\n    volumes = [],\n    doNotPullImage,\n    tag,\n  }: Readonly<{\n    imageName: string;\n    volumes?: Array<{ hostPath: string; containerPath: string }>;\n    doNotPullImage?: boolean;\n    tag: string;\n  }>): Promise<{ Id: string; isNew: boolean }> {\n    // First, try to find existing containers with the given tag\n    const existingContainers = await this.listContainers(true);\n    const matchingContainers = existingContainers.filter(\n      (container) =>\n        container.Labels && container.Labels['com.example.tag'] === tag\n    );\n\n    if (matchingContainers && matchingContainers.length > 0) {\n      // Randomly select a container from the matching ones\n      const randomIndex = Math.floor(Math.random() * matchingContainers.length);\n      const selectedContainer = matchingContainers[randomIndex];\n\n      if (selectedContainer) {\n        // Connect to the selected container\n        await this.connectToContainer(selectedContainer.Id);\n        return { Id: selectedContainer.Id, isNew: false };\n      }\n    }\n\n    // If no container with the tag exists, create a new one\n    const newContainer = await this.createContainer({\n      imageName,\n      volumes,\n      doNotPullImage,\n      tag,\n    });\n\n    return { Id: newContainer.Id, isNew: true };\n  }\n\n  async startContainer(): Promise<void> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/start`,\n      {\n        method: 'POST',\n      }\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to start container: ${response.statusText}`);\n    }\n  }\n\n  async connectToContainer(containerId: string): Promise<void> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to connect to container: ${response.statusText}`);\n    }\n\n    this.containerId = containerId;\n  }\n\n  async stopContainers({\n    tag,\n    remove,\n    timeout = 10,\n  }: Readonly<{ tag?: string; remove?: boolean; timeout?: number }>): Promise<\n    Array<{ Id: string; Action: 'stopped' | 'removed' }>\n  > {\n    const results: Array<{ Id: string; Action: 'stopped' | 'removed' }> = [];\n\n    // List all containers\n    const containers = await this.listContainers(true);\n\n    // Filter containers by tag if provided\n    const targetContainers = tag\n      ? containers.filter(\n          (container) => container.Labels['com.example.tag'] === tag\n        )\n      : containers;\n\n    for (const container of targetContainers) {\n      // Stop the container if it's running\n      if (container.State.Status === 'running') {\n        const stopResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}/stop?t=${timeout}`,\n          { method: 'POST' }\n        );\n\n        if (!stopResponse.ok) {\n          console.warn(\n            `Failed to stop container ${container.Id}: ${stopResponse.statusText}`\n          );\n          continue;\n        }\n\n        results.push({ Id: container.Id, Action: 'stopped' });\n      }\n\n      // Remove the container if the remove flag is set\n      if (remove) {\n        const removeResponse = await this.fetchDockerAPI(\n          `/containers/${container.Id}`,\n          { method: 'DELETE' }\n        );\n\n        if (!removeResponse.ok) {\n          console.warn(\n            `Failed to remove container ${container.Id}: ${removeResponse.statusText}`\n          );\n          continue;\n        }\n\n        results.push({ Id: container.Id, Action: 'removed' });\n      }\n    }\n\n    return results;\n  }\n\n  async listContainers(all = false): Promise<AxDockerContainer[]> {\n    const response = await this.fetchDockerAPI(`/containers/json?all=${all}`, {\n      method: 'GET',\n    });\n    return response.json() as Promise<AxDockerContainer[]>;\n  }\n\n  async getContainerLogs(): Promise<string> {\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n    const response = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/logs?stdout=true&stderr=true`,\n      { method: 'GET' }\n    );\n    return response.text();\n  }\n\n  async executeCommand(command: string) {\n    console.log('Executing command:', command);\n\n    if (!this.containerId) {\n      throw new Error('No container created or connected');\n    }\n\n    // Check container state\n    const containerInfo = await this.getContainerInfo(this.containerId);\n\n    if (containerInfo.State.Status !== 'running') {\n      await this.startContainer();\n\n      // Wait for the container to be in the \"running\" state\n      await this.waitForContainerToBeRunning(this.containerId);\n    }\n\n    // Create exec instance\n    const createResponse = await this.fetchDockerAPI(\n      `/containers/${this.containerId}/exec`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Cmd: ['sh', '-c', command],\n          AttachStdout: true,\n          AttachStderr: true,\n        }),\n      }\n    );\n\n    if (!createResponse.ok) {\n      throw new Error(\n        `Failed to create exec instance: ${createResponse.statusText}`\n      );\n    }\n\n    const execData = (await createResponse.json()) as { Id: string };\n\n    // Start exec instance\n    const startResponse = await this.fetchDockerAPI(\n      `/exec/${execData.Id}/start`,\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          Detach: false,\n          Tty: false,\n        }),\n      }\n    );\n\n    if (!startResponse.ok) {\n      throw new Error(\n        `Failed to start exec instance: ${startResponse.statusText}`\n      );\n    }\n\n    // Return the output\n    return await startResponse.text();\n  }\n\n  // Add these new methods to the class:\n\n  private async getContainerInfo(\n    containerId: string\n  ): Promise<AxDockerContainer> {\n    const response = await this.fetchDockerAPI(\n      `/containers/${containerId}/json`\n    );\n    if (!response.ok) {\n      throw new Error(`Failed to get container info: ${response.statusText}`);\n    }\n    return response.json() as Promise<AxDockerContainer>;\n  }\n\n  private async waitForContainerToBeRunning(\n    containerId: string,\n    timeout = 30000\n  ): Promise<void> {\n    const startTime = Date.now();\n    while (Date.now() - startTime < timeout) {\n      const containerInfo = await this.getContainerInfo(containerId);\n      if (containerInfo.State.Status === 'running') {\n        return;\n      }\n      await new Promise((resolve) => setTimeout(resolve, 1000)); // Wait for 1 second before checking again\n    }\n    throw new Error('Timeout waiting for container to start');\n  }\n\n  private async fetchDockerAPI(\n    endpoint: string,\n    options?: Readonly<RequestInit>\n  ): Promise<Response> {\n    const url = new URL(endpoint, this.apiUrl).toString();\n    return await fetch(url, options);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: 'commandExecution',\n      description:\n        'Use this function to execute shell commands, scripts, and programs. This function enables interaction with the file system, running system utilities, and performing tasks that require a shell interface.',\n      parameters: {\n        type: 'object',\n        properties: {\n          command: {\n            type: 'string',\n            description:\n              'Shell command to execute. eg. `ls -l` or `echo \"Hello, World!\"`.',\n          },\n        },\n        required: ['command'],\n      },\n\n      func: async ({ command }: Readonly<{ command: string }>) =>\n        await this.executeCommand(command),\n    };\n  }\n}\n", "import type {\n  AxAIService,\n  AxAIServiceOptions,\n  AxFunction,\n} from '../ai/types.js';\n\nexport class AxEmbeddingAdapter {\n  private aiService: AxAIService;\n  private info: {\n    name: string;\n    description: string;\n    argumentDescription: string;\n  };\n  private func: (\n    args: readonly number[],\n    extra?: Readonly<AxAIServiceOptions>\n  ) => Promise<unknown>;\n\n  constructor({\n    ai,\n    info,\n    func,\n  }: Readonly<{\n    ai: AxAIService;\n    info: Readonly<{\n      name: string;\n      description: string;\n      argumentDescription: string;\n    }>;\n    func: (\n      args: readonly number[],\n      extra?: Readonly<AxAIServiceOptions>\n    ) => Promise<unknown>;\n  }>) {\n    this.aiService = ai;\n    this.info = info;\n    this.func = func;\n  }\n\n  private async embedAdapter(\n    text: string,\n    extra?: Readonly<AxAIServiceOptions>\n  ): Promise<unknown> {\n    const embedRes = await this.aiService.embed(\n      { texts: [text] },\n      {\n        sessionId: extra?.sessionId,\n        abortSignal: extra?.abortSignal,\n      }\n    );\n    const embeds = embedRes.embeddings.at(0);\n\n    if (!embeds) {\n      throw new Error('Failed to embed text');\n    }\n\n    return this.func.length === 2\n      ? this.func(embeds, extra)\n      : this.func(embeds);\n  }\n\n  public toFunction(): AxFunction {\n    return {\n      name: this.info.name,\n      description: this.info.description,\n      parameters: {\n        type: 'object',\n        properties: {\n          text: {\n            type: 'string',\n            description: this.info.argumentDescription,\n          },\n        },\n        required: ['text'],\n      },\n      func: ({ text }: Readonly<{ text: string }>, options) =>\n        this.embedAdapter(text, options),\n    };\n  }\n}\n", "import type {\n  AxFunction,\n  AxLoggerData,\n  AxLoggerFunction,\n} from '../ai/types.js';\nimport { randomUUID } from '../util/crypto.js';\n\nimport type { AxMCPTransport } from './transport.js';\nimport type {\n  AxMCPInitializeParams,\n  AxMCPInitializeResult,\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPToolsListResult,\n} from './types.js';\n\n/**\n * Configuration for overriding function properties\n */\ninterface FunctionOverride {\n  /** Original function name to override */\n  name: string;\n  /** Updates to apply to the function */\n  updates: {\n    /** Alternative name for the function */\n    name?: string;\n    /** Alternative description for the function */\n    description?: string;\n  };\n}\n\n/**\n * Options for the MCP client\n */\ninterface AxMCPClientOptions {\n  /** Enable debug logging */\n  debug?: boolean;\n  /** Logger function for debug output */\n  logger?: AxLoggerFunction;\n  /**\n   * List of function overrides\n   * Use this to provide alternative names and descriptions for functions\n   * while preserving their original functionality\n   *\n   * Example:\n   * ```\n   * functionOverrides: [\n   *   {\n   *     name: \"original-function-name\",\n   *     updates: {\n   *       name: \"new-function-name\",\n   *       description: \"New function description\"\n   *     }\n   *   }\n   * ]\n   * ```\n   */\n  functionOverrides?: FunctionOverride[];\n}\n\nexport class AxMCPClient {\n  private functions: AxFunction[] = [];\n  private activeRequests: Map<string, { reject: (reason: unknown) => void }> =\n    new Map();\n  private capabilities: {\n    tools?: boolean;\n    resources?: boolean;\n    prompts?: boolean;\n  } = {};\n  private logger: AxLoggerFunction;\n\n  constructor(\n    private readonly transport: AxMCPTransport,\n    private readonly options: Readonly<AxMCPClientOptions> = {}\n  ) {\n    this.logger =\n      options.logger ??\n      ((message: string | AxLoggerData) => {\n        if (typeof message === 'string') {\n          console.log(message);\n        } else {\n          console.log(JSON.stringify(message, null, 2));\n        }\n      });\n  }\n\n  async init(): Promise<void> {\n    if ('connect' in this.transport) {\n      await this.transport.connect?.();\n    }\n\n    const { result: res } = await this.sendRequest<\n      AxMCPInitializeParams,\n      AxMCPInitializeResult\n    >('initialize', {\n      protocolVersion: '2024-11-05',\n      capabilities: {\n        roots: { listChanged: true },\n        sampling: {},\n      },\n      clientInfo: {\n        name: 'AxMCPClient',\n        version: '1.0.0',\n      },\n    });\n\n    const expectedProtocolVersion = '2024-11-05';\n    if (res.protocolVersion !== expectedProtocolVersion) {\n      throw new Error(\n        `Protocol version mismatch. Expected ${expectedProtocolVersion} but got ${res.protocolVersion}`\n      );\n    }\n\n    if (res.capabilities.tools) {\n      this.capabilities.tools = true;\n    }\n\n    if (res.capabilities.resources) {\n      this.capabilities.resources = true;\n    }\n\n    if (res.capabilities.prompts) {\n      this.capabilities.prompts = true;\n    }\n\n    await this.sendNotification('notifications/initialized');\n\n    await this.discoverFunctions();\n  }\n\n  private async discoverFunctions(): Promise<void> {\n    if (!this.capabilities.tools) {\n      throw new Error('Tools are not supported');\n    }\n\n    const { result: res } = await this.sendRequest<\n      undefined,\n      AxMCPToolsListResult\n    >('tools/list');\n\n    this.functions = res.tools.map((fn): AxFunction => {\n      // Check if there's an override for this function\n      const override = this.options.functionOverrides?.find(\n        (o) => o.name === fn.name\n      );\n\n      const parameters = fn.inputSchema.properties\n        ? {\n            properties: fn.inputSchema.properties,\n            required: fn.inputSchema.required ?? [],\n            type: fn.inputSchema.type,\n          }\n        : undefined;\n\n      return {\n        name: override?.updates.name ?? fn.name,\n        description: override?.updates.description ?? fn.description,\n        parameters,\n        func: async (args) => {\n          // Always use original name when calling the function\n          const { result } = await this.sendRequest<{\n            name: string;\n            // eslint-disable-next-line functional/functional-parameters\n            arguments: unknown;\n          }>('tools/call', { name: fn.name, arguments: args });\n          return result;\n        },\n      };\n    });\n  }\n\n  async ping(timeout = 3000): Promise<void> {\n    const pingPromise = this.sendRequest('ping');\n    const timeoutPromise = new Promise((_, reject) =>\n      setTimeout(\n        () => reject(new Error('Ping response timeout exceeded')),\n        timeout\n      )\n    );\n    const response = (await Promise.race([pingPromise, timeoutPromise])) as {\n      result: unknown;\n    };\n    const { result } = response;\n    if (\n      typeof result !== 'object' ||\n      result === null ||\n      Object.keys(result).length !== 0\n    ) {\n      throw new Error(`Unexpected ping response: ${JSON.stringify(result)}`);\n    }\n  }\n\n  toFunction(): AxFunction[] {\n    return this.functions;\n  }\n\n  cancelRequest(id: string): void {\n    if (this.activeRequests.has(id)) {\n      this.sendNotification('notifications/cancelled', {\n        requestId: id,\n        reason: 'Client cancelled request',\n      });\n      const entry = this.activeRequests.get(id);\n      if (entry) {\n        entry.reject(new Error(`Request ${id} cancelled`));\n      }\n      this.activeRequests.delete(id);\n    }\n  }\n\n  private async sendRequest<T = unknown, R = unknown>(\n    method: string,\n    params: T = {} as T\n  ): Promise<{ id: string; result: R }> {\n    const requestId = randomUUID();\n    const request: AxMCPJSONRPCRequest<T> = {\n      jsonrpc: '2.0',\n      id: requestId,\n      method,\n      params,\n    };\n\n    const responsePromise = new Promise<{ result: R }>((resolve, reject) => {\n      this.activeRequests.set(requestId, { reject });\n      this.transport\n        .send(request)\n        .then((res: unknown) => {\n          this.activeRequests.delete(requestId);\n          if (res !== null && typeof res === 'object' && 'error' in res) {\n            const errorObj = res as {\n              error: { code: number; message: string };\n            };\n            reject(\n              new Error(\n                `RPC Error ${errorObj.error.code}: ${errorObj.error.message}`\n              )\n            );\n          } else if (\n            res !== null &&\n            typeof res === 'object' &&\n            'result' in res\n          ) {\n            resolve({ result: (res as { result: R }).result });\n          } else {\n            reject(new Error('Invalid response no result or error'));\n          }\n        })\n        .catch((err: unknown) => {\n          this.activeRequests.delete(requestId);\n          reject(err);\n        });\n    });\n\n    const { result } = await responsePromise;\n    return { id: requestId, result };\n  }\n\n  private async sendNotification(\n    method: string,\n    params: Record<string, unknown> = {}\n  ): Promise<void> {\n    const notification: AxMCPJSONRPCNotification = {\n      jsonrpc: '2.0',\n      method,\n      params,\n    };\n\n    const { debug } = this.options;\n    if (debug) {\n      const loggerData: AxLoggerData = {\n        name: 'Notification',\n        id: 'mcp_notification',\n        value: `Sending notification: ${JSON.stringify(notification, null, 2)}`,\n      };\n      this.logger(loggerData);\n    }\n\n    await this.transport.sendNotification(notification);\n  }\n}\n", "import type { AxMCPTransport } from './transport.js';\nimport type {\n  AxMCPJSONRPCNotification,\n  AxMCPJSONRPCRequest,\n  AxMCPJSONRPCResponse,\n} from './types.js';\n\nexport class AxMCPHTTPSSETransport implements AxMCPTransport {\n  private endpoint: string | null = null;\n  private sseUrl: string;\n  private eventSource?: EventSource;\n\n  constructor(sseUrl: string) {\n    this.sseUrl = sseUrl;\n  }\n\n  async connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      this.eventSource = new EventSource(this.sseUrl);\n\n      this.eventSource.addEventListener('endpoint', (event: Event) => {\n        try {\n          const messageEvent = event as MessageEvent;\n          const data = JSON.parse(messageEvent.data);\n          if (!data.uri) {\n            throw new Error('Endpoint URI missing in SSE event data');\n          }\n          this.endpoint = data.uri;\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      this.eventSource.onerror = () => {\n        reject(new Error('Failed to establish SSE connection'));\n      };\n    });\n  }\n\n  async send(\n    message: AxMCPJSONRPCRequest<unknown> | AxMCPJSONRPCNotification\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    if (!this.endpoint) {\n      throw new Error(\n        'HTTPTransport endpoint is not initialized. Call connect() first.'\n      );\n    }\n\n    const res = await fetch(this.endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(message),\n    });\n\n    if (!res.ok) {\n      throw new Error(`HTTP error ${res.status}: ${res.statusText}`);\n    }\n\n    return res.json() as Promise<AxMCPJSONRPCResponse<unknown>>;\n  }\n\n  async sendNotification(\n    message: Readonly<AxMCPJSONRPCNotification>\n  ): Promise<void> {\n    if (!this.endpoint) {\n      throw new Error(\n        'HTTPTransport endpoint is not initialized. Call connect() first.'\n      );\n    }\n    await fetch(this.endpoint, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(message),\n    });\n  }\n}\n\nexport interface AxMCPStreamableHTTPTransportOptions {\n  /**\n   * Custom headers to include with all HTTP requests\n   * Note: Content-Type, Accept, and Mcp-Session-Id are managed automatically\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * Authorization header value (convenience for common use case)\n   * If provided, will be added to the headers as 'Authorization'\n   */\n  authorization?: string;\n}\n\n/**\n * AxMCPStreambleHTTPTransport implements the 2025-03-26 Streamable HTTP transport specification\n * This transport uses a single HTTP endpoint that supports both POST and GET methods\n */\nexport class AxMCPStreambleHTTPTransport implements AxMCPTransport {\n  private mcpEndpoint: string;\n  private sessionId?: string;\n  private eventSource?: EventSource;\n  private pendingRequests = new Map<\n    string | number,\n    {\n      resolve: (value: AxMCPJSONRPCResponse<unknown>) => void;\n      reject: (reason: unknown) => void;\n    }\n  >();\n  private messageHandler?: (\n    message: AxMCPJSONRPCRequest<unknown> | AxMCPJSONRPCNotification\n  ) => void;\n  private customHeaders: Record<string, string>;\n\n  constructor(\n    mcpEndpoint: string,\n    options?: AxMCPStreamableHTTPTransportOptions\n  ) {\n    this.mcpEndpoint = mcpEndpoint;\n    this.customHeaders = { ...options?.headers };\n\n    // Add authorization header if provided\n    if (options?.authorization) {\n      this.customHeaders.Authorization = options.authorization;\n    }\n  }\n\n  /**\n   * Update custom headers (useful for refreshing tokens)\n   */\n  setHeaders(headers: Record<string, string>): void {\n    this.customHeaders = { ...headers };\n  }\n\n  /**\n   * Update authorization header (convenience method)\n   */\n  setAuthorization(authorization: string): void {\n    this.customHeaders.Authorization = authorization;\n  }\n\n  /**\n   * Get a copy of the current custom headers\n   */\n  getHeaders(): Record<string, string> {\n    return { ...this.customHeaders };\n  }\n\n  /**\n   * Build headers for HTTP requests, merging custom headers with required ones\n   */\n  private buildHeaders(\n    baseHeaders: Record<string, string>\n  ): Record<string, string> {\n    const headers = { ...this.customHeaders, ...baseHeaders };\n\n    if (this.sessionId) {\n      headers['Mcp-Session-Id'] = this.sessionId;\n    }\n\n    return headers;\n  }\n\n  /**\n   * Set a handler for incoming server messages (requests/notifications)\n   */\n  setMessageHandler(\n    handler: (\n      message: AxMCPJSONRPCRequest<unknown> | AxMCPJSONRPCNotification\n    ) => void\n  ): void {\n    this.messageHandler = handler;\n  }\n\n  async connect(): Promise<void> {\n    // For Streamable HTTP, connection is implicit when making requests\n    // But we can optionally open a GET SSE stream for server-initiated messages\n    return Promise.resolve();\n  }\n\n  /**\n   * Opens an SSE stream to listen for server-initiated messages\n   */\n  async openListeningStream(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const headers = this.buildHeaders({\n        Accept: 'text/event-stream',\n      });\n\n      // Note: EventSource doesn't support custom headers in standard browsers\n      // For custom headers with SSE, you may need to use fetch with ReadableStream\n      // or use a library that supports custom headers\n      const url = new URL(this.mcpEndpoint);\n\n      // If we have custom headers, we need to use fetch instead of EventSource\n      if (Object.keys(this.customHeaders).length > 0) {\n        this.openListeningStreamWithFetch(headers).then(resolve).catch(reject);\n        return;\n      }\n\n      this.eventSource = new EventSource(url.toString());\n\n      this.eventSource.onopen = () => {\n        resolve();\n      };\n\n      this.eventSource.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          if (this.messageHandler) {\n            this.messageHandler(message);\n          }\n        } catch (error) {\n          console.error('Failed to parse SSE message:', error);\n        }\n      };\n\n      this.eventSource.onerror = () => {\n        reject(new Error('Failed to establish SSE connection'));\n      };\n    });\n  }\n\n  /**\n   * Opens an SSE stream using fetch API to support custom headers\n   */\n  private async openListeningStreamWithFetch(\n    headers: Record<string, string>\n  ): Promise<void> {\n    const response = await fetch(this.mcpEndpoint, {\n      method: 'GET',\n      headers,\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Failed to open SSE stream: ${response.status} ${response.statusText}`\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('No response body available for SSE stream');\n    }\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n\n    const processStream = async (): Promise<void> => {\n      try {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          reader.releaseLock();\n          return;\n        }\n\n        buffer += decoder.decode(value, { stream: true });\n        const lines = buffer.split('\\n');\n        buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6); // Remove 'data: ' prefix\n            if (data === '[DONE]') {\n              return;\n            }\n\n            try {\n              const message = JSON.parse(data);\n              if (this.messageHandler) {\n                this.messageHandler(message);\n              }\n            } catch (error) {\n              console.error('Failed to parse SSE data:', error);\n            }\n          }\n        }\n\n        // Continue reading\n        await processStream();\n      } catch (error) {\n        reader.releaseLock();\n        throw error;\n      }\n    };\n\n    await processStream();\n  }\n\n  async send(\n    message: Readonly<AxMCPJSONRPCRequest<unknown>>\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    const headers = this.buildHeaders({\n      'Content-Type': 'application/json',\n      Accept: 'application/json, text/event-stream',\n    });\n\n    const response = await fetch(this.mcpEndpoint, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(message),\n    });\n\n    if (!response.ok) {\n      if (response.status === 404 && this.sessionId) {\n        // Session expired, clear it\n        this.sessionId = undefined;\n        throw new Error('Session expired. Please reinitialize.');\n      }\n      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n    }\n\n    // Check if this is the initialization response with session ID\n    const sessionIdHeader = response.headers.get('Mcp-Session-Id');\n    if (sessionIdHeader) {\n      this.sessionId = sessionIdHeader;\n    }\n\n    const contentType = response.headers.get('Content-Type');\n\n    if (contentType?.includes('text/event-stream')) {\n      // Handle SSE response\n      return this.handleSSEResponse(response, message.id);\n    }\n    if (contentType?.includes('application/json')) {\n      // Handle JSON response\n      return response.json() as Promise<AxMCPJSONRPCResponse<unknown>>;\n    }\n    throw new Error(`Unexpected content type: ${contentType}`);\n  }\n\n  private async handleSSEResponse(\n    response: Response,\n    requestId: string | number\n  ): Promise<AxMCPJSONRPCResponse<unknown>> {\n    return new Promise((resolve, reject) => {\n      const reader = response.body?.getReader();\n      if (!reader) {\n        reject(new Error('No response body reader available'));\n        return;\n      }\n\n      const decoder = new TextDecoder();\n      let buffer = '';\n\n      const processChunk = async (): Promise<void> => {\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            reader.releaseLock();\n            return;\n          }\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || ''; // Keep incomplete line in buffer\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6); // Remove 'data: ' prefix\n              if (data === '[DONE]') {\n                return;\n              }\n\n              try {\n                const message = JSON.parse(data);\n\n                // Check if this is the response to our request\n                if ('id' in message && message.id === requestId) {\n                  resolve(message as AxMCPJSONRPCResponse<unknown>);\n                  return;\n                }\n\n                // Handle other messages (server requests/notifications)\n                if (this.messageHandler) {\n                  this.messageHandler(message);\n                }\n              } catch (error) {\n                console.error('Failed to parse SSE data:', error);\n              }\n            }\n          }\n\n          // Continue reading\n          await processChunk();\n        } catch (error) {\n          reader.releaseLock();\n          reject(error);\n        }\n      };\n\n      processChunk().catch(reject);\n    });\n  }\n\n  async sendNotification(\n    message: Readonly<AxMCPJSONRPCNotification>\n  ): Promise<void> {\n    const headers = this.buildHeaders({\n      'Content-Type': 'application/json',\n      Accept: 'application/json, text/event-stream',\n    });\n\n    const response = await fetch(this.mcpEndpoint, {\n      method: 'POST',\n      headers,\n      body: JSON.stringify(message),\n    });\n\n    if (!response.ok) {\n      if (response.status === 404 && this.sessionId) {\n        // Session expired, clear it\n        this.sessionId = undefined;\n        throw new Error('Session expired. Please reinitialize.');\n      }\n      throw new Error(`HTTP error ${response.status}: ${response.statusText}`);\n    }\n\n    // For notifications, we expect 202 Accepted with no body\n    if (response.status !== 202) {\n      console.warn(`Unexpected status for notification: ${response.status}`);\n    }\n  }\n\n  /**\n   * Explicitly terminate the session (if supported by server)\n   */\n  async terminateSession(): Promise<void> {\n    if (!this.sessionId) {\n      return;\n    }\n\n    try {\n      const headers = this.buildHeaders({});\n\n      const response = await fetch(this.mcpEndpoint, {\n        method: 'DELETE',\n        headers,\n      });\n\n      if (response.status === 405) {\n        // Server doesn't support explicit session termination\n        console.info('Server does not support explicit session termination');\n      }\n    } catch (error) {\n      console.error('Failed to terminate session:', error);\n    } finally {\n      this.sessionId = undefined;\n    }\n  }\n\n  /**\n   * Close any open connections\n   */\n  close(): void {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = undefined;\n    }\n  }\n}\n", "import type {\n  AxAIModelList,\n  AxAIService,\n  AxFunction,\n  AxFunctionHandler,\n  AxFunctionJSONSchema,\n} from '../ai/types.js';\nimport type { AxInputFunctionType } from '../dsp/functions.js';\nimport { AxGen } from '../dsp/generate.js';\nimport { AxSignature } from '../dsp/sig.js';\nimport type { ParseSignature } from '../dsp/sigtypes.js';\nimport type {\n  AxGenIn,\n  AxGenOut,\n  AxGenStreamingOut,\n  AxMessage,\n  AxProgramDemos,\n  AxProgramExamples,\n  AxProgramForwardOptions,\n  AxProgramForwardOptionsWithModels,\n  AxProgrammable,\n  AxProgramStreamingForwardOptionsWithModels,\n  AxSetExamplesOptions,\n  AxTunable,\n  AxUsable,\n} from '../dsp/types.js';\n\n/**\n * Interface for agents that can be used as child agents.\n * Provides methods to get the agent's function definition and features.\n */\nexport interface AxAgentic<IN extends AxGenIn, OUT extends AxGenOut>\n  extends AxProgrammable<IN, OUT> {\n  getFunction(): AxFunction;\n  getFeatures(): AxAgentFeatures;\n}\n\nexport type AxAgentOptions = Omit<\n  AxProgramForwardOptions<string>,\n  'functions'\n> & {\n  disableSmartModelRouting?: boolean;\n  /** List of field names that should not be automatically passed from parent to child agents */\n  excludeFieldsFromPassthrough?: string[];\n  debug?: boolean;\n};\n\nexport interface AxAgentFeatures {\n  /** Whether this agent can use smart model routing (requires an AI service) */\n  canConfigureSmartModelRouting: boolean;\n  /** List of fields that this agent excludes from parent->child value passing */\n  excludeFieldsFromPassthrough: string[];\n}\n\n/**\n * Processes a child agent's function, applying model routing and input injection as needed.\n * Handles both the schema modifications and function wrapping.\n */\nfunction processChildAgentFunction<IN extends AxGenIn>(\n  childFunction: Readonly<AxFunction>,\n  parentValues: IN | AxMessage<IN>[],\n  parentInputKeys: string[],\n  modelList: AxAIModelList<string> | undefined,\n  options: Readonly<{\n    debug: boolean;\n    disableSmartModelRouting: boolean;\n    excludeFieldsFromPassthrough: string[];\n    canConfigureSmartModelRouting: boolean;\n  }>\n): AxFunction {\n  const processedFunction = { ...childFunction };\n\n  // Process input field injection\n  if (processedFunction.parameters) {\n    const childKeys = processedFunction.parameters.properties\n      ? Object.keys(processedFunction.parameters.properties)\n      : [];\n\n    // Find common keys between parent and child, excluding 'model' and specified exclusions\n    const commonKeys = parentInputKeys\n      .filter((key) => childKeys.includes(key))\n      .filter((key) => key !== 'model');\n    const injectionKeys = commonKeys.filter(\n      (key) => !options.excludeFieldsFromPassthrough.includes(key)\n    );\n\n    if (injectionKeys.length > 0) {\n      // Remove injected fields from child schema\n      processedFunction.parameters = removePropertiesFromSchema(\n        processedFunction.parameters,\n        injectionKeys\n      );\n\n      // Wrap function to inject parent values\n      const originalFunc = processedFunction.func;\n      // add debug logging if enabled\n      processedFunction.func = async (childArgs, funcOptions) => {\n        // Extract values from parentValues - handle both IN and AxMessage<IN>[] cases\n        let valuesToInject: Partial<IN> = {};\n        if (Array.isArray(parentValues)) {\n          // If parentValues is an array of messages, find the most recent user message\n          const lastUserMessage = parentValues\n            .filter((msg) => msg.role === 'user')\n            .pop();\n          if (lastUserMessage) {\n            valuesToInject = pick(\n              lastUserMessage.values,\n              injectionKeys as (keyof IN)[]\n            );\n          }\n        } else {\n          // If parentValues is a single IN object\n          valuesToInject = pick(parentValues, injectionKeys as (keyof IN)[]);\n        }\n\n        const updatedChildArgs = {\n          ...childArgs,\n          ...valuesToInject,\n        };\n\n        return await originalFunc(updatedChildArgs, funcOptions);\n      };\n    }\n\n    return processedFunction;\n  }\n\n  // Apply smart model routing if enabled\n  if (\n    modelList &&\n    !options.disableSmartModelRouting &&\n    options.canConfigureSmartModelRouting\n  ) {\n    processedFunction.parameters = addModelParameter(\n      processedFunction.parameters,\n      modelList\n    );\n  }\n\n  return processedFunction;\n}\n\nconst descriptionError = new Error(\n  'Agent description must be at least 20 characters (explain in detail what the agent does)'\n);\n\nconst definitionError = new Error(\n  'Agent definition is the prompt you give to the LLM for the agent. It must be detailed and at least 100 characters'\n);\n\n/**\n * An AI agent that can process inputs using an AI service and coordinate with child agents.\n * Supports features like smart model routing and automatic input field passing to child agents.\n *\n * @deprecated Use the `agent()` factory function instead of instantiating this class directly.\n * The factory function provides better type inference and cleaner syntax.\n * This class will be removed in v15.0.0.\n *\n * Migration timeline:\n * - v13.0.24+: Deprecation warnings (current)\n * - v14.0.0: Runtime console warnings\n * - v15.0.0: Complete removal\n *\n * @example\n * // Old (deprecated):\n * const myAgent = new AxAgent({\n *   name: 'myAgent',\n *   description: 'An agent that does something',\n *   signature: 'userInput:string -> responseText:string'\n * });\n *\n * // New (recommended):\n * const myAgent = agent('userInput:string -> responseText:string', {\n *   name: 'myAgent',\n *   description: 'An agent that does something'\n * });\n */\nexport class AxAgent<IN extends AxGenIn, OUT extends AxGenOut>\n  implements AxAgentic<IN, OUT>\n{\n  private ai?: AxAIService;\n  private program: AxGen<IN, OUT>;\n  private functions?: AxInputFunctionType;\n  private agents?: AxAgentic<IN, OUT>[];\n  private disableSmartModelRouting?: boolean;\n  private excludeFieldsFromPassthrough: string[];\n  private debug?: boolean;\n\n  private name: string;\n  //   private subAgentList?: string\n  private func: AxFunction;\n\n  constructor(\n    {\n      ai,\n      name,\n      description,\n      definition,\n      signature,\n      agents,\n      functions,\n    }: Readonly<{\n      ai?: Readonly<AxAIService>;\n      name: string;\n      description: string;\n      definition?: string;\n      signature: NonNullable<ConstructorParameters<typeof AxSignature>[0]>;\n      agents?: AxAgentic<IN, OUT>[];\n      functions?: AxInputFunctionType;\n    }>,\n    options?: Readonly<AxAgentOptions>\n  ) {\n    const { disableSmartModelRouting, excludeFieldsFromPassthrough, debug } =\n      options ?? {};\n\n    this.ai = ai;\n    this.agents = agents;\n    this.functions = functions;\n    this.disableSmartModelRouting = disableSmartModelRouting;\n    this.excludeFieldsFromPassthrough = excludeFieldsFromPassthrough ?? [];\n    this.debug = debug;\n\n    if (!name || name.length < 5) {\n      throw new Error(\n        'Agent name must be at least 10 characters (more descriptive)'\n      );\n    }\n\n    if (!description || description.length < 20) {\n      throw descriptionError;\n    }\n\n    if (definition && definition.length < 100) {\n      throw definitionError;\n    }\n\n    this.program = new AxGen<IN, OUT>(signature, {\n      ...options,\n      description: definition ?? description,\n    });\n\n    for (const agent of agents ?? []) {\n      this.program.register(\n        agent as unknown as Readonly<AxTunable<IN, OUT> & AxUsable>\n      );\n    }\n\n    this.name = name;\n    // this.subAgentList = agents?.map((a) => a.getFunction().name).join(', ')\n\n    this.func = {\n      name: toCamelCase(this.name),\n      description,\n      parameters: this.program.getSignature().toJSONSchema(),\n      func: () => this.forward,\n    };\n\n    const mm = ai?.getModelList();\n    // Only add model parameter if smart routing is enabled and model list exists\n    if (mm && !this.disableSmartModelRouting) {\n      this.func.parameters = addModelParameter(this.func.parameters, mm);\n    }\n  }\n\n  /**\n   * Creates a new AxAgent instance with type-safe signature parsing.\n   * This is the recommended way to create agents with string-based signatures.\n   *\n   * @param signature - The signature string defining input/output fields\n   * @param config - Agent configuration including name, description, etc.\n   * @returns A new AxAgent instance with inferred types\n   *\n   * @example\n   * ```typescript\n   * const agent = AxAgent.create(\n   *   'userInput:string \"User question\" -> responseText:string \"Agent response\"',\n   *   {\n   *     name: 'helpfulAgent',\n   *     description: 'An agent that provides helpful responses to user questions',\n   *     definition: 'You are a helpful assistant that provides clear, accurate responses to user questions.',\n   *     ai: llm\n   *   }\n   * );\n   * ```\n   */\n  public static create<const T extends string>(\n    signature: T,\n    config: AxAgentConfig<\n      ParseSignature<T>['inputs'],\n      ParseSignature<T>['outputs']\n    >\n  ): AxAgent<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n    const typedSignature = AxSignature.create(signature);\n    const { ai, name, description, definition, agents, functions, ...options } =\n      config;\n\n    return new AxAgent(\n      {\n        ai,\n        name,\n        description,\n        definition,\n        signature: typedSignature,\n        agents,\n        functions,\n      },\n      options\n    );\n  }\n\n  public setExamples(\n    examples: Readonly<AxProgramExamples<IN, OUT>>,\n    options?: Readonly<AxSetExamplesOptions>\n  ) {\n    this.program.setExamples(examples, options);\n  }\n\n  public setId(id: string) {\n    this.program.setId(id);\n  }\n\n  public setParentId(parentId: string) {\n    this.program.setParentId(parentId);\n  }\n\n  public getTraces() {\n    return this.program.getTraces();\n  }\n\n  public setDemos(demos: readonly AxProgramDemos<IN, OUT>[]) {\n    this.program.setDemos(demos);\n  }\n\n  public getUsage() {\n    return this.program.getUsage();\n  }\n\n  public resetUsage() {\n    this.program.resetUsage();\n  }\n\n  public getFunction(): AxFunction {\n    const boundFunc = this.forward.bind(this);\n\n    // Create a wrapper function that excludes the 'ai' parameter\n    const wrappedFunc: AxFunctionHandler = async (\n      valuesAndModel: IN & { model: string },\n      options?\n    ): Promise<string> => {\n      const { model, ...values } = valuesAndModel;\n\n      const ai = this.ai ?? options?.ai;\n      if (!ai) {\n        throw new Error('AI service is required to run the agent');\n      }\n      const ret = await boundFunc(ai, values as unknown as IN, {\n        ...options,\n        model,\n      });\n\n      const sig = this.program.getSignature();\n      const outFields = sig.getOutputFields();\n      const result = Object.keys(ret)\n        .map((k) => {\n          const field = outFields.find((f) => f.name === k);\n          if (field) {\n            return `${field.title}: ${ret[k]}`;\n          }\n          return `${k}: ${ret[k]}`;\n        })\n        .join('\\n');\n\n      return result;\n    };\n\n    return {\n      ...this.func,\n      func: wrappedFunc,\n    };\n  }\n\n  public getFeatures(): AxAgentFeatures {\n    return {\n      canConfigureSmartModelRouting: this.ai === undefined,\n      excludeFieldsFromPassthrough: this.excludeFieldsFromPassthrough,\n    };\n  }\n\n  /**\n   * Initializes the agent's execution context, processing child agents and their functions.\n   */\n  private init<T extends Readonly<AxAIService>>(\n    parentAi: T,\n    values: IN | AxMessage<IN>[],\n    options: Readonly<AxProgramForwardOptionsWithModels<T>> | undefined\n  ) {\n    const ai = this.ai ?? parentAi;\n    const mm = ai?.getModelList();\n\n    // Get parent's input schema and keys\n    const parentSchema = this.program.getSignature().getInputFields();\n    const parentKeys = parentSchema.map((p) => p.name);\n    const debug = this.getDebug<T>(ai, options);\n\n    // Process each child agent's function\n    const agentFuncs = this.agents?.map((agent) => {\n      const f = agent.getFeatures();\n\n      const processOptions = {\n        debug,\n        disableSmartModelRouting: !!this.disableSmartModelRouting,\n        excludeFieldsFromPassthrough: f.excludeFieldsFromPassthrough,\n        canConfigureSmartModelRouting: f.canConfigureSmartModelRouting,\n      };\n\n      return processChildAgentFunction(\n        agent.getFunction(),\n        values,\n        parentKeys,\n        mm,\n        processOptions\n      );\n    });\n\n    // Combine all functions\n    const functions: AxInputFunctionType = [\n      ...(options?.functions ?? this.functions ?? []),\n      ...(agentFuncs ?? []),\n    ];\n\n    return { ai, functions, debug };\n  }\n\n  public async forward<T extends Readonly<AxAIService>>(\n    parentAi: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): Promise<OUT> {\n    const { ai, functions, debug } = this.init<T>(parentAi, values, options);\n    return await this.program.forward(ai, values, {\n      ...options,\n      debug,\n      functions,\n    });\n  }\n\n  public async *streamingForward<T extends Readonly<AxAIService>>(\n    parentAi: T,\n    values: IN | AxMessage<IN>[],\n    options?: Readonly<AxProgramStreamingForwardOptionsWithModels<T>>\n  ): AxGenStreamingOut<OUT> {\n    const { ai, functions, debug } = this.init<T>(parentAi, values, options);\n    return yield* this.program.streamingForward(ai, values, {\n      ...options,\n      debug,\n      functions,\n    });\n  }\n\n  /**\n   * Updates the agent's description.\n   * This updates both the stored description and the function's description.\n   *\n   * @param description - New description for the agent (must be at least 20 characters)\n   * @throws Error if description is too short\n   */\n  public setDescription(description: string): void {\n    if (!description || description.length < 20) {\n      throw descriptionError;\n    }\n\n    this.program.getSignature().setDescription(description);\n    this.func.description = description;\n  }\n\n  public setDefinition(definition: string): void {\n    if (!definition || definition.length < 100) {\n      throw definitionError;\n    }\n\n    this.program.setDescription(definition);\n    this.func.description = definition;\n  }\n\n  public getSignature(): AxSignature {\n    return this.program.getSignature();\n  }\n\n  public setSignature(\n    signature: NonNullable<ConstructorParameters<typeof AxSignature>[0]>\n  ) {\n    this.program.setSignature(signature);\n  }\n\n  private getDebug<T extends Readonly<AxAIService>>(\n    ai: AxAIService,\n    options?: Readonly<AxProgramForwardOptionsWithModels<T>>\n  ): boolean {\n    return options?.debug ?? this.debug ?? ai?.getOptions()?.debug ?? false;\n  }\n}\n\nfunction toCamelCase(inputString: string): string {\n  // Split the string by any non-alphanumeric character (including underscores, spaces, hyphens)\n  const words = inputString.split(/[^a-zA-Z0-9]/);\n\n  // Map through each word, capitalize the first letter of each word except the first word\n  const camelCaseString = words\n    .map((word, index) => {\n      // Lowercase the word to handle cases like uppercase letters in input\n      const lowerWord = word.toLowerCase();\n\n      // Capitalize the first letter of each word except the first one\n      if (index > 0 && lowerWord && lowerWord[0]) {\n        return lowerWord[0].toUpperCase() + lowerWord.slice(1);\n      }\n\n      return lowerWord;\n    })\n    .join('');\n\n  return camelCaseString;\n}\n\n/**\n * Adds a required model parameter to a JSON Schema definition based on provided model mappings.\n * The model parameter will be an enum with values from the model map keys.\n *\n * @param parameters - The original JSON Schema parameters definition (optional)\n * @param models - Array of model mappings containing keys, model names and descriptions\n * @returns Updated JSON Schema with added model parameter\n */\nexport function addModelParameter(\n  parameters: AxFunctionJSONSchema | undefined,\n  models: AxAIModelList<string>\n): AxFunctionJSONSchema {\n  // If parameters is undefined, create a base schema\n  const baseSchema: AxFunctionJSONSchema = parameters\n    ? structuredClone(parameters)\n    : {\n        type: 'object',\n        properties: {},\n        required: [],\n      };\n\n  // Check if model parameter already exists\n  if (baseSchema.properties?.model) {\n    return baseSchema;\n  }\n\n  // Create the model property schema\n  const modelProperty: AxFunctionJSONSchema & {\n    enum: string[];\n    description: string;\n  } = {\n    type: 'string',\n    enum: models.map((m) => m.key),\n    description: `The AI model to use for this function call. Available options: ${models\n      .map((m) => `\\`${m.key}\\` ${m.description}`)\n      .join(', ')}`,\n  };\n\n  // Create new properties object with model parameter\n  const newProperties = {\n    ...(baseSchema.properties ?? {}),\n    model: modelProperty,\n  };\n\n  // Add model to required fields\n  const newRequired = [...(baseSchema.required ?? []), 'model'];\n\n  // Return updated schema\n  return {\n    ...baseSchema,\n    properties: newProperties,\n    required: newRequired,\n  };\n}\n\n// New helper: removePropertiesFromSchema\n//    Clones a JSON schema and removes properties and required fields matching the provided keys.\nfunction removePropertiesFromSchema(\n  schema: Readonly<AxFunctionJSONSchema>,\n  keys: string[]\n): AxFunctionJSONSchema {\n  const newSchema = structuredClone(schema);\n  if (newSchema.properties) {\n    for (const key of keys) {\n      delete newSchema.properties[key];\n    }\n  }\n  if (Array.isArray(newSchema.required)) {\n    const filteredRequired = newSchema.required.filter(\n      (r: string) => !keys.includes(r)\n    );\n    Object.defineProperty(newSchema, 'required', {\n      value: filteredRequired,\n      writable: true,\n      configurable: true,\n    });\n  }\n  return newSchema;\n}\n\n// New helper: pick\n//    Returns an object composed of the picked object properties.\nfunction pick<T extends object, K extends keyof T>(\n  obj: T,\n  keys: K[]\n): Pick<T, K> {\n  const result = {} as Pick<T, K>;\n  for (const key of keys) {\n    if (key in obj) {\n      result[key] = obj[key];\n    }\n  }\n  return result;\n}\n\n/**\n * Configuration options for creating an agent using the agent() factory function.\n */\nexport interface AxAgentConfig<IN extends AxGenIn, OUT extends AxGenOut>\n  extends AxAgentOptions {\n  ai?: AxAIService;\n  name: string;\n  description: string;\n  definition?: string;\n  agents?: AxAgentic<IN, OUT>[];\n  functions?: AxInputFunctionType;\n}\n\n/**\n * Creates a strongly-typed AI agent from a string signature.\n * This is the recommended way to create agents, providing better type inference and cleaner syntax.\n *\n * @param signature - The input/output signature as a string (e.g., \"userInput:string -> responseText:string\")\n * @param config - Configuration options for the agent\n * @returns A typed agent instance\n *\n * @example\n * ```typescript\n * const myAgent = agent('userInput:string -> responseText:string', {\n *   name: 'myAgent',\n *   description: 'An agent that processes user input and returns a response',\n *   definition: 'You are a helpful assistant that responds to user queries...'\n * });\n *\n * // With child agents\n * const parentAgent = agent('taskDescription:string -> completedTask:string', {\n *   name: 'parentAgent',\n *   description: 'Coordinates child agents to complete tasks',\n *   agents: [childAgent1, childAgent2]\n * });\n *\n * // Type-safe usage\n * const result = await myAgent.forward(ai, { userInput: 'Hello!' });\n * console.log(result.responseText); // TypeScript knows this exists\n * ```\n */\nexport function agent<const T extends string>(\n  signature: T,\n  config: AxAgentConfig<\n    ParseSignature<T>['inputs'],\n    ParseSignature<T>['outputs']\n  >\n): AxAgent<ParseSignature<T>['inputs'], ParseSignature<T>['outputs']> {\n  const typedSignature = AxSignature.create(signature);\n  const { ai, name, description, definition, agents, functions, ...options } =\n    config;\n\n  return new AxAgent(\n    {\n      ai,\n      name,\n      description,\n      definition,\n      signature: typedSignature,\n      agents,\n      functions,\n    },\n    options\n  );\n}\n", "import { flow } from '../flow/flow.js';\nimport type { AxFlowLoggerFunction } from '../flow/logger.js';\n\n/**\n * Advanced Multi-hop RAG with iterative query refinement, context accumulation,\n * parallel sub-queries, and self-healing quality feedback loops\n *\n * @param queryFn - Function to execute search queries and return results\n * @param options - Configuration options\n * @returns AxFlow instance with advanced RAG capability\n */\nexport const axRAG = (\n  queryFn: (query: string) => Promise<string>,\n  options?: {\n    maxHops?: number;\n    qualityThreshold?: number;\n    maxIterations?: number;\n    qualityTarget?: number;\n    disableQualityHealing?: boolean;\n    logger?: AxFlowLoggerFunction;\n    debug?: boolean;\n  }\n) => {\n  const maxHops = options?.maxHops ?? 3;\n  const qualityThreshold = options?.qualityThreshold ?? 0.8;\n  const maxIterations = options?.maxIterations ?? 2;\n  const qualityTarget = options?.qualityTarget ?? 0.85;\n  const disableQualityHealing = options?.disableQualityHealing ?? false;\n\n  return (\n    flow<{ originalQuestion: string }>({\n      logger: options?.logger,\n      debug: options?.debug,\n    })\n      // Define nodes for comprehensive RAG pipeline\n      .node(\n        'queryGenerator',\n        'originalQuestion:string, previousContext?:string -> searchQuery:string, queryReasoning:string'\n      )\n      .node(\n        'contextualizer',\n        'retrievedDocument:string, accumulatedContext?:string -> enhancedContext:string'\n      )\n      .node(\n        'qualityAssessor',\n        'currentContext:string, originalQuestion:string -> completenessScore:number, missingAspects:string[]'\n      )\n      .node(\n        'questionDecomposer',\n        'complexQuestion:string -> subQuestions:string[], decompositionReason:string'\n      )\n      .node(\n        'evidenceSynthesizer',\n        'collectedEvidence:string[], originalQuestion:string -> synthesizedEvidence:string, evidenceGaps:string[]'\n      )\n      .node(\n        'gapAnalyzer',\n        'synthesizedEvidence:string, evidenceGaps:string[], originalQuestion:string -> needsMoreInfo:boolean, focusedQueries:string[]'\n      )\n      .node(\n        'answerGenerator',\n        'finalContext:string, originalQuestion:string -> comprehensiveAnswer:string, confidenceLevel:number'\n      )\n      .node(\n        'queryRefiner',\n        'originalQuestion:string, currentContext:string, missingAspects:string[] -> refinedQuery:string'\n      )\n      .node(\n        'qualityValidator',\n        'generatedAnswer:string, userQuery:string -> qualityScore:number, issues:string[]'\n      )\n      .node(\n        'answerHealer',\n        'originalAnswer:string, healingDocument:string, issues?:string[] -> healedAnswer:string'\n      )\n\n      // Initialize comprehensive state\n      .map((state) => ({\n        ...state,\n        maxHops,\n        qualityThreshold,\n        maxIterations,\n        qualityTarget,\n        disableQualityHealing,\n        currentHop: 0,\n        accumulatedContext: '',\n        retrievedContexts: [] as string[],\n        completenessScore: 0,\n        searchQuery: state.originalQuestion,\n        shouldContinue: true,\n        iteration: 0,\n        allEvidence: [] as string[],\n        evidenceSources: [] as string[],\n        needsMoreInfo: true,\n        healingAttempts: 0,\n        currentQuality: 0,\n        shouldContinueHealing: true,\n        currentAnswer: '',\n        currentIssues: [] as string[],\n      }))\n\n      // Phase 1: Multi-hop retrieval with iterative refinement\n      .while(\n        (state) =>\n          state.currentHop < state.maxHops &&\n          state.completenessScore < state.qualityThreshold &&\n          state.shouldContinue\n      )\n      // Increment hop counter\n      .map((state) => ({\n        ...state,\n        currentHop: state.currentHop + 1,\n      }))\n\n      // Generate search query\n      .execute('queryGenerator', (state) => ({\n        originalQuestion: state.originalQuestion,\n        previousContext: state.accumulatedContext || undefined,\n      }))\n\n      // Use the provided queryFn for actual retrieval\n      .map(async (state) => {\n        const searchQuery =\n          (state.queryGeneratorResult?.searchQuery as string) ||\n          state.searchQuery ||\n          state.originalQuestion;\n        const retrievedDocument = await queryFn(searchQuery);\n        return {\n          ...state,\n          retrievalResult: {\n            retrievedDocument,\n            retrievalConfidence: 0.9, // Could extract from queryFn if supported\n          },\n        };\n      })\n\n      // Contextualize the retrieved document\n      .execute('contextualizer', (state) => ({\n        retrievedDocument: state.retrievalResult.retrievedDocument,\n        accumulatedContext: state.accumulatedContext || undefined,\n      }))\n\n      // Assess the quality and completeness of current context\n      .execute('qualityAssessor', (state) => ({\n        currentContext: state.contextualizerResult.enhancedContext,\n        originalQuestion: state.originalQuestion,\n      }))\n\n      // Update state with new information\n      .map((state) => ({\n        ...state,\n        accumulatedContext: state.contextualizerResult.enhancedContext,\n        retrievedContexts: [\n          ...state.retrievedContexts,\n          state.retrievalResult.retrievedDocument,\n        ],\n        completenessScore: state.qualityAssessorResult\n          .completenessScore as number,\n        searchQuery: state.queryGeneratorResult.searchQuery as string,\n        shouldContinue:\n          (state.qualityAssessorResult.completenessScore as number) <\n          state.qualityThreshold,\n      }))\n\n      // Refine query for next iteration if needed\n      .branch(\n        (state) => state.shouldContinue && state.currentHop < state.maxHops\n      )\n      .when(true)\n      .execute('queryRefiner', (state) => ({\n        originalQuestion: state.originalQuestion,\n        currentContext: state.accumulatedContext,\n        missingAspects: state.qualityAssessorResult.missingAspects,\n      }))\n      .map((state) => ({\n        ...state,\n        searchQuery:\n          state.queryRefinerResult?.refinedQuery || state.searchQuery,\n      }))\n      .when(false)\n      .map((state) => state) // No refinement needed\n      .merge()\n\n      .endWhile()\n\n      // Phase 2: Advanced parallel sub-query processing for complex questions\n      // Initialize allEvidence with retrieved contexts from Phase 1\n      .map((state) => ({\n        ...state,\n        allEvidence:\n          state.retrievedContexts.length > 0 ? state.retrievedContexts : [],\n      }))\n\n      .while(\n        (state) => state.iteration < state.maxIterations && state.needsMoreInfo\n      )\n      .map((state) => ({\n        ...state,\n        iteration: state.iteration + 1,\n      }))\n\n      // First iteration: decompose the complex question\n      .branch((state) => state.iteration === 1)\n      .when(true)\n      .execute('questionDecomposer', (state) => ({\n        complexQuestion: state.originalQuestion,\n      }))\n      .map((state) => ({\n        ...state,\n        currentQueries: state.questionDecomposerResult.subQuestions,\n      }))\n      .when(false)\n      // Use focused queries from gap analysis for subsequent iterations\n      .map((state) => ({\n        ...state,\n        currentQueries:\n          ((state as any).gapAnalyzerResult?.focusedQueries as string[]) || [],\n      }))\n      .merge()\n\n      // Parallel retrieval for current set of queries\n      .map(async (state) => {\n        const queries = state.currentQueries || [];\n        const retrievalResults =\n          queries.length > 0\n            ? await Promise.all(\n                queries.filter(Boolean).map((query: string) => queryFn(query))\n              )\n            : [];\n        return {\n          ...state,\n          retrievalResults,\n        };\n      })\n\n      // Synthesize evidence from current iteration\n      .execute('evidenceSynthesizer', (state) => {\n        const evidence = [\n          ...(state.allEvidence || []),\n          ...(state.retrievalResults || []),\n        ].filter(Boolean);\n\n        return {\n          collectedEvidence:\n            evidence.length > 0 ? evidence : ['No evidence collected yet'],\n          originalQuestion: state.originalQuestion,\n        };\n      })\n\n      // Analyze gaps and determine if more information is needed\n      .execute('gapAnalyzer', (state) => ({\n        synthesizedEvidence:\n          state.evidenceSynthesizerResult.synthesizedEvidence,\n        evidenceGaps: state.evidenceSynthesizerResult.evidenceGaps,\n        originalQuestion: state.originalQuestion,\n      }))\n\n      // Update state with new evidence and gap analysis\n      .map((state) => ({\n        ...state,\n        allEvidence: [...state.allEvidence, ...state.retrievalResults],\n        evidenceSources: [\n          ...state.evidenceSources,\n          `Iteration ${state.iteration} sources`,\n        ],\n        needsMoreInfo: state.gapAnalyzerResult.needsMoreInfo,\n        synthesizedEvidence:\n          state.evidenceSynthesizerResult.synthesizedEvidence,\n      }))\n\n      .endWhile()\n\n      // Phase 3: Generate initial comprehensive answer\n      .execute('answerGenerator', (state) => ({\n        finalContext:\n          state.accumulatedContext ||\n          state.synthesizedEvidence ||\n          state.allEvidence.join('\\n'),\n        originalQuestion: state.originalQuestion,\n      }))\n\n      // Phase 4: Self-healing quality validation and improvement (conditional)\n      .branch((state) => !state.disableQualityHealing)\n      .when(true)\n      .execute('qualityValidator', (state) => ({\n        generatedAnswer: state.answerGeneratorResult.comprehensiveAnswer,\n        userQuery: state.originalQuestion,\n      }))\n      .map((state) => ({\n        ...state,\n        currentAnswer: state.answerGeneratorResult\n          .comprehensiveAnswer as string,\n        currentQuality: state.qualityValidatorResult.qualityScore as number,\n        currentIssues: state.qualityValidatorResult.issues as string[],\n        shouldContinueHealing:\n          (state.qualityValidatorResult.qualityScore as number) <\n          state.qualityTarget,\n      }))\n\n      // Healing loop for quality improvement\n      .while(\n        (state) => state.healingAttempts < 3 && state.shouldContinueHealing\n      )\n      .map((state) => ({\n        ...state,\n        healingAttempts: state.healingAttempts + 1,\n      }))\n\n      // Use queryFn for healing retrieval\n      .map(async (state) => {\n        const issues = (state.currentIssues as string[]) || [];\n        const healingQuery =\n          issues.length > 0\n            ? `${state.originalQuestion} addressing issues: ${issues.join(', ')}`\n            : `${state.originalQuestion} quality improvement`;\n        const healingDocument = await queryFn(healingQuery);\n        return {\n          ...state,\n          healingResult: { healingDocument },\n        };\n      })\n\n      .execute('answerHealer', (state) => ({\n        originalAnswer: state.currentAnswer,\n        healingDocument: state.healingResult.healingDocument,\n        issues: state.currentIssues,\n      }))\n\n      // Re-validate after healing\n      .execute('qualityValidator', (state) => ({\n        generatedAnswer: state.answerHealerResult.healedAnswer,\n        userQuery: state.originalQuestion,\n      }))\n      .map((state) => ({\n        ...state,\n        currentAnswer: state.answerHealerResult.healedAnswer as string,\n        currentQuality: state.qualityValidatorResult.qualityScore as number,\n        currentIssues: state.qualityValidatorResult.issues as string[],\n        shouldContinueHealing:\n          (state.qualityValidatorResult.qualityScore as number) <\n          state.qualityTarget,\n      }))\n\n      .endWhile()\n      .when(false)\n      // Skip quality healing - use answer directly from Phase 3\n      .map((state) => ({\n        ...state,\n        currentAnswer: state.answerGeneratorResult.comprehensiveAnswer,\n        currentQuality: 1.0, // Assume perfect quality when disabled\n        currentIssues: [] as string[],\n        shouldContinueHealing: false,\n      }))\n      .merge()\n\n      // Final output mapping\n      .returns((state) => ({\n        finalAnswer: state.currentAnswer,\n        totalHops: state.currentHop,\n        retrievedContexts: state.retrievedContexts,\n        iterationCount: state.iteration,\n        healingAttempts: state.healingAttempts,\n        qualityAchieved: state.currentQuality,\n      }))\n  );\n};\n"],
  "mappings": "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E,YAAA2J,EAAW,IAAI,MAAM,KAAK,GAAG,MACnC,EAAE,OAAO,CAAC9I,CAAI,EAAE,GAChB,EACE,aAAab,GAAS,YACxB,CACF,GAOIyqB,KALY,MAAM,KAAK,GAAG,MAAM,EAClC,OAAO,WACP,QAAQ9gB,EAAW,CAAC,EACtB,CAAC,GAEe;AAChB,QAAI,OAAO3J,GAAS,UAAW,UAAU;AACvC,UAAM,EAAE,QAAAumC,EAAO,IAAIvmC;AACnByqB,UAAIA,EAAE,OAAQA,OAAMA,EAAE,SAAS8b,CAAM;IACvC;AAEI,SAAK,SACP,QAAQ,IACN,GAAGhpB,GAAS,YAAY,UAAU1c,CAAI,EAAE,CAAC;EAAK0c,GAAS,YACrD,KAAK,UAAUkN,EAAE,IAAKA,OAAM,GAAGA,EAAE,EAAE,KAAKA,EAAE,KAAK,EAAE,CAAC,CACpD,CAAC,EACH;AAGF,QAAM+b,IAAe/b,EAAE,GAAG,CAAC;AAC3B,WAAK+b,IAIEA,EAAa,KAHX;EAIX;EAEO,WAAWxmC,GAA8C;AAC1D,WAAOA,EAAQ,SAAU,cAC3B,KAAK,QAAQA,EAAQ;EAEzB;AACF;AC9GO,IAAMymC,KAAY,oBAAI,IAAI,CAC/B,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,QACA,SACA,SACA,QACA,MACA,cACA,aACA,eACA,UACA,OACA,YACA,MACA,SACA,OACA,MACA,MACA,YACA,aACA,WACA,SACA,cACA,MACA,SACA,WACA,MACA,OACA,SACA,MACA,MACA,OACA,SACA,UACA,UACA,SACA,SACA,WACA,QACA,YACA,UACA,MACA,SACA,WACA,YACA,UACA,MACA,OACA,YACA,WACA,OACA,WACA,UACA,WACA,UACA,YACA,UACA,WACA,YACA,MACA,MACA,SACA,cACA,UACA,cACA,eACA,iBACA,MACA,OACA,QACA,SACA,UACA,SACA,UACA,MACA,OACA,SACA,OACA,UACA,cACA,MACA,MACA,QACA,MACA,aACA,MACA,QACA,WACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,QACA,MACA,MACA,MACA,UACA,WACA,UACA,WACA,YACA,QACA,UACA,cACA,SACA,aACA,cACA,UACA,UACA,SACA,WACA,SACA,UACA,WACA,QACA,UACA,WACA,UACA,MACA,QACA,QACA,MACA,MACA,MACA,MACA,QACA,UACA,MACA,MACA,SACA,WACA,MACA,MACA,MACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,QACA,QACA,OACA,UACA,QACA,SACA,SACA,UACA,MACA,MACA,MACA,WACA,aACA,MACA,MACA,MACA,WACA,MACA,OACA,MACA,MACA,WACA,MACA,SACA,MACA,MACA,OACA,QACA,SACA,OACA,cACA,gBACA,YACA,eACA,WACA,cACA,YACA,iBACA,SACA,UACA,WACA,YACA,UACA,MACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,aACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,QACA,MACA,MACA,MACA,cACA,YACA,aACA,WACA,UACA,MACA,MACA,OACA,QACA,UACA,aACA,MACA,MACA,MACA,MACA,QACA,SACA,WACA,SACA,OACA,QACA,SACA,QACA,aACA,MACA,MACA,MACA,MACA,MACA,OACA,UACA,MACA,MACA,KACA,MACA,MACA,MACA,QACA,MACA,MACA,OACA,MACA,MACA,UACA,MACA,MACA,SACA,UACA,UACA,MACA,MACA,UACA,QACA,aACA,MACA,SACA,MACA,OACA,UACA,UACA,YACA,MACA,MACA,MACA,MACA,MACA,cACA,OACA,MACA,SACA,OACA,MACA,MACA,QACA,QACA,SACA,aACA,YACA,cACA,cACA,MACA,WACA,WACA,UACA,MACA,KACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,WACA,SACA,QACA,QACA,QACA,QACA,SACA,QACA,OACA,MACA,MACA,MACA,MACA,YACA,aACA,WACA,OACA,UACA,YACA,SACA,SACA,SACA,QACA,MACA,QACA,SACA,MACA,MACA,QACA,WACA,eACA,MACA,KACA,MACA,QACA,MACA,OACA,QACA,WACA,MACA,QACA,SACA,SACA,UACA,MACA,MACA,MACA,QACA,SACA,QACA,OACA,UACA,MACA,aACA,MACA,MACA,KACA,MACA,MACA,OACA,QACA,UACA,WACA,UACA,OACA,QACA,SACA,UACA,QACA,SACA,WACA,UACA,MACA,OACA,QACA,SACA,SACA,QACA,SACA,OACA,QACA,aACA,UACA,UACA,SACA,UACA,YACA,QACA,WACA,OACA,QACA,MACA,MACA,OACA,OACA,WACA,OACA,UACA,MACA,MACA,QACA,aACA,OACA,WACA,WACA,SACA,MACA,MACA,QACA,MACA,WACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,QACA,MACA,MACA,OACA,MACA,MACA,MACA,WACA,MACA,MACA,MACA,MACA,QACA,MACA,OACA,aACA,eACA,cACA,aACA,MACA,YACA,OACA,UACA,SACA,YACA,aACA,aACA,eACA,SACA,WACA,WACA,YACA,QACA,aACA,UACA,MACA,MACA,MACA,MACA,MACA,OACA,SACA,MACA,OACA,QACA,SACA,OACA,QACA,UACA,MACA,QACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,QACA,KACA,MACA,QACA,SACA,QACA,MACA,MACA,MACA,QACA,SACA,SACA,MACA,KACA,MACA,MACA,WACA,QACA,UACA,SACA,UACA,YACA,MACA,MACA,MACA,SACA,OACA,QACA,QACA,OACA,QACA,SACA,MACA,QACA,SACA,UACA,QACA,UACA,MACA,MACA,MACA,MACA,MACA,QACA,WACA,SACA,OACA,MACA,MACA,MACA,OACA,KACA,MACA,MACA,QACA,UACA,QACA,SACA,QACA,OACA,SACA,MACA,QACA,SACA,YACA,aACA,UACA,MACA,SACA,UACA,YACA,QACA,WACA,QACA,QACA,MACA,MACA,MACA,QACA,YACA,QACA,UACA,QACA,MACA,OACA,MACA,MACA,MACA,QACA,OACA,QACA,SACA,WACA,MACA,UACA,SACA,KACA,MACA,MACA,QACA,UACA,OACA,MACA,MACA,MACA,QACA,UACA,eACA,aACA,QACA,SACA,WACA,SACA,WACA,SACA,gBACA,OACA,QACA,MACA,MACA,QACA,UACA,MACA,MACA,MACA,MACA,UACA,OACA,QACA,eACA,SACA,OACA,YACA,OACA,OACA,SACA,WACA,SACA,OACA,WACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,UACA,YACA,aACA,MACA,MACA,MACA,OACA,SACA,MACA,MACA,MACA,MACA,MACA,QACA,MACA,OACA,MACA,WACA,MACA,QACA,OACA,QACA,QACA,QACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,SACA,UACA,aACA,MACA,SACA,OACA,QACA,aACA,OACA,WACA,QACA,WACA,MACA,SACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,QACA,aACA,SACA,OACA,QACA,cACA,gBACA,OACA,QACA,MACA,MACA,MACA,OACA,WACA,MACA,MACA,MACA,MACA,MACA,MACA,UACA,UACA,QACA,MACA,MACA,MACA,UACA,YACA,YACA,eACA,MACA,MACA,MACA,iBACA,WACA,cACA,cACA,aACA,YACA,YACA,SACA,YACA,MACA,MACA,MACA,OACA,MACA,KACA,MACA,MACA,OACA,WACA,SACA,MACA,KACA,MACA,MACA,OACA,UACA,MACA,MACA,MACA,WACA,UACA,cACA,UACA,YACA,OACA,QACA,aACA,cACA,WACA,WACA,cACA,YACA,mBACA,gBACA,YACA,aACA,WACA,MACA,MACA,MACA,SACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,KACA,MACA,MACA,QACA,QACA,OACA,OACA,UACA,QACA,MACA,MACA,MACA,OACA,UACA,YACA,WACA,OACA,UACA,QACA,UACA,WACA,SACA,QACA,QACA,UACA,YACA,QACA,WACA,aACA,SACA,WACA,MACA,SACA,QACA,UACA,OACA,QACA,SACA,UACA,QACA,SACA,UACA,WACA,aACA,aACA,QACA,UACA,SACA,UACA,SACA,MACA,QACA,eACA,iBACA,WACA,aACA,SACA,WACA,OACA,SACA,MACA,MACA,YACA,MACA,MACA,MACA,QACA,YACA,WACA,WACA,YACA,aACA,YACA,aACA,YACA,aACA,QACA,SACA,MACA,gBACA,aACA,WACA,cACA,MACA,MACA,MACA,MACA,SACA,QACA,YACA,OACA,iBACA,gBACA,QACA,gBACA,WACA,OACA,QACA,MACA,UACA,MACA,KACA,MACA,MACA,MACA,QACA,SACA,UACA,MACA,MACA,MACA,MACA,QACA,OACA,SACA,MACA,MACA,QACA,SACA,UACA,SACA,QACA,WACA,SACA,UACA,WACA,OACA,SACA,UACA,QACA,cACA,QACA,UACA,SACA,cACA,WACA,UACA,aACA,WACA,YACA,WACA,WACA,UACA,WACA,WACA,aACA,YACA,SACA,QACA,SACA,UACA,WACA,UACA,WACA,WACA,UACA,QACA,SACA,SACA,QACA,YACA,cACA,SACA,QACA,UACA,WACA,YACA,SACA,UACA,WACA,cACA,QACA,QACA,MACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,YACA,OACA,QACA,OACA,UACA,WACA,MACA,MACA,MACA,SACA,SACA,SACA,OACA,UACA,MACA,OACA,MACA,MACA,UACA,UACA,SACA,OACA,MACA,KACA,SACA,MACA,MACA,MACA,MACA,MACA,MACA,SACA,iBACA,UACA,UACA,YACA,SACA,QACA,MACA,MACA,QACA,OACA,MACA,MACA,OACA,QACA,UACA,YACA,cACA,QACA,SACA,WACA,MACA,KACA,MACA,SACA,WACA,MACA,MACA,MACA,QACA,OACA,OACA,MACA,MACA,OACA,QACA,aACA,MACA,MACA,MACA,MACA,KACA,MACA,QACA,SACA,OACA,QACA,SACA,UACA,OACA,MACA,OACA,QACA,WACA,QACA,SACA,UACA,QACA,QACA,SACA,SACA,UACA,WACA,SACA,QACA,YACA,WACA,SACA,UACA,QACA,UACA,YACA,UACA,SACA,cACA,WACA,WACA,WACA,UACA,WACA,aACA,YACA,WACA,SACA,SACA,QACA,WACA,OACA,QACA,WACA,SACA,UACA,QACA,YACA,QACA,SACA,SACA,OACA,SACA,MACA,UACA,QACA,WACA,QACA,QACA,UACA,WACA,MACA,OACA,UACA,QACA,SACA,SACA,SACA,SACA,UACA,WACA,YACA,OACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,OACA,OACA,MACA,MACA,OACA,QACA,SACA,UACA,QACA,SACA,UACA,SACA,YACA,cACA,UACA,MACA,MACA,MACA,KACA,QACA,MACA,MACA,MACF,CAAC;ACjoCD,SAASC,GACPl7B,KACAm7B,GACU;AACV,SAAOn7B,IAAO,OAAQo7B,OAAU,CAACD,EAAW,IAAIC,CAAK,CAAC;AACxD;AAYA,SAASC,GAAYr7B,KAAmD;AACtE,MAAMs7B,IAAkC,CAAC;AACzC,WAAWF,KAASp7B,IAClBs7B,GAAQF,CAAK,KAAKE,EAAQF,CAAK,KAAK,KAAK;AAE3C,SAAOE;AACT;AAYA,SAASC,GAAc1mB,KAAmB;AACxC,MAAI2mB,IAAa3mB,IAAE,UAAU,KAAK;AAClC,SAAA2mB,IAAaA,EAAW,QAAQ,mBAAmB,GAAG,GACtDA,IAAaA,EAAW,MAAM,KAAK,EAAE,KAAK,GAAG,GAC7CA,IAAaA,EAAW,QAAQ,uCAAuC,EAAE,GAClEA,EAAW,YAAY;AAChC;AAYA,SAASC,GAAQ9pB,KAAoB+pB,GAA6B;AAChE,SAAOH,GAAc5pB,GAAU,MAAM4pB,GAAcG,CAAW,IAAI,IAAM;AAC1E;AAaA,SAASC,GAAQhqB,KAAoB+pB,GAA6B;AAChE,MAAME,IAAmBL,GAAc5pB,GAAU,EAAE,MAAM,GAAG,GACtDkqB,IAAoBN,GAAcG,CAAW,EAAE,MAAM,GAAG,GAGxDI,IAAmBT,GAAYO,CAAgB,GAC/CG,IAAoBV,GAAYQ,CAAiB,GAEnDG,IAAU;AAC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",
  "names": ["s", "M", "t", "e", "n", "r", "i", "u", "D", "_", "w", "a", "O", "b", "m", "f", "l", "$", "y", "v", "g", "o", "d", "c", "h", "s", "e", "t", "n", "r", "i", "o", "a", "f", "h", "u", "d", "l", "c", "m", "M", "Y", "D", "w", "L", "t", "n", "i", "o", "r", "e", "u", "f", "s", "a", "s", "t", "i", "e", "f", "n", "u", "o", "r", "isCompatible", "DiagComponentLogger", "_i", "DiagLogLevel", "DiagAPI", "_i", "__spreadArray", "__read", "self", "BaseContext", "self", "context", "NoopContextManager", "fn", "_i", "__spreadArray", "__read", "API_NAME", "ContextAPI", "context", "fn", "_i", "__spreadArray", "__read", "TraceFlags", "NonRecordingSpan", "context", "NoopTracer", "context", "fn", "ProxyTracer", "context", "NoopTracerProvider", "ProxyTracerProvider", "SpanKind", "API_NAME", "TraceAPI", "getModelInfo", "model", "modelInfo", "models", "modelEntry", "v", "mappedModel", "exactMatch", "normalizedName", "normalizedMatch", "webCrypto", "randomUUID", "sha256", "data", "encoder", "inputData", "hashBuffer", "b", "Hash", "chunk", "encoding", "hash", "i", "char", "createHash", "algorithm", "SSEParser", "options", "controller", "error", "rawData", "lines", "line", "colonIndex", "field", "value", "retryValue", "parsedData", "e", "TextDecodeTransformer", "text", "TextDecoderStreamPolyfill", "defaultRetryConfig", "textDecoderStream", "AxAIServiceError", "message", "url", "requestBody", "responseBody", "context", "_depth", "_options", "AxAIServiceStatusError", "status", "statusText", "AxAIServiceNetworkError", "originalError", "AxAIServiceResponseError", "AxAIServiceStreamTerminatedError", "lastChunk", "AxAIServiceTimeoutError", "timeoutMs", "AxAIServiceAbortedError", "reason", "AxAIServiceAuthenticationError", "AxAIRefusalError", "refusalMessage", "requestId", "AxMediaNotSupportedError", "mediaType", "provider", "fallbackAvailable", "AxContentProcessingError", "contentType", "processingStep", "safeReadResponseBody", "response", "calculateRetryDelay", "attempt", "config", "createRequestMetrics", "updateRetryMetrics", "metrics", "shouldRetry", "apiCall", "api", "json", "retryConfig", "timeoutId", "baseUrl", "apiPath", "apiUrl", "originalUrl", "combinedAbortController", "userAbortHandler", "originalAbort", "res", "delay", "resolve", "resJson", "chunkCount", "reader", "decoder", "buffer", "read", "done", "closed", "events", "event", "eventType", "parsed", "parseError", "streamMetrics", "trackingStream", "axGlobals", "result", "ColorLog", "colorCode", "_colorLog", "defaultOutput", "formatChatMessage", "msg", "hideContent", "cl", "colorize", "colorMethod", "header", "items", "item", "content", "call", "params", "axCreateDefaultColorLogger", "output", "divider", "typedData", "formattedMessage", "streamingContent", "embedding", "defaultLogger", "axCreateDefaultTextLogger", "axSpanAttributes", "axSpanEvents", "AxLLMRequestTypeValues", "AxSpanKindValues", "TypeTransformer", "transformFn", "doneCallback", "obj", "val", "RespTransformStream", "mergeFunctionCalls", "functionCalls", "functionCallDeltas", "Fc", "fc", "logChatRequest", "chatPrompt", "step", "logger", "hideSystemPrompt", "filteredPrompt", "logResponse", "resp", "loggerData", "logResponseStreamingResult", "index", "logResponseStreamingDoneResult", "values", "combinedResults", "existing", "logFunctionResults", "results", "logFunctionError", "fixingInstructions", "logValidationError", "logAssertionError", "logRefusalError", "logEmbedRequest", "texts", "embedModel", "logEmbedResponse", "embeddings", "sampleEmbeddings", "logResultPickerUsed", "sampleCount", "selectedIndex", "latency", "sanitizeLabels", "labels", "sanitized", "key", "stringValue", "globalAIMetricsInstruments", "getOrCreateAIMetricsInstruments", "meter", "createMetricsInstruments", "recordLatencyMetric", "instruments", "type", "duration", "aiService", "recordLatencyStatsMetrics", "meanLatency", "p95Latency", "p99Latency", "recordErrorMetric", "recordErrorRateMetric", "errorRate", "recordRequestMetric", "recordTokenMetric", "tokens", "recordStreamingRequestMetric", "isStreaming", "recordFunctionCallMetric", "functionName", "recordRequestSizeMetric", "sizeBytes", "recordResponseSizeMetric", "recordModelConfigMetrics", "temperature", "maxTokens", "recordEstimatedCostMetric", "costUSD", "recordPromptLengthMetric", "lengthChars", "recordContextWindowUsageMetric", "usageRatio", "recordTimeoutMetric", "recordAbortMetric", "recordThinkingBudgetUsageMetric", "tokensUsed", "recordMultimodalRequestMetric", "hasImages", "hasAudio", "axBaseAIDefaultConfig", "axBaseAIDefaultCreativeConfig", "AxBaseAI", "aiImpl", "name", "apiURL", "headers", "defaults", "supportFor", "validateModels", "samples", "percentile", "sorted", "a", "metricsInstruments", "isError", "modelUsage", "promptTokens", "completionTokens", "totalTokens", "thoughtsTokens", "req", "part", "totalLength", "info", "promptCostPer1M", "completionCostPer1M", "modelName", "modelConfig", "promptLength", "requestSize", "chatResponse", "responseSize", "chatResult", "contextUsage", "estimatedCost", "startTime", "validateAxMessageArray", "SpanKind", "span", "fn", "cleanFn", "cleanParams", "chatReq", "debug", "functions", "apiConfig", "reqValue", "setChatRequestEvents", "rt", "rv", "respFn", "wrappedRespFn", "state", "tokenUsage", "setChatResponseEvents", "doneCb", "sourceStream", "transformState", "transformedValues", "transformedValue", "embedReq", "createEmbedReq", "resValue", "excludeContentFromTrace", "userMessages", "prompt", "eventData", "userEventData", "thoughTokens", "toolCalls", "keys", "AxAIAnthropicModel", "AxAIAnthropicVertexModel", "axModelInfoAnthropic", "cleanSchemaForAnthropic", "schema", "cleaned", "axAIAnthropicDefaultConfig", "axAIAnthropicVertexDefaultConfig", "AxAIAnthropicImpl", "isVertex", "stream", "toolsChoice", "system", "otherMessages", "messages", "createMessages", "tools", "stopSequences", "topP", "topK", "n", "thinkingConfig", "levels", "finishReason", "mapFinishReason", "showThoughts", "sstate", "contentBlock", "delta", "id", "usage", "AxAIAnthropic", "_AxAIAnthropic", "apiKey", "projectId", "region", "Config", "mi", "input", "mergeAssistantMessages", "mergedMessages", "cur", "lastMessage", "stopReason", "AxAIOpenAIModel", "AxAIOpenAIEmbedModel", "AxAIOpenAIResponsesModel", "axModelInfoOpenAI", "axModelInfoOpenAIResponses", "isOpenAIThinkingModel", "thinkingModels", "axAIOpenAIDefaultConfig", "axAIOpenAIBestConfig", "axAIOpenAICreativeConfig", "axAIOpenAIFastConfig", "AxAIOpenAIImpl", "streamingUsage", "chatReqUpdater", "frequencyPenalty", "store", "isThinkingModel", "choices", "choice", "role", "refusal", "thought", "annotations", "oaiFinishReason", "Id", "c", "AxAIOpenAIBase", "AxAIOpenAI", "axAIAzureOpenAIDefaultConfig", "axAIAzureOpenAICreativeConfig", "axAIAzureOpenAIFastConfig", "axAIAzureOpenAIBestConfig", "AxAIAzureOpenAI", "resourceName", "deploymentName", "version", "host", "AxBalancer", "_AxBalancer", "services", "cs", "aMetrics", "bMetrics", "failure", "retries", "lastFailureTime", "timeSinceLastFailure", "backoffMs", "gotNextService", "serviceWithModel", "service", "referenceModelList", "referenceKeys", "modelList", "serviceKeys", "axAnalyzeRequestRequirements", "request", "hasFiles", "hasUrls", "requiresFunctions", "requiresStreaming", "requiresCaching", "contentTypes", "estimatedTokens", "axValidateProviderCapabilities", "requirements", "features", "missingCapabilities", "warnings", "alternatives", "maxSize", "maxDuration", "axScoreProvidersForRequest", "providers", "validation", "score", "supportedCapabilities", "axSelectOptimalProvider", "availableProviders", "scoredProviders", "fullyCompatible", "p", "bestProvider", "axGetCompatibilityReport", "providerScores", "recommendedProvider", "totalRequirements", "supportedRequirements", "summary", "axGetProvidersWithMediaSupport", "axGetFormatCompatibility", "compatibility", "mediaFeatures", "format", "AxAICohereModel", "AxAICohereEmbedModel", "axModelInfoCohere", "axAICohereDefaultConfig", "axAICohereCreativeConfig", "AxAICohereImpl", "lastChatMsg", "restOfChat", "chatHistory", "createHistory", "props", "toolResults", "chat", "t", "ss", "AxAICohere", "createToolCall", "f", "outputs", "parameters", "AxAIDeepSeekModel", "axModelInfoDeepSeek", "axAIDeepSeekDefaultConfig", "axAIDeepSeekCodeConfig", "AxAIDeepSeek", "AxAIGoogleGeminiModel", "AxAIGoogleGeminiEmbedModel", "AxAIGoogleGeminiSafetyCategory", "AxAIGoogleGeminiSafetyThreshold", "AxAIGoogleGeminiEmbedTypes", "axModelInfoGoogleGemini", "cleanSchemaForGemini", "safetySettings", "axAIGoogleGeminiDefaultConfig", "axAIGoogleGeminiDefaultCreativeConfig", "AxAIGoogleGeminiImpl", "endpointId", "pf", "keyValue", "systemPrompts", "systemInstruction", "contents", "parts", "args", "cleanedFunctions", "toolConfig", "allowedFunctionNames", "generationConfig", "candidate", "prediction", "AxAIGoogleGemini", "_AxAIGoogleGemini", "path", "colorLog", "AxRateLimiterTokenUsage", "refillRate", "now", "tokensToAdd", "AxAIGroqModel", "axModelInfoGroq", "axAIGroqDefaultConfig", "AxAIGroq", "Options", "rateLimiter", "tokensPerMin", "func", "axModelInfoHuggingFace", "AxAIHuggingFaceModel", "axAIHuggingFaceDefaultConfig", "axAIHuggingFaceCreativeConfig", "AxAIHuggingFaceImpl", "functionsList", "inputs", "AxAIHuggingFace", "AxAIMistralModel", "AxAIMistralEmbedModels", "axModelInfoMistral", "axAIMistralDefaultConfig", "axAIMistralBestConfig", "AxAIMistral", "max_completion_tokens", "messagesUpdated", "contentUpdated", "AxMockAIService", "_model", "sortedSamples", "p95Index", "p99Index", "totalRequests", "AxMultiServiceRouter", "_AxMultiServiceRouter", "description", "isInternal", "otherService", "modelKey", "_", "reqWithoutModel", "embedModelKey", "reqWithoutEmbedModel", "s", "serviceInstance", "firstServiceEntry", "entry", "axAIOllamaDefaultConfig", "axAIOllamaDefaultCreativeConfig", "AxAIOllama", "isOpenAIResponsesThinkingModel", "AxAIOpenAIResponsesImpl", "responsesReqUpdater", "ExhaustiveCheck", "excludeSystemMessages", "mappedContent", "assistantMessage", "invalidRole", "instructionsFromPrompt", "systemMessageFoundAndUsed", "finalInstructions", "includeFields", "reasoningSummary", "reasoningEffort", "mutableReq", "inputItems", "currentReasoning", "finalReqToProcess", "currentResult", "contentToText", "streamEvent", "baseResult", "remoteId", "fileSearchItem", "r", "webSearchItem", "computerItem", "codeItem", "imageItem", "shellItem", "mcpItem", "responseId", "refusalContent", "axAIOpenAIResponsesDefaultConfig", "axAIOpenAIResponsesBestConfig", "axAIOpenAIResponsesCreativeConfig", "AxAIOpenAIResponsesBase", "formattedModels", "AxAIOpenAIResponses", "axProcessContentForProvider", "processedContent", "transcription", "extractedText", "fetchedContent", "axAnalyzeChatPromptRequirements", "AxAIRekaModel", "axModelInfoReka", "axAIRekaDefaultConfig", "axAIRekaBestConfig", "axAIRekaCreativeConfig", "axAIRekaFastConfig", "AxAIRekaImpl", "responses", "AxAIReka", "AxProviderRouter", "routingResult", "processedRequest", "processingOptions", "enhancedOptions", "processedChatPrompt", "processingApplied", "degradations", "fallbackProviders", "fallbackProvider", "issues", "recommendations", "capabilityMatrix", "axModelInfoTogether", "axAITogetherDefaultConfig", "AxAITogether", "axValidateChatRequestMessage", "systemItem", "userItem", "contentItem", "textItem", "audioItem", "assistantItem", "functionItem", "axValidateChatResponseResult", "resultsArray", "arrayIndex", "annotation", "callIndex", "functionCall", "validFinishReasons", "AxAIWebLLMModel", "axModelInfoWebLLM", "axAIWebLLMDefaultConfig", "axAIWebLLMCreativeConfig", "AxAIWebLLMImpl", "engine", "baseMsg", "_req", "toolCall", "deltaToolCall", "existingCall", "_resp", "AxAIWebLLM", "AxAIGrokModel", "AxAIGrokEmbedModels", "axModelInfoGrok", "axAIGrokDefaultConfig", "axAIGrokBestConfig", "AxAIGrok", "searchParams", "source", "ai", "AxAI", "_AxAI", "AxDBBase", "fetch", "tracer", "update", "baseURL", "AxDBCloudflare", "accountId", "_update", "batchReq", "table", "metadata", "AxDBMemory", "ids", "matches", "distance", "dotProduct", "normA", "normB", "zeroVectorA", "zeroVectorB", "vectorA", "vectorB", "sqrtNormA", "sqrtNormB", "createPineconeQueryRequest", "AxDBPinecone", "AxDBWeaviate", "objects", "filter", "resMatches", "match", "AxDB", "AxDBManager", "db", "chunkerInput", "initialChunks", "maxWordsPerChunk", "minWordsPerChunk", "chunks", "processChunks", "bs", "batch", "query", "topPercent", "abortSignal", "rewrittenQuery", "queries", "queryResults", "m", "tp", "resultItems", "getTopInPercent", "rankedItems", "currentChunk", "currentWordCount", "words", "wordCount", "remainingWords", "slice", "entries", "percent", "sortedEntries", "topTenPercentCount", "MemoryImpl", "lastItem", "tagIndex", "indices", "acc", "AxMemory", "sessionId", "AxAssertionError", "extraFields", "assertAssertions", "asserts", "assert", "assertStreamingAssertions", "xstate", "final", "fieldAsserts", "currValue", "axDefaultMetricsConfig", "globalGenMetricsInstruments", "getOrCreateGenMetricsInstruments", "activeMeter", "createGenMetricsInstruments", "axCheckMetricsHealth", "currentMetricsConfig", "axUpdateMetricsConfig", "axGetMetricsConfig", "maxLength", "recordGenerationMetric", "success", "signatureName", "recordMultiStepMetric", "stepsUsed", "maxSteps", "recordValidationErrorMetric", "errorType", "recordRefusalErrorMetric", "recordErrorCorrectionMetric", "attempts", "maxRetries", "recordFunctionCallingMetric", "functionsEnabled", "functionsExecuted", "hadFunctionCalls", "functionErrorCorrection", "recordFieldProcessingMetric", "fieldProcessorsExecuted", "streamingFieldProcessorsExecuted", "recordStreamingMetric", "deltasEmitted", "finalizationDuration", "recordSamplesMetric", "samplesCount", "resultPickerUsed", "resultPickerLatency", "recordSignatureComplexityMetrics", "inputFields", "outputFields", "examplesCount", "demosCount", "recordPerformanceMetric", "metricType", "ValidationError", "fields", "toFieldType", "baseType", "handleValidationErrorForGenerate", "errCount", "errorFields", "handleAssertionErrorForGenerate", "handleRefusalErrorForGenerate", "validateJSONSchema", "errors", "validateSchemaObject", "validTypes", "subSchema", "requiredProp", "errorMessage", "AxFunctionError", "FunctionError", "funcId", "fieldName", "fieldSchema", "bulletPoints", "fieldError", "schemaDescription", "AxFunctionProcessor", "funcList", "fnSpec", "opt", "parseFunctions", "newFuncs", "existingFuncs", "processFunctions", "functionList", "mem", "functionResultFormatter", "funcProc", "promises", "functionResult", "errorEventData", "functionResults", "successfulResults", "parseFunctionCalls", "_values", "createFunctionConfig", "definedFunctionCall", "firstStep", "dayjs", "utc", "timezone", "customParseFormat", "parseLLMFriendlyDate", "dateStr", "required", "ParseLlmFriendlyDate", "err", "parseLLMFriendlyDateTime", "ParseLlmFriendlyDateTime", "dateTimeStr", "dateTimeRegex", "dateTime", "timeZone", "date", "formatDateWithTimezone", "validateValue", "ft", "validateSingleValue", "expectedType", "validImage", "validAudio", "validFile", "validUrl", "isValid", "gotType", "mergeProgramUsage", "usages", "usageMap", "currentUsage", "parseMarkdownList", "listBullets", "numberedListRegex", "list", "trimmedLine", "mergeDeltas", "base", "currentDelta", "target", "baseValue", "deltaValue", "LRUCache", "firstKey", "globalPrefixCache", "matchesContent", "prefix", "startIndex", "prefixCache", "exactMatchIndex", "prefixes", "longestPartialMatch", "partialPrefix", "extractValues", "sig", "strictMode", "streamingExtractValues", "streamingExtractFinalValue", "checkMissingRequiredFields", "_xstate", "missingFields", "skipEarlyFail", "expectedField", "prefixLen", "foundValidFieldPrefix", "futureField", "futurePrefix", "assumedFieldContent", "parsedValue", "validateAndParseFieldValue", "firstRequiredField", "parseOptionalFieldsFromFullContent", "fieldIndex", "endIndex", "otherField", "otherPrefix", "otherFieldIndex", "fieldValue", "convertValueToType", "extractBlock", "className", "yieldDelta", "fieldIsArray", "fieldTypeName", "pos", "isFirstChunk", "d1", "d2", "d3", "streamValues", "prevField", "processFieldProcessors", "fieldProcessors", "processor", "processFn", "addToMemory", "processStreamingFieldProcessors", "resultText", "_key", "getFieldProcessingMessage", "isCodeField", "fieldTitle", "processStreamingResponse", "states", "lastChunkUsage", "ProcessStreamingResponse", "finalizeStreamingResponse", "signature", "streamingFieldProcessors", "thoughtFieldName", "streamingAsserts", "traceId", "funcs", "fx", "processResponse", "deltas", "shouldContinueSteps", "stopFunction", "lastMemItem", "stopFunctionExecuted", "isFunction", "isProcessor", "tag", "AxInstanceRegistry", "instance", "SignatureValidationError", "position", "suggestion", "SignatureParser", "optionalDesc", "remaining", "inputNames", "outputNames", "outputField", "start", "end", "before", "after", "pointer", "parseFieldFn", "section", "isOptional", "typeName", "isArray", "desc", "classNamesString", "fieldType", "suggestions", "camelCaseRegex", "snakeCaseRegex", "types", "foundType", "currentWord", "baseMessage", "suggestionPart", "fullMessage", "invalidMatch", "invalidId", "quoteChars", "quoteChar", "escaped", "startPos", "partialString", "strOrRegex", "found", "parseSignature", "AxSignatureBuilder", "fieldInfo", "prepend", "AxSignature", "AxFluentFieldType", "_AxFluentFieldType", "language", "convertFieldTypeToAxField", "AxSignatureValidationError", "_AxSignature", "title", "parsedField", "validateField", "existingField", "inputField", "parsedFields", "newSig", "fieldToAdd", "properties", "renderSignature", "renderField", "descriptionPart", "inputFieldsRendered", "outputFieldsRendered", "isValidCase", "inputString", "validateFieldType", "option", "trimmedOption", "AxProgram", "instruction", "prog", "child", "parentId", "examples", "traces", "Traces", "cu", "demos", "hasChildren", "hasMatchingDemo", "demo", "functionCallInstructions", "formattingRules", "AxPromptTemplate", "fieldTemplates", "task", "inArgs", "renderDescFields", "outArgs", "formatDescription", "renderInputFields", "renderOutputFields", "renderedExamples", "examplesInSystemPrompt", "completion", "combineConsecutiveStrings", "systemContent", "combinedItems", "systemPrompt", "history", "firstItem", "userContent", "groupedFields", "valuesList", "exampleContext", "renderedInputItem", "renderedOutputItem", "renderedItem", "renderedItems", "isEmptyValue", "processedValue", "processValue", "validateImage", "validated", "validateAudio", "validateFile", "validateUrl", "requiredMsg", "separator", "current", "previous", "str", "checkForFunctionCalls", "hasFunctionResults", "extractFunctionResults", "assistantMessages", "functionMessages", "assistantMsg", "funcCall", "funcResult", "selectFromSamples", "resultPicker", "fieldResults", "selectFromSamplesInMemory", "lastMemory", "AxGen", "streaming", "traceContext", "stepIndex", "thinkingTokenBudget", "promptTemplateClass", "currentPromptTemplateOptions", "promptTemplate", "promptRenderStart", "promptRenderDuration", "memoryUpdateStart", "memoryUpdateDuration", "multiStepLoop", "generator", "allFunctionsExecuted", "enhanceError", "stateCreationStart", "stateCreationDuration", "funcNames", "attributes", "traceLabel", "spanName", "currentContext", "trace", "errorCorrectionAttempts", "currentVersion", "resultPickerStart", "finalMetricsInstruments", "selectedResult", "AxGenerateError", "details", "trimNonAlphaNum", "splitIntoTwo", "matchResult", "firstPart", "secondPart", "dedup", "seq", "seen", "x", "extractIdAndText", "extractIndexPrefixedText", "batchArray", "arr", "size", "chunkedArr", "AxStringUtil", "AxDefaultResultReranker", "sortedIndexes", "originalIndex", "AxApacheTika", "Args", "fileData", "acceptValue", "fetchOptions", "files", "uploadPromises", "batchResults", "AxSimpleClassifierClass", "AxSimpleClassifier", "classes", "ret", "cutoff", "matchedClass", "stopwords", "filterTokens", "exclusions", "token", "countTokens", "counter", "normalizeText", "normalized", "emScore", "groundTruth", "f1Score", "predictionTokens", "groundTruthTokens", "predictionCounts", "groundTruthCounts", "numSame", "v1", "v2", "precision", "recall", "novelF1ScoreOptimized", "returnRecall", "historyTokens", "f1", "AxEvalUtil", "AxTestPrompt", "program", "metricFn", "_st", "total", "sumOfScores", "ex", "averageScore", "AxHFDataLoader", "dataset", "split", "offset", "length", "ds", "rows", "count", "renameMap", "resultFieldName", "axCreateDefaultOptimizerColorLogger", "lightDivider", "heavyDivider", "axCreateDefaultOptimizerTextLogger", "axDefaultOptimizerLogger", "axDefaultOptimizerMetricsConfig", "globalOptimizerMetricsInstruments", "getOrCreateOptimizerMetricsInstruments", "createOptimizerMetricsInstruments", "currentOptimizerMetricsConfig", "axUpdateOptimizerMetricsConfig", "axGetOptimizerMetricsConfig", "sanitizeOptimizerLabels", "recordOptimizationMetric", "optimizerType", "programSignature", "recordConvergenceMetric", "rounds", "currentScore", "improvement", "stagnationRounds", "recordEarlyStoppingMetric", "recordResourceUsageMetric", "costIncurred", "memoryUsage", "recordOptimizationDurationMetric", "recordTeacherStudentMetric", "scoreImprovement", "recordCheckpointMetric", "operation", "recordParetoMetric", "frontSize", "solutionsGenerated", "hypervolume", "recordProgramComplexityMetric", "validationSetSize", "recordOptimizerPerformanceMetric", "recordOptimizerConfigurationMetric", "targetScore", "maxRounds", "AxDefaultCostTracker", "totalCost", "costPer1K", "AxBaseOptimizer", "costTracker", "seed", "bestScoreRound", "preferTeacher", "earlyStopReason", "updateProgress", "round", "configuration", "optimizerConfig", "bestScore", "bestConfiguration", "optimizerState", "onEarlyStop", "_stats", "onProgress", "progress", "compileResult", "_optimizerType", "solutions", "constraintSolutions", "allSolutions", "paretoFront", "sol", "sampleExample", "samplePrediction", "sampleScores", "objectives", "weightCombinations", "weights", "weightedMetric", "example", "scores", "weightedScore", "objective", "primaryObjective", "constraintMetric", "primaryScore", "penalty", "combinations", "equalWeights", "obj1", "obj2", "w1", "w2", "obj3", "testProgram", "predictions", "valSet", "allScores", "evalSet", "avgScores", "sum", "solutionA", "isDominated", "dominatedCount", "j", "solutionB", "scoresA", "scoresB", "atLeastAsGood", "strictlyBetter", "scoreA", "scoreB", "firstSolution", "sortedSolutions", "prevScore2", "solution", "score1", "score2", "saveFn", "checkpointId", "checkpoint", "loadFn", "interval", "currentCost", "AxBootstrapFewShot", "roundIndex", "maxDemos", "aiOpt", "randomSample", "previousSuccessCount", "exList", "forwardOptions", "groupTracesByKeys", "programTraces", "groupedTraces", "programTrace", "programDemosArray", "programId", "array", "clonedArray", "caI", "caJ", "PythonOptimizerClient", "jobId", "studyName", "pollInterval", "maxWaitTime", "lastError", "ms", "AxMiPRO", "clientOptions", "level", "summaryPrompt", "sampleSize", "tip", "candidateIndex", "programSummary", "datasetSummary", "previousInstructions", "contextInfo", "instructionPrompt", "enhancedTemplates", "_program", "instructions", "aiToUse", "tips", "tipIndex", "tipToUse", "selectedExamples", "idx", "bootstrappedDemos", "labeledExamples", "validationExamples", "bestConfig", "scoreHistory", "startRound", "currentTrial", "totalScore", "evalSize", "baseSize", "axMajorityVotePicker", "shuffled", "miproOptions", "optimizedGen", "axgen", "similarConfigs", "mean", "variance", "similarities", "diff", "totalWeight", "std", "z", "phi", "pdfValue", "a1", "a2", "a3", "a4", "a5", "sign", "absX", "y", "candidates", "numCandidates", "acquisitionValue", "optimizationRequest", "job", "bestProgram", "totalTrials", "trial", "studyResults", "_config", "validResults", "evaluationExamples", "counts", "sample", "bestKey", "bestCount", "k", "ax", "typedSignature", "AxFlowDependencyAnalyzer", "mapping", "_nodeName", "dependencies", "stateAccessMatches", "tracker", "accessed", "self", "prop", "functionSource", "templateMatches", "destructureMatches", "_target", "processBatches", "batchSize", "batchPromises", "batchIndex", "AxFlowExecutionPlanner", "stepFunction", "nodeName", "stepType", "mapTransform", "mergeOptions", "deriveOptions", "produces", "allFields", "transform", "branchFields", "otherDependencies", "dep", "sourceAnalysis", "mockState", "originalKeys", "addedFields", "fieldAssignments", "assignment", "propertyAssignments", "recentExecuteSteps", "processedSteps", "availableFields", "currentLevel", "currentLevelSteps", "remainingSteps", "nextStep", "optimizedSteps", "group", "parallelStep", "parallelResult", "mergedState", "g", "formatState", "formatted", "objStr", "formatTime", "axCreateFlowColorLogger", "smallDivider", "stepIcon", "completeIcon", "axCreateFlowTextLogger", "axDefaultFlowLogger", "createTimingLogger", "timingData", "AxFlowSubContextImpl", "nodeGenerators", "dynamicContext", "nodeProgram", "nodeInputs", "initialState", "currentState", "AxFlowTypedSubContextImpl", "AxFlow", "_AxFlow", "letter", "steps", "_isOptimized", "stepsExecuted", "stepMetadata", "previousFields", "stepStartTime", "executionTime", "newFields", "nodeResult", "_index", "stepInfo", "nodeNameMatch", "nodeExecMatch", "executionPlan", "allProducedFields", "allConsumedFields", "inputFieldNames", "consumed", "outputFieldNames", "lastStep", "produced", "isConsumed", "nodeGen", "camelCaseName", "inferredSignature", "allTraces", "nodeTraces", "allUsage", "nodeUsage", "report", "flowStartTime", "inputValues", "lastUserMessage", "useAutoParallel", "totalExecutionTime", "nodeValue", "nodeGenerator", "programInstance", "signatureOrAxGenOrClass", "transformOrTransforms", "transforms", "parallelMapStep", "orderedResults", "currentBranch", "label", "existingUsage", "existingTraces", "predicate", "branchContext", "mergeStep", "branchValue", "branchSteps", "branches", "branchFn", "subContext", "resultKey", "mergeFunction", "parallelMergeStep", "mergedValue", "newState", "condition", "targetLabel", "maxIterations", "targetIndex", "feedbackStepIndex", "iterations", "iterationKey", "loopStartIndex", "placeholderStep", "loopBodySteps", "outputFieldName", "inputFieldName", "inputValue", "planInfo", "baseSignature", "extensions", "extendedSig", "flow", "AxDockerSession", "imageName", "volumes", "doNotPullImage", "binds", "containerConfig", "matchingContainers", "container", "randomIndex", "selectedContainer", "containerId", "remove", "timeout", "containers", "targetContainers", "stopResponse", "removeResponse", "all", "command", "createResponse", "execData", "startResponse", "endpoint", "AxEmbeddingAdapter", "extra", "embeds", "AxMCPClient", "transport", "expectedProtocolVersion", "override", "o", "pingPromise", "timeoutPromise", "reject", "method", "responsePromise", "errorObj", "notification", "AxMCPHTTPSSETransport", "sseUrl", "AxMCPStreambleHTTPTransport", "mcpEndpoint", "authorization", "baseHeaders", "handler", "processStream", "sessionIdHeader", "processChunk", "processChildAgentFunction", "childFunction", "parentValues", "parentInputKeys", "processedFunction", "childKeys", "injectionKeys", "removePropertiesFromSchema", "originalFunc", "childArgs", "funcOptions", "valuesToInject", "pick", "updatedChildArgs", "addModelParameter", "descriptionError", "definitionError", "AxAgent", "_AxAgent", "definition", "agents", "disableSmartModelRouting", "excludeFieldsFromPassthrough", "agent", "toCamelCase", "mm", "boundFunc", "wrappedFunc", "valuesAndModel", "outFields", "parentAi", "parentKeys", "agentFuncs", "processOptions", "word", "lowerWord", "baseSchema", "modelProperty", "newProperties", "newRequired", "newSchema", "filteredRequired", "axRAG", "queryFn", "maxHops", "qualityThreshold", "qualityTarget", "disableQualityHealing", "searchQuery", "retrievedDocument", "retrievalResults", "evidence", "healingQuery", "healingDocument"]
}
