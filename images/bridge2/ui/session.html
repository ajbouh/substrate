<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mithril/2.2.3/mithril.min.js" integrity="sha512-veJyRkYTPP9HJBUEq3oqA1uBzxGA+OiiHkcgT4Nm8Ovg9dNKSxf4mxClYVCkujcxIz+reFruwp4OPsXY10U8UA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdn.jsdelivr.net/npm/cbor-js@0.1.0/cbor.min.js"></script>
  <script src="./webrtc/localmedia.js"></script>
  <link rel="stylesheet" href="./ui/session.css" />
</head>
<body class="flex flex-row bg-gray-900 text-white antialiased">
  <script type="module">

import {Session} from "./ui/session.js";
import {Sidebar} from "./ui/sidebar.js";
import {Topbar} from "./ui/topbar.js";
import {Session as SFU} from "./webrtc/session.js";

let webSocketURL = (() => {
  let u = new URL(`ws://${location.host}${location.pathname}`);
  if (window.location.protocol == "https:") {
    u.protocol = 'wss:'
  }
  return u.toString();
})();

let micSess = null;
let screenSess = null;
const initSession = () => {
  let sess = new SFU(`${webSocketURL}?sfu`);
  sess.onclose = (evt) => console.log("Websocket has closed");
  sess.onerror = (evt) => console.log("ERROR: " + evt.data);
  sess.ontrack = ({ streams: [stream], track }) => {
    // no-op!
    return
  };
  return sess;
};

let localMedia = null;
const initLocalMedia = () => {
  if (!localMedia) {
    localMedia = new LocalMedia({
      videoSource: false,
      ondevicechange: () => m.redraw(),
      onstreamchange: (stream) => {
        if (micSess == null) {
          micSess = initSession();
        }
        micSess.setStream(stream);
      },
    });
  }
  return localMedia;
}

let screenMedia = null;

const shareScreen = () => {
  if (screenMedia) {
    screenMedia.updateStream();
    return
  }
  screenMedia = new LocalMedia({
    videoSource: 'screen',
    // videoEnabled: false,
    onstreamchange: (stream) => {
      if (screenSess == null) {
        screenSess = initSession();
      }
      screenSess.setStream(stream);
    },
  });
};

let viewModel = {};
let dataWS = new WebSocket(`${webSocketURL}?data`);
dataWS.binaryType = 'arraybuffer';
dataWS.onmessage = e => {
  const data = CBOR.decode((new Uint8Array(e.data)).buffer);

  const events = data.Session == null ? [] : data.Session.Tracks.map(t => t.Events).filter(e => e).flat();
  const sessionStart = data.Session && new Date(data.Session.Start).getTime();

  viewModel = {
    sessions: data.Sessions,
    activeSession: data.Session,
    entries: events.filter(e => e.Type === "transcription").sort((a, b) => {
      return a.Start - b.Start;
    }).map(t => {
      return {
        speakerLabel: "user",
        start: new Date(sessionStart + (t.Start / 1000000)), // todo: convert
        text: t.Data.segments.map(s => s.text).join()
      }
    })
  }
  m.redraw()
  setTimeout(() => {
    const elt = document.getElementById("entries");
    if (elt && elt.lastChild) {
      elt.lastChild.scrollIntoView({ block: "end", behavior: 'smooth' })
    }
  }, 0);
}

m.mount(document.body, {
  view: () => [
    m(Sidebar, {activeSession: viewModel.activeSession, sessions: viewModel.sessions}),
    m("div", {"class":"flex flex-col mx-auto grow"},
      viewModel.activeSession ?
        [
          m(Topbar, {localMedia: initLocalMedia(), shareScreen, activeSession: viewModel.activeSession}),
          m("div", {"class":"grow px-6 mt-4 overflow-auto","id":"session"},
            m(Session, {summary: "Summary", entries: viewModel.entries})
          )
        ]
      : [
        m("div", {"class": "grow px-6 mt-4"}, [
          m("a", {"href": "./sessions/new", "class": "rounded border border-2 px-3 py-2"}, "New session")
        ])
      ]
    )
  ],
});

  </script>
</body>
</html>
